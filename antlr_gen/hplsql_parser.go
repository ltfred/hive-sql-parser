// Code generated from Hplsql.g4 by ANTLR 4.13.2. DO NOT EDIT.

package antlr_gen // Hplsql

import (
	"fmt"
	"strconv"
	"strings"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type HplsqlParser struct {
	*antlr.BaseParser
}

var HplsqlParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func hplsqlParserInit() {
	staticData := &HplsqlParserStaticData
	staticData.LiteralNames = []string{
		"", "'@'", "'#'", "'%'", "'!'", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "'+'", "':'", "','",
		"'||'", "'/'", "'.'", "'..'", "'='", "'=='", "'<>'", "'!='", "'>'",
		"'>='", "'<'", "'<='", "'*'", "'{'", "'('", "'['", "'}'", "')'", "']'",
		"';'", "'-'",
	}
	staticData.SymbolicNames = []string{
		"", "", "", "", "", "T_ACTION", "T_ADD2", "T_ALL", "T_ALLOCATE", "T_ALTER",
		"T_AND", "T_ANSI_NULLS", "T_ANSI_PADDING", "T_AS", "T_ASC", "T_ASSOCIATE",
		"T_AT", "T_AUTO_INCREMENT", "T_AVG", "T_BATCHSIZE", "T_BEGIN", "T_BETWEEN",
		"T_BIGINT", "T_BINARY_DOUBLE", "T_BINARY_FLOAT", "T_BINARY_INTEGER",
		"T_BIT", "T_BODY", "T_BREAK", "T_BULK", "T_BY", "T_BYTE", "T_BOOLEAN",
		"T_CALL", "T_CALLER", "T_CASCADE", "T_CASE", "T_CASESPECIFIC", "T_CAST",
		"T_CHAR", "T_CHARACTER", "T_CHARSET", "T_CLIENT", "T_CLOSE", "T_CLUSTERED",
		"T_CMP", "T_COLLECT", "T_COLLECTION", "T_COLUMN", "T_COMMENT", "T_CONSTANT",
		"T_COMMIT", "T_COMPRESS", "T_CONCAT", "T_CONDITION", "T_CONSTRAINT",
		"T_CONTINUE", "T_COPY", "T_COUNT", "T_COUNT_BIG", "T_CREATE", "T_CREATION",
		"T_CREATOR", "T_CS", "T_CURRENT", "T_CURRENT_SCHEMA", "T_CURSOR", "T_DATABASE",
		"T_DATA", "T_DATE", "T_DATETIME", "T_DAY", "T_DAYS", "T_DEC", "T_DECIMAL",
		"T_DECLARE", "T_DEFAULT", "T_DEFERRED", "T_DEFINED", "T_DEFINER", "T_DEFINITION",
		"T_DELETE", "T_DELIMITED", "T_DELIMITER", "T_DESC", "T_DESCRIBE", "T_DIAGNOSTICS",
		"T_DIR", "T_DIRECTORY", "T_DISTINCT", "T_DISTRIBUTE", "T_DO", "T_DOUBLE",
		"T_DROP", "T_DYNAMIC", "T_ELSE", "T_ELSEIF", "T_ELSIF", "T_ENABLE",
		"T_END", "T_ENGINE", "T_ESCAPED", "T_EXCEPT", "T_EXEC", "T_EXECUTE",
		"T_EXCEPTION", "T_EXCLUSIVE", "T_EXISTS", "T_EXIT", "T_FALLBACK", "T_FALSE",
		"T_FETCH", "T_FIELDS", "T_FILE", "T_FILES", "T_FLOAT", "T_FOR", "T_FOREIGN",
		"T_FORMAT", "T_FOUND", "T_FROM", "T_FULL", "T_FUNCTION", "T_GET", "T_GLOBAL",
		"T_GO", "T_GRANT", "T_GROUP", "T_HANDLER", "T_HASH", "T_HAVING", "T_HDFS",
		"T_HIVE", "T_HOST", "T_IDENTITY", "T_IF", "T_IGNORE", "T_IMMEDIATE",
		"T_IN", "T_INCLUDE", "T_INDEX", "T_INITRANS", "T_INNER", "T_INOUT",
		"T_INSERT", "T_INT", "T_INT2", "T_INT4", "T_INT8", "T_INTEGER", "T_INTERSECT",
		"T_INTERVAL", "T_INTO", "T_INVOKER", "T_IS", "T_ISOPEN", "T_ITEMS",
		"T_JOIN", "T_KEEP", "T_KEY", "T_KEYS", "T_LANGUAGE", "T_LEAVE", "T_LEFT",
		"T_LIKE", "T_LIMIT", "T_LINES", "T_LOCAL", "T_LOCATION", "T_LOCATOR",
		"T_LOCATORS", "T_LOCKS", "T_LOG", "T_LOGGED", "T_LOGGING", "T_LOOP",
		"T_MAP", "T_MATCHED", "T_MAX", "T_MAXTRANS", "T_MERGE", "T_MESSAGE_TEXT",
		"T_MICROSECOND", "T_MICROSECONDS", "T_MILLIS", "T_MIN", "T_MULTISET",
		"T_NCHAR", "T_NEW", "T_NVARCHAR", "T_NO", "T_NOCOUNT", "T_NOCOMPRESS",
		"T_NOLOGGING", "T_NONE", "T_NOT", "T_NOTFOUND", "T_NULL", "T_NUMERIC",
		"T_NUMBER", "T_OBJECT", "T_OFF", "T_OF", "T_ON", "T_ONLY", "T_OPEN",
		"T_OR", "T_ORDER", "T_OUT", "T_OUTER", "T_OVER", "T_OVERWRITE", "T_OWNER",
		"T_PACKAGE", "T_PARTITION", "T_PARTITIONED", "T_PCTFREE", "T_PCTUSED",
		"T_PLS_INTEGER", "T_PRECISION", "T_PRESERVE", "T_PRIMARY", "T_PRINT",
		"T_PROC", "T_PROCEDURE", "T_QUALIFY", "T_QUERY_BAND", "T_QUIT", "T_QUOTED_IDENTIFIER",
		"T_RAISE", "T_REAL", "T_REFERENCES", "T_REGEXP", "T_REPLACE", "T_RESIGNAL",
		"T_RESTRICT", "T_RESULT", "T_RESULT_SET_LOCATOR", "T_RETURN", "T_RETURNS",
		"T_REVERSE", "T_RIGHT", "T_RLIKE", "T_ROLE", "T_ROLLBACK", "T_ROW",
		"T_ROWS", "T_ROWTYPE", "T_ROW_COUNT", "T_RR", "T_RS", "T_PWD", "T_TRIM",
		"T_SCHEMA", "T_SECOND", "T_SECONDS", "T_SECURITY", "T_SEGMENT", "T_SEL",
		"T_SELECT", "T_SET", "T_SESSION", "T_SESSIONS", "T_SETS", "T_SHARE",
		"T_SIGNAL", "T_SIMPLE_DOUBLE", "T_SIMPLE_FLOAT", "T_SIMPLE_INTEGER",
		"T_SMALLDATETIME", "T_SMALLINT", "T_SQL", "T_SQLEXCEPTION", "T_SQLINSERT",
		"T_SQLSTATE", "T_SQLWARNING", "T_STATS", "T_STATISTICS", "T_STEP", "T_STORAGE",
		"T_STORED", "T_STRING", "T_SUBDIR", "T_SUBSTRING", "T_SUM", "T_SUMMARY",
		"T_SYS_REFCURSOR", "T_TABLE", "T_TABLESPACE", "T_TEMPORARY", "T_TERMINATED",
		"T_TEXTIMAGE_ON", "T_THEN", "T_TIME", "T_TIMESTAMP", "T_TINYINT", "T_TITLE",
		"T_TO", "T_TOP", "T_TRANSACTION", "T_TRUE", "T_TRUNCATE", "T_UNION",
		"T_UNIQUE", "T_UPDATE", "T_UR", "T_USE", "T_USING", "T_VALUE", "T_VALUES",
		"T_VAR", "T_VARCHAR", "T_VARCHAR2", "T_VARYING", "T_VOLATILE", "T_WHEN",
		"T_WHERE", "T_WHILE", "T_WITH", "T_WITHOUT", "T_WORK", "T_XACT_ABORT",
		"T_XML", "T_YES", "T_ACTIVITY_COUNT", "T_CUME_DIST", "T_CURRENT_DATE",
		"T_CURRENT_TIME_MILLIS", "T_CURRENT_TIMESTAMP", "T_CURRENT_USER", "T_DENSE_RANK",
		"T_FIRST_VALUE", "T_LAG", "T_LAST_VALUE", "T_LEAD", "T_MAX_PART_STRING",
		"T_MIN_PART_STRING", "T_MAX_PART_INT", "T_MIN_PART_INT", "T_MAX_PART_DATE",
		"T_MIN_PART_DATE", "T_PART_COUNT", "T_PART_LOC", "T_RANK", "T_ROW_NUMBER",
		"T_STDEV", "T_SYSDATE", "T_VARIANCE", "T_USER", "T_ADD", "T_COLON",
		"T_COMMA", "T_PIPE", "T_DIV", "T_DOT", "T_DOT2", "T_EQUAL", "T_EQUAL2",
		"T_NOTEQUAL", "T_NOTEQUAL2", "T_GREATER", "T_GREATEREQUAL", "T_LESS",
		"T_LESSEQUAL", "T_MUL", "T_OPEN_B", "T_OPEN_P", "T_OPEN_SB", "T_CLOSE_B",
		"T_CLOSE_P", "T_CLOSE_SB", "T_SEMICOLON", "T_SUB", "L_ID", "L_S_STRING",
		"L_D_STRING", "L_INT", "L_DEC", "L_WS", "L_M_COMMENT", "L_S_COMMENT",
		"L_FILE", "L_LABEL",
	}
	staticData.RuleNames = []string{
		"program", "block", "begin_end_block", "single_block_stmt", "block_end",
		"proc_block", "stmt", "semicolon_stmt", "exception_block", "exception_block_item",
		"null_stmt", "expr_stmt", "assignment_stmt", "assignment_stmt_item",
		"assignment_stmt_single_item", "assignment_stmt_collection_item", "assignment_stmt_multiple_item",
		"assignment_stmt_select_item", "allocate_cursor_stmt", "associate_locator_stmt",
		"begin_transaction_stmt", "break_stmt", "call_stmt", "declare_stmt",
		"declare_block", "declare_block_inplace", "declare_stmt_item", "declare_var_item",
		"declare_condition_item", "declare_cursor_item", "cursor_with_return",
		"cursor_without_return", "declare_handler_item", "declare_temporary_table_item",
		"create_table_stmt", "create_local_temp_table_stmt", "create_table_definition",
		"create_table_column_comment", "create_table_columns", "create_table_columns_item",
		"column_name", "create_table_column_inline_cons", "create_table_column_cons",
		"create_table_fk_action", "create_table_preoptions", "create_table_preoptions_item",
		"create_table_preoptions_td_item", "create_table_options", "create_table_options_item",
		"create_table_options_ora_item", "create_table_options_db2_item", "create_table_options_td_item",
		"partition_column_name", "partition_dtype", "partition_dtype_len", "create_table_hive_partition_columns_item",
		"create_table_hive_partition_column_comment", "create_table_hive_partition_columns",
		"create_table_hive_partitiion", "create_table_options_hive_comment",
		"create_table_options_hive_item", "create_table_hive_row_format", "create_table_hive_row_format_fields",
		"create_table_options_mssql_item", "create_table_options_mysql_item",
		"alter_table_stmt", "alter_table_item", "alter_table_add_constraint",
		"alter_table_add_constraint_item", "dtype", "dtype_len", "dtype_attr",
		"dtype_default", "create_database_stmt", "create_database_option", "create_function_stmt",
		"create_function_return", "create_package_stmt", "package_spec", "package_spec_item",
		"create_package_body_stmt", "package_body", "package_body_item", "create_procedure_stmt",
		"create_routine_params", "create_routine_param_item", "create_routine_options",
		"create_routine_option", "drop_stmt", "end_transaction_stmt", "exec_stmt",
		"if_stmt", "if_plsql_stmt", "if_tsql_stmt", "if_bteq_stmt", "elseif_block",
		"else_block", "include_stmt", "insert_stmt", "insert_stmt_cols", "insert_stmt_rows",
		"insert_stmt_row", "insert_directory_stmt", "exit_stmt", "get_diag_stmt",
		"get_diag_stmt_item", "get_diag_stmt_exception_item", "get_diag_stmt_rowcount_item",
		"grant_stmt", "grant_stmt_item", "leave_stmt", "map_object_stmt", "open_stmt",
		"fetch_stmt", "fetch_limit", "collect_stats_stmt", "collect_stats_clause",
		"close_stmt", "cmp_stmt", "cmp_source", "copy_from_local_stmt", "copy_stmt",
		"copy_source", "copy_target", "copy_option", "copy_file_option", "commit_stmt",
		"create_index_stmt", "create_index_col", "index_storage_clause", "index_mssql_storage_clause",
		"print_stmt", "quit_stmt", "raise_stmt", "resignal_stmt", "return_stmt",
		"rollback_stmt", "set_session_option", "set_current_schema_option",
		"set_mssql_session_option", "set_teradata_session_option", "signal_stmt",
		"summary_stmt", "truncate_stmt", "use_stmt", "values_into_stmt", "while_stmt",
		"unconditional_loop_stmt", "for_cursor_stmt", "for_range_stmt", "label",
		"using_clause", "select_stmt", "cte_select_stmt", "cte_select_stmt_item",
		"cte_select_cols", "fullselect_stmt", "fullselect_stmt_item", "fullselect_set_clause",
		"subselect_stmt", "select_list", "select_list_set", "select_list_limit",
		"select_list_item", "select_list_alias", "select_list_asterisk", "table_row",
		"into_clause", "bulk_collect_clause", "from_clause", "from_table_clause",
		"from_table_name_clause", "from_subselect_clause", "from_join_clause",
		"from_join_type_clause", "from_table_values_clause", "from_table_values_row",
		"from_alias_clause", "table_name", "where_clause", "group_by_clause",
		"having_clause", "qualify_clause", "order_by_clause", "select_options",
		"select_options_item", "update_stmt", "update_assignment", "update_table",
		"update_upsert", "merge_stmt", "merge_table", "merge_condition", "merge_action",
		"delete_stmt", "delete_alias", "describe_stmt", "bool_expr", "bool_expr_atom",
		"bool_expr_unary", "bool_expr_single_in", "bool_expr_multi_in", "bool_expr_binary",
		"bool_expr_logical_operator", "bool_expr_binary_operator", "expr", "expr_atom",
		"expr_interval", "interval_item", "expr_concat", "expr_concat_item",
		"expr_case", "expr_case_simple", "expr_case_searched", "expr_cursor_attribute",
		"expr_agg_window_func", "expr_func_all_distinct", "expr_func_over_clause",
		"expr_func_partition_by_clause", "expr_spec_func", "expr_func", "expr_dot",
		"expr_dot_method_call", "expr_dot_property_access", "expr_func_params",
		"func_param", "expr_select", "expr_file", "hive", "hive_item", "host",
		"host_cmd", "host_stmt", "file_name", "date_literal", "timestamp_literal",
		"ident", "qident", "string", "int_number", "dec_number", "bool_literal",
		"null_const", "non_reserved_words",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 382, 3534, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2,
		176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7,
		180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2,
		185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7,
		189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2,
		194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7,
		198, 2, 199, 7, 199, 2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2,
		203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206, 7, 206, 2, 207, 7,
		207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2,
		212, 7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7,
		216, 2, 217, 7, 217, 2, 218, 7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2,
		221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 2, 224, 7, 224, 2, 225, 7,
		225, 2, 226, 7, 226, 2, 227, 7, 227, 2, 228, 7, 228, 2, 229, 7, 229, 2,
		230, 7, 230, 2, 231, 7, 231, 2, 232, 7, 232, 2, 233, 7, 233, 2, 234, 7,
		234, 2, 235, 7, 235, 2, 236, 7, 236, 2, 237, 7, 237, 2, 238, 7, 238, 2,
		239, 7, 239, 2, 240, 7, 240, 2, 241, 7, 241, 2, 242, 7, 242, 2, 243, 7,
		243, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 3, 1, 494, 8, 1, 1, 1, 3, 1, 497, 8,
		1, 4, 1, 499, 8, 1, 11, 1, 12, 1, 500, 1, 2, 3, 2, 504, 8, 2, 1, 2, 1,
		2, 1, 2, 3, 2, 509, 8, 2, 1, 2, 1, 2, 1, 3, 1, 3, 1, 3, 3, 3, 516, 8, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 522, 8, 3, 3, 3, 524, 8, 3, 1, 4, 1, 4, 1,
		4, 1, 5, 1, 5, 4, 5, 531, 8, 5, 11, 5, 12, 5, 532, 1, 5, 3, 5, 536, 8,
		5, 3, 5, 538, 8, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1,
		6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1,
		6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1,
		6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1,
		6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1,
		6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 3, 6, 602, 8, 6, 1, 7, 1, 7, 1, 8, 1,
		8, 4, 8, 608, 8, 8, 11, 8, 12, 8, 609, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1,
		9, 1, 10, 1, 10, 1, 11, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 3, 12, 626,
		8, 12, 1, 12, 1, 12, 1, 12, 5, 12, 631, 8, 12, 10, 12, 12, 12, 634, 9,
		12, 3, 12, 636, 8, 12, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 642, 8, 13, 1,
		14, 1, 14, 3, 14, 646, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14,
		1, 14, 3, 14, 655, 8, 14, 1, 14, 1, 14, 1, 14, 3, 14, 660, 8, 14, 1, 15,
		1, 15, 1, 15, 1, 15, 1, 15, 1, 16, 1, 16, 1, 16, 1, 16, 5, 16, 671, 8,
		16, 10, 16, 12, 16, 674, 9, 16, 1, 16, 1, 16, 3, 16, 678, 8, 16, 1, 16,
		1, 16, 1, 16, 1, 16, 1, 16, 5, 16, 685, 8, 16, 10, 16, 12, 16, 688, 9,
		16, 1, 16, 1, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 5, 17, 697, 8, 17,
		10, 17, 12, 17, 700, 9, 17, 1, 17, 1, 17, 3, 17, 704, 8, 17, 1, 17, 3,
		17, 707, 8, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 18, 1, 18, 1, 18,
		1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 721, 8, 18, 1, 18, 1, 18, 1, 19, 1,
		19, 1, 19, 3, 19, 728, 8, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 5, 19,
		735, 8, 19, 10, 19, 12, 19, 738, 9, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1,
		19, 1, 20, 1, 20, 1, 20, 1, 21, 1, 21, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22,
		754, 8, 22, 1, 23, 1, 23, 1, 23, 1, 23, 5, 23, 760, 8, 23, 10, 23, 12,
		23, 763, 9, 23, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 5, 24, 771, 8,
		24, 10, 24, 12, 24, 774, 9, 24, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 5, 25,
		781, 8, 25, 10, 25, 12, 25, 784, 9, 25, 1, 26, 1, 26, 1, 26, 1, 26, 1,
		26, 3, 26, 791, 8, 26, 1, 27, 1, 27, 1, 27, 5, 27, 796, 8, 27, 10, 27,
		12, 27, 799, 9, 27, 1, 27, 3, 27, 802, 8, 27, 1, 27, 1, 27, 3, 27, 806,
		8, 27, 1, 27, 5, 27, 809, 8, 27, 10, 27, 12, 27, 812, 9, 27, 1, 27, 3,
		27, 815, 8, 27, 1, 27, 1, 27, 1, 27, 3, 27, 820, 8, 27, 1, 27, 1, 27, 3,
		27, 824, 8, 27, 1, 27, 1, 27, 3, 27, 828, 8, 27, 1, 28, 1, 28, 1, 28, 1,
		29, 1, 29, 1, 29, 1, 29, 1, 29, 3, 29, 838, 8, 29, 1, 29, 1, 29, 3, 29,
		842, 8, 29, 1, 29, 1, 29, 1, 29, 3, 29, 847, 8, 29, 1, 30, 1, 30, 1, 30,
		3, 30, 852, 8, 30, 1, 30, 1, 30, 3, 30, 856, 8, 30, 1, 31, 1, 31, 1, 31,
		1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 3, 32, 869, 8,
		32, 1, 32, 1, 32, 1, 33, 3, 33, 874, 8, 33, 1, 33, 1, 33, 1, 33, 1, 33,
		3, 33, 880, 8, 33, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 3,
		34, 889, 8, 34, 1, 34, 1, 34, 3, 34, 893, 8, 34, 1, 34, 1, 34, 1, 35, 1,
		35, 1, 35, 1, 35, 3, 35, 901, 8, 35, 1, 35, 3, 35, 904, 8, 35, 1, 35, 1,
		35, 1, 35, 3, 35, 909, 8, 35, 1, 35, 1, 35, 1, 36, 3, 36, 914, 8, 36, 1,
		36, 1, 36, 1, 36, 1, 36, 1, 36, 3, 36, 921, 8, 36, 1, 36, 1, 36, 1, 36,
		1, 36, 1, 36, 1, 36, 1, 36, 3, 36, 930, 8, 36, 1, 36, 3, 36, 933, 8, 36,
		1, 37, 1, 37, 1, 37, 1, 38, 1, 38, 3, 38, 940, 8, 38, 1, 38, 1, 38, 1,
		38, 3, 38, 945, 8, 38, 5, 38, 947, 8, 38, 10, 38, 12, 38, 950, 9, 38, 1,
		39, 1, 39, 1, 39, 3, 39, 955, 8, 39, 1, 39, 5, 39, 958, 8, 39, 10, 39,
		12, 39, 961, 9, 39, 1, 39, 5, 39, 964, 8, 39, 10, 39, 12, 39, 967, 9, 39,
		1, 39, 1, 39, 3, 39, 971, 8, 39, 1, 39, 3, 39, 974, 8, 39, 1, 40, 1, 40,
		1, 41, 1, 41, 3, 41, 980, 8, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1,
		41, 1, 41, 1, 41, 1, 41, 1, 41, 5, 41, 992, 8, 41, 10, 41, 12, 41, 995,
		9, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 5, 41, 1002, 8, 41, 10, 41, 12,
		41, 1005, 9, 41, 1, 41, 1, 41, 1, 41, 3, 41, 1010, 8, 41, 1, 42, 1, 42,
		1, 42, 3, 42, 1015, 8, 42, 1, 42, 1, 42, 1, 42, 3, 42, 1020, 8, 42, 1,
		42, 1, 42, 1, 42, 3, 42, 1025, 8, 42, 5, 42, 1027, 8, 42, 10, 42, 12, 42,
		1030, 9, 42, 1, 42, 1, 42, 3, 42, 1034, 8, 42, 1, 42, 3, 42, 1037, 8, 42,
		1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 5, 42, 1045, 8, 42, 10, 42, 12,
		42, 1048, 9, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 5, 42,
		1057, 8, 42, 10, 42, 12, 42, 1060, 9, 42, 1, 42, 1, 42, 5, 42, 1064, 8,
		42, 10, 42, 12, 42, 1067, 9, 42, 3, 42, 1069, 8, 42, 1, 43, 1, 43, 1, 43,
		1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 1081, 8, 43, 1,
		44, 4, 44, 1084, 8, 44, 11, 44, 12, 44, 1085, 1, 45, 1, 45, 1, 45, 3, 45,
		1091, 8, 45, 1, 46, 3, 46, 1094, 8, 46, 1, 46, 1, 46, 1, 47, 4, 47, 1099,
		8, 47, 11, 47, 12, 47, 1100, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48,
		1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 1113, 8, 48, 1, 49, 1, 49, 1, 49, 1,
		49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 4, 49, 1126, 8, 49,
		11, 49, 12, 49, 1127, 1, 49, 1, 49, 1, 49, 3, 49, 1133, 8, 49, 1, 50, 3,
		50, 1136, 8, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50,
		1, 50, 1, 50, 1, 50, 5, 50, 1149, 8, 50, 10, 50, 12, 50, 1152, 9, 50, 1,
		50, 1, 50, 1, 50, 3, 50, 1157, 8, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50,
		1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 1168, 8, 50, 1, 51, 3, 51, 1171, 8,
		51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 5, 51, 1179, 8, 51, 10, 51,
		12, 51, 1182, 9, 51, 1, 51, 1, 51, 1, 51, 1, 51, 3, 51, 1188, 8, 51, 1,
		52, 1, 52, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53,
		1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1205, 8, 53, 1, 53, 1, 53, 1, 53, 1,
		53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53,
		1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1,
		53, 1, 53, 1, 53, 3, 53, 1234, 8, 53, 1, 54, 1, 54, 1, 54, 3, 54, 1239,
		8, 54, 1, 54, 1, 54, 3, 54, 1243, 8, 54, 1, 54, 1, 54, 1, 55, 1, 55, 1,
		55, 3, 55, 1250, 8, 55, 1, 56, 1, 56, 1, 56, 1, 57, 1, 57, 3, 57, 1257,
		8, 57, 1, 57, 1, 57, 1, 57, 3, 57, 1262, 8, 57, 5, 57, 1264, 8, 57, 10,
		57, 12, 57, 1267, 9, 57, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 59,
		1, 59, 1, 59, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 3, 60, 1284, 8,
		60, 1, 61, 1, 61, 1, 61, 1, 61, 5, 61, 1290, 8, 61, 10, 61, 12, 61, 1293,
		9, 61, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 3, 62, 1302, 8,
		62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62,
		1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 3, 62, 1322, 8,
		62, 1, 63, 1, 63, 1, 63, 1, 63, 3, 63, 1328, 8, 63, 1, 64, 1, 64, 3, 64,
		1332, 8, 64, 1, 64, 1, 64, 1, 64, 3, 64, 1337, 8, 64, 1, 64, 1, 64, 3,
		64, 1341, 8, 64, 1, 64, 1, 64, 1, 64, 3, 64, 1346, 8, 64, 1, 64, 3, 64,
		1349, 8, 64, 1, 64, 1, 64, 1, 64, 3, 64, 1354, 8, 64, 1, 64, 3, 64, 1357,
		8, 64, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 66, 1, 66, 1, 67, 1, 67, 1,
		67, 3, 67, 1369, 8, 67, 1, 67, 1, 67, 1, 68, 1, 68, 1, 68, 3, 68, 1376,
		8, 68, 1, 68, 1, 68, 1, 68, 3, 68, 1381, 8, 68, 1, 68, 1, 68, 1, 68, 3,
		68, 1386, 8, 68, 5, 68, 1388, 8, 68, 10, 68, 12, 68, 1391, 9, 68, 1, 68,
		1, 68, 3, 68, 1395, 8, 68, 1, 68, 3, 68, 1398, 8, 68, 1, 68, 1, 68, 1,
		68, 1, 68, 1, 68, 1, 68, 5, 68, 1406, 8, 68, 10, 68, 12, 68, 1409, 9, 68,
		1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 5, 68, 1418, 8, 68, 10,
		68, 12, 68, 1421, 9, 68, 1, 68, 1, 68, 5, 68, 1425, 8, 68, 10, 68, 12,
		68, 1428, 9, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 3, 68, 1435, 8, 68,
		1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1,
		69, 1, 69, 1, 69, 3, 69, 1450, 8, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69,
		1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1,
		69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69,
		1, 69, 3, 69, 1479, 8, 69, 1, 70, 1, 70, 1, 70, 3, 70, 1484, 8, 70, 1,
		70, 1, 70, 3, 70, 1488, 8, 70, 1, 70, 1, 70, 1, 71, 3, 71, 1493, 8, 71,
		1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 3, 71, 1500, 8, 71, 1, 71, 3, 71, 1503,
		8, 71, 1, 72, 3, 72, 1506, 8, 72, 1, 72, 1, 72, 1, 72, 3, 72, 1511, 8,
		72, 1, 72, 1, 72, 3, 72, 1515, 8, 72, 3, 72, 1517, 8, 72, 1, 73, 1, 73,
		1, 73, 1, 73, 1, 73, 3, 73, 1524, 8, 73, 1, 73, 1, 73, 5, 73, 1528, 8,
		73, 10, 73, 12, 73, 1531, 9, 73, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 1537,
		8, 74, 1, 75, 1, 75, 1, 75, 1, 75, 3, 75, 1543, 8, 75, 1, 75, 3, 75, 1546,
		8, 75, 1, 75, 1, 75, 1, 75, 3, 75, 1551, 8, 75, 1, 75, 1, 75, 3, 75, 1555,
		8, 75, 1, 75, 3, 75, 1558, 8, 75, 1, 75, 1, 75, 1, 76, 1, 76, 1, 76, 3,
		76, 1565, 8, 76, 1, 77, 1, 77, 1, 77, 1, 77, 3, 77, 1571, 8, 77, 1, 77,
		3, 77, 1574, 8, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1,
		77, 3, 77, 1584, 8, 77, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 5, 78, 1591,
		8, 78, 10, 78, 12, 78, 1594, 9, 78, 1, 79, 1, 79, 1, 79, 1, 79, 3, 79,
		1600, 8, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 3, 79, 1607, 8, 79, 3,
		79, 1609, 8, 79, 1, 80, 1, 80, 1, 80, 1, 80, 3, 80, 1615, 8, 80, 1, 80,
		3, 80, 1618, 8, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1,
		80, 1, 80, 3, 80, 1629, 8, 80, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 5, 81,
		1636, 8, 81, 10, 81, 12, 81, 1639, 9, 81, 1, 82, 1, 82, 1, 82, 3, 82, 1644,
		8, 82, 1, 83, 1, 83, 1, 83, 1, 83, 3, 83, 1650, 8, 83, 1, 83, 3, 83, 1653,
		8, 83, 1, 83, 1, 83, 1, 83, 3, 83, 1658, 8, 83, 1, 83, 3, 83, 1661, 8,
		83, 1, 83, 3, 83, 1664, 8, 83, 1, 83, 3, 83, 1667, 8, 83, 1, 83, 3, 83,
		1670, 8, 83, 1, 83, 1, 83, 1, 83, 1, 83, 3, 83, 1676, 8, 83, 1, 84, 1,
		84, 1, 84, 1, 84, 1, 84, 1, 84, 5, 84, 1684, 8, 84, 10, 84, 12, 84, 1687,
		9, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 5, 84, 1695, 8, 84, 10,
		84, 12, 84, 1698, 9, 84, 3, 84, 1700, 8, 84, 1, 85, 1, 85, 1, 85, 1, 85,
		1, 85, 3, 85, 1707, 8, 85, 1, 85, 1, 85, 1, 85, 3, 85, 1712, 8, 85, 1,
		85, 5, 85, 1715, 8, 85, 10, 85, 12, 85, 1718, 9, 85, 1, 85, 3, 85, 1721,
		8, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 3, 85, 1729, 8, 85, 1,
		85, 1, 85, 3, 85, 1733, 8, 85, 1, 85, 5, 85, 1736, 8, 85, 10, 85, 12, 85,
		1739, 9, 85, 1, 85, 3, 85, 1742, 8, 85, 3, 85, 1744, 8, 85, 1, 86, 4, 86,
		1747, 8, 86, 11, 86, 12, 86, 1748, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1,
		87, 3, 87, 1757, 8, 87, 1, 87, 1, 87, 1, 87, 3, 87, 1762, 8, 87, 1, 88,
		1, 88, 1, 88, 1, 88, 3, 88, 1768, 8, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1,
		88, 3, 88, 1775, 8, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 3, 88, 1782,
		8, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 3, 88, 1789, 8, 88, 1, 88, 3,
		88, 1792, 8, 88, 1, 89, 1, 89, 1, 89, 1, 90, 1, 90, 3, 90, 1799, 8, 90,
		1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 3, 90, 1807, 8, 90, 1, 90, 1,
		90, 1, 90, 1, 90, 5, 90, 1813, 8, 90, 10, 90, 12, 90, 1816, 9, 90, 3, 90,
		1818, 8, 90, 1, 90, 3, 90, 1821, 8, 90, 1, 91, 1, 91, 1, 91, 3, 91, 1826,
		8, 91, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 5, 92, 1833, 8, 92, 10, 92, 12,
		92, 1836, 9, 92, 1, 92, 3, 92, 1839, 8, 92, 1, 92, 1, 92, 1, 92, 1, 93,
		1, 93, 1, 93, 1, 93, 1, 93, 3, 93, 1849, 8, 93, 1, 94, 1, 94, 1, 94, 1,
		94, 1, 94, 1, 94, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 96, 1, 96, 1, 96,
		1, 97, 1, 97, 1, 97, 3, 97, 1868, 8, 97, 1, 98, 1, 98, 1, 98, 1, 98, 1,
		98, 3, 98, 1875, 8, 98, 3, 98, 1877, 8, 98, 1, 98, 1, 98, 3, 98, 1881,
		8, 98, 1, 98, 1, 98, 3, 98, 1885, 8, 98, 1, 99, 1, 99, 1, 99, 1, 99, 5,
		99, 1891, 8, 99, 10, 99, 12, 99, 1894, 9, 99, 1, 99, 1, 99, 1, 100, 1,
		100, 1, 100, 1, 100, 5, 100, 1902, 8, 100, 10, 100, 12, 100, 1905, 9, 100,
		1, 101, 1, 101, 1, 101, 1, 101, 5, 101, 1911, 8, 101, 10, 101, 12, 101,
		1914, 9, 101, 1, 101, 1, 101, 1, 102, 1, 102, 1, 102, 3, 102, 1921, 8,
		102, 1, 102, 1, 102, 1, 102, 1, 102, 1, 103, 1, 103, 3, 103, 1929, 8, 103,
		1, 103, 1, 103, 3, 103, 1933, 8, 103, 1, 104, 1, 104, 1, 104, 1, 104, 1,
		105, 1, 105, 3, 105, 1941, 8, 105, 1, 106, 1, 106, 1, 106, 1, 106, 1, 106,
		1, 106, 1, 107, 1, 107, 1, 107, 1, 107, 1, 108, 1, 108, 1, 108, 1, 108,
		5, 108, 1957, 8, 108, 10, 108, 12, 108, 1960, 9, 108, 1, 108, 1, 108, 1,
		108, 1, 108, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 110, 1, 110, 3,
		110, 1973, 8, 110, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 3, 111, 1980,
		8, 111, 1, 111, 1, 111, 3, 111, 1984, 8, 111, 1, 112, 1, 112, 1, 112, 1,
		112, 1, 112, 3, 112, 1991, 8, 112, 3, 112, 1993, 8, 112, 1, 113, 1, 113,
		3, 113, 1997, 8, 113, 1, 113, 1, 113, 3, 113, 2001, 8, 113, 1, 113, 1,
		113, 1, 113, 1, 113, 5, 113, 2007, 8, 113, 10, 113, 12, 113, 2010, 9, 113,
		1, 113, 3, 113, 2013, 8, 113, 1, 114, 1, 114, 1, 114, 1, 115, 1, 115, 1,
		115, 1, 115, 1, 115, 3, 115, 2023, 8, 115, 1, 116, 1, 116, 1, 116, 1, 116,
		1, 116, 5, 116, 2030, 8, 116, 10, 116, 12, 116, 2033, 9, 116, 1, 116, 1,
		116, 1, 117, 1, 117, 1, 117, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1,
		118, 1, 119, 1, 119, 3, 119, 2048, 8, 119, 1, 119, 1, 119, 1, 119, 1, 119,
		3, 119, 2054, 8, 119, 1, 119, 1, 119, 3, 119, 2058, 8, 119, 1, 120, 1,
		120, 1, 120, 1, 120, 1, 120, 1, 120, 5, 120, 2066, 8, 120, 10, 120, 12,
		120, 2069, 9, 120, 1, 120, 1, 120, 1, 120, 5, 120, 2074, 8, 120, 10, 120,
		12, 120, 2077, 9, 120, 1, 121, 1, 121, 1, 121, 1, 121, 1, 121, 1, 121,
		3, 121, 2085, 8, 121, 1, 121, 1, 121, 3, 121, 2089, 8, 121, 1, 121, 1,
		121, 5, 121, 2093, 8, 121, 10, 121, 12, 121, 2096, 9, 121, 1, 122, 1, 122,
		3, 122, 2100, 8, 122, 1, 123, 1, 123, 3, 123, 2104, 8, 123, 1, 124, 1,
		124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 3, 124, 2114, 8, 124,
		1, 125, 1, 125, 1, 126, 1, 126, 3, 126, 2120, 8, 126, 1, 127, 1, 127, 3,
		127, 2124, 8, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127,
		1, 127, 5, 127, 2134, 8, 127, 10, 127, 12, 127, 2137, 9, 127, 1, 127, 1,
		127, 1, 128, 1, 128, 3, 128, 2143, 8, 128, 1, 129, 1, 129, 1, 130, 1, 130,
		1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 5, 130,
		2157, 8, 130, 10, 130, 12, 130, 2160, 9, 130, 1, 130, 1, 130, 5, 130, 2164,
		8, 130, 10, 130, 12, 130, 2167, 9, 130, 1, 131, 1, 131, 1, 131, 1, 131,
		1, 131, 1, 131, 1, 131, 3, 131, 2176, 8, 131, 1, 132, 3, 132, 2179, 8,
		132, 1, 132, 1, 132, 3, 132, 2183, 8, 132, 1, 133, 1, 133, 1, 134, 1, 134,
		1, 134, 3, 134, 2190, 8, 134, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 3,
		134, 2197, 8, 134, 3, 134, 2199, 8, 134, 1, 135, 1, 135, 3, 135, 2203,
		8, 135, 1, 136, 1, 136, 3, 136, 2207, 8, 136, 1, 137, 1, 137, 1, 137, 3,
		137, 2212, 8, 137, 1, 138, 3, 138, 2215, 8, 138, 1, 138, 1, 138, 3, 138,
		2219, 8, 138, 1, 138, 3, 138, 2222, 8, 138, 1, 138, 1, 138, 1, 139, 1,
		139, 1, 139, 1, 140, 1, 140, 1, 140, 1, 140, 3, 140, 2233, 8, 140, 1, 140,
		3, 140, 2236, 8, 140, 1, 140, 1, 140, 1, 140, 1, 141, 1, 141, 1, 141, 1,
		142, 1, 142, 1, 142, 3, 142, 2247, 8, 142, 1, 142, 1, 142, 1, 142, 1, 142,
		3, 142, 2253, 8, 142, 1, 142, 1, 142, 3, 142, 2257, 8, 142, 3, 142, 2259,
		8, 142, 1, 143, 1, 143, 3, 143, 2263, 8, 143, 1, 143, 1, 143, 1, 144, 1,
		144, 1, 144, 1, 145, 1, 145, 3, 145, 2272, 8, 145, 1, 145, 1, 145, 1, 145,
		5, 145, 2277, 8, 145, 10, 145, 12, 145, 2280, 9, 145, 1, 145, 3, 145, 2283,
		8, 145, 1, 145, 1, 145, 3, 145, 2287, 8, 145, 1, 145, 1, 145, 1, 145, 5,
		145, 2292, 8, 145, 10, 145, 12, 145, 2295, 9, 145, 1, 145, 3, 145, 2298,
		8, 145, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 3, 146, 2306, 8,
		146, 1, 147, 1, 147, 1, 147, 1, 147, 1, 147, 1, 148, 1, 148, 1, 148, 1,
		148, 3, 148, 2317, 8, 148, 1, 148, 1, 148, 3, 148, 2321, 8, 148, 1, 148,
		1, 148, 1, 148, 1, 148, 1, 148, 1, 149, 1, 149, 1, 149, 1, 149, 3, 149,
		2332, 8, 149, 1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 3, 149, 2339, 8,
		149, 1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 1, 150, 1, 150, 1, 150, 1,
		150, 1, 150, 1, 150, 3, 150, 2352, 8, 150, 1, 151, 1, 151, 1, 151, 1, 151,
		5, 151, 2358, 8, 151, 10, 151, 12, 151, 2361, 9, 151, 1, 152, 3, 152, 2364,
		8, 152, 1, 152, 1, 152, 1, 153, 1, 153, 1, 153, 1, 153, 5, 153, 2372, 8,
		153, 10, 153, 12, 153, 2375, 9, 153, 1, 154, 1, 154, 3, 154, 2379, 8, 154,
		1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1, 155, 1, 155, 1, 155, 1, 155,
		5, 155, 2390, 8, 155, 10, 155, 12, 155, 2393, 9, 155, 1, 155, 1, 155, 1,
		156, 1, 156, 1, 156, 1, 156, 5, 156, 2401, 8, 156, 10, 156, 12, 156, 2404,
		9, 156, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 3, 157, 2411, 8, 157, 1,
		158, 1, 158, 3, 158, 2415, 8, 158, 1, 158, 1, 158, 3, 158, 2419, 8, 158,
		1, 158, 1, 158, 3, 158, 2423, 8, 158, 3, 158, 2425, 8, 158, 1, 159, 1,
		159, 1, 159, 3, 159, 2430, 8, 159, 1, 159, 3, 159, 2433, 8, 159, 1, 159,
		3, 159, 2436, 8, 159, 1, 159, 3, 159, 2439, 8, 159, 1, 159, 1, 159, 3,
		159, 2443, 8, 159, 1, 159, 3, 159, 2446, 8, 159, 1, 159, 3, 159, 2449,
		8, 159, 1, 160, 3, 160, 2452, 8, 160, 1, 160, 3, 160, 2455, 8, 160, 1,
		160, 1, 160, 1, 160, 5, 160, 2460, 8, 160, 10, 160, 12, 160, 2463, 9, 160,
		1, 161, 1, 161, 1, 162, 1, 162, 1, 162, 1, 163, 1, 163, 1, 163, 3, 163,
		2473, 8, 163, 1, 163, 1, 163, 3, 163, 2477, 8, 163, 1, 163, 3, 163, 2480,
		8, 163, 1, 164, 1, 164, 3, 164, 2484, 8, 164, 1, 164, 1, 164, 1, 164, 1,
		164, 1, 164, 3, 164, 2491, 8, 164, 1, 165, 1, 165, 3, 165, 2495, 8, 165,
		1, 165, 1, 165, 1, 166, 1, 166, 1, 166, 1, 166, 1, 166, 1, 167, 3, 167,
		2505, 8, 167, 1, 167, 1, 167, 1, 167, 3, 167, 2510, 8, 167, 1, 167, 1,
		167, 1, 167, 3, 167, 2515, 8, 167, 5, 167, 2517, 8, 167, 10, 167, 12, 167,
		2520, 9, 167, 1, 168, 1, 168, 1, 168, 1, 169, 1, 169, 1, 169, 5, 169, 2528,
		8, 169, 10, 169, 12, 169, 2531, 9, 169, 1, 170, 1, 170, 1, 170, 3, 170,
		2536, 8, 170, 1, 171, 1, 171, 3, 171, 2540, 8, 171, 1, 172, 1, 172, 1,
		172, 1, 172, 3, 172, 2546, 8, 172, 1, 173, 1, 173, 1, 173, 1, 173, 1, 173,
		1, 173, 1, 173, 3, 173, 2555, 8, 173, 1, 174, 3, 174, 2558, 8, 174, 1,
		174, 1, 174, 1, 174, 3, 174, 2563, 8, 174, 1, 174, 3, 174, 2566, 8, 174,
		1, 175, 1, 175, 1, 175, 1, 175, 1, 175, 1, 175, 5, 175, 2574, 8, 175, 10,
		175, 12, 175, 2577, 9, 175, 1, 175, 1, 175, 3, 175, 2581, 8, 175, 1, 176,
		1, 176, 1, 176, 1, 176, 1, 176, 5, 176, 2588, 8, 176, 10, 176, 12, 176,
		2591, 9, 176, 1, 176, 1, 176, 3, 176, 2595, 8, 176, 1, 177, 1, 177, 3,
		177, 2599, 8, 177, 1, 177, 1, 177, 1, 177, 1, 177, 1, 177, 5, 177, 2606,
		8, 177, 10, 177, 12, 177, 2609, 9, 177, 1, 177, 3, 177, 2612, 8, 177, 1,
		178, 1, 178, 1, 179, 1, 179, 1, 179, 1, 180, 1, 180, 1, 180, 1, 180, 1,
		180, 5, 180, 2624, 8, 180, 10, 180, 12, 180, 2627, 9, 180, 1, 181, 1, 181,
		1, 181, 1, 182, 1, 182, 1, 182, 1, 183, 1, 183, 1, 183, 1, 183, 3, 183,
		2639, 8, 183, 1, 183, 1, 183, 1, 183, 3, 183, 2644, 8, 183, 5, 183, 2646,
		8, 183, 10, 183, 12, 183, 2649, 9, 183, 1, 184, 4, 184, 2652, 8, 184, 11,
		184, 12, 184, 2653, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1,
		185, 1, 185, 1, 185, 3, 185, 2665, 8, 185, 3, 185, 2667, 8, 185, 1, 186,
		1, 186, 1, 186, 1, 186, 1, 186, 3, 186, 2674, 8, 186, 1, 186, 3, 186, 2677,
		8, 186, 1, 187, 1, 187, 1, 187, 5, 187, 2682, 8, 187, 10, 187, 12, 187,
		2685, 9, 187, 1, 188, 1, 188, 3, 188, 2689, 8, 188, 1, 188, 1, 188, 1,
		188, 1, 188, 3, 188, 2695, 8, 188, 1, 188, 3, 188, 2698, 8, 188, 1, 188,
		3, 188, 2701, 8, 188, 1, 189, 1, 189, 1, 189, 1, 190, 1, 190, 1, 190, 1,
		190, 1, 190, 1, 190, 1, 190, 1, 190, 4, 190, 2714, 8, 190, 11, 190, 12,
		190, 2715, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 3, 191, 2723, 8, 191,
		1, 191, 3, 191, 2726, 8, 191, 1, 191, 3, 191, 2729, 8, 191, 1, 192, 1,
		192, 3, 192, 2733, 8, 192, 1, 192, 1, 192, 1, 192, 3, 192, 2738, 8, 192,
		1, 192, 1, 192, 1, 192, 1, 192, 3, 192, 2744, 8, 192, 1, 193, 1, 193, 3,
		193, 2748, 8, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193,
		5, 193, 2757, 8, 193, 10, 193, 12, 193, 2760, 9, 193, 1, 193, 3, 193, 2763,
		8, 193, 1, 193, 3, 193, 2766, 8, 193, 1, 194, 1, 194, 3, 194, 2770, 8,
		194, 1, 194, 1, 194, 3, 194, 2774, 8, 194, 1, 194, 1, 194, 3, 194, 2778,
		8, 194, 1, 195, 1, 195, 3, 195, 2782, 8, 195, 1, 195, 1, 195, 1, 196, 1,
		196, 3, 196, 2788, 8, 196, 1, 196, 1, 196, 1, 197, 1, 197, 3, 197, 2794,
		8, 197, 1, 197, 1, 197, 1, 197, 1, 197, 1, 197, 3, 197, 2801, 8, 197, 1,
		197, 1, 197, 1, 197, 1, 197, 5, 197, 2807, 8, 197, 10, 197, 12, 197, 2810,
		9, 197, 1, 198, 1, 198, 1, 198, 3, 198, 2815, 8, 198, 1, 199, 1, 199, 1,
		199, 3, 199, 2820, 8, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199,
		1, 199, 1, 199, 1, 199, 3, 199, 2831, 8, 199, 1, 199, 1, 199, 1, 199, 1,
		199, 1, 199, 1, 199, 1, 199, 3, 199, 2840, 8, 199, 1, 200, 1, 200, 3, 200,
		2844, 8, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 5, 200, 2851, 8,
		200, 10, 200, 12, 200, 2854, 9, 200, 1, 200, 3, 200, 2857, 8, 200, 1, 200,
		1, 200, 1, 201, 1, 201, 1, 201, 1, 201, 5, 201, 2865, 8, 201, 10, 201,
		12, 201, 2868, 9, 201, 1, 201, 1, 201, 3, 201, 2872, 8, 201, 1, 201, 1,
		201, 1, 201, 1, 201, 1, 201, 1, 202, 1, 202, 1, 202, 1, 202, 1, 203, 1,
		203, 1, 204, 1, 204, 1, 204, 1, 204, 1, 204, 1, 204, 1, 204, 1, 204, 1,
		204, 3, 204, 2894, 8, 204, 1, 204, 3, 204, 2897, 8, 204, 1, 205, 1, 205,
		1, 205, 1, 205, 1, 205, 1, 205, 1, 205, 1, 205, 1, 205, 1, 205, 1, 205,
		1, 205, 1, 205, 1, 205, 1, 205, 1, 205, 1, 205, 1, 205, 3, 205, 2917, 8,
		205, 1, 205, 1, 205, 1, 205, 1, 205, 1, 205, 1, 205, 1, 205, 1, 205, 5,
		205, 2927, 8, 205, 10, 205, 12, 205, 2930, 9, 205, 1, 206, 1, 206, 1, 206,
		1, 206, 1, 206, 1, 206, 1, 206, 1, 206, 3, 206, 2940, 8, 206, 1, 207, 1,
		207, 1, 207, 1, 207, 1, 208, 1, 208, 1, 209, 1, 209, 1, 209, 1, 209, 1,
		209, 5, 209, 2953, 8, 209, 10, 209, 12, 209, 2956, 9, 209, 1, 210, 1, 210,
		1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 3, 210,
		2968, 8, 210, 1, 211, 1, 211, 3, 211, 2972, 8, 211, 1, 212, 1, 212, 1,
		212, 1, 212, 1, 212, 1, 212, 1, 212, 4, 212, 2981, 8, 212, 11, 212, 12,
		212, 2982, 1, 212, 1, 212, 3, 212, 2987, 8, 212, 1, 212, 1, 212, 1, 213,
		1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 4, 213, 2997, 8, 213, 11, 213,
		12, 213, 2998, 1, 213, 1, 213, 3, 213, 3003, 8, 213, 1, 213, 1, 213, 1,
		214, 1, 214, 1, 214, 1, 214, 1, 215, 1, 215, 1, 215, 3, 215, 3014, 8, 215,
		1, 215, 1, 215, 1, 215, 3, 215, 3019, 8, 215, 1, 215, 1, 215, 1, 215, 3,
		215, 3024, 8, 215, 1, 215, 1, 215, 3, 215, 3028, 8, 215, 1, 215, 1, 215,
		3, 215, 3032, 8, 215, 1, 215, 1, 215, 1, 215, 3, 215, 3037, 8, 215, 1,
		215, 1, 215, 3, 215, 3041, 8, 215, 1, 215, 1, 215, 3, 215, 3045, 8, 215,
		1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215,
		1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215,
		1, 215, 1, 215, 1, 215, 3, 215, 3068, 8, 215, 3, 215, 3070, 8, 215, 1,
		215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1,
		215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 3, 215, 3088, 8, 215,
		3, 215, 3090, 8, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 3,
		215, 3098, 8, 215, 1, 215, 1, 215, 1, 215, 3, 215, 3103, 8, 215, 1, 215,
		1, 215, 1, 215, 3, 215, 3108, 8, 215, 1, 215, 1, 215, 1, 215, 3, 215, 3113,
		8, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215,
		1, 215, 1, 215, 1, 215, 3, 215, 3126, 8, 215, 1, 215, 1, 215, 1, 215, 3,
		215, 3131, 8, 215, 1, 215, 1, 215, 1, 215, 3, 215, 3136, 8, 215, 1, 215,
		1, 215, 1, 215, 3, 215, 3141, 8, 215, 1, 215, 1, 215, 1, 215, 3, 215, 3146,
		8, 215, 1, 215, 1, 215, 1, 215, 3, 215, 3151, 8, 215, 1, 215, 1, 215, 1,
		215, 3, 215, 3156, 8, 215, 1, 215, 1, 215, 1, 215, 3, 215, 3161, 8, 215,
		3, 215, 3163, 8, 215, 1, 216, 1, 216, 1, 217, 1, 217, 1, 217, 3, 217, 3170,
		8, 217, 1, 217, 3, 217, 3173, 8, 217, 1, 217, 1, 217, 1, 218, 1, 218, 1,
		218, 1, 218, 1, 218, 5, 218, 3182, 8, 218, 10, 218, 12, 218, 3185, 9, 218,
		1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 3, 219, 3194, 8,
		219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 3, 219, 3202, 8, 219,
		1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 3, 219, 3211, 8,
		219, 1, 219, 1, 219, 1, 219, 1, 219, 3, 219, 3217, 8, 219, 1, 219, 1, 219,
		1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219,
		1, 219, 1, 219, 5, 219, 3232, 8, 219, 10, 219, 12, 219, 3235, 9, 219, 3,
		219, 3237, 8, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219,
		1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 5, 219, 3251, 8, 219, 10, 219,
		12, 219, 3254, 9, 219, 3, 219, 3256, 8, 219, 1, 219, 1, 219, 1, 219, 1,
		219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 5,
		219, 3270, 8, 219, 10, 219, 12, 219, 3273, 9, 219, 3, 219, 3275, 8, 219,
		1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219,
		1, 219, 1, 219, 1, 219, 5, 219, 3289, 8, 219, 10, 219, 12, 219, 3292, 9,
		219, 3, 219, 3294, 8, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219,
		1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 5, 219, 3308, 8, 219, 10,
		219, 12, 219, 3311, 9, 219, 3, 219, 3313, 8, 219, 1, 219, 1, 219, 1, 219,
		1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219,
		5, 219, 3327, 8, 219, 10, 219, 12, 219, 3330, 9, 219, 3, 219, 3332, 8,
		219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1,
		219, 1, 219, 5, 219, 3344, 8, 219, 10, 219, 12, 219, 3347, 9, 219, 1, 219,
		1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219,
		4, 219, 3359, 8, 219, 11, 219, 12, 219, 3360, 1, 219, 1, 219, 3, 219, 3365,
		8, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219,
		1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 3, 219, 3381, 8, 219, 1,
		219, 1, 219, 1, 219, 1, 219, 3, 219, 3387, 8, 219, 1, 220, 1, 220, 1, 220,
		3, 220, 3392, 8, 220, 1, 220, 1, 220, 1, 221, 1, 221, 3, 221, 3398, 8,
		221, 1, 222, 1, 222, 3, 222, 3402, 8, 222, 1, 222, 1, 222, 1, 222, 1, 223,
		1, 223, 3, 223, 3409, 8, 223, 1, 223, 1, 223, 1, 223, 1, 224, 1, 224, 1,
		224, 5, 224, 3417, 8, 224, 10, 224, 12, 224, 3420, 9, 224, 1, 225, 1, 225,
		1, 225, 1, 225, 3, 225, 3426, 8, 225, 3, 225, 3428, 8, 225, 1, 225, 1,
		225, 1, 226, 1, 226, 3, 226, 3434, 8, 226, 1, 227, 1, 227, 3, 227, 3438,
		8, 227, 1, 228, 1, 228, 5, 228, 3442, 8, 228, 10, 228, 12, 228, 3445, 9,
		228, 1, 229, 1, 229, 1, 229, 1, 229, 1, 229, 1, 229, 1, 229, 1, 229, 1,
		229, 1, 229, 1, 229, 1, 229, 3, 229, 3459, 8, 229, 1, 230, 1, 230, 1, 230,
		1, 230, 1, 230, 3, 230, 3466, 8, 230, 1, 231, 5, 231, 3469, 8, 231, 10,
		231, 12, 231, 3472, 9, 231, 1, 232, 1, 232, 1, 232, 1, 233, 1, 233, 1,
		233, 1, 233, 3, 233, 3481, 8, 233, 1, 233, 1, 233, 1, 233, 5, 233, 3486,
		8, 233, 10, 233, 12, 233, 3489, 9, 233, 3, 233, 3491, 8, 233, 1, 234, 1,
		234, 1, 234, 1, 235, 1, 235, 1, 235, 1, 236, 3, 236, 3500, 8, 236, 1, 236,
		1, 236, 3, 236, 3504, 8, 236, 1, 237, 1, 237, 1, 237, 5, 237, 3509, 8,
		237, 10, 237, 12, 237, 3512, 9, 237, 1, 238, 1, 238, 3, 238, 3516, 8, 238,
		1, 239, 3, 239, 3519, 8, 239, 1, 239, 1, 239, 1, 240, 3, 240, 3524, 8,
		240, 1, 240, 1, 240, 1, 241, 1, 241, 1, 242, 1, 242, 1, 243, 1, 243, 1,
		243, 1, 3470, 2, 394, 410, 244, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20,
		22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56,
		58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92,
		94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122,
		124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152,
		154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182,
		184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212,
		214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242,
		244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270, 272,
		274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302,
		304, 306, 308, 310, 312, 314, 316, 318, 320, 322, 324, 326, 328, 330, 332,
		334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362,
		364, 366, 368, 370, 372, 374, 376, 378, 380, 382, 384, 386, 388, 390, 392,
		394, 396, 398, 400, 402, 404, 406, 408, 410, 412, 414, 416, 418, 420, 422,
		424, 426, 428, 430, 432, 434, 436, 438, 440, 442, 444, 446, 448, 450, 452,
		454, 456, 458, 460, 462, 464, 466, 468, 470, 472, 474, 476, 478, 480, 482,
		484, 486, 0, 50, 3, 0, 1, 2, 353, 353, 371, 371, 2, 0, 99, 99, 315, 315,
		1, 0, 169, 170, 3, 0, 13, 13, 116, 116, 154, 154, 2, 0, 34, 34, 42, 42,
		2, 0, 56, 56, 108, 108, 2, 0, 186, 186, 260, 260, 2, 0, 14, 14, 84, 84,
		2, 0, 81, 81, 304, 304, 2, 0, 109, 109, 172, 172, 2, 0, 81, 81, 220, 220,
		2, 0, 77, 77, 137, 137, 3, 0, 141, 141, 179, 179, 216, 217, 2, 0, 174,
		174, 193, 193, 2, 0, 190, 190, 323, 323, 2, 0, 178, 178, 376, 376, 2, 0,
		31, 31, 39, 39, 2, 0, 37, 37, 63, 63, 2, 0, 67, 67, 253, 253, 2, 0, 13,
		13, 154, 154, 1, 0, 238, 239, 1, 0, 223, 224, 4, 0, 62, 62, 79, 79, 153,
		153, 212, 212, 2, 0, 122, 122, 224, 224, 1, 0, 103, 104, 1, 0, 96, 97,
		1, 0, 276, 277, 2, 0, 248, 248, 284, 284, 3, 0, 81, 81, 136, 136, 211,
		211, 4, 0, 11, 12, 191, 191, 228, 228, 321, 321, 2, 0, 201, 201, 203, 203,
		2, 0, 261, 261, 299, 299, 4, 0, 20, 20, 91, 91, 175, 175, 292, 292, 2,
		0, 175, 175, 317, 317, 2, 0, 30, 30, 278, 278, 1, 0, 258, 259, 2, 0, 7,
		7, 89, 89, 3, 0, 121, 121, 163, 163, 241, 241, 3, 0, 63, 63, 249, 250,
		305, 305, 3, 0, 106, 106, 264, 264, 304, 304, 1, 0, 84, 85, 2, 0, 10, 10,
		206, 206, 3, 0, 164, 164, 232, 232, 242, 242, 2, 0, 353, 353, 364, 364,
		2, 0, 349, 349, 372, 372, 3, 0, 71, 72, 182, 183, 254, 255, 2, 0, 53, 53,
		352, 352, 3, 0, 119, 119, 155, 155, 196, 196, 2, 0, 110, 110, 300, 300,
		17, 0, 5, 24, 26, 31, 33, 94, 98, 98, 100, 183, 185, 196, 198, 201, 203,
		214, 216, 217, 219, 246, 248, 267, 269, 292, 294, 294, 296, 301, 303, 314,
		317, 334, 341, 348, 4002, 0, 488, 1, 0, 0, 0, 2, 498, 1, 0, 0, 0, 4, 503,
		1, 0, 0, 0, 6, 523, 1, 0, 0, 0, 8, 525, 1, 0, 0, 0, 10, 537, 1, 0, 0, 0,
		12, 601, 1, 0, 0, 0, 14, 603, 1, 0, 0, 0, 16, 605, 1, 0, 0, 0, 18, 611,
		1, 0, 0, 0, 20, 617, 1, 0, 0, 0, 22, 619, 1, 0, 0, 0, 24, 635, 1, 0, 0,
		0, 26, 641, 1, 0, 0, 0, 28, 659, 1, 0, 0, 0, 30, 661, 1, 0, 0, 0, 32, 666,
		1, 0, 0, 0, 34, 703, 1, 0, 0, 0, 36, 713, 1, 0, 0, 0, 38, 724, 1, 0, 0,
		0, 40, 744, 1, 0, 0, 0, 42, 747, 1, 0, 0, 0, 44, 749, 1, 0, 0, 0, 46, 755,
		1, 0, 0, 0, 48, 764, 1, 0, 0, 0, 50, 775, 1, 0, 0, 0, 52, 790, 1, 0, 0,
		0, 54, 827, 1, 0, 0, 0, 56, 829, 1, 0, 0, 0, 58, 837, 1, 0, 0, 0, 60, 848,
		1, 0, 0, 0, 62, 857, 1, 0, 0, 0, 64, 860, 1, 0, 0, 0, 66, 873, 1, 0, 0,
		0, 68, 883, 1, 0, 0, 0, 70, 896, 1, 0, 0, 0, 72, 929, 1, 0, 0, 0, 74, 934,
		1, 0, 0, 0, 76, 937, 1, 0, 0, 0, 78, 973, 1, 0, 0, 0, 80, 975, 1, 0, 0,
		0, 82, 1009, 1, 0, 0, 0, 84, 1068, 1, 0, 0, 0, 86, 1070, 1, 0, 0, 0, 88,
		1083, 1, 0, 0, 0, 90, 1090, 1, 0, 0, 0, 92, 1093, 1, 0, 0, 0, 94, 1098,
		1, 0, 0, 0, 96, 1112, 1, 0, 0, 0, 98, 1132, 1, 0, 0, 0, 100, 1167, 1, 0,
		0, 0, 102, 1187, 1, 0, 0, 0, 104, 1189, 1, 0, 0, 0, 106, 1233, 1, 0, 0,
		0, 108, 1235, 1, 0, 0, 0, 110, 1246, 1, 0, 0, 0, 112, 1251, 1, 0, 0, 0,
		114, 1254, 1, 0, 0, 0, 116, 1268, 1, 0, 0, 0, 118, 1274, 1, 0, 0, 0, 120,
		1283, 1, 0, 0, 0, 122, 1285, 1, 0, 0, 0, 124, 1321, 1, 0, 0, 0, 126, 1327,
		1, 0, 0, 0, 128, 1356, 1, 0, 0, 0, 130, 1358, 1, 0, 0, 0, 132, 1363, 1,
		0, 0, 0, 134, 1365, 1, 0, 0, 0, 136, 1434, 1, 0, 0, 0, 138, 1478, 1, 0,
		0, 0, 140, 1480, 1, 0, 0, 0, 142, 1502, 1, 0, 0, 0, 144, 1516, 1, 0, 0,
		0, 146, 1518, 1, 0, 0, 0, 148, 1536, 1, 0, 0, 0, 150, 1545, 1, 0, 0, 0,
		152, 1561, 1, 0, 0, 0, 154, 1573, 1, 0, 0, 0, 156, 1585, 1, 0, 0, 0, 158,
		1608, 1, 0, 0, 0, 160, 1617, 1, 0, 0, 0, 162, 1630, 1, 0, 0, 0, 164, 1643,
		1, 0, 0, 0, 166, 1652, 1, 0, 0, 0, 168, 1699, 1, 0, 0, 0, 170, 1743, 1,
		0, 0, 0, 172, 1746, 1, 0, 0, 0, 174, 1761, 1, 0, 0, 0, 176, 1791, 1, 0,
		0, 0, 178, 1793, 1, 0, 0, 0, 180, 1796, 1, 0, 0, 0, 182, 1825, 1, 0, 0,
		0, 184, 1827, 1, 0, 0, 0, 186, 1843, 1, 0, 0, 0, 188, 1850, 1, 0, 0, 0,
		190, 1856, 1, 0, 0, 0, 192, 1861, 1, 0, 0, 0, 194, 1864, 1, 0, 0, 0, 196,
		1869, 1, 0, 0, 0, 198, 1886, 1, 0, 0, 0, 200, 1897, 1, 0, 0, 0, 202, 1906,
		1, 0, 0, 0, 204, 1917, 1, 0, 0, 0, 206, 1926, 1, 0, 0, 0, 208, 1934, 1,
		0, 0, 0, 210, 1940, 1, 0, 0, 0, 212, 1942, 1, 0, 0, 0, 214, 1948, 1, 0,
		0, 0, 216, 1952, 1, 0, 0, 0, 218, 1965, 1, 0, 0, 0, 220, 1970, 1, 0, 0,
		0, 222, 1974, 1, 0, 0, 0, 224, 1985, 1, 0, 0, 0, 226, 1994, 1, 0, 0, 0,
		228, 2014, 1, 0, 0, 0, 230, 2017, 1, 0, 0, 0, 232, 2024, 1, 0, 0, 0, 234,
		2036, 1, 0, 0, 0, 236, 2039, 1, 0, 0, 0, 238, 2053, 1, 0, 0, 0, 240, 2059,
		1, 0, 0, 0, 242, 2078, 1, 0, 0, 0, 244, 2099, 1, 0, 0, 0, 246, 2103, 1,
		0, 0, 0, 248, 2113, 1, 0, 0, 0, 250, 2115, 1, 0, 0, 0, 252, 2117, 1, 0,
		0, 0, 254, 2121, 1, 0, 0, 0, 256, 2140, 1, 0, 0, 0, 258, 2144, 1, 0, 0,
		0, 260, 2146, 1, 0, 0, 0, 262, 2175, 1, 0, 0, 0, 264, 2178, 1, 0, 0, 0,
		266, 2184, 1, 0, 0, 0, 268, 2186, 1, 0, 0, 0, 270, 2200, 1, 0, 0, 0, 272,
		2204, 1, 0, 0, 0, 274, 2211, 1, 0, 0, 0, 276, 2218, 1, 0, 0, 0, 278, 2225,
		1, 0, 0, 0, 280, 2228, 1, 0, 0, 0, 282, 2240, 1, 0, 0, 0, 284, 2243, 1,
		0, 0, 0, 286, 2260, 1, 0, 0, 0, 288, 2266, 1, 0, 0, 0, 290, 2269, 1, 0,
		0, 0, 292, 2299, 1, 0, 0, 0, 294, 2307, 1, 0, 0, 0, 296, 2312, 1, 0, 0,
		0, 298, 2327, 1, 0, 0, 0, 300, 2351, 1, 0, 0, 0, 302, 2353, 1, 0, 0, 0,
		304, 2363, 1, 0, 0, 0, 306, 2367, 1, 0, 0, 0, 308, 2376, 1, 0, 0, 0, 310,
		2385, 1, 0, 0, 0, 312, 2396, 1, 0, 0, 0, 314, 2410, 1, 0, 0, 0, 316, 2424,
		1, 0, 0, 0, 318, 2426, 1, 0, 0, 0, 320, 2451, 1, 0, 0, 0, 322, 2464, 1,
		0, 0, 0, 324, 2466, 1, 0, 0, 0, 326, 2479, 1, 0, 0, 0, 328, 2490, 1, 0,
		0, 0, 330, 2494, 1, 0, 0, 0, 332, 2498, 1, 0, 0, 0, 334, 2504, 1, 0, 0,
		0, 336, 2521, 1, 0, 0, 0, 338, 2524, 1, 0, 0, 0, 340, 2535, 1, 0, 0, 0,
		342, 2537, 1, 0, 0, 0, 344, 2541, 1, 0, 0, 0, 346, 2554, 1, 0, 0, 0, 348,
		2565, 1, 0, 0, 0, 350, 2567, 1, 0, 0, 0, 352, 2594, 1, 0, 0, 0, 354, 2596,
		1, 0, 0, 0, 356, 2613, 1, 0, 0, 0, 358, 2615, 1, 0, 0, 0, 360, 2618, 1,
		0, 0, 0, 362, 2628, 1, 0, 0, 0, 364, 2631, 1, 0, 0, 0, 366, 2634, 1, 0,
		0, 0, 368, 2651, 1, 0, 0, 0, 370, 2666, 1, 0, 0, 0, 372, 2668, 1, 0, 0,
		0, 374, 2678, 1, 0, 0, 0, 376, 2694, 1, 0, 0, 0, 378, 2702, 1, 0, 0, 0,
		380, 2705, 1, 0, 0, 0, 382, 2722, 1, 0, 0, 0, 384, 2743, 1, 0, 0, 0, 386,
		2765, 1, 0, 0, 0, 388, 2767, 1, 0, 0, 0, 390, 2779, 1, 0, 0, 0, 392, 2785,
		1, 0, 0, 0, 394, 2800, 1, 0, 0, 0, 396, 2814, 1, 0, 0, 0, 398, 2839, 1,
		0, 0, 0, 400, 2841, 1, 0, 0, 0, 402, 2860, 1, 0, 0, 0, 404, 2878, 1, 0,
		0, 0, 406, 2882, 1, 0, 0, 0, 408, 2896, 1, 0, 0, 0, 410, 2916, 1, 0, 0,
		0, 412, 2939, 1, 0, 0, 0, 414, 2941, 1, 0, 0, 0, 416, 2945, 1, 0, 0, 0,
		418, 2947, 1, 0, 0, 0, 420, 2967, 1, 0, 0, 0, 422, 2971, 1, 0, 0, 0, 424,
		2973, 1, 0, 0, 0, 426, 2990, 1, 0, 0, 0, 428, 3006, 1, 0, 0, 0, 430, 3162,
		1, 0, 0, 0, 432, 3164, 1, 0, 0, 0, 434, 3166, 1, 0, 0, 0, 436, 3176, 1,
		0, 0, 0, 438, 3386, 1, 0, 0, 0, 440, 3388, 1, 0, 0, 0, 442, 3397, 1, 0,
		0, 0, 444, 3401, 1, 0, 0, 0, 446, 3408, 1, 0, 0, 0, 448, 3413, 1, 0, 0,
		0, 450, 3421, 1, 0, 0, 0, 452, 3433, 1, 0, 0, 0, 454, 3437, 1, 0, 0, 0,
		456, 3439, 1, 0, 0, 0, 458, 3458, 1, 0, 0, 0, 460, 3465, 1, 0, 0, 0, 462,
		3470, 1, 0, 0, 0, 464, 3473, 1, 0, 0, 0, 466, 3490, 1, 0, 0, 0, 468, 3492,
		1, 0, 0, 0, 470, 3495, 1, 0, 0, 0, 472, 3499, 1, 0, 0, 0, 474, 3505, 1,
		0, 0, 0, 476, 3515, 1, 0, 0, 0, 478, 3518, 1, 0, 0, 0, 480, 3523, 1, 0,
		0, 0, 482, 3527, 1, 0, 0, 0, 484, 3529, 1, 0, 0, 0, 486, 3531, 1, 0, 0,
		0, 488, 489, 3, 2, 1, 0, 489, 490, 5, 0, 0, 1, 490, 1, 1, 0, 0, 0, 491,
		494, 3, 4, 2, 0, 492, 494, 3, 12, 6, 0, 493, 491, 1, 0, 0, 0, 493, 492,
		1, 0, 0, 0, 494, 496, 1, 0, 0, 0, 495, 497, 5, 125, 0, 0, 496, 495, 1,
		0, 0, 0, 496, 497, 1, 0, 0, 0, 497, 499, 1, 0, 0, 0, 498, 493, 1, 0, 0,
		0, 499, 500, 1, 0, 0, 0, 500, 498, 1, 0, 0, 0, 500, 501, 1, 0, 0, 0, 501,
		3, 1, 0, 0, 0, 502, 504, 3, 48, 24, 0, 503, 502, 1, 0, 0, 0, 503, 504,
		1, 0, 0, 0, 504, 505, 1, 0, 0, 0, 505, 506, 5, 20, 0, 0, 506, 508, 3, 2,
		1, 0, 507, 509, 3, 16, 8, 0, 508, 507, 1, 0, 0, 0, 508, 509, 1, 0, 0, 0,
		509, 510, 1, 0, 0, 0, 510, 511, 3, 8, 4, 0, 511, 5, 1, 0, 0, 0, 512, 513,
		5, 20, 0, 0, 513, 515, 3, 2, 1, 0, 514, 516, 3, 16, 8, 0, 515, 514, 1,
		0, 0, 0, 515, 516, 1, 0, 0, 0, 516, 517, 1, 0, 0, 0, 517, 518, 3, 8, 4,
		0, 518, 524, 1, 0, 0, 0, 519, 521, 3, 12, 6, 0, 520, 522, 5, 371, 0, 0,
		521, 520, 1, 0, 0, 0, 521, 522, 1, 0, 0, 0, 522, 524, 1, 0, 0, 0, 523,
		512, 1, 0, 0, 0, 523, 519, 1, 0, 0, 0, 524, 7, 1, 0, 0, 0, 525, 526, 4,
		4, 0, 0, 526, 527, 5, 99, 0, 0, 527, 9, 1, 0, 0, 0, 528, 538, 3, 4, 2,
		0, 529, 531, 3, 12, 6, 0, 530, 529, 1, 0, 0, 0, 531, 532, 1, 0, 0, 0, 532,
		530, 1, 0, 0, 0, 532, 533, 1, 0, 0, 0, 533, 535, 1, 0, 0, 0, 534, 536,
		5, 125, 0, 0, 535, 534, 1, 0, 0, 0, 535, 536, 1, 0, 0, 0, 536, 538, 1,
		0, 0, 0, 537, 528, 1, 0, 0, 0, 537, 530, 1, 0, 0, 0, 538, 11, 1, 0, 0,
		0, 539, 602, 3, 24, 12, 0, 540, 602, 3, 36, 18, 0, 541, 602, 3, 130, 65,
		0, 542, 602, 3, 38, 19, 0, 543, 602, 3, 40, 20, 0, 544, 602, 3, 42, 21,
		0, 545, 602, 3, 44, 22, 0, 546, 602, 3, 230, 115, 0, 547, 602, 3, 234,
		117, 0, 548, 602, 3, 236, 118, 0, 549, 602, 3, 240, 120, 0, 550, 602, 3,
		242, 121, 0, 551, 602, 3, 252, 126, 0, 552, 602, 3, 146, 73, 0, 553, 602,
		3, 150, 75, 0, 554, 602, 3, 254, 127, 0, 555, 602, 3, 70, 35, 0, 556, 602,
		3, 154, 77, 0, 557, 602, 3, 160, 80, 0, 558, 602, 3, 166, 83, 0, 559, 602,
		3, 68, 34, 0, 560, 602, 3, 46, 23, 0, 561, 602, 3, 388, 194, 0, 562, 602,
		3, 392, 196, 0, 563, 602, 3, 176, 88, 0, 564, 602, 3, 178, 89, 0, 565,
		602, 3, 180, 90, 0, 566, 602, 3, 206, 103, 0, 567, 602, 3, 226, 113, 0,
		568, 602, 3, 296, 148, 0, 569, 602, 3, 298, 149, 0, 570, 602, 3, 182, 91,
		0, 571, 602, 3, 194, 97, 0, 572, 602, 3, 196, 98, 0, 573, 602, 3, 204,
		102, 0, 574, 602, 3, 208, 104, 0, 575, 602, 3, 216, 108, 0, 576, 602, 3,
		220, 110, 0, 577, 602, 3, 222, 111, 0, 578, 602, 3, 380, 190, 0, 579, 602,
		3, 224, 112, 0, 580, 602, 3, 262, 131, 0, 581, 602, 3, 264, 132, 0, 582,
		602, 3, 266, 133, 0, 583, 602, 3, 268, 134, 0, 584, 602, 3, 270, 135, 0,
		585, 602, 3, 272, 136, 0, 586, 602, 3, 304, 152, 0, 587, 602, 3, 282, 141,
		0, 588, 602, 3, 284, 142, 0, 589, 602, 3, 372, 186, 0, 590, 602, 3, 288,
		144, 0, 591, 602, 3, 286, 143, 0, 592, 602, 3, 290, 145, 0, 593, 602, 3,
		292, 146, 0, 594, 602, 3, 294, 147, 0, 595, 602, 3, 300, 150, 0, 596, 602,
		3, 456, 228, 0, 597, 602, 3, 460, 230, 0, 598, 602, 3, 20, 10, 0, 599,
		602, 3, 22, 11, 0, 600, 602, 3, 14, 7, 0, 601, 539, 1, 0, 0, 0, 601, 540,
		1, 0, 0, 0, 601, 541, 1, 0, 0, 0, 601, 542, 1, 0, 0, 0, 601, 543, 1, 0,
		0, 0, 601, 544, 1, 0, 0, 0, 601, 545, 1, 0, 0, 0, 601, 546, 1, 0, 0, 0,
		601, 547, 1, 0, 0, 0, 601, 548, 1, 0, 0, 0, 601, 549, 1, 0, 0, 0, 601,
		550, 1, 0, 0, 0, 601, 551, 1, 0, 0, 0, 601, 552, 1, 0, 0, 0, 601, 553,
		1, 0, 0, 0, 601, 554, 1, 0, 0, 0, 601, 555, 1, 0, 0, 0, 601, 556, 1, 0,
		0, 0, 601, 557, 1, 0, 0, 0, 601, 558, 1, 0, 0, 0, 601, 559, 1, 0, 0, 0,
		601, 560, 1, 0, 0, 0, 601, 561, 1, 0, 0, 0, 601, 562, 1, 0, 0, 0, 601,
		563, 1, 0, 0, 0, 601, 564, 1, 0, 0, 0, 601, 565, 1, 0, 0, 0, 601, 566,
		1, 0, 0, 0, 601, 567, 1, 0, 0, 0, 601, 568, 1, 0, 0, 0, 601, 569, 1, 0,
		0, 0, 601, 570, 1, 0, 0, 0, 601, 571, 1, 0, 0, 0, 601, 572, 1, 0, 0, 0,
		601, 573, 1, 0, 0, 0, 601, 574, 1, 0, 0, 0, 601, 575, 1, 0, 0, 0, 601,
		576, 1, 0, 0, 0, 601, 577, 1, 0, 0, 0, 601, 578, 1, 0, 0, 0, 601, 579,
		1, 0, 0, 0, 601, 580, 1, 0, 0, 0, 601, 581, 1, 0, 0, 0, 601, 582, 1, 0,
		0, 0, 601, 583, 1, 0, 0, 0, 601, 584, 1, 0, 0, 0, 601, 585, 1, 0, 0, 0,
		601, 586, 1, 0, 0, 0, 601, 587, 1, 0, 0, 0, 601, 588, 1, 0, 0, 0, 601,
		589, 1, 0, 0, 0, 601, 590, 1, 0, 0, 0, 601, 591, 1, 0, 0, 0, 601, 592,
		1, 0, 0, 0, 601, 593, 1, 0, 0, 0, 601, 594, 1, 0, 0, 0, 601, 595, 1, 0,
		0, 0, 601, 596, 1, 0, 0, 0, 601, 597, 1, 0, 0, 0, 601, 598, 1, 0, 0, 0,
		601, 599, 1, 0, 0, 0, 601, 600, 1, 0, 0, 0, 602, 13, 1, 0, 0, 0, 603, 604,
		7, 0, 0, 0, 604, 15, 1, 0, 0, 0, 605, 607, 5, 105, 0, 0, 606, 608, 3, 18,
		9, 0, 607, 606, 1, 0, 0, 0, 608, 609, 1, 0, 0, 0, 609, 607, 1, 0, 0, 0,
		609, 610, 1, 0, 0, 0, 610, 17, 1, 0, 0, 0, 611, 612, 5, 315, 0, 0, 612,
		613, 5, 373, 0, 0, 613, 614, 5, 292, 0, 0, 614, 615, 3, 2, 1, 0, 615, 616,
		8, 1, 0, 0, 616, 19, 1, 0, 0, 0, 617, 618, 5, 197, 0, 0, 618, 21, 1, 0,
		0, 0, 619, 620, 4, 11, 1, 0, 620, 621, 3, 410, 205, 0, 621, 23, 1, 0, 0,
		0, 622, 623, 5, 260, 0, 0, 623, 636, 3, 274, 137, 0, 624, 626, 5, 260,
		0, 0, 625, 624, 1, 0, 0, 0, 625, 626, 1, 0, 0, 0, 626, 627, 1, 0, 0, 0,
		627, 632, 3, 26, 13, 0, 628, 629, 5, 351, 0, 0, 629, 631, 3, 26, 13, 0,
		630, 628, 1, 0, 0, 0, 631, 634, 1, 0, 0, 0, 632, 630, 1, 0, 0, 0, 632,
		633, 1, 0, 0, 0, 633, 636, 1, 0, 0, 0, 634, 632, 1, 0, 0, 0, 635, 622,
		1, 0, 0, 0, 635, 625, 1, 0, 0, 0, 636, 25, 1, 0, 0, 0, 637, 642, 3, 28,
		14, 0, 638, 642, 3, 32, 16, 0, 639, 642, 3, 34, 17, 0, 640, 642, 3, 30,
		15, 0, 641, 637, 1, 0, 0, 0, 641, 638, 1, 0, 0, 0, 641, 639, 1, 0, 0, 0,
		641, 640, 1, 0, 0, 0, 642, 27, 1, 0, 0, 0, 643, 645, 3, 474, 237, 0, 644,
		646, 5, 350, 0, 0, 645, 644, 1, 0, 0, 0, 645, 646, 1, 0, 0, 0, 646, 647,
		1, 0, 0, 0, 647, 648, 5, 356, 0, 0, 648, 649, 3, 410, 205, 0, 649, 660,
		1, 0, 0, 0, 650, 651, 5, 366, 0, 0, 651, 652, 3, 474, 237, 0, 652, 654,
		5, 369, 0, 0, 653, 655, 5, 350, 0, 0, 654, 653, 1, 0, 0, 0, 654, 655, 1,
		0, 0, 0, 655, 656, 1, 0, 0, 0, 656, 657, 5, 356, 0, 0, 657, 658, 3, 410,
		205, 0, 658, 660, 1, 0, 0, 0, 659, 643, 1, 0, 0, 0, 659, 650, 1, 0, 0,
		0, 660, 29, 1, 0, 0, 0, 661, 662, 3, 440, 220, 0, 662, 663, 5, 350, 0,
		0, 663, 664, 5, 356, 0, 0, 664, 665, 3, 410, 205, 0, 665, 31, 1, 0, 0,
		0, 666, 667, 5, 366, 0, 0, 667, 672, 3, 472, 236, 0, 668, 669, 5, 351,
		0, 0, 669, 671, 3, 472, 236, 0, 670, 668, 1, 0, 0, 0, 671, 674, 1, 0, 0,
		0, 672, 670, 1, 0, 0, 0, 672, 673, 1, 0, 0, 0, 673, 675, 1, 0, 0, 0, 674,
		672, 1, 0, 0, 0, 675, 677, 5, 369, 0, 0, 676, 678, 5, 350, 0, 0, 677, 676,
		1, 0, 0, 0, 677, 678, 1, 0, 0, 0, 678, 679, 1, 0, 0, 0, 679, 680, 5, 356,
		0, 0, 680, 681, 5, 366, 0, 0, 681, 686, 3, 410, 205, 0, 682, 683, 5, 351,
		0, 0, 683, 685, 3, 410, 205, 0, 684, 682, 1, 0, 0, 0, 685, 688, 1, 0, 0,
		0, 686, 684, 1, 0, 0, 0, 686, 687, 1, 0, 0, 0, 687, 689, 1, 0, 0, 0, 688,
		686, 1, 0, 0, 0, 689, 690, 5, 369, 0, 0, 690, 33, 1, 0, 0, 0, 691, 704,
		3, 472, 236, 0, 692, 693, 5, 366, 0, 0, 693, 698, 3, 472, 236, 0, 694,
		695, 5, 351, 0, 0, 695, 697, 3, 472, 236, 0, 696, 694, 1, 0, 0, 0, 697,
		700, 1, 0, 0, 0, 698, 696, 1, 0, 0, 0, 698, 699, 1, 0, 0, 0, 699, 701,
		1, 0, 0, 0, 700, 698, 1, 0, 0, 0, 701, 702, 5, 369, 0, 0, 702, 704, 1,
		0, 0, 0, 703, 691, 1, 0, 0, 0, 703, 692, 1, 0, 0, 0, 704, 706, 1, 0, 0,
		0, 705, 707, 5, 350, 0, 0, 706, 705, 1, 0, 0, 0, 706, 707, 1, 0, 0, 0,
		707, 708, 1, 0, 0, 0, 708, 709, 5, 356, 0, 0, 709, 710, 5, 366, 0, 0, 710,
		711, 3, 304, 152, 0, 711, 712, 5, 369, 0, 0, 712, 35, 1, 0, 0, 0, 713,
		714, 5, 8, 0, 0, 714, 715, 3, 472, 236, 0, 715, 716, 5, 66, 0, 0, 716,
		720, 5, 116, 0, 0, 717, 718, 5, 236, 0, 0, 718, 721, 5, 260, 0, 0, 719,
		721, 5, 224, 0, 0, 720, 717, 1, 0, 0, 0, 720, 719, 1, 0, 0, 0, 721, 722,
		1, 0, 0, 0, 722, 723, 3, 472, 236, 0, 723, 37, 1, 0, 0, 0, 724, 727, 5,
		15, 0, 0, 725, 726, 5, 236, 0, 0, 726, 728, 5, 260, 0, 0, 727, 725, 1,
		0, 0, 0, 727, 728, 1, 0, 0, 0, 728, 729, 1, 0, 0, 0, 729, 730, 7, 2, 0,
		0, 730, 731, 5, 366, 0, 0, 731, 736, 3, 472, 236, 0, 732, 733, 5, 351,
		0, 0, 733, 735, 3, 472, 236, 0, 734, 732, 1, 0, 0, 0, 735, 738, 1, 0, 0,
		0, 736, 734, 1, 0, 0, 0, 736, 737, 1, 0, 0, 0, 737, 739, 1, 0, 0, 0, 738,
		736, 1, 0, 0, 0, 739, 740, 5, 369, 0, 0, 740, 741, 5, 318, 0, 0, 741, 742,
		5, 224, 0, 0, 742, 743, 3, 472, 236, 0, 743, 39, 1, 0, 0, 0, 744, 745,
		5, 20, 0, 0, 745, 746, 5, 299, 0, 0, 746, 41, 1, 0, 0, 0, 747, 748, 5,
		28, 0, 0, 748, 43, 1, 0, 0, 0, 749, 753, 5, 33, 0, 0, 750, 754, 3, 442,
		221, 0, 751, 754, 3, 440, 220, 0, 752, 754, 3, 472, 236, 0, 753, 750, 1,
		0, 0, 0, 753, 751, 1, 0, 0, 0, 753, 752, 1, 0, 0, 0, 754, 45, 1, 0, 0,
		0, 755, 756, 5, 75, 0, 0, 756, 761, 3, 52, 26, 0, 757, 758, 5, 351, 0,
		0, 758, 760, 3, 52, 26, 0, 759, 757, 1, 0, 0, 0, 760, 763, 1, 0, 0, 0,
		761, 759, 1, 0, 0, 0, 761, 762, 1, 0, 0, 0, 762, 47, 1, 0, 0, 0, 763, 761,
		1, 0, 0, 0, 764, 765, 5, 75, 0, 0, 765, 766, 3, 52, 26, 0, 766, 772, 5,
		371, 0, 0, 767, 768, 3, 52, 26, 0, 768, 769, 5, 371, 0, 0, 769, 771, 1,
		0, 0, 0, 770, 767, 1, 0, 0, 0, 771, 774, 1, 0, 0, 0, 772, 770, 1, 0, 0,
		0, 772, 773, 1, 0, 0, 0, 773, 49, 1, 0, 0, 0, 774, 772, 1, 0, 0, 0, 775,
		776, 3, 52, 26, 0, 776, 782, 5, 371, 0, 0, 777, 778, 3, 52, 26, 0, 778,
		779, 5, 371, 0, 0, 779, 781, 1, 0, 0, 0, 780, 777, 1, 0, 0, 0, 781, 784,
		1, 0, 0, 0, 782, 780, 1, 0, 0, 0, 782, 783, 1, 0, 0, 0, 783, 51, 1, 0,
		0, 0, 784, 782, 1, 0, 0, 0, 785, 791, 3, 58, 29, 0, 786, 791, 3, 56, 28,
		0, 787, 791, 3, 64, 32, 0, 788, 791, 3, 54, 27, 0, 789, 791, 3, 66, 33,
		0, 790, 785, 1, 0, 0, 0, 790, 786, 1, 0, 0, 0, 790, 787, 1, 0, 0, 0, 790,
		788, 1, 0, 0, 0, 790, 789, 1, 0, 0, 0, 791, 53, 1, 0, 0, 0, 792, 797, 3,
		472, 236, 0, 793, 794, 5, 351, 0, 0, 794, 796, 3, 472, 236, 0, 795, 793,
		1, 0, 0, 0, 796, 799, 1, 0, 0, 0, 797, 795, 1, 0, 0, 0, 797, 798, 1, 0,
		0, 0, 798, 801, 1, 0, 0, 0, 799, 797, 1, 0, 0, 0, 800, 802, 5, 13, 0, 0,
		801, 800, 1, 0, 0, 0, 801, 802, 1, 0, 0, 0, 802, 803, 1, 0, 0, 0, 803,
		805, 3, 138, 69, 0, 804, 806, 3, 140, 70, 0, 805, 804, 1, 0, 0, 0, 805,
		806, 1, 0, 0, 0, 806, 810, 1, 0, 0, 0, 807, 809, 3, 142, 71, 0, 808, 807,
		1, 0, 0, 0, 809, 812, 1, 0, 0, 0, 810, 808, 1, 0, 0, 0, 810, 811, 1, 0,
		0, 0, 811, 814, 1, 0, 0, 0, 812, 810, 1, 0, 0, 0, 813, 815, 3, 144, 72,
		0, 814, 813, 1, 0, 0, 0, 814, 815, 1, 0, 0, 0, 815, 828, 1, 0, 0, 0, 816,
		817, 3, 472, 236, 0, 817, 819, 5, 50, 0, 0, 818, 820, 5, 13, 0, 0, 819,
		818, 1, 0, 0, 0, 819, 820, 1, 0, 0, 0, 820, 821, 1, 0, 0, 0, 821, 823,
		3, 138, 69, 0, 822, 824, 3, 140, 70, 0, 823, 822, 1, 0, 0, 0, 823, 824,
		1, 0, 0, 0, 824, 825, 1, 0, 0, 0, 825, 826, 3, 144, 72, 0, 826, 828, 1,
		0, 0, 0, 827, 792, 1, 0, 0, 0, 827, 816, 1, 0, 0, 0, 828, 55, 1, 0, 0,
		0, 829, 830, 3, 472, 236, 0, 830, 831, 5, 54, 0, 0, 831, 57, 1, 0, 0, 0,
		832, 833, 5, 66, 0, 0, 833, 838, 3, 472, 236, 0, 834, 835, 3, 472, 236,
		0, 835, 836, 5, 66, 0, 0, 836, 838, 1, 0, 0, 0, 837, 832, 1, 0, 0, 0, 837,
		834, 1, 0, 0, 0, 838, 841, 1, 0, 0, 0, 839, 842, 3, 60, 30, 0, 840, 842,
		3, 62, 31, 0, 841, 839, 1, 0, 0, 0, 841, 840, 1, 0, 0, 0, 841, 842, 1,
		0, 0, 0, 842, 843, 1, 0, 0, 0, 843, 846, 7, 3, 0, 0, 844, 847, 3, 304,
		152, 0, 845, 847, 3, 410, 205, 0, 846, 844, 1, 0, 0, 0, 846, 845, 1, 0,
		0, 0, 847, 59, 1, 0, 0, 0, 848, 849, 5, 318, 0, 0, 849, 851, 5, 238, 0,
		0, 850, 852, 5, 204, 0, 0, 851, 850, 1, 0, 0, 0, 851, 852, 1, 0, 0, 0,
		852, 855, 1, 0, 0, 0, 853, 854, 5, 297, 0, 0, 854, 856, 7, 4, 0, 0, 855,
		853, 1, 0, 0, 0, 855, 856, 1, 0, 0, 0, 856, 61, 1, 0, 0, 0, 857, 858, 5,
		319, 0, 0, 858, 859, 5, 238, 0, 0, 859, 63, 1, 0, 0, 0, 860, 861, 7, 5,
		0, 0, 861, 862, 5, 128, 0, 0, 862, 868, 5, 116, 0, 0, 863, 869, 5, 272,
		0, 0, 864, 869, 5, 275, 0, 0, 865, 866, 5, 195, 0, 0, 866, 869, 5, 119,
		0, 0, 867, 869, 3, 472, 236, 0, 868, 863, 1, 0, 0, 0, 868, 864, 1, 0, 0,
		0, 868, 865, 1, 0, 0, 0, 868, 867, 1, 0, 0, 0, 869, 870, 1, 0, 0, 0, 870,
		871, 3, 6, 3, 0, 871, 65, 1, 0, 0, 0, 872, 874, 5, 124, 0, 0, 873, 872,
		1, 0, 0, 0, 873, 874, 1, 0, 0, 0, 874, 875, 1, 0, 0, 0, 875, 876, 5, 289,
		0, 0, 876, 877, 5, 287, 0, 0, 877, 879, 3, 474, 237, 0, 878, 880, 3, 88,
		44, 0, 879, 878, 1, 0, 0, 0, 879, 880, 1, 0, 0, 0, 880, 881, 1, 0, 0, 0,
		881, 882, 3, 72, 36, 0, 882, 67, 1, 0, 0, 0, 883, 884, 5, 60, 0, 0, 884,
		888, 5, 287, 0, 0, 885, 886, 5, 135, 0, 0, 886, 887, 5, 195, 0, 0, 887,
		889, 5, 107, 0, 0, 888, 885, 1, 0, 0, 0, 888, 889, 1, 0, 0, 0, 889, 890,
		1, 0, 0, 0, 890, 892, 3, 356, 178, 0, 891, 893, 3, 88, 44, 0, 892, 891,
		1, 0, 0, 0, 892, 893, 1, 0, 0, 0, 893, 894, 1, 0, 0, 0, 894, 895, 3, 72,
		36, 0, 895, 69, 1, 0, 0, 0, 896, 903, 5, 60, 0, 0, 897, 898, 5, 167, 0,
		0, 898, 904, 5, 289, 0, 0, 899, 901, 7, 6, 0, 0, 900, 899, 1, 0, 0, 0,
		900, 901, 1, 0, 0, 0, 901, 902, 1, 0, 0, 0, 902, 904, 5, 314, 0, 0, 903,
		897, 1, 0, 0, 0, 903, 900, 1, 0, 0, 0, 904, 905, 1, 0, 0, 0, 905, 906,
		5, 287, 0, 0, 906, 908, 3, 474, 237, 0, 907, 909, 3, 88, 44, 0, 908, 907,
		1, 0, 0, 0, 908, 909, 1, 0, 0, 0, 909, 910, 1, 0, 0, 0, 910, 911, 3, 72,
		36, 0, 911, 71, 1, 0, 0, 0, 912, 914, 5, 13, 0, 0, 913, 912, 1, 0, 0, 0,
		913, 914, 1, 0, 0, 0, 914, 915, 1, 0, 0, 0, 915, 916, 5, 366, 0, 0, 916,
		917, 3, 304, 152, 0, 917, 918, 5, 369, 0, 0, 918, 930, 1, 0, 0, 0, 919,
		921, 5, 13, 0, 0, 920, 919, 1, 0, 0, 0, 920, 921, 1, 0, 0, 0, 921, 922,
		1, 0, 0, 0, 922, 930, 3, 304, 152, 0, 923, 924, 5, 366, 0, 0, 924, 925,
		3, 76, 38, 0, 925, 926, 5, 369, 0, 0, 926, 930, 1, 0, 0, 0, 927, 928, 5,
		164, 0, 0, 928, 930, 3, 356, 178, 0, 929, 913, 1, 0, 0, 0, 929, 920, 1,
		0, 0, 0, 929, 923, 1, 0, 0, 0, 929, 927, 1, 0, 0, 0, 930, 932, 1, 0, 0,
		0, 931, 933, 3, 94, 47, 0, 932, 931, 1, 0, 0, 0, 932, 933, 1, 0, 0, 0,
		933, 73, 1, 0, 0, 0, 934, 935, 5, 49, 0, 0, 935, 936, 3, 410, 205, 0, 936,
		75, 1, 0, 0, 0, 937, 939, 3, 78, 39, 0, 938, 940, 3, 74, 37, 0, 939, 938,
		1, 0, 0, 0, 939, 940, 1, 0, 0, 0, 940, 948, 1, 0, 0, 0, 941, 942, 5, 351,
		0, 0, 942, 944, 3, 78, 39, 0, 943, 945, 3, 74, 37, 0, 944, 943, 1, 0, 0,
		0, 944, 945, 1, 0, 0, 0, 945, 947, 1, 0, 0, 0, 946, 941, 1, 0, 0, 0, 947,
		950, 1, 0, 0, 0, 948, 946, 1, 0, 0, 0, 948, 949, 1, 0, 0, 0, 949, 77, 1,
		0, 0, 0, 950, 948, 1, 0, 0, 0, 951, 952, 3, 80, 40, 0, 952, 954, 3, 138,
		69, 0, 953, 955, 3, 140, 70, 0, 954, 953, 1, 0, 0, 0, 954, 955, 1, 0, 0,
		0, 955, 959, 1, 0, 0, 0, 956, 958, 3, 142, 71, 0, 957, 956, 1, 0, 0, 0,
		958, 961, 1, 0, 0, 0, 959, 957, 1, 0, 0, 0, 959, 960, 1, 0, 0, 0, 960,
		965, 1, 0, 0, 0, 961, 959, 1, 0, 0, 0, 962, 964, 3, 82, 41, 0, 963, 962,
		1, 0, 0, 0, 964, 967, 1, 0, 0, 0, 965, 963, 1, 0, 0, 0, 965, 966, 1, 0,
		0, 0, 966, 974, 1, 0, 0, 0, 967, 965, 1, 0, 0, 0, 968, 969, 5, 55, 0, 0,
		969, 971, 3, 474, 237, 0, 970, 968, 1, 0, 0, 0, 970, 971, 1, 0, 0, 0, 971,
		972, 1, 0, 0, 0, 972, 974, 3, 84, 42, 0, 973, 951, 1, 0, 0, 0, 973, 970,
		1, 0, 0, 0, 974, 79, 1, 0, 0, 0, 975, 976, 3, 474, 237, 0, 976, 81, 1,
		0, 0, 0, 977, 1010, 3, 144, 72, 0, 978, 980, 5, 195, 0, 0, 979, 978, 1,
		0, 0, 0, 979, 980, 1, 0, 0, 0, 980, 981, 1, 0, 0, 0, 981, 1010, 5, 197,
		0, 0, 982, 983, 5, 221, 0, 0, 983, 1010, 5, 159, 0, 0, 984, 1010, 5, 303,
		0, 0, 985, 986, 5, 231, 0, 0, 986, 987, 3, 356, 178, 0, 987, 988, 5, 366,
		0, 0, 988, 989, 3, 474, 237, 0, 989, 993, 5, 369, 0, 0, 990, 992, 3, 86,
		43, 0, 991, 990, 1, 0, 0, 0, 992, 995, 1, 0, 0, 0, 993, 991, 1, 0, 0, 0,
		993, 994, 1, 0, 0, 0, 994, 1010, 1, 0, 0, 0, 995, 993, 1, 0, 0, 0, 996,
		997, 5, 134, 0, 0, 997, 998, 5, 366, 0, 0, 998, 1003, 5, 376, 0, 0, 999,
		1000, 5, 351, 0, 0, 1000, 1002, 5, 376, 0, 0, 1001, 999, 1, 0, 0, 0, 1002,
		1005, 1, 0, 0, 0, 1003, 1001, 1, 0, 0, 0, 1003, 1004, 1, 0, 0, 0, 1004,
		1006, 1, 0, 0, 0, 1005, 1003, 1, 0, 0, 0, 1006, 1010, 5, 369, 0, 0, 1007,
		1010, 5, 17, 0, 0, 1008, 1010, 5, 98, 0, 0, 1009, 977, 1, 0, 0, 0, 1009,
		979, 1, 0, 0, 0, 1009, 982, 1, 0, 0, 0, 1009, 984, 1, 0, 0, 0, 1009, 985,
		1, 0, 0, 0, 1009, 996, 1, 0, 0, 0, 1009, 1007, 1, 0, 0, 0, 1009, 1008,
		1, 0, 0, 0, 1010, 83, 1, 0, 0, 0, 1011, 1012, 5, 221, 0, 0, 1012, 1014,
		5, 159, 0, 0, 1013, 1015, 5, 44, 0, 0, 1014, 1013, 1, 0, 0, 0, 1014, 1015,
		1, 0, 0, 0, 1015, 1016, 1, 0, 0, 0, 1016, 1017, 5, 366, 0, 0, 1017, 1019,
		3, 474, 237, 0, 1018, 1020, 7, 7, 0, 0, 1019, 1018, 1, 0, 0, 0, 1019, 1020,
		1, 0, 0, 0, 1020, 1028, 1, 0, 0, 0, 1021, 1022, 5, 351, 0, 0, 1022, 1024,
		3, 474, 237, 0, 1023, 1025, 7, 7, 0, 0, 1024, 1023, 1, 0, 0, 0, 1024, 1025,
		1, 0, 0, 0, 1025, 1027, 1, 0, 0, 0, 1026, 1021, 1, 0, 0, 0, 1027, 1030,
		1, 0, 0, 0, 1028, 1026, 1, 0, 0, 0, 1028, 1029, 1, 0, 0, 0, 1029, 1031,
		1, 0, 0, 0, 1030, 1028, 1, 0, 0, 0, 1031, 1033, 5, 369, 0, 0, 1032, 1034,
		5, 98, 0, 0, 1033, 1032, 1, 0, 0, 0, 1033, 1034, 1, 0, 0, 0, 1034, 1036,
		1, 0, 0, 0, 1035, 1037, 3, 258, 129, 0, 1036, 1035, 1, 0, 0, 0, 1036, 1037,
		1, 0, 0, 0, 1037, 1069, 1, 0, 0, 0, 1038, 1039, 5, 117, 0, 0, 1039, 1040,
		5, 159, 0, 0, 1040, 1041, 5, 366, 0, 0, 1041, 1046, 3, 474, 237, 0, 1042,
		1043, 5, 351, 0, 0, 1043, 1045, 3, 474, 237, 0, 1044, 1042, 1, 0, 0, 0,
		1045, 1048, 1, 0, 0, 0, 1046, 1044, 1, 0, 0, 0, 1046, 1047, 1, 0, 0, 0,
		1047, 1049, 1, 0, 0, 0, 1048, 1046, 1, 0, 0, 0, 1049, 1050, 5, 369, 0,
		0, 1050, 1051, 5, 231, 0, 0, 1051, 1052, 3, 356, 178, 0, 1052, 1053, 5,
		366, 0, 0, 1053, 1058, 3, 474, 237, 0, 1054, 1055, 5, 351, 0, 0, 1055,
		1057, 3, 474, 237, 0, 1056, 1054, 1, 0, 0, 0, 1057, 1060, 1, 0, 0, 0, 1058,
		1056, 1, 0, 0, 0, 1058, 1059, 1, 0, 0, 0, 1059, 1061, 1, 0, 0, 0, 1060,
		1058, 1, 0, 0, 0, 1061, 1065, 5, 369, 0, 0, 1062, 1064, 3, 86, 43, 0, 1063,
		1062, 1, 0, 0, 0, 1064, 1067, 1, 0, 0, 0, 1065, 1063, 1, 0, 0, 0, 1065,
		1066, 1, 0, 0, 0, 1066, 1069, 1, 0, 0, 0, 1067, 1065, 1, 0, 0, 0, 1068,
		1011, 1, 0, 0, 0, 1068, 1038, 1, 0, 0, 0, 1069, 85, 1, 0, 0, 0, 1070, 1071,
		5, 203, 0, 0, 1071, 1080, 7, 8, 0, 0, 1072, 1073, 5, 190, 0, 0, 1073, 1081,
		5, 5, 0, 0, 1074, 1081, 5, 235, 0, 0, 1075, 1076, 5, 260, 0, 0, 1076, 1081,
		5, 197, 0, 0, 1077, 1078, 5, 260, 0, 0, 1078, 1081, 5, 76, 0, 0, 1079,
		1081, 5, 35, 0, 0, 1080, 1072, 1, 0, 0, 0, 1080, 1074, 1, 0, 0, 0, 1080,
		1075, 1, 0, 0, 0, 1080, 1077, 1, 0, 0, 0, 1080, 1079, 1, 0, 0, 0, 1081,
		87, 1, 0, 0, 0, 1082, 1084, 3, 90, 45, 0, 1083, 1082, 1, 0, 0, 0, 1084,
		1085, 1, 0, 0, 0, 1085, 1083, 1, 0, 0, 0, 1085, 1086, 1, 0, 0, 0, 1086,
		89, 1, 0, 0, 0, 1087, 1088, 5, 351, 0, 0, 1088, 1091, 3, 92, 46, 0, 1089,
		1091, 3, 120, 60, 0, 1090, 1087, 1, 0, 0, 0, 1090, 1089, 1, 0, 0, 0, 1091,
		91, 1, 0, 0, 0, 1092, 1094, 5, 190, 0, 0, 1093, 1092, 1, 0, 0, 0, 1093,
		1094, 1, 0, 0, 0, 1094, 1095, 1, 0, 0, 0, 1095, 1096, 7, 9, 0, 0, 1096,
		93, 1, 0, 0, 0, 1097, 1099, 3, 96, 48, 0, 1098, 1097, 1, 0, 0, 0, 1099,
		1100, 1, 0, 0, 0, 1100, 1098, 1, 0, 0, 0, 1100, 1101, 1, 0, 0, 0, 1101,
		95, 1, 0, 0, 0, 1102, 1103, 5, 203, 0, 0, 1103, 1104, 5, 51, 0, 0, 1104,
		1105, 7, 10, 0, 0, 1105, 1113, 5, 246, 0, 0, 1106, 1113, 3, 98, 49, 0,
		1107, 1113, 3, 100, 50, 0, 1108, 1113, 3, 102, 51, 0, 1109, 1113, 3, 120,
		60, 0, 1110, 1113, 3, 126, 63, 0, 1111, 1113, 3, 128, 64, 0, 1112, 1102,
		1, 0, 0, 0, 1112, 1106, 1, 0, 0, 0, 1112, 1107, 1, 0, 0, 0, 1112, 1108,
		1, 0, 0, 0, 1112, 1109, 1, 0, 0, 0, 1112, 1110, 1, 0, 0, 0, 1112, 1111,
		1, 0, 0, 0, 1113, 97, 1, 0, 0, 0, 1114, 1115, 5, 257, 0, 0, 1115, 1116,
		5, 61, 0, 0, 1116, 1133, 7, 11, 0, 0, 1117, 1118, 7, 12, 0, 0, 1118, 1133,
		5, 376, 0, 0, 1119, 1133, 5, 192, 0, 0, 1120, 1133, 7, 13, 0, 0, 1121,
		1122, 5, 279, 0, 0, 1122, 1125, 5, 366, 0, 0, 1123, 1126, 3, 474, 237,
		0, 1124, 1126, 5, 376, 0, 0, 1125, 1123, 1, 0, 0, 0, 1125, 1124, 1, 0,
		0, 0, 1126, 1127, 1, 0, 0, 0, 1127, 1125, 1, 0, 0, 0, 1127, 1128, 1, 0,
		0, 0, 1128, 1129, 1, 0, 0, 0, 1129, 1133, 5, 369, 0, 0, 1130, 1131, 5,
		288, 0, 0, 1131, 1133, 3, 474, 237, 0, 1132, 1114, 1, 0, 0, 0, 1132, 1117,
		1, 0, 0, 0, 1132, 1119, 1, 0, 0, 0, 1132, 1120, 1, 0, 0, 0, 1132, 1121,
		1, 0, 0, 0, 1132, 1130, 1, 0, 0, 0, 1133, 99, 1, 0, 0, 0, 1134, 1136, 5,
		140, 0, 0, 1135, 1134, 1, 0, 0, 0, 1135, 1136, 1, 0, 0, 0, 1136, 1137,
		1, 0, 0, 0, 1137, 1138, 5, 138, 0, 0, 1138, 1168, 3, 474, 237, 0, 1139,
		1140, 5, 318, 0, 0, 1140, 1168, 5, 233, 0, 0, 1141, 1142, 5, 90, 0, 0,
		1142, 1143, 5, 30, 0, 0, 1143, 1144, 5, 129, 0, 0, 1144, 1145, 5, 366,
		0, 0, 1145, 1150, 3, 474, 237, 0, 1146, 1147, 5, 351, 0, 0, 1147, 1149,
		3, 474, 237, 0, 1148, 1146, 1, 0, 0, 0, 1149, 1152, 1, 0, 0, 0, 1150, 1148,
		1, 0, 0, 0, 1150, 1151, 1, 0, 0, 0, 1151, 1153, 1, 0, 0, 0, 1152, 1150,
		1, 0, 0, 0, 1153, 1154, 5, 369, 0, 0, 1154, 1168, 1, 0, 0, 0, 1155, 1157,
		5, 195, 0, 0, 1156, 1155, 1, 0, 0, 0, 1156, 1157, 1, 0, 0, 0, 1157, 1158,
		1, 0, 0, 0, 1158, 1168, 5, 173, 0, 0, 1159, 1160, 5, 52, 0, 0, 1160, 1168,
		7, 14, 0, 0, 1161, 1162, 5, 80, 0, 0, 1162, 1168, 5, 204, 0, 0, 1163, 1164,
		5, 318, 0, 0, 1164, 1165, 5, 235, 0, 0, 1165, 1166, 5, 203, 0, 0, 1166,
		1168, 5, 93, 0, 0, 1167, 1135, 1, 0, 0, 0, 1167, 1139, 1, 0, 0, 0, 1167,
		1141, 1, 0, 0, 0, 1167, 1156, 1, 0, 0, 0, 1167, 1159, 1, 0, 0, 0, 1167,
		1161, 1, 0, 0, 0, 1167, 1163, 1, 0, 0, 0, 1168, 101, 1, 0, 0, 0, 1169,
		1171, 5, 303, 0, 0, 1170, 1169, 1, 0, 0, 0, 1170, 1171, 1, 0, 0, 0, 1171,
		1172, 1, 0, 0, 0, 1172, 1173, 5, 221, 0, 0, 1173, 1174, 5, 140, 0, 0, 1174,
		1175, 5, 366, 0, 0, 1175, 1180, 3, 474, 237, 0, 1176, 1177, 5, 351, 0,
		0, 1177, 1179, 3, 474, 237, 0, 1178, 1176, 1, 0, 0, 0, 1179, 1182, 1, 0,
		0, 0, 1180, 1178, 1, 0, 0, 0, 1180, 1181, 1, 0, 0, 0, 1181, 1183, 1, 0,
		0, 0, 1182, 1180, 1, 0, 0, 0, 1183, 1184, 5, 369, 0, 0, 1184, 1188, 1,
		0, 0, 0, 1185, 1186, 5, 318, 0, 0, 1186, 1188, 5, 68, 0, 0, 1187, 1170,
		1, 0, 0, 0, 1187, 1185, 1, 0, 0, 0, 1188, 103, 1, 0, 0, 0, 1189, 1190,
		3, 474, 237, 0, 1190, 105, 1, 0, 0, 0, 1191, 1234, 5, 39, 0, 0, 1192, 1234,
		5, 40, 0, 0, 1193, 1234, 5, 22, 0, 0, 1194, 1234, 5, 23, 0, 0, 1195, 1234,
		5, 24, 0, 0, 1196, 1234, 5, 25, 0, 0, 1197, 1234, 5, 26, 0, 0, 1198, 1234,
		5, 69, 0, 0, 1199, 1234, 5, 70, 0, 0, 1200, 1234, 5, 73, 0, 0, 1201, 1234,
		5, 74, 0, 0, 1202, 1204, 5, 92, 0, 0, 1203, 1205, 5, 219, 0, 0, 1204, 1203,
		1, 0, 0, 0, 1204, 1205, 1, 0, 0, 0, 1205, 1234, 1, 0, 0, 0, 1206, 1234,
		5, 115, 0, 0, 1207, 1234, 5, 145, 0, 0, 1208, 1234, 5, 146, 0, 0, 1209,
		1234, 5, 147, 0, 0, 1210, 1234, 5, 148, 0, 0, 1211, 1234, 5, 149, 0, 0,
		1212, 1234, 5, 187, 0, 0, 1213, 1234, 5, 189, 0, 0, 1214, 1234, 5, 199,
		0, 0, 1215, 1234, 5, 198, 0, 0, 1216, 1234, 5, 218, 0, 0, 1217, 1234, 5,
		230, 0, 0, 1218, 1219, 5, 237, 0, 0, 1219, 1234, 5, 313, 0, 0, 1220, 1234,
		5, 267, 0, 0, 1221, 1234, 5, 266, 0, 0, 1222, 1234, 5, 268, 0, 0, 1223,
		1234, 5, 270, 0, 0, 1224, 1234, 5, 269, 0, 0, 1225, 1234, 5, 281, 0, 0,
		1226, 1234, 5, 286, 0, 0, 1227, 1234, 5, 294, 0, 0, 1228, 1234, 5, 295,
		0, 0, 1229, 1234, 5, 311, 0, 0, 1230, 1234, 5, 312, 0, 0, 1231, 1234, 5,
		322, 0, 0, 1232, 1234, 5, 32, 0, 0, 1233, 1191, 1, 0, 0, 0, 1233, 1192,
		1, 0, 0, 0, 1233, 1193, 1, 0, 0, 0, 1233, 1194, 1, 0, 0, 0, 1233, 1195,
		1, 0, 0, 0, 1233, 1196, 1, 0, 0, 0, 1233, 1197, 1, 0, 0, 0, 1233, 1198,
		1, 0, 0, 0, 1233, 1199, 1, 0, 0, 0, 1233, 1200, 1, 0, 0, 0, 1233, 1201,
		1, 0, 0, 0, 1233, 1202, 1, 0, 0, 0, 1233, 1206, 1, 0, 0, 0, 1233, 1207,
		1, 0, 0, 0, 1233, 1208, 1, 0, 0, 0, 1233, 1209, 1, 0, 0, 0, 1233, 1210,
		1, 0, 0, 0, 1233, 1211, 1, 0, 0, 0, 1233, 1212, 1, 0, 0, 0, 1233, 1213,
		1, 0, 0, 0, 1233, 1214, 1, 0, 0, 0, 1233, 1215, 1, 0, 0, 0, 1233, 1216,
		1, 0, 0, 0, 1233, 1217, 1, 0, 0, 0, 1233, 1218, 1, 0, 0, 0, 1233, 1220,
		1, 0, 0, 0, 1233, 1221, 1, 0, 0, 0, 1233, 1222, 1, 0, 0, 0, 1233, 1223,
		1, 0, 0, 0, 1233, 1224, 1, 0, 0, 0, 1233, 1225, 1, 0, 0, 0, 1233, 1226,
		1, 0, 0, 0, 1233, 1227, 1, 0, 0, 0, 1233, 1228, 1, 0, 0, 0, 1233, 1229,
		1, 0, 0, 0, 1233, 1230, 1, 0, 0, 0, 1233, 1231, 1, 0, 0, 0, 1233, 1232,
		1, 0, 0, 0, 1234, 107, 1, 0, 0, 0, 1235, 1236, 5, 366, 0, 0, 1236, 1238,
		7, 15, 0, 0, 1237, 1239, 7, 16, 0, 0, 1238, 1237, 1, 0, 0, 0, 1238, 1239,
		1, 0, 0, 0, 1239, 1242, 1, 0, 0, 0, 1240, 1241, 5, 351, 0, 0, 1241, 1243,
		5, 376, 0, 0, 1242, 1240, 1, 0, 0, 0, 1242, 1243, 1, 0, 0, 0, 1243, 1244,
		1, 0, 0, 0, 1244, 1245, 5, 369, 0, 0, 1245, 109, 1, 0, 0, 0, 1246, 1247,
		3, 104, 52, 0, 1247, 1249, 3, 106, 53, 0, 1248, 1250, 3, 108, 54, 0, 1249,
		1248, 1, 0, 0, 0, 1249, 1250, 1, 0, 0, 0, 1250, 111, 1, 0, 0, 0, 1251,
		1252, 5, 49, 0, 0, 1252, 1253, 3, 410, 205, 0, 1253, 113, 1, 0, 0, 0, 1254,
		1256, 3, 110, 55, 0, 1255, 1257, 3, 112, 56, 0, 1256, 1255, 1, 0, 0, 0,
		1256, 1257, 1, 0, 0, 0, 1257, 1265, 1, 0, 0, 0, 1258, 1259, 5, 351, 0,
		0, 1259, 1261, 3, 110, 55, 0, 1260, 1262, 3, 112, 56, 0, 1261, 1260, 1,
		0, 0, 0, 1261, 1262, 1, 0, 0, 0, 1262, 1264, 1, 0, 0, 0, 1263, 1258, 1,
		0, 0, 0, 1264, 1267, 1, 0, 0, 0, 1265, 1263, 1, 0, 0, 0, 1265, 1266, 1,
		0, 0, 0, 1266, 115, 1, 0, 0, 0, 1267, 1265, 1, 0, 0, 0, 1268, 1269, 5,
		215, 0, 0, 1269, 1270, 5, 30, 0, 0, 1270, 1271, 5, 366, 0, 0, 1271, 1272,
		3, 114, 57, 0, 1272, 1273, 5, 369, 0, 0, 1273, 117, 1, 0, 0, 0, 1274, 1275,
		5, 49, 0, 0, 1275, 1276, 3, 410, 205, 0, 1276, 119, 1, 0, 0, 0, 1277, 1284,
		3, 118, 59, 0, 1278, 1284, 3, 116, 58, 0, 1279, 1284, 3, 122, 61, 0, 1280,
		1281, 5, 280, 0, 0, 1281, 1282, 5, 13, 0, 0, 1282, 1284, 3, 474, 237, 0,
		1283, 1277, 1, 0, 0, 0, 1283, 1278, 1, 0, 0, 0, 1283, 1279, 1, 0, 0, 0,
		1283, 1280, 1, 0, 0, 0, 1284, 121, 1, 0, 0, 0, 1285, 1286, 5, 245, 0, 0,
		1286, 1287, 5, 118, 0, 0, 1287, 1291, 5, 82, 0, 0, 1288, 1290, 3, 124,
		62, 0, 1289, 1288, 1, 0, 0, 0, 1290, 1293, 1, 0, 0, 0, 1291, 1289, 1, 0,
		0, 0, 1291, 1292, 1, 0, 0, 0, 1292, 123, 1, 0, 0, 0, 1293, 1291, 1, 0,
		0, 0, 1294, 1295, 5, 112, 0, 0, 1295, 1296, 5, 290, 0, 0, 1296, 1297, 5,
		30, 0, 0, 1297, 1301, 3, 410, 205, 0, 1298, 1299, 5, 101, 0, 0, 1299, 1300,
		5, 30, 0, 0, 1300, 1302, 3, 410, 205, 0, 1301, 1298, 1, 0, 0, 0, 1301,
		1302, 1, 0, 0, 0, 1302, 1322, 1, 0, 0, 0, 1303, 1304, 5, 47, 0, 0, 1304,
		1305, 5, 156, 0, 0, 1305, 1306, 5, 290, 0, 0, 1306, 1307, 5, 30, 0, 0,
		1307, 1322, 3, 410, 205, 0, 1308, 1309, 5, 176, 0, 0, 1309, 1310, 5, 160,
		0, 0, 1310, 1311, 5, 290, 0, 0, 1311, 1312, 5, 30, 0, 0, 1312, 1322, 3,
		410, 205, 0, 1313, 1314, 5, 166, 0, 0, 1314, 1315, 5, 290, 0, 0, 1315,
		1316, 5, 30, 0, 0, 1316, 1322, 3, 410, 205, 0, 1317, 1318, 5, 197, 0, 0,
		1318, 1319, 5, 78, 0, 0, 1319, 1320, 5, 13, 0, 0, 1320, 1322, 3, 410, 205,
		0, 1321, 1294, 1, 0, 0, 0, 1321, 1303, 1, 0, 0, 0, 1321, 1308, 1, 0, 0,
		0, 1321, 1313, 1, 0, 0, 0, 1321, 1317, 1, 0, 0, 0, 1322, 125, 1, 0, 0,
		0, 1323, 1324, 5, 203, 0, 0, 1324, 1328, 3, 474, 237, 0, 1325, 1326, 5,
		291, 0, 0, 1326, 1328, 3, 474, 237, 0, 1327, 1323, 1, 0, 0, 0, 1327, 1325,
		1, 0, 0, 0, 1328, 127, 1, 0, 0, 0, 1329, 1331, 5, 17, 0, 0, 1330, 1332,
		5, 356, 0, 0, 1331, 1330, 1, 0, 0, 0, 1331, 1332, 1, 0, 0, 0, 1332, 1333,
		1, 0, 0, 0, 1333, 1357, 3, 410, 205, 0, 1334, 1336, 5, 49, 0, 0, 1335,
		1337, 5, 356, 0, 0, 1336, 1335, 1, 0, 0, 0, 1336, 1337, 1, 0, 0, 0, 1337,
		1338, 1, 0, 0, 0, 1338, 1357, 3, 410, 205, 0, 1339, 1341, 5, 76, 0, 0,
		1340, 1339, 1, 0, 0, 0, 1340, 1341, 1, 0, 0, 0, 1341, 1345, 1, 0, 0, 0,
		1342, 1343, 5, 40, 0, 0, 1343, 1346, 5, 260, 0, 0, 1344, 1346, 5, 41, 0,
		0, 1345, 1342, 1, 0, 0, 0, 1345, 1344, 1, 0, 0, 0, 1346, 1348, 1, 0, 0,
		0, 1347, 1349, 5, 356, 0, 0, 1348, 1347, 1, 0, 0, 0, 1348, 1349, 1, 0,
		0, 0, 1349, 1350, 1, 0, 0, 0, 1350, 1357, 3, 410, 205, 0, 1351, 1353, 5,
		100, 0, 0, 1352, 1354, 5, 356, 0, 0, 1353, 1352, 1, 0, 0, 0, 1353, 1354,
		1, 0, 0, 0, 1354, 1355, 1, 0, 0, 0, 1355, 1357, 3, 410, 205, 0, 1356, 1329,
		1, 0, 0, 0, 1356, 1334, 1, 0, 0, 0, 1356, 1340, 1, 0, 0, 0, 1356, 1351,
		1, 0, 0, 0, 1357, 129, 1, 0, 0, 0, 1358, 1359, 5, 9, 0, 0, 1359, 1360,
		5, 287, 0, 0, 1360, 1361, 3, 356, 178, 0, 1361, 1362, 3, 132, 66, 0, 1362,
		131, 1, 0, 0, 0, 1363, 1364, 3, 134, 67, 0, 1364, 133, 1, 0, 0, 0, 1365,
		1368, 5, 6, 0, 0, 1366, 1367, 5, 55, 0, 0, 1367, 1369, 3, 474, 237, 0,
		1368, 1366, 1, 0, 0, 0, 1368, 1369, 1, 0, 0, 0, 1369, 1370, 1, 0, 0, 0,
		1370, 1371, 3, 136, 68, 0, 1371, 135, 1, 0, 0, 0, 1372, 1373, 5, 221, 0,
		0, 1373, 1375, 5, 159, 0, 0, 1374, 1376, 5, 44, 0, 0, 1375, 1374, 1, 0,
		0, 0, 1375, 1376, 1, 0, 0, 0, 1376, 1377, 1, 0, 0, 0, 1377, 1378, 5, 366,
		0, 0, 1378, 1380, 3, 474, 237, 0, 1379, 1381, 7, 7, 0, 0, 1380, 1379, 1,
		0, 0, 0, 1380, 1381, 1, 0, 0, 0, 1381, 1389, 1, 0, 0, 0, 1382, 1383, 5,
		351, 0, 0, 1383, 1385, 3, 474, 237, 0, 1384, 1386, 7, 7, 0, 0, 1385, 1384,
		1, 0, 0, 0, 1385, 1386, 1, 0, 0, 0, 1386, 1388, 1, 0, 0, 0, 1387, 1382,
		1, 0, 0, 0, 1388, 1391, 1, 0, 0, 0, 1389, 1387, 1, 0, 0, 0, 1389, 1390,
		1, 0, 0, 0, 1390, 1392, 1, 0, 0, 0, 1391, 1389, 1, 0, 0, 0, 1392, 1394,
		5, 369, 0, 0, 1393, 1395, 5, 98, 0, 0, 1394, 1393, 1, 0, 0, 0, 1394, 1395,
		1, 0, 0, 0, 1395, 1397, 1, 0, 0, 0, 1396, 1398, 3, 258, 129, 0, 1397, 1396,
		1, 0, 0, 0, 1397, 1398, 1, 0, 0, 0, 1398, 1435, 1, 0, 0, 0, 1399, 1400,
		5, 117, 0, 0, 1400, 1401, 5, 159, 0, 0, 1401, 1402, 5, 366, 0, 0, 1402,
		1407, 3, 474, 237, 0, 1403, 1404, 5, 351, 0, 0, 1404, 1406, 3, 474, 237,
		0, 1405, 1403, 1, 0, 0, 0, 1406, 1409, 1, 0, 0, 0, 1407, 1405, 1, 0, 0,
		0, 1407, 1408, 1, 0, 0, 0, 1408, 1410, 1, 0, 0, 0, 1409, 1407, 1, 0, 0,
		0, 1410, 1411, 5, 369, 0, 0, 1411, 1412, 5, 231, 0, 0, 1412, 1413, 3, 356,
		178, 0, 1413, 1414, 5, 366, 0, 0, 1414, 1419, 3, 474, 237, 0, 1415, 1416,
		5, 351, 0, 0, 1416, 1418, 3, 474, 237, 0, 1417, 1415, 1, 0, 0, 0, 1418,
		1421, 1, 0, 0, 0, 1419, 1417, 1, 0, 0, 0, 1419, 1420, 1, 0, 0, 0, 1420,
		1422, 1, 0, 0, 0, 1421, 1419, 1, 0, 0, 0, 1422, 1426, 5, 369, 0, 0, 1423,
		1425, 3, 86, 43, 0, 1424, 1423, 1, 0, 0, 0, 1425, 1428, 1, 0, 0, 0, 1426,
		1424, 1, 0, 0, 0, 1426, 1427, 1, 0, 0, 0, 1427, 1435, 1, 0, 0, 0, 1428,
		1426, 1, 0, 0, 0, 1429, 1430, 5, 76, 0, 0, 1430, 1431, 3, 410, 205, 0,
		1431, 1432, 5, 116, 0, 0, 1432, 1433, 3, 474, 237, 0, 1433, 1435, 1, 0,
		0, 0, 1434, 1372, 1, 0, 0, 0, 1434, 1399, 1, 0, 0, 0, 1434, 1429, 1, 0,
		0, 0, 1435, 137, 1, 0, 0, 0, 1436, 1479, 5, 39, 0, 0, 1437, 1479, 5, 40,
		0, 0, 1438, 1479, 5, 22, 0, 0, 1439, 1479, 5, 23, 0, 0, 1440, 1479, 5,
		24, 0, 0, 1441, 1479, 5, 25, 0, 0, 1442, 1479, 5, 26, 0, 0, 1443, 1479,
		5, 69, 0, 0, 1444, 1479, 5, 70, 0, 0, 1445, 1479, 5, 73, 0, 0, 1446, 1479,
		5, 74, 0, 0, 1447, 1449, 5, 92, 0, 0, 1448, 1450, 5, 219, 0, 0, 1449, 1448,
		1, 0, 0, 0, 1449, 1450, 1, 0, 0, 0, 1450, 1479, 1, 0, 0, 0, 1451, 1479,
		5, 115, 0, 0, 1452, 1479, 5, 145, 0, 0, 1453, 1479, 5, 146, 0, 0, 1454,
		1479, 5, 147, 0, 0, 1455, 1479, 5, 148, 0, 0, 1456, 1479, 5, 149, 0, 0,
		1457, 1479, 5, 187, 0, 0, 1458, 1479, 5, 189, 0, 0, 1459, 1479, 5, 199,
		0, 0, 1460, 1479, 5, 198, 0, 0, 1461, 1479, 5, 218, 0, 0, 1462, 1479, 5,
		230, 0, 0, 1463, 1464, 5, 237, 0, 0, 1464, 1479, 5, 313, 0, 0, 1465, 1479,
		5, 267, 0, 0, 1466, 1479, 5, 266, 0, 0, 1467, 1479, 5, 268, 0, 0, 1468,
		1479, 5, 270, 0, 0, 1469, 1479, 5, 269, 0, 0, 1470, 1479, 5, 281, 0, 0,
		1471, 1479, 5, 286, 0, 0, 1472, 1479, 5, 294, 0, 0, 1473, 1479, 5, 295,
		0, 0, 1474, 1479, 5, 311, 0, 0, 1475, 1479, 5, 312, 0, 0, 1476, 1479, 5,
		322, 0, 0, 1477, 1479, 5, 32, 0, 0, 1478, 1436, 1, 0, 0, 0, 1478, 1437,
		1, 0, 0, 0, 1478, 1438, 1, 0, 0, 0, 1478, 1439, 1, 0, 0, 0, 1478, 1440,
		1, 0, 0, 0, 1478, 1441, 1, 0, 0, 0, 1478, 1442, 1, 0, 0, 0, 1478, 1443,
		1, 0, 0, 0, 1478, 1444, 1, 0, 0, 0, 1478, 1445, 1, 0, 0, 0, 1478, 1446,
		1, 0, 0, 0, 1478, 1447, 1, 0, 0, 0, 1478, 1451, 1, 0, 0, 0, 1478, 1452,
		1, 0, 0, 0, 1478, 1453, 1, 0, 0, 0, 1478, 1454, 1, 0, 0, 0, 1478, 1455,
		1, 0, 0, 0, 1478, 1456, 1, 0, 0, 0, 1478, 1457, 1, 0, 0, 0, 1478, 1458,
		1, 0, 0, 0, 1478, 1459, 1, 0, 0, 0, 1478, 1460, 1, 0, 0, 0, 1478, 1461,
		1, 0, 0, 0, 1478, 1462, 1, 0, 0, 0, 1478, 1463, 1, 0, 0, 0, 1478, 1465,
		1, 0, 0, 0, 1478, 1466, 1, 0, 0, 0, 1478, 1467, 1, 0, 0, 0, 1478, 1468,
		1, 0, 0, 0, 1478, 1469, 1, 0, 0, 0, 1478, 1470, 1, 0, 0, 0, 1478, 1471,
		1, 0, 0, 0, 1478, 1472, 1, 0, 0, 0, 1478, 1473, 1, 0, 0, 0, 1478, 1474,
		1, 0, 0, 0, 1478, 1475, 1, 0, 0, 0, 1478, 1476, 1, 0, 0, 0, 1478, 1477,
		1, 0, 0, 0, 1479, 139, 1, 0, 0, 0, 1480, 1481, 5, 366, 0, 0, 1481, 1483,
		7, 15, 0, 0, 1482, 1484, 7, 16, 0, 0, 1483, 1482, 1, 0, 0, 0, 1483, 1484,
		1, 0, 0, 0, 1484, 1487, 1, 0, 0, 0, 1485, 1486, 5, 351, 0, 0, 1486, 1488,
		5, 376, 0, 0, 1487, 1485, 1, 0, 0, 0, 1487, 1488, 1, 0, 0, 0, 1488, 1489,
		1, 0, 0, 0, 1489, 1490, 5, 369, 0, 0, 1490, 141, 1, 0, 0, 0, 1491, 1493,
		5, 195, 0, 0, 1492, 1491, 1, 0, 0, 0, 1492, 1493, 1, 0, 0, 0, 1493, 1494,
		1, 0, 0, 0, 1494, 1503, 5, 197, 0, 0, 1495, 1496, 5, 40, 0, 0, 1496, 1497,
		5, 260, 0, 0, 1497, 1503, 3, 472, 236, 0, 1498, 1500, 5, 195, 0, 0, 1499,
		1498, 1, 0, 0, 0, 1499, 1500, 1, 0, 0, 0, 1500, 1501, 1, 0, 0, 0, 1501,
		1503, 7, 17, 0, 0, 1502, 1492, 1, 0, 0, 0, 1502, 1495, 1, 0, 0, 0, 1502,
		1499, 1, 0, 0, 0, 1503, 143, 1, 0, 0, 0, 1504, 1506, 5, 350, 0, 0, 1505,
		1504, 1, 0, 0, 0, 1505, 1506, 1, 0, 0, 0, 1506, 1507, 1, 0, 0, 0, 1507,
		1508, 5, 356, 0, 0, 1508, 1517, 3, 410, 205, 0, 1509, 1511, 5, 318, 0,
		0, 1510, 1509, 1, 0, 0, 0, 1510, 1511, 1, 0, 0, 0, 1511, 1512, 1, 0, 0,
		0, 1512, 1514, 5, 76, 0, 0, 1513, 1515, 3, 410, 205, 0, 1514, 1513, 1,
		0, 0, 0, 1514, 1515, 1, 0, 0, 0, 1515, 1517, 1, 0, 0, 0, 1516, 1505, 1,
		0, 0, 0, 1516, 1510, 1, 0, 0, 0, 1517, 145, 1, 0, 0, 0, 1518, 1519, 5,
		60, 0, 0, 1519, 1523, 7, 18, 0, 0, 1520, 1521, 5, 135, 0, 0, 1521, 1522,
		5, 195, 0, 0, 1522, 1524, 5, 107, 0, 0, 1523, 1520, 1, 0, 0, 0, 1523, 1524,
		1, 0, 0, 0, 1524, 1525, 1, 0, 0, 0, 1525, 1529, 3, 410, 205, 0, 1526, 1528,
		3, 148, 74, 0, 1527, 1526, 1, 0, 0, 0, 1528, 1531, 1, 0, 0, 0, 1529, 1527,
		1, 0, 0, 0, 1529, 1530, 1, 0, 0, 0, 1530, 147, 1, 0, 0, 0, 1531, 1529,
		1, 0, 0, 0, 1532, 1533, 5, 49, 0, 0, 1533, 1537, 3, 410, 205, 0, 1534,
		1535, 5, 168, 0, 0, 1535, 1537, 3, 410, 205, 0, 1536, 1532, 1, 0, 0, 0,
		1536, 1534, 1, 0, 0, 0, 1537, 149, 1, 0, 0, 0, 1538, 1546, 5, 9, 0, 0,
		1539, 1542, 5, 60, 0, 0, 1540, 1541, 5, 206, 0, 0, 1541, 1543, 5, 233,
		0, 0, 1542, 1540, 1, 0, 0, 0, 1542, 1543, 1, 0, 0, 0, 1543, 1546, 1, 0,
		0, 0, 1544, 1546, 5, 233, 0, 0, 1545, 1538, 1, 0, 0, 0, 1545, 1539, 1,
		0, 0, 0, 1545, 1544, 1, 0, 0, 0, 1545, 1546, 1, 0, 0, 0, 1546, 1547, 1,
		0, 0, 0, 1547, 1548, 5, 122, 0, 0, 1548, 1550, 3, 472, 236, 0, 1549, 1551,
		3, 168, 84, 0, 1550, 1549, 1, 0, 0, 0, 1550, 1551, 1, 0, 0, 0, 1551, 1552,
		1, 0, 0, 0, 1552, 1554, 3, 152, 76, 0, 1553, 1555, 7, 19, 0, 0, 1554, 1553,
		1, 0, 0, 0, 1554, 1555, 1, 0, 0, 0, 1555, 1557, 1, 0, 0, 0, 1556, 1558,
		3, 50, 25, 0, 1557, 1556, 1, 0, 0, 0, 1557, 1558, 1, 0, 0, 0, 1558, 1559,
		1, 0, 0, 0, 1559, 1560, 3, 6, 3, 0, 1560, 151, 1, 0, 0, 0, 1561, 1562,
		7, 20, 0, 0, 1562, 1564, 3, 138, 69, 0, 1563, 1565, 3, 140, 70, 0, 1564,
		1563, 1, 0, 0, 0, 1564, 1565, 1, 0, 0, 0, 1565, 153, 1, 0, 0, 0, 1566,
		1574, 5, 9, 0, 0, 1567, 1570, 5, 60, 0, 0, 1568, 1569, 5, 206, 0, 0, 1569,
		1571, 5, 233, 0, 0, 1570, 1568, 1, 0, 0, 0, 1570, 1571, 1, 0, 0, 0, 1571,
		1574, 1, 0, 0, 0, 1572, 1574, 5, 233, 0, 0, 1573, 1566, 1, 0, 0, 0, 1573,
		1567, 1, 0, 0, 0, 1573, 1572, 1, 0, 0, 0, 1573, 1574, 1, 0, 0, 0, 1574,
		1575, 1, 0, 0, 0, 1575, 1576, 5, 213, 0, 0, 1576, 1577, 3, 472, 236, 0,
		1577, 1578, 7, 19, 0, 0, 1578, 1579, 3, 156, 78, 0, 1579, 1583, 5, 99,
		0, 0, 1580, 1581, 3, 472, 236, 0, 1581, 1582, 5, 371, 0, 0, 1582, 1584,
		1, 0, 0, 0, 1583, 1580, 1, 0, 0, 0, 1583, 1584, 1, 0, 0, 0, 1584, 155,
		1, 0, 0, 0, 1585, 1586, 3, 158, 79, 0, 1586, 1592, 5, 371, 0, 0, 1587,
		1588, 3, 158, 79, 0, 1588, 1589, 5, 371, 0, 0, 1589, 1591, 1, 0, 0, 0,
		1590, 1587, 1, 0, 0, 0, 1591, 1594, 1, 0, 0, 0, 1592, 1590, 1, 0, 0, 0,
		1592, 1593, 1, 0, 0, 0, 1593, 157, 1, 0, 0, 0, 1594, 1592, 1, 0, 0, 0,
		1595, 1609, 3, 52, 26, 0, 1596, 1597, 5, 122, 0, 0, 1597, 1599, 3, 472,
		236, 0, 1598, 1600, 3, 168, 84, 0, 1599, 1598, 1, 0, 0, 0, 1599, 1600,
		1, 0, 0, 0, 1600, 1601, 1, 0, 0, 0, 1601, 1602, 3, 152, 76, 0, 1602, 1609,
		1, 0, 0, 0, 1603, 1604, 7, 21, 0, 0, 1604, 1606, 3, 472, 236, 0, 1605,
		1607, 3, 168, 84, 0, 1606, 1605, 1, 0, 0, 0, 1606, 1607, 1, 0, 0, 0, 1607,
		1609, 1, 0, 0, 0, 1608, 1595, 1, 0, 0, 0, 1608, 1596, 1, 0, 0, 0, 1608,
		1603, 1, 0, 0, 0, 1609, 159, 1, 0, 0, 0, 1610, 1618, 5, 9, 0, 0, 1611,
		1614, 5, 60, 0, 0, 1612, 1613, 5, 206, 0, 0, 1613, 1615, 5, 233, 0, 0,
		1614, 1612, 1, 0, 0, 0, 1614, 1615, 1, 0, 0, 0, 1615, 1618, 1, 0, 0, 0,
		1616, 1618, 5, 233, 0, 0, 1617, 1610, 1, 0, 0, 0, 1617, 1611, 1, 0, 0,
		0, 1617, 1616, 1, 0, 0, 0, 1617, 1618, 1, 0, 0, 0, 1618, 1619, 1, 0, 0,
		0, 1619, 1620, 5, 213, 0, 0, 1620, 1621, 5, 27, 0, 0, 1621, 1622, 3, 472,
		236, 0, 1622, 1623, 7, 19, 0, 0, 1623, 1624, 3, 162, 81, 0, 1624, 1628,
		5, 99, 0, 0, 1625, 1626, 3, 472, 236, 0, 1626, 1627, 5, 371, 0, 0, 1627,
		1629, 1, 0, 0, 0, 1628, 1625, 1, 0, 0, 0, 1628, 1629, 1, 0, 0, 0, 1629,
		161, 1, 0, 0, 0, 1630, 1631, 3, 164, 82, 0, 1631, 1637, 5, 371, 0, 0, 1632,
		1633, 3, 164, 82, 0, 1633, 1634, 5, 371, 0, 0, 1634, 1636, 1, 0, 0, 0,
		1635, 1632, 1, 0, 0, 0, 1636, 1639, 1, 0, 0, 0, 1637, 1635, 1, 0, 0, 0,
		1637, 1638, 1, 0, 0, 0, 1638, 163, 1, 0, 0, 0, 1639, 1637, 1, 0, 0, 0,
		1640, 1644, 3, 52, 26, 0, 1641, 1644, 3, 150, 75, 0, 1642, 1644, 3, 166,
		83, 0, 1643, 1640, 1, 0, 0, 0, 1643, 1641, 1, 0, 0, 0, 1643, 1642, 1, 0,
		0, 0, 1644, 165, 1, 0, 0, 0, 1645, 1653, 5, 9, 0, 0, 1646, 1649, 5, 60,
		0, 0, 1647, 1648, 5, 206, 0, 0, 1648, 1650, 5, 233, 0, 0, 1649, 1647, 1,
		0, 0, 0, 1649, 1650, 1, 0, 0, 0, 1650, 1653, 1, 0, 0, 0, 1651, 1653, 5,
		233, 0, 0, 1652, 1645, 1, 0, 0, 0, 1652, 1646, 1, 0, 0, 0, 1652, 1651,
		1, 0, 0, 0, 1652, 1653, 1, 0, 0, 0, 1653, 1654, 1, 0, 0, 0, 1654, 1655,
		7, 21, 0, 0, 1655, 1657, 3, 472, 236, 0, 1656, 1658, 3, 168, 84, 0, 1657,
		1656, 1, 0, 0, 0, 1657, 1658, 1, 0, 0, 0, 1658, 1660, 1, 0, 0, 0, 1659,
		1661, 3, 172, 86, 0, 1660, 1659, 1, 0, 0, 0, 1660, 1661, 1, 0, 0, 0, 1661,
		1663, 1, 0, 0, 0, 1662, 1664, 7, 19, 0, 0, 1663, 1662, 1, 0, 0, 0, 1663,
		1664, 1, 0, 0, 0, 1664, 1666, 1, 0, 0, 0, 1665, 1667, 3, 50, 25, 0, 1666,
		1665, 1, 0, 0, 0, 1666, 1667, 1, 0, 0, 0, 1667, 1669, 1, 0, 0, 0, 1668,
		1670, 3, 300, 150, 0, 1669, 1668, 1, 0, 0, 0, 1669, 1670, 1, 0, 0, 0, 1670,
		1671, 1, 0, 0, 0, 1671, 1675, 3, 10, 5, 0, 1672, 1673, 3, 472, 236, 0,
		1673, 1674, 5, 371, 0, 0, 1674, 1676, 1, 0, 0, 0, 1675, 1672, 1, 0, 0,
		0, 1675, 1676, 1, 0, 0, 0, 1676, 167, 1, 0, 0, 0, 1677, 1678, 5, 366, 0,
		0, 1678, 1700, 5, 369, 0, 0, 1679, 1680, 5, 366, 0, 0, 1680, 1685, 3, 170,
		85, 0, 1681, 1682, 5, 351, 0, 0, 1682, 1684, 3, 170, 85, 0, 1683, 1681,
		1, 0, 0, 0, 1684, 1687, 1, 0, 0, 0, 1685, 1683, 1, 0, 0, 0, 1685, 1686,
		1, 0, 0, 0, 1686, 1688, 1, 0, 0, 0, 1687, 1685, 1, 0, 0, 0, 1688, 1689,
		5, 369, 0, 0, 1689, 1700, 1, 0, 0, 0, 1690, 1691, 4, 84, 2, 0, 1691, 1696,
		3, 170, 85, 0, 1692, 1693, 5, 351, 0, 0, 1693, 1695, 3, 170, 85, 0, 1694,
		1692, 1, 0, 0, 0, 1695, 1698, 1, 0, 0, 0, 1696, 1694, 1, 0, 0, 0, 1696,
		1697, 1, 0, 0, 0, 1697, 1700, 1, 0, 0, 0, 1698, 1696, 1, 0, 0, 0, 1699,
		1677, 1, 0, 0, 0, 1699, 1679, 1, 0, 0, 0, 1699, 1690, 1, 0, 0, 0, 1700,
		169, 1, 0, 0, 0, 1701, 1707, 5, 138, 0, 0, 1702, 1707, 5, 208, 0, 0, 1703,
		1707, 5, 143, 0, 0, 1704, 1705, 5, 138, 0, 0, 1705, 1707, 5, 208, 0, 0,
		1706, 1701, 1, 0, 0, 0, 1706, 1702, 1, 0, 0, 0, 1706, 1703, 1, 0, 0, 0,
		1706, 1704, 1, 0, 0, 0, 1706, 1707, 1, 0, 0, 0, 1707, 1708, 1, 0, 0, 0,
		1708, 1709, 3, 472, 236, 0, 1709, 1711, 3, 138, 69, 0, 1710, 1712, 3, 140,
		70, 0, 1711, 1710, 1, 0, 0, 0, 1711, 1712, 1, 0, 0, 0, 1712, 1716, 1, 0,
		0, 0, 1713, 1715, 3, 142, 71, 0, 1714, 1713, 1, 0, 0, 0, 1715, 1718, 1,
		0, 0, 0, 1716, 1714, 1, 0, 0, 0, 1716, 1717, 1, 0, 0, 0, 1717, 1720, 1,
		0, 0, 0, 1718, 1716, 1, 0, 0, 0, 1719, 1721, 3, 144, 72, 0, 1720, 1719,
		1, 0, 0, 0, 1720, 1721, 1, 0, 0, 0, 1721, 1744, 1, 0, 0, 0, 1722, 1728,
		3, 472, 236, 0, 1723, 1729, 5, 138, 0, 0, 1724, 1729, 5, 208, 0, 0, 1725,
		1729, 5, 143, 0, 0, 1726, 1727, 5, 138, 0, 0, 1727, 1729, 5, 208, 0, 0,
		1728, 1723, 1, 0, 0, 0, 1728, 1724, 1, 0, 0, 0, 1728, 1725, 1, 0, 0, 0,
		1728, 1726, 1, 0, 0, 0, 1728, 1729, 1, 0, 0, 0, 1729, 1730, 1, 0, 0, 0,
		1730, 1732, 3, 138, 69, 0, 1731, 1733, 3, 140, 70, 0, 1732, 1731, 1, 0,
		0, 0, 1732, 1733, 1, 0, 0, 0, 1733, 1737, 1, 0, 0, 0, 1734, 1736, 3, 142,
		71, 0, 1735, 1734, 1, 0, 0, 0, 1736, 1739, 1, 0, 0, 0, 1737, 1735, 1, 0,
		0, 0, 1737, 1738, 1, 0, 0, 0, 1738, 1741, 1, 0, 0, 0, 1739, 1737, 1, 0,
		0, 0, 1740, 1742, 3, 144, 72, 0, 1741, 1740, 1, 0, 0, 0, 1741, 1742, 1,
		0, 0, 0, 1742, 1744, 1, 0, 0, 0, 1743, 1706, 1, 0, 0, 0, 1743, 1722, 1,
		0, 0, 0, 1744, 171, 1, 0, 0, 0, 1745, 1747, 3, 174, 87, 0, 1746, 1745,
		1, 0, 0, 0, 1747, 1748, 1, 0, 0, 0, 1748, 1746, 1, 0, 0, 0, 1748, 1749,
		1, 0, 0, 0, 1749, 173, 1, 0, 0, 0, 1750, 1751, 5, 161, 0, 0, 1751, 1762,
		5, 271, 0, 0, 1752, 1753, 5, 271, 0, 0, 1753, 1754, 5, 256, 0, 0, 1754,
		1762, 7, 22, 0, 0, 1755, 1757, 5, 94, 0, 0, 1756, 1755, 1, 0, 0, 0, 1756,
		1757, 1, 0, 0, 0, 1757, 1758, 1, 0, 0, 0, 1758, 1759, 5, 236, 0, 0, 1759,
		1760, 5, 263, 0, 0, 1760, 1762, 5, 376, 0, 0, 1761, 1750, 1, 0, 0, 0, 1761,
		1752, 1, 0, 0, 0, 1761, 1756, 1, 0, 0, 0, 1762, 175, 1, 0, 0, 0, 1763,
		1764, 5, 93, 0, 0, 1764, 1767, 5, 287, 0, 0, 1765, 1766, 5, 135, 0, 0,
		1766, 1768, 5, 107, 0, 0, 1767, 1765, 1, 0, 0, 0, 1767, 1768, 1, 0, 0,
		0, 1768, 1769, 1, 0, 0, 0, 1769, 1792, 3, 356, 178, 0, 1770, 1771, 5, 93,
		0, 0, 1771, 1774, 5, 213, 0, 0, 1772, 1773, 5, 135, 0, 0, 1773, 1775, 5,
		107, 0, 0, 1774, 1772, 1, 0, 0, 0, 1774, 1775, 1, 0, 0, 0, 1775, 1776,
		1, 0, 0, 0, 1776, 1792, 3, 472, 236, 0, 1777, 1778, 5, 93, 0, 0, 1778,
		1781, 7, 23, 0, 0, 1779, 1780, 5, 135, 0, 0, 1780, 1782, 5, 107, 0, 0,
		1781, 1779, 1, 0, 0, 0, 1781, 1782, 1, 0, 0, 0, 1782, 1783, 1, 0, 0, 0,
		1783, 1792, 3, 472, 236, 0, 1784, 1785, 5, 93, 0, 0, 1785, 1788, 7, 18,
		0, 0, 1786, 1787, 5, 135, 0, 0, 1787, 1789, 5, 107, 0, 0, 1788, 1786, 1,
		0, 0, 0, 1788, 1789, 1, 0, 0, 0, 1789, 1790, 1, 0, 0, 0, 1790, 1792, 3,
		410, 205, 0, 1791, 1763, 1, 0, 0, 0, 1791, 1770, 1, 0, 0, 0, 1791, 1777,
		1, 0, 0, 0, 1791, 1784, 1, 0, 0, 0, 1792, 177, 1, 0, 0, 0, 1793, 1794,
		5, 99, 0, 0, 1794, 1795, 5, 299, 0, 0, 1795, 179, 1, 0, 0, 0, 1796, 1798,
		7, 24, 0, 0, 1797, 1799, 5, 137, 0, 0, 1798, 1797, 1, 0, 0, 0, 1798, 1799,
		1, 0, 0, 0, 1799, 1800, 1, 0, 0, 0, 1800, 1806, 3, 410, 205, 0, 1801, 1802,
		5, 366, 0, 0, 1802, 1803, 3, 448, 224, 0, 1803, 1804, 5, 369, 0, 0, 1804,
		1807, 1, 0, 0, 0, 1805, 1807, 3, 448, 224, 0, 1806, 1801, 1, 0, 0, 0, 1806,
		1805, 1, 0, 0, 0, 1806, 1807, 1, 0, 0, 0, 1807, 1817, 1, 0, 0, 0, 1808,
		1809, 5, 152, 0, 0, 1809, 1814, 5, 373, 0, 0, 1810, 1811, 5, 351, 0, 0,
		1811, 1813, 5, 373, 0, 0, 1812, 1810, 1, 0, 0, 0, 1813, 1816, 1, 0, 0,
		0, 1814, 1812, 1, 0, 0, 0, 1814, 1815, 1, 0, 0, 0, 1815, 1818, 1, 0, 0,
		0, 1816, 1814, 1, 0, 0, 0, 1817, 1808, 1, 0, 0, 0, 1817, 1818, 1, 0, 0,
		0, 1818, 1820, 1, 0, 0, 0, 1819, 1821, 3, 302, 151, 0, 1820, 1819, 1, 0,
		0, 0, 1820, 1821, 1, 0, 0, 0, 1821, 181, 1, 0, 0, 0, 1822, 1826, 3, 184,
		92, 0, 1823, 1826, 3, 186, 93, 0, 1824, 1826, 3, 188, 94, 0, 1825, 1822,
		1, 0, 0, 0, 1825, 1823, 1, 0, 0, 0, 1825, 1824, 1, 0, 0, 0, 1826, 183,
		1, 0, 0, 0, 1827, 1828, 5, 135, 0, 0, 1828, 1829, 3, 394, 197, 0, 1829,
		1830, 5, 292, 0, 0, 1830, 1834, 3, 2, 1, 0, 1831, 1833, 3, 190, 95, 0,
		1832, 1831, 1, 0, 0, 0, 1833, 1836, 1, 0, 0, 0, 1834, 1832, 1, 0, 0, 0,
		1834, 1835, 1, 0, 0, 0, 1835, 1838, 1, 0, 0, 0, 1836, 1834, 1, 0, 0, 0,
		1837, 1839, 3, 192, 96, 0, 1838, 1837, 1, 0, 0, 0, 1838, 1839, 1, 0, 0,
		0, 1839, 1840, 1, 0, 0, 0, 1840, 1841, 5, 99, 0, 0, 1841, 1842, 5, 135,
		0, 0, 1842, 185, 1, 0, 0, 0, 1843, 1844, 5, 135, 0, 0, 1844, 1845, 3, 394,
		197, 0, 1845, 1848, 3, 6, 3, 0, 1846, 1847, 5, 95, 0, 0, 1847, 1849, 3,
		6, 3, 0, 1848, 1846, 1, 0, 0, 0, 1848, 1849, 1, 0, 0, 0, 1849, 187, 1,
		0, 0, 0, 1850, 1851, 5, 354, 0, 0, 1851, 1852, 5, 135, 0, 0, 1852, 1853,
		3, 394, 197, 0, 1853, 1854, 5, 292, 0, 0, 1854, 1855, 3, 6, 3, 0, 1855,
		189, 1, 0, 0, 0, 1856, 1857, 7, 25, 0, 0, 1857, 1858, 3, 394, 197, 0, 1858,
		1859, 5, 292, 0, 0, 1859, 1860, 3, 2, 1, 0, 1860, 191, 1, 0, 0, 0, 1861,
		1862, 5, 95, 0, 0, 1862, 1863, 3, 2, 1, 0, 1863, 193, 1, 0, 0, 0, 1864,
		1867, 5, 139, 0, 0, 1865, 1868, 3, 466, 233, 0, 1866, 1868, 3, 410, 205,
		0, 1867, 1865, 1, 0, 0, 0, 1867, 1866, 1, 0, 0, 0, 1868, 195, 1, 0, 0,
		0, 1869, 1876, 5, 144, 0, 0, 1870, 1871, 5, 211, 0, 0, 1871, 1877, 5, 287,
		0, 0, 1872, 1874, 5, 152, 0, 0, 1873, 1875, 5, 287, 0, 0, 1874, 1873, 1,
		0, 0, 0, 1874, 1875, 1, 0, 0, 0, 1875, 1877, 1, 0, 0, 0, 1876, 1870, 1,
		0, 0, 0, 1876, 1872, 1, 0, 0, 0, 1877, 1878, 1, 0, 0, 0, 1878, 1880, 3,
		356, 178, 0, 1879, 1881, 3, 198, 99, 0, 1880, 1879, 1, 0, 0, 0, 1880, 1881,
		1, 0, 0, 0, 1881, 1884, 1, 0, 0, 0, 1882, 1885, 3, 304, 152, 0, 1883, 1885,
		3, 200, 100, 0, 1884, 1882, 1, 0, 0, 0, 1884, 1883, 1, 0, 0, 0, 1885, 197,
		1, 0, 0, 0, 1886, 1887, 5, 366, 0, 0, 1887, 1892, 3, 474, 237, 0, 1888,
		1889, 5, 351, 0, 0, 1889, 1891, 3, 474, 237, 0, 1890, 1888, 1, 0, 0, 0,
		1891, 1894, 1, 0, 0, 0, 1892, 1890, 1, 0, 0, 0, 1892, 1893, 1, 0, 0, 0,
		1893, 1895, 1, 0, 0, 0, 1894, 1892, 1, 0, 0, 0, 1895, 1896, 5, 369, 0,
		0, 1896, 199, 1, 0, 0, 0, 1897, 1898, 5, 309, 0, 0, 1898, 1903, 3, 202,
		101, 0, 1899, 1900, 5, 351, 0, 0, 1900, 1902, 3, 202, 101, 0, 1901, 1899,
		1, 0, 0, 0, 1902, 1905, 1, 0, 0, 0, 1903, 1901, 1, 0, 0, 0, 1903, 1904,
		1, 0, 0, 0, 1904, 201, 1, 0, 0, 0, 1905, 1903, 1, 0, 0, 0, 1906, 1907,
		5, 366, 0, 0, 1907, 1912, 3, 410, 205, 0, 1908, 1909, 5, 351, 0, 0, 1909,
		1911, 3, 410, 205, 0, 1910, 1908, 1, 0, 0, 0, 1911, 1914, 1, 0, 0, 0, 1912,
		1910, 1, 0, 0, 0, 1912, 1913, 1, 0, 0, 0, 1913, 1915, 1, 0, 0, 0, 1914,
		1912, 1, 0, 0, 0, 1915, 1916, 5, 369, 0, 0, 1916, 203, 1, 0, 0, 0, 1917,
		1918, 5, 144, 0, 0, 1918, 1920, 5, 211, 0, 0, 1919, 1921, 5, 167, 0, 0,
		1920, 1919, 1, 0, 0, 0, 1920, 1921, 1, 0, 0, 0, 1921, 1922, 1, 0, 0, 0,
		1922, 1923, 5, 88, 0, 0, 1923, 1924, 3, 454, 227, 0, 1924, 1925, 3, 452,
		226, 0, 1925, 205, 1, 0, 0, 0, 1926, 1928, 5, 108, 0, 0, 1927, 1929, 5,
		373, 0, 0, 1928, 1927, 1, 0, 0, 0, 1928, 1929, 1, 0, 0, 0, 1929, 1932,
		1, 0, 0, 0, 1930, 1931, 5, 315, 0, 0, 1931, 1933, 3, 394, 197, 0, 1932,
		1930, 1, 0, 0, 0, 1932, 1933, 1, 0, 0, 0, 1933, 207, 1, 0, 0, 0, 1934,
		1935, 5, 123, 0, 0, 1935, 1936, 5, 86, 0, 0, 1936, 1937, 3, 210, 105, 0,
		1937, 209, 1, 0, 0, 0, 1938, 1941, 3, 212, 106, 0, 1939, 1941, 3, 214,
		107, 0, 1940, 1938, 1, 0, 0, 0, 1940, 1939, 1, 0, 0, 0, 1941, 211, 1, 0,
		0, 0, 1942, 1943, 5, 105, 0, 0, 1943, 1944, 5, 376, 0, 0, 1944, 1945, 3,
		474, 237, 0, 1945, 1946, 5, 356, 0, 0, 1946, 1947, 5, 181, 0, 0, 1947,
		213, 1, 0, 0, 0, 1948, 1949, 3, 474, 237, 0, 1949, 1950, 5, 356, 0, 0,
		1950, 1951, 5, 248, 0, 0, 1951, 215, 1, 0, 0, 0, 1952, 1953, 5, 126, 0,
		0, 1953, 1958, 3, 218, 109, 0, 1954, 1955, 5, 351, 0, 0, 1955, 1957, 3,
		218, 109, 0, 1956, 1954, 1, 0, 0, 0, 1957, 1960, 1, 0, 0, 0, 1958, 1956,
		1, 0, 0, 0, 1958, 1959, 1, 0, 0, 0, 1959, 1961, 1, 0, 0, 0, 1960, 1958,
		1, 0, 0, 0, 1961, 1962, 5, 297, 0, 0, 1962, 1963, 5, 243, 0, 0, 1963, 1964,
		3, 474, 237, 0, 1964, 217, 1, 0, 0, 0, 1965, 1966, 5, 104, 0, 0, 1966,
		1967, 5, 203, 0, 0, 1967, 1968, 5, 224, 0, 0, 1968, 1969, 3, 474, 237,
		0, 1969, 219, 1, 0, 0, 0, 1970, 1972, 5, 162, 0, 0, 1971, 1973, 5, 373,
		0, 0, 1972, 1971, 1, 0, 0, 0, 1972, 1973, 1, 0, 0, 0, 1973, 221, 1, 0,
		0, 0, 1974, 1975, 5, 176, 0, 0, 1975, 1976, 5, 200, 0, 0, 1976, 1979, 3,
		472, 236, 0, 1977, 1978, 5, 297, 0, 0, 1978, 1980, 3, 472, 236, 0, 1979,
		1977, 1, 0, 0, 0, 1979, 1980, 1, 0, 0, 0, 1980, 1983, 1, 0, 0, 0, 1981,
		1982, 5, 16, 0, 0, 1982, 1984, 3, 472, 236, 0, 1983, 1981, 1, 0, 0, 0,
		1983, 1984, 1, 0, 0, 0, 1984, 223, 1, 0, 0, 0, 1985, 1986, 5, 205, 0, 0,
		1986, 1992, 3, 472, 236, 0, 1987, 1990, 5, 116, 0, 0, 1988, 1991, 3, 304,
		152, 0, 1989, 1991, 3, 410, 205, 0, 1990, 1988, 1, 0, 0, 0, 1990, 1989,
		1, 0, 0, 0, 1991, 1993, 1, 0, 0, 0, 1992, 1987, 1, 0, 0, 0, 1992, 1993,
		1, 0, 0, 0, 1993, 225, 1, 0, 0, 0, 1994, 1996, 5, 111, 0, 0, 1995, 1997,
		5, 120, 0, 0, 1996, 1995, 1, 0, 0, 0, 1996, 1997, 1, 0, 0, 0, 1997, 1998,
		1, 0, 0, 0, 1998, 2000, 3, 472, 236, 0, 1999, 2001, 3, 336, 168, 0, 2000,
		1999, 1, 0, 0, 0, 2000, 2001, 1, 0, 0, 0, 2001, 2002, 1, 0, 0, 0, 2002,
		2003, 5, 152, 0, 0, 2003, 2008, 3, 472, 236, 0, 2004, 2005, 5, 351, 0,
		0, 2005, 2007, 3, 472, 236, 0, 2006, 2004, 1, 0, 0, 0, 2007, 2010, 1, 0,
		0, 0, 2008, 2006, 1, 0, 0, 0, 2008, 2009, 1, 0, 0, 0, 2009, 2012, 1, 0,
		0, 0, 2010, 2008, 1, 0, 0, 0, 2011, 2013, 3, 228, 114, 0, 2012, 2011, 1,
		0, 0, 0, 2012, 2013, 1, 0, 0, 0, 2013, 227, 1, 0, 0, 0, 2014, 2015, 5,
		165, 0, 0, 2015, 2016, 3, 410, 205, 0, 2016, 229, 1, 0, 0, 0, 2017, 2018,
		5, 46, 0, 0, 2018, 2019, 7, 26, 0, 0, 2019, 2020, 5, 203, 0, 0, 2020, 2022,
		3, 356, 178, 0, 2021, 2023, 3, 232, 116, 0, 2022, 2021, 1, 0, 0, 0, 2022,
		2023, 1, 0, 0, 0, 2023, 231, 1, 0, 0, 0, 2024, 2025, 5, 48, 0, 0, 2025,
		2026, 5, 366, 0, 0, 2026, 2031, 3, 474, 237, 0, 2027, 2028, 5, 351, 0,
		0, 2028, 2030, 3, 474, 237, 0, 2029, 2027, 1, 0, 0, 0, 2030, 2033, 1, 0,
		0, 0, 2031, 2029, 1, 0, 0, 0, 2031, 2032, 1, 0, 0, 0, 2032, 2034, 1, 0,
		0, 0, 2033, 2031, 1, 0, 0, 0, 2034, 2035, 5, 369, 0, 0, 2035, 233, 1, 0,
		0, 0, 2036, 2037, 5, 43, 0, 0, 2037, 2038, 5, 373, 0, 0, 2038, 235, 1,
		0, 0, 0, 2039, 2040, 5, 45, 0, 0, 2040, 2041, 7, 27, 0, 0, 2041, 2042,
		3, 238, 119, 0, 2042, 2043, 5, 351, 0, 0, 2043, 2044, 3, 238, 119, 0, 2044,
		237, 1, 0, 0, 0, 2045, 2047, 3, 356, 178, 0, 2046, 2048, 3, 358, 179, 0,
		2047, 2046, 1, 0, 0, 0, 2047, 2048, 1, 0, 0, 0, 2048, 2054, 1, 0, 0, 0,
		2049, 2050, 5, 366, 0, 0, 2050, 2051, 3, 304, 152, 0, 2051, 2052, 5, 369,
		0, 0, 2052, 2054, 1, 0, 0, 0, 2053, 2045, 1, 0, 0, 0, 2053, 2049, 1, 0,
		0, 0, 2054, 2057, 1, 0, 0, 0, 2055, 2056, 5, 16, 0, 0, 2056, 2058, 3, 474,
		237, 0, 2057, 2055, 1, 0, 0, 0, 2057, 2058, 1, 0, 0, 0, 2058, 239, 1, 0,
		0, 0, 2059, 2060, 5, 57, 0, 0, 2060, 2061, 5, 120, 0, 0, 2061, 2062, 5,
		167, 0, 0, 2062, 2067, 3, 244, 122, 0, 2063, 2064, 5, 351, 0, 0, 2064,
		2066, 3, 244, 122, 0, 2065, 2063, 1, 0, 0, 0, 2066, 2069, 1, 0, 0, 0, 2067,
		2065, 1, 0, 0, 0, 2067, 2068, 1, 0, 0, 0, 2068, 2070, 1, 0, 0, 0, 2069,
		2067, 1, 0, 0, 0, 2070, 2071, 5, 297, 0, 0, 2071, 2075, 3, 246, 123, 0,
		2072, 2074, 3, 250, 125, 0, 2073, 2072, 1, 0, 0, 0, 2074, 2077, 1, 0, 0,
		0, 2075, 2073, 1, 0, 0, 0, 2075, 2076, 1, 0, 0, 0, 2076, 241, 1, 0, 0,
		0, 2077, 2075, 1, 0, 0, 0, 2078, 2084, 5, 57, 0, 0, 2079, 2085, 3, 356,
		178, 0, 2080, 2081, 5, 366, 0, 0, 2081, 2082, 3, 304, 152, 0, 2082, 2083,
		5, 369, 0, 0, 2083, 2085, 1, 0, 0, 0, 2084, 2079, 1, 0, 0, 0, 2084, 2080,
		1, 0, 0, 0, 2085, 2086, 1, 0, 0, 0, 2086, 2088, 5, 297, 0, 0, 2087, 2089,
		5, 131, 0, 0, 2088, 2087, 1, 0, 0, 0, 2088, 2089, 1, 0, 0, 0, 2089, 2090,
		1, 0, 0, 0, 2090, 2094, 3, 246, 123, 0, 2091, 2093, 3, 248, 124, 0, 2092,
		2091, 1, 0, 0, 0, 2093, 2096, 1, 0, 0, 0, 2094, 2092, 1, 0, 0, 0, 2094,
		2095, 1, 0, 0, 0, 2095, 243, 1, 0, 0, 0, 2096, 2094, 1, 0, 0, 0, 2097,
		2100, 3, 466, 233, 0, 2098, 2100, 3, 410, 205, 0, 2099, 2097, 1, 0, 0,
		0, 2099, 2098, 1, 0, 0, 0, 2100, 245, 1, 0, 0, 0, 2101, 2104, 3, 466, 233,
		0, 2102, 2104, 3, 410, 205, 0, 2103, 2101, 1, 0, 0, 0, 2103, 2102, 1, 0,
		0, 0, 2104, 247, 1, 0, 0, 0, 2105, 2106, 5, 16, 0, 0, 2106, 2114, 3, 474,
		237, 0, 2107, 2108, 5, 19, 0, 0, 2108, 2114, 3, 410, 205, 0, 2109, 2110,
		5, 83, 0, 0, 2110, 2114, 3, 410, 205, 0, 2111, 2112, 5, 273, 0, 0, 2112,
		2114, 3, 474, 237, 0, 2113, 2105, 1, 0, 0, 0, 2113, 2107, 1, 0, 0, 0, 2113,
		2109, 1, 0, 0, 0, 2113, 2111, 1, 0, 0, 0, 2114, 249, 1, 0, 0, 0, 2115,
		2116, 7, 28, 0, 0, 2116, 251, 1, 0, 0, 0, 2117, 2119, 5, 51, 0, 0, 2118,
		2120, 5, 320, 0, 0, 2119, 2118, 1, 0, 0, 0, 2119, 2120, 1, 0, 0, 0, 2120,
		253, 1, 0, 0, 0, 2121, 2123, 5, 60, 0, 0, 2122, 2124, 5, 303, 0, 0, 2123,
		2122, 1, 0, 0, 0, 2123, 2124, 1, 0, 0, 0, 2124, 2125, 1, 0, 0, 0, 2125,
		2126, 5, 140, 0, 0, 2126, 2127, 3, 474, 237, 0, 2127, 2128, 5, 203, 0,
		0, 2128, 2129, 3, 356, 178, 0, 2129, 2130, 5, 366, 0, 0, 2130, 2135, 3,
		256, 128, 0, 2131, 2132, 5, 351, 0, 0, 2132, 2134, 3, 256, 128, 0, 2133,
		2131, 1, 0, 0, 0, 2134, 2137, 1, 0, 0, 0, 2135, 2133, 1, 0, 0, 0, 2135,
		2136, 1, 0, 0, 0, 2136, 2138, 1, 0, 0, 0, 2137, 2135, 1, 0, 0, 0, 2138,
		2139, 5, 369, 0, 0, 2139, 255, 1, 0, 0, 0, 2140, 2142, 3, 474, 237, 0,
		2141, 2143, 7, 7, 0, 0, 2142, 2141, 1, 0, 0, 0, 2142, 2143, 1, 0, 0, 0,
		2143, 257, 1, 0, 0, 0, 2144, 2145, 3, 260, 130, 0, 2145, 259, 1, 0, 0,
		0, 2146, 2147, 5, 318, 0, 0, 2147, 2148, 5, 366, 0, 0, 2148, 2149, 3, 474,
		237, 0, 2149, 2150, 5, 356, 0, 0, 2150, 2158, 3, 474, 237, 0, 2151, 2152,
		5, 351, 0, 0, 2152, 2153, 3, 474, 237, 0, 2153, 2154, 5, 356, 0, 0, 2154,
		2155, 3, 474, 237, 0, 2155, 2157, 1, 0, 0, 0, 2156, 2151, 1, 0, 0, 0, 2157,
		2160, 1, 0, 0, 0, 2158, 2156, 1, 0, 0, 0, 2158, 2159, 1, 0, 0, 0, 2159,
		2161, 1, 0, 0, 0, 2160, 2158, 1, 0, 0, 0, 2161, 2165, 5, 369, 0, 0, 2162,
		2164, 3, 126, 63, 0, 2163, 2162, 1, 0, 0, 0, 2164, 2167, 1, 0, 0, 0, 2165,
		2163, 1, 0, 0, 0, 2165, 2166, 1, 0, 0, 0, 2166, 261, 1, 0, 0, 0, 2167,
		2165, 1, 0, 0, 0, 2168, 2169, 5, 222, 0, 0, 2169, 2176, 3, 410, 205, 0,
		2170, 2171, 5, 222, 0, 0, 2171, 2172, 5, 366, 0, 0, 2172, 2173, 3, 410,
		205, 0, 2173, 2174, 5, 369, 0, 0, 2174, 2176, 1, 0, 0, 0, 2175, 2168, 1,
		0, 0, 0, 2175, 2170, 1, 0, 0, 0, 2176, 263, 1, 0, 0, 0, 2177, 2179, 5,
		354, 0, 0, 2178, 2177, 1, 0, 0, 0, 2178, 2179, 1, 0, 0, 0, 2179, 2180,
		1, 0, 0, 0, 2180, 2182, 5, 227, 0, 0, 2181, 2183, 3, 410, 205, 0, 2182,
		2181, 1, 0, 0, 0, 2182, 2183, 1, 0, 0, 0, 2183, 265, 1, 0, 0, 0, 2184,
		2185, 5, 229, 0, 0, 2185, 267, 1, 0, 0, 0, 2186, 2198, 5, 234, 0, 0, 2187,
		2189, 5, 274, 0, 0, 2188, 2190, 5, 308, 0, 0, 2189, 2188, 1, 0, 0, 0, 2189,
		2190, 1, 0, 0, 0, 2190, 2191, 1, 0, 0, 0, 2191, 2196, 3, 410, 205, 0, 2192,
		2193, 5, 260, 0, 0, 2193, 2194, 5, 181, 0, 0, 2194, 2195, 5, 356, 0, 0,
		2195, 2197, 3, 410, 205, 0, 2196, 2192, 1, 0, 0, 0, 2196, 2197, 1, 0, 0,
		0, 2197, 2199, 1, 0, 0, 0, 2198, 2187, 1, 0, 0, 0, 2198, 2199, 1, 0, 0,
		0, 2199, 269, 1, 0, 0, 0, 2200, 2202, 5, 238, 0, 0, 2201, 2203, 3, 410,
		205, 0, 2202, 2201, 1, 0, 0, 0, 2202, 2203, 1, 0, 0, 0, 2203, 271, 1, 0,
		0, 0, 2204, 2206, 5, 244, 0, 0, 2205, 2207, 5, 320, 0, 0, 2206, 2205, 1,
		0, 0, 0, 2206, 2207, 1, 0, 0, 0, 2207, 273, 1, 0, 0, 0, 2208, 2212, 3,
		276, 138, 0, 2209, 2212, 3, 278, 139, 0, 2210, 2212, 3, 280, 140, 0, 2211,
		2208, 1, 0, 0, 0, 2211, 2209, 1, 0, 0, 0, 2211, 2210, 1, 0, 0, 0, 2212,
		275, 1, 0, 0, 0, 2213, 2215, 5, 64, 0, 0, 2214, 2213, 1, 0, 0, 0, 2214,
		2215, 1, 0, 0, 0, 2215, 2216, 1, 0, 0, 0, 2216, 2219, 5, 253, 0, 0, 2217,
		2219, 5, 65, 0, 0, 2218, 2214, 1, 0, 0, 0, 2218, 2217, 1, 0, 0, 0, 2219,
		2221, 1, 0, 0, 0, 2220, 2222, 5, 356, 0, 0, 2221, 2220, 1, 0, 0, 0, 2221,
		2222, 1, 0, 0, 0, 2222, 2223, 1, 0, 0, 0, 2223, 2224, 3, 410, 205, 0, 2224,
		277, 1, 0, 0, 0, 2225, 2226, 7, 29, 0, 0, 2226, 2227, 7, 30, 0, 0, 2227,
		279, 1, 0, 0, 0, 2228, 2229, 5, 226, 0, 0, 2229, 2232, 5, 356, 0, 0, 2230,
		2233, 3, 410, 205, 0, 2231, 2233, 5, 194, 0, 0, 2232, 2230, 1, 0, 0, 0,
		2232, 2231, 1, 0, 0, 0, 2233, 2235, 1, 0, 0, 0, 2234, 2236, 5, 304, 0,
		0, 2235, 2234, 1, 0, 0, 0, 2235, 2236, 1, 0, 0, 0, 2236, 2237, 1, 0, 0,
		0, 2237, 2238, 5, 116, 0, 0, 2238, 2239, 7, 31, 0, 0, 2239, 281, 1, 0,
		0, 0, 2240, 2241, 5, 265, 0, 0, 2241, 2242, 3, 472, 236, 0, 2242, 283,
		1, 0, 0, 0, 2243, 2246, 5, 285, 0, 0, 2244, 2245, 5, 298, 0, 0, 2245, 2247,
		3, 410, 205, 0, 2246, 2244, 1, 0, 0, 0, 2246, 2247, 1, 0, 0, 0, 2247, 2248,
		1, 0, 0, 0, 2248, 2258, 5, 116, 0, 0, 2249, 2259, 3, 304, 152, 0, 2250,
		2252, 3, 356, 178, 0, 2251, 2253, 3, 358, 179, 0, 2252, 2251, 1, 0, 0,
		0, 2252, 2253, 1, 0, 0, 0, 2253, 2256, 1, 0, 0, 0, 2254, 2255, 5, 165,
		0, 0, 2255, 2257, 3, 410, 205, 0, 2256, 2254, 1, 0, 0, 0, 2256, 2257, 1,
		0, 0, 0, 2257, 2259, 1, 0, 0, 0, 2258, 2249, 1, 0, 0, 0, 2258, 2250, 1,
		0, 0, 0, 2259, 285, 1, 0, 0, 0, 2260, 2262, 5, 301, 0, 0, 2261, 2263, 5,
		287, 0, 0, 2262, 2261, 1, 0, 0, 0, 2262, 2263, 1, 0, 0, 0, 2263, 2264,
		1, 0, 0, 0, 2264, 2265, 3, 356, 178, 0, 2265, 287, 1, 0, 0, 0, 2266, 2267,
		5, 306, 0, 0, 2267, 2268, 3, 410, 205, 0, 2268, 289, 1, 0, 0, 0, 2269,
		2271, 5, 309, 0, 0, 2270, 2272, 5, 366, 0, 0, 2271, 2270, 1, 0, 0, 0, 2271,
		2272, 1, 0, 0, 0, 2272, 2273, 1, 0, 0, 0, 2273, 2278, 3, 410, 205, 0, 2274,
		2275, 5, 351, 0, 0, 2275, 2277, 3, 410, 205, 0, 2276, 2274, 1, 0, 0, 0,
		2277, 2280, 1, 0, 0, 0, 2278, 2276, 1, 0, 0, 0, 2278, 2279, 1, 0, 0, 0,
		2279, 2282, 1, 0, 0, 0, 2280, 2278, 1, 0, 0, 0, 2281, 2283, 5, 369, 0,
		0, 2282, 2281, 1, 0, 0, 0, 2282, 2283, 1, 0, 0, 0, 2283, 2284, 1, 0, 0,
		0, 2284, 2286, 5, 152, 0, 0, 2285, 2287, 5, 366, 0, 0, 2286, 2285, 1, 0,
		0, 0, 2286, 2287, 1, 0, 0, 0, 2287, 2288, 1, 0, 0, 0, 2288, 2293, 3, 472,
		236, 0, 2289, 2290, 5, 351, 0, 0, 2290, 2292, 3, 472, 236, 0, 2291, 2289,
		1, 0, 0, 0, 2292, 2295, 1, 0, 0, 0, 2293, 2291, 1, 0, 0, 0, 2293, 2294,
		1, 0, 0, 0, 2294, 2297, 1, 0, 0, 0, 2295, 2293, 1, 0, 0, 0, 2296, 2298,
		5, 369, 0, 0, 2297, 2296, 1, 0, 0, 0, 2297, 2298, 1, 0, 0, 0, 2298, 291,
		1, 0, 0, 0, 2299, 2300, 5, 317, 0, 0, 2300, 2301, 3, 394, 197, 0, 2301,
		2302, 7, 32, 0, 0, 2302, 2303, 3, 2, 1, 0, 2303, 2305, 5, 99, 0, 0, 2304,
		2306, 7, 33, 0, 0, 2305, 2304, 1, 0, 0, 0, 2305, 2306, 1, 0, 0, 0, 2306,
		293, 1, 0, 0, 0, 2307, 2308, 5, 175, 0, 0, 2308, 2309, 3, 2, 1, 0, 2309,
		2310, 5, 99, 0, 0, 2310, 2311, 5, 175, 0, 0, 2311, 295, 1, 0, 0, 0, 2312,
		2313, 5, 116, 0, 0, 2313, 2314, 5, 373, 0, 0, 2314, 2316, 5, 138, 0, 0,
		2315, 2317, 5, 366, 0, 0, 2316, 2315, 1, 0, 0, 0, 2316, 2317, 1, 0, 0,
		0, 2317, 2318, 1, 0, 0, 0, 2318, 2320, 3, 304, 152, 0, 2319, 2321, 5, 369,
		0, 0, 2320, 2319, 1, 0, 0, 0, 2320, 2321, 1, 0, 0, 0, 2321, 2322, 1, 0,
		0, 0, 2322, 2323, 5, 175, 0, 0, 2323, 2324, 3, 2, 1, 0, 2324, 2325, 5,
		99, 0, 0, 2325, 2326, 5, 175, 0, 0, 2326, 297, 1, 0, 0, 0, 2327, 2328,
		5, 116, 0, 0, 2328, 2329, 5, 373, 0, 0, 2329, 2331, 5, 138, 0, 0, 2330,
		2332, 5, 240, 0, 0, 2331, 2330, 1, 0, 0, 0, 2331, 2332, 1, 0, 0, 0, 2332,
		2333, 1, 0, 0, 0, 2333, 2334, 3, 410, 205, 0, 2334, 2335, 5, 355, 0, 0,
		2335, 2338, 3, 410, 205, 0, 2336, 2337, 7, 34, 0, 0, 2337, 2339, 3, 410,
		205, 0, 2338, 2336, 1, 0, 0, 0, 2338, 2339, 1, 0, 0, 0, 2339, 2340, 1,
		0, 0, 0, 2340, 2341, 5, 175, 0, 0, 2341, 2342, 3, 2, 1, 0, 2342, 2343,
		5, 99, 0, 0, 2343, 2344, 5, 175, 0, 0, 2344, 299, 1, 0, 0, 0, 2345, 2352,
		5, 382, 0, 0, 2346, 2347, 5, 362, 0, 0, 2347, 2348, 5, 362, 0, 0, 2348,
		2349, 5, 373, 0, 0, 2349, 2350, 5, 360, 0, 0, 2350, 2352, 5, 360, 0, 0,
		2351, 2345, 1, 0, 0, 0, 2351, 2346, 1, 0, 0, 0, 2352, 301, 1, 0, 0, 0,
		2353, 2354, 5, 307, 0, 0, 2354, 2359, 3, 410, 205, 0, 2355, 2356, 5, 351,
		0, 0, 2356, 2358, 3, 410, 205, 0, 2357, 2355, 1, 0, 0, 0, 2358, 2361, 1,
		0, 0, 0, 2359, 2357, 1, 0, 0, 0, 2359, 2360, 1, 0, 0, 0, 2360, 303, 1,
		0, 0, 0, 2361, 2359, 1, 0, 0, 0, 2362, 2364, 3, 306, 153, 0, 2363, 2362,
		1, 0, 0, 0, 2363, 2364, 1, 0, 0, 0, 2364, 2365, 1, 0, 0, 0, 2365, 2366,
		3, 312, 156, 0, 2366, 305, 1, 0, 0, 0, 2367, 2368, 5, 318, 0, 0, 2368,
		2373, 3, 308, 154, 0, 2369, 2370, 5, 351, 0, 0, 2370, 2372, 3, 308, 154,
		0, 2371, 2369, 1, 0, 0, 0, 2372, 2375, 1, 0, 0, 0, 2373, 2371, 1, 0, 0,
		0, 2373, 2374, 1, 0, 0, 0, 2374, 307, 1, 0, 0, 0, 2375, 2373, 1, 0, 0,
		0, 2376, 2378, 3, 474, 237, 0, 2377, 2379, 3, 310, 155, 0, 2378, 2377,
		1, 0, 0, 0, 2378, 2379, 1, 0, 0, 0, 2379, 2380, 1, 0, 0, 0, 2380, 2381,
		5, 13, 0, 0, 2381, 2382, 5, 366, 0, 0, 2382, 2383, 3, 312, 156, 0, 2383,
		2384, 5, 369, 0, 0, 2384, 309, 1, 0, 0, 0, 2385, 2386, 5, 366, 0, 0, 2386,
		2391, 3, 474, 237, 0, 2387, 2388, 5, 351, 0, 0, 2388, 2390, 3, 474, 237,
		0, 2389, 2387, 1, 0, 0, 0, 2390, 2393, 1, 0, 0, 0, 2391, 2389, 1, 0, 0,
		0, 2391, 2392, 1, 0, 0, 0, 2392, 2394, 1, 0, 0, 0, 2393, 2391, 1, 0, 0,
		0, 2394, 2395, 5, 369, 0, 0, 2395, 311, 1, 0, 0, 0, 2396, 2402, 3, 314,
		157, 0, 2397, 2398, 3, 316, 158, 0, 2398, 2399, 3, 314, 157, 0, 2399, 2401,
		1, 0, 0, 0, 2400, 2397, 1, 0, 0, 0, 2401, 2404, 1, 0, 0, 0, 2402, 2400,
		1, 0, 0, 0, 2402, 2403, 1, 0, 0, 0, 2403, 313, 1, 0, 0, 0, 2404, 2402,
		1, 0, 0, 0, 2405, 2411, 3, 318, 159, 0, 2406, 2407, 5, 366, 0, 0, 2407,
		2408, 3, 312, 156, 0, 2408, 2409, 5, 369, 0, 0, 2409, 2411, 1, 0, 0, 0,
		2410, 2405, 1, 0, 0, 0, 2410, 2406, 1, 0, 0, 0, 2411, 315, 1, 0, 0, 0,
		2412, 2414, 5, 302, 0, 0, 2413, 2415, 5, 7, 0, 0, 2414, 2413, 1, 0, 0,
		0, 2414, 2415, 1, 0, 0, 0, 2415, 2425, 1, 0, 0, 0, 2416, 2418, 5, 102,
		0, 0, 2417, 2419, 5, 7, 0, 0, 2418, 2417, 1, 0, 0, 0, 2418, 2419, 1, 0,
		0, 0, 2419, 2425, 1, 0, 0, 0, 2420, 2422, 5, 150, 0, 0, 2421, 2423, 5,
		7, 0, 0, 2422, 2421, 1, 0, 0, 0, 2422, 2423, 1, 0, 0, 0, 2423, 2425, 1,
		0, 0, 0, 2424, 2412, 1, 0, 0, 0, 2424, 2416, 1, 0, 0, 0, 2424, 2420, 1,
		0, 0, 0, 2425, 317, 1, 0, 0, 0, 2426, 2427, 7, 35, 0, 0, 2427, 2429, 3,
		320, 160, 0, 2428, 2430, 3, 334, 167, 0, 2429, 2428, 1, 0, 0, 0, 2429,
		2430, 1, 0, 0, 0, 2430, 2432, 1, 0, 0, 0, 2431, 2433, 3, 338, 169, 0, 2432,
		2431, 1, 0, 0, 0, 2432, 2433, 1, 0, 0, 0, 2433, 2435, 1, 0, 0, 0, 2434,
		2436, 3, 358, 179, 0, 2435, 2434, 1, 0, 0, 0, 2435, 2436, 1, 0, 0, 0, 2436,
		2438, 1, 0, 0, 0, 2437, 2439, 3, 360, 180, 0, 2438, 2437, 1, 0, 0, 0, 2438,
		2439, 1, 0, 0, 0, 2439, 2442, 1, 0, 0, 0, 2440, 2443, 3, 362, 181, 0, 2441,
		2443, 3, 364, 182, 0, 2442, 2440, 1, 0, 0, 0, 2442, 2441, 1, 0, 0, 0, 2442,
		2443, 1, 0, 0, 0, 2443, 2445, 1, 0, 0, 0, 2444, 2446, 3, 366, 183, 0, 2445,
		2444, 1, 0, 0, 0, 2445, 2446, 1, 0, 0, 0, 2446, 2448, 1, 0, 0, 0, 2447,
		2449, 3, 368, 184, 0, 2448, 2447, 1, 0, 0, 0, 2448, 2449, 1, 0, 0, 0, 2449,
		319, 1, 0, 0, 0, 2450, 2452, 3, 322, 161, 0, 2451, 2450, 1, 0, 0, 0, 2451,
		2452, 1, 0, 0, 0, 2452, 2454, 1, 0, 0, 0, 2453, 2455, 3, 324, 162, 0, 2454,
		2453, 1, 0, 0, 0, 2454, 2455, 1, 0, 0, 0, 2455, 2456, 1, 0, 0, 0, 2456,
		2461, 3, 326, 163, 0, 2457, 2458, 5, 351, 0, 0, 2458, 2460, 3, 326, 163,
		0, 2459, 2457, 1, 0, 0, 0, 2460, 2463, 1, 0, 0, 0, 2461, 2459, 1, 0, 0,
		0, 2461, 2462, 1, 0, 0, 0, 2462, 321, 1, 0, 0, 0, 2463, 2461, 1, 0, 0,
		0, 2464, 2465, 7, 36, 0, 0, 2465, 323, 1, 0, 0, 0, 2466, 2467, 5, 298,
		0, 0, 2467, 2468, 3, 410, 205, 0, 2468, 325, 1, 0, 0, 0, 2469, 2470, 3,
		474, 237, 0, 2470, 2471, 5, 356, 0, 0, 2471, 2473, 1, 0, 0, 0, 2472, 2469,
		1, 0, 0, 0, 2472, 2473, 1, 0, 0, 0, 2473, 2474, 1, 0, 0, 0, 2474, 2476,
		3, 410, 205, 0, 2475, 2477, 3, 328, 164, 0, 2476, 2475, 1, 0, 0, 0, 2476,
		2477, 1, 0, 0, 0, 2477, 2480, 1, 0, 0, 0, 2478, 2480, 3, 330, 165, 0, 2479,
		2472, 1, 0, 0, 0, 2479, 2478, 1, 0, 0, 0, 2480, 327, 1, 0, 0, 0, 2481,
		2483, 4, 164, 3, 0, 2482, 2484, 5, 13, 0, 0, 2483, 2482, 1, 0, 0, 0, 2483,
		2484, 1, 0, 0, 0, 2484, 2485, 1, 0, 0, 0, 2485, 2491, 3, 474, 237, 0, 2486,
		2487, 5, 366, 0, 0, 2487, 2488, 5, 296, 0, 0, 2488, 2489, 5, 374, 0, 0,
		2489, 2491, 5, 369, 0, 0, 2490, 2481, 1, 0, 0, 0, 2490, 2486, 1, 0, 0,
		0, 2491, 329, 1, 0, 0, 0, 2492, 2493, 5, 373, 0, 0, 2493, 2495, 5, 354,
		0, 0, 2494, 2492, 1, 0, 0, 0, 2494, 2495, 1, 0, 0, 0, 2495, 2496, 1, 0,
		0, 0, 2496, 2497, 5, 364, 0, 0, 2497, 331, 1, 0, 0, 0, 2498, 2499, 3, 472,
		236, 0, 2499, 2500, 5, 366, 0, 0, 2500, 2501, 5, 376, 0, 0, 2501, 2502,
		5, 369, 0, 0, 2502, 333, 1, 0, 0, 0, 2503, 2505, 3, 336, 168, 0, 2504,
		2503, 1, 0, 0, 0, 2504, 2505, 1, 0, 0, 0, 2505, 2506, 1, 0, 0, 0, 2506,
		2509, 5, 152, 0, 0, 2507, 2510, 3, 332, 166, 0, 2508, 2510, 3, 472, 236,
		0, 2509, 2507, 1, 0, 0, 0, 2509, 2508, 1, 0, 0, 0, 2510, 2518, 1, 0, 0,
		0, 2511, 2514, 5, 351, 0, 0, 2512, 2515, 3, 332, 166, 0, 2513, 2515, 3,
		472, 236, 0, 2514, 2512, 1, 0, 0, 0, 2514, 2513, 1, 0, 0, 0, 2515, 2517,
		1, 0, 0, 0, 2516, 2511, 1, 0, 0, 0, 2517, 2520, 1, 0, 0, 0, 2518, 2516,
		1, 0, 0, 0, 2518, 2519, 1, 0, 0, 0, 2519, 335, 1, 0, 0, 0, 2520, 2518,
		1, 0, 0, 0, 2521, 2522, 5, 29, 0, 0, 2522, 2523, 5, 46, 0, 0, 2523, 337,
		1, 0, 0, 0, 2524, 2525, 5, 120, 0, 0, 2525, 2529, 3, 340, 170, 0, 2526,
		2528, 3, 346, 173, 0, 2527, 2526, 1, 0, 0, 0, 2528, 2531, 1, 0, 0, 0, 2529,
		2527, 1, 0, 0, 0, 2529, 2530, 1, 0, 0, 0, 2530, 339, 1, 0, 0, 0, 2531,
		2529, 1, 0, 0, 0, 2532, 2536, 3, 342, 171, 0, 2533, 2536, 3, 344, 172,
		0, 2534, 2536, 3, 350, 175, 0, 2535, 2532, 1, 0, 0, 0, 2535, 2533, 1, 0,
		0, 0, 2535, 2534, 1, 0, 0, 0, 2536, 341, 1, 0, 0, 0, 2537, 2539, 3, 356,
		178, 0, 2538, 2540, 3, 354, 177, 0, 2539, 2538, 1, 0, 0, 0, 2539, 2540,
		1, 0, 0, 0, 2540, 343, 1, 0, 0, 0, 2541, 2542, 5, 366, 0, 0, 2542, 2543,
		3, 304, 152, 0, 2543, 2545, 5, 369, 0, 0, 2544, 2546, 3, 354, 177, 0, 2545,
		2544, 1, 0, 0, 0, 2545, 2546, 1, 0, 0, 0, 2546, 345, 1, 0, 0, 0, 2547,
		2548, 5, 351, 0, 0, 2548, 2555, 3, 340, 170, 0, 2549, 2550, 3, 348, 174,
		0, 2550, 2551, 3, 340, 170, 0, 2551, 2552, 5, 203, 0, 0, 2552, 2553, 3,
		394, 197, 0, 2553, 2555, 1, 0, 0, 0, 2554, 2547, 1, 0, 0, 0, 2554, 2549,
		1, 0, 0, 0, 2555, 347, 1, 0, 0, 0, 2556, 2558, 5, 142, 0, 0, 2557, 2556,
		1, 0, 0, 0, 2557, 2558, 1, 0, 0, 0, 2558, 2559, 1, 0, 0, 0, 2559, 2566,
		5, 157, 0, 0, 2560, 2562, 7, 37, 0, 0, 2561, 2563, 5, 209, 0, 0, 2562,
		2561, 1, 0, 0, 0, 2562, 2563, 1, 0, 0, 0, 2563, 2564, 1, 0, 0, 0, 2564,
		2566, 5, 157, 0, 0, 2565, 2557, 1, 0, 0, 0, 2565, 2560, 1, 0, 0, 0, 2566,
		349, 1, 0, 0, 0, 2567, 2568, 5, 287, 0, 0, 2568, 2569, 5, 366, 0, 0, 2569,
		2570, 5, 309, 0, 0, 2570, 2575, 3, 352, 176, 0, 2571, 2572, 5, 351, 0,
		0, 2572, 2574, 3, 352, 176, 0, 2573, 2571, 1, 0, 0, 0, 2574, 2577, 1, 0,
		0, 0, 2575, 2573, 1, 0, 0, 0, 2575, 2576, 1, 0, 0, 0, 2576, 2578, 1, 0,
		0, 0, 2577, 2575, 1, 0, 0, 0, 2578, 2580, 5, 369, 0, 0, 2579, 2581, 3,
		354, 177, 0, 2580, 2579, 1, 0, 0, 0, 2580, 2581, 1, 0, 0, 0, 2581, 351,
		1, 0, 0, 0, 2582, 2595, 3, 410, 205, 0, 2583, 2584, 5, 366, 0, 0, 2584,
		2589, 3, 410, 205, 0, 2585, 2586, 5, 351, 0, 0, 2586, 2588, 3, 410, 205,
		0, 2587, 2585, 1, 0, 0, 0, 2588, 2591, 1, 0, 0, 0, 2589, 2587, 1, 0, 0,
		0, 2589, 2590, 1, 0, 0, 0, 2590, 2592, 1, 0, 0, 0, 2591, 2589, 1, 0, 0,
		0, 2592, 2593, 5, 369, 0, 0, 2593, 2595, 1, 0, 0, 0, 2594, 2582, 1, 0,
		0, 0, 2594, 2583, 1, 0, 0, 0, 2595, 353, 1, 0, 0, 0, 2596, 2598, 4, 177,
		4, 0, 2597, 2599, 5, 13, 0, 0, 2598, 2597, 1, 0, 0, 0, 2598, 2599, 1, 0,
		0, 0, 2599, 2600, 1, 0, 0, 0, 2600, 2611, 3, 474, 237, 0, 2601, 2602, 5,
		366, 0, 0, 2602, 2607, 5, 373, 0, 0, 2603, 2604, 5, 351, 0, 0, 2604, 2606,
		5, 373, 0, 0, 2605, 2603, 1, 0, 0, 0, 2606, 2609, 1, 0, 0, 0, 2607, 2605,
		1, 0, 0, 0, 2607, 2608, 1, 0, 0, 0, 2608, 2610, 1, 0, 0, 0, 2609, 2607,
		1, 0, 0, 0, 2610, 2612, 5, 369, 0, 0, 2611, 2601, 1, 0, 0, 0, 2611, 2612,
		1, 0, 0, 0, 2612, 355, 1, 0, 0, 0, 2613, 2614, 3, 474, 237, 0, 2614, 357,
		1, 0, 0, 0, 2615, 2616, 5, 316, 0, 0, 2616, 2617, 3, 394, 197, 0, 2617,
		359, 1, 0, 0, 0, 2618, 2619, 5, 127, 0, 0, 2619, 2620, 5, 30, 0, 0, 2620,
		2625, 3, 410, 205, 0, 2621, 2622, 5, 351, 0, 0, 2622, 2624, 3, 410, 205,
		0, 2623, 2621, 1, 0, 0, 0, 2624, 2627, 1, 0, 0, 0, 2625, 2623, 1, 0, 0,
		0, 2625, 2626, 1, 0, 0, 0, 2626, 361, 1, 0, 0, 0, 2627, 2625, 1, 0, 0,
		0, 2628, 2629, 5, 130, 0, 0, 2629, 2630, 3, 394, 197, 0, 2630, 363, 1,
		0, 0, 0, 2631, 2632, 5, 225, 0, 0, 2632, 2633, 3, 394, 197, 0, 2633, 365,
		1, 0, 0, 0, 2634, 2635, 5, 207, 0, 0, 2635, 2636, 5, 30, 0, 0, 2636, 2638,
		3, 410, 205, 0, 2637, 2639, 7, 7, 0, 0, 2638, 2637, 1, 0, 0, 0, 2638, 2639,
		1, 0, 0, 0, 2639, 2647, 1, 0, 0, 0, 2640, 2641, 5, 351, 0, 0, 2641, 2643,
		3, 410, 205, 0, 2642, 2644, 7, 7, 0, 0, 2643, 2642, 1, 0, 0, 0, 2643, 2644,
		1, 0, 0, 0, 2644, 2646, 1, 0, 0, 0, 2645, 2640, 1, 0, 0, 0, 2646, 2649,
		1, 0, 0, 0, 2647, 2645, 1, 0, 0, 0, 2647, 2648, 1, 0, 0, 0, 2648, 367,
		1, 0, 0, 0, 2649, 2647, 1, 0, 0, 0, 2650, 2652, 3, 370, 185, 0, 2651, 2650,
		1, 0, 0, 0, 2652, 2653, 1, 0, 0, 0, 2653, 2651, 1, 0, 0, 0, 2653, 2654,
		1, 0, 0, 0, 2654, 369, 1, 0, 0, 0, 2655, 2656, 5, 165, 0, 0, 2656, 2667,
		3, 410, 205, 0, 2657, 2658, 5, 318, 0, 0, 2658, 2664, 7, 38, 0, 0, 2659,
		2660, 5, 306, 0, 0, 2660, 2661, 5, 10, 0, 0, 2661, 2662, 5, 158, 0, 0,
		2662, 2663, 7, 39, 0, 0, 2663, 2665, 5, 171, 0, 0, 2664, 2659, 1, 0, 0,
		0, 2664, 2665, 1, 0, 0, 0, 2665, 2667, 1, 0, 0, 0, 2666, 2655, 1, 0, 0,
		0, 2666, 2657, 1, 0, 0, 0, 2667, 371, 1, 0, 0, 0, 2668, 2669, 5, 304, 0,
		0, 2669, 2670, 3, 376, 188, 0, 2670, 2671, 5, 260, 0, 0, 2671, 2673, 3,
		374, 187, 0, 2672, 2674, 3, 358, 179, 0, 2673, 2672, 1, 0, 0, 0, 2673,
		2674, 1, 0, 0, 0, 2674, 2676, 1, 0, 0, 0, 2675, 2677, 3, 378, 189, 0, 2676,
		2675, 1, 0, 0, 0, 2676, 2677, 1, 0, 0, 0, 2677, 373, 1, 0, 0, 0, 2678,
		2683, 3, 26, 13, 0, 2679, 2680, 5, 351, 0, 0, 2680, 2682, 3, 26, 13, 0,
		2681, 2679, 1, 0, 0, 0, 2682, 2685, 1, 0, 0, 0, 2683, 2681, 1, 0, 0, 0,
		2683, 2684, 1, 0, 0, 0, 2684, 375, 1, 0, 0, 0, 2685, 2683, 1, 0, 0, 0,
		2686, 2688, 3, 356, 178, 0, 2687, 2689, 3, 338, 169, 0, 2688, 2687, 1,
		0, 0, 0, 2688, 2689, 1, 0, 0, 0, 2689, 2695, 1, 0, 0, 0, 2690, 2691, 5,
		366, 0, 0, 2691, 2692, 3, 304, 152, 0, 2692, 2693, 5, 369, 0, 0, 2693,
		2695, 1, 0, 0, 0, 2694, 2686, 1, 0, 0, 0, 2694, 2690, 1, 0, 0, 0, 2695,
		2700, 1, 0, 0, 0, 2696, 2698, 5, 13, 0, 0, 2697, 2696, 1, 0, 0, 0, 2697,
		2698, 1, 0, 0, 0, 2698, 2699, 1, 0, 0, 0, 2699, 2701, 3, 474, 237, 0, 2700,
		2697, 1, 0, 0, 0, 2700, 2701, 1, 0, 0, 0, 2701, 377, 1, 0, 0, 0, 2702,
		2703, 5, 95, 0, 0, 2703, 2704, 3, 196, 98, 0, 2704, 379, 1, 0, 0, 0, 2705,
		2706, 5, 180, 0, 0, 2706, 2707, 5, 152, 0, 0, 2707, 2708, 3, 382, 191,
		0, 2708, 2709, 5, 307, 0, 0, 2709, 2710, 3, 382, 191, 0, 2710, 2711, 5,
		203, 0, 0, 2711, 2713, 3, 394, 197, 0, 2712, 2714, 3, 384, 192, 0, 2713,
		2712, 1, 0, 0, 0, 2714, 2715, 1, 0, 0, 0, 2715, 2713, 1, 0, 0, 0, 2715,
		2716, 1, 0, 0, 0, 2716, 381, 1, 0, 0, 0, 2717, 2723, 3, 356, 178, 0, 2718,
		2719, 5, 366, 0, 0, 2719, 2720, 3, 304, 152, 0, 2720, 2721, 5, 369, 0,
		0, 2721, 2723, 1, 0, 0, 0, 2722, 2717, 1, 0, 0, 0, 2722, 2718, 1, 0, 0,
		0, 2723, 2728, 1, 0, 0, 0, 2724, 2726, 5, 13, 0, 0, 2725, 2724, 1, 0, 0,
		0, 2725, 2726, 1, 0, 0, 0, 2726, 2727, 1, 0, 0, 0, 2727, 2729, 3, 474,
		237, 0, 2728, 2725, 1, 0, 0, 0, 2728, 2729, 1, 0, 0, 0, 2729, 383, 1, 0,
		0, 0, 2730, 2732, 5, 315, 0, 0, 2731, 2733, 5, 195, 0, 0, 2732, 2731, 1,
		0, 0, 0, 2732, 2733, 1, 0, 0, 0, 2733, 2734, 1, 0, 0, 0, 2734, 2737, 5,
		177, 0, 0, 2735, 2736, 5, 10, 0, 0, 2736, 2738, 3, 394, 197, 0, 2737, 2735,
		1, 0, 0, 0, 2737, 2738, 1, 0, 0, 0, 2738, 2739, 1, 0, 0, 0, 2739, 2740,
		5, 292, 0, 0, 2740, 2744, 3, 386, 193, 0, 2741, 2742, 5, 95, 0, 0, 2742,
		2744, 5, 136, 0, 0, 2743, 2730, 1, 0, 0, 0, 2743, 2741, 1, 0, 0, 0, 2744,
		385, 1, 0, 0, 0, 2745, 2747, 5, 144, 0, 0, 2746, 2748, 3, 198, 99, 0, 2747,
		2746, 1, 0, 0, 0, 2747, 2748, 1, 0, 0, 0, 2748, 2749, 1, 0, 0, 0, 2749,
		2750, 5, 309, 0, 0, 2750, 2766, 3, 202, 101, 0, 2751, 2752, 5, 304, 0,
		0, 2752, 2753, 5, 260, 0, 0, 2753, 2758, 3, 26, 13, 0, 2754, 2755, 5, 351,
		0, 0, 2755, 2757, 3, 26, 13, 0, 2756, 2754, 1, 0, 0, 0, 2757, 2760, 1,
		0, 0, 0, 2758, 2756, 1, 0, 0, 0, 2758, 2759, 1, 0, 0, 0, 2759, 2762, 1,
		0, 0, 0, 2760, 2758, 1, 0, 0, 0, 2761, 2763, 3, 358, 179, 0, 2762, 2761,
		1, 0, 0, 0, 2762, 2763, 1, 0, 0, 0, 2763, 2766, 1, 0, 0, 0, 2764, 2766,
		5, 81, 0, 0, 2765, 2745, 1, 0, 0, 0, 2765, 2751, 1, 0, 0, 0, 2765, 2764,
		1, 0, 0, 0, 2766, 387, 1, 0, 0, 0, 2767, 2769, 5, 81, 0, 0, 2768, 2770,
		5, 120, 0, 0, 2769, 2768, 1, 0, 0, 0, 2769, 2770, 1, 0, 0, 0, 2770, 2771,
		1, 0, 0, 0, 2771, 2773, 3, 356, 178, 0, 2772, 2774, 3, 390, 195, 0, 2773,
		2772, 1, 0, 0, 0, 2773, 2774, 1, 0, 0, 0, 2774, 2777, 1, 0, 0, 0, 2775,
		2778, 3, 358, 179, 0, 2776, 2778, 5, 7, 0, 0, 2777, 2775, 1, 0, 0, 0, 2777,
		2776, 1, 0, 0, 0, 2777, 2778, 1, 0, 0, 0, 2778, 389, 1, 0, 0, 0, 2779,
		2781, 4, 195, 5, 0, 2780, 2782, 5, 13, 0, 0, 2781, 2780, 1, 0, 0, 0, 2781,
		2782, 1, 0, 0, 0, 2782, 2783, 1, 0, 0, 0, 2783, 2784, 3, 474, 237, 0, 2784,
		391, 1, 0, 0, 0, 2785, 2787, 7, 40, 0, 0, 2786, 2788, 5, 287, 0, 0, 2787,
		2786, 1, 0, 0, 0, 2787, 2788, 1, 0, 0, 0, 2788, 2789, 1, 0, 0, 0, 2789,
		2790, 3, 356, 178, 0, 2790, 393, 1, 0, 0, 0, 2791, 2793, 6, 197, -1, 0,
		2792, 2794, 5, 195, 0, 0, 2793, 2792, 1, 0, 0, 0, 2793, 2794, 1, 0, 0,
		0, 2794, 2795, 1, 0, 0, 0, 2795, 2796, 5, 366, 0, 0, 2796, 2797, 3, 394,
		197, 0, 2797, 2798, 5, 369, 0, 0, 2798, 2801, 1, 0, 0, 0, 2799, 2801, 3,
		396, 198, 0, 2800, 2791, 1, 0, 0, 0, 2800, 2799, 1, 0, 0, 0, 2801, 2808,
		1, 0, 0, 0, 2802, 2803, 10, 2, 0, 0, 2803, 2804, 3, 406, 203, 0, 2804,
		2805, 3, 394, 197, 3, 2805, 2807, 1, 0, 0, 0, 2806, 2802, 1, 0, 0, 0, 2807,
		2810, 1, 0, 0, 0, 2808, 2806, 1, 0, 0, 0, 2808, 2809, 1, 0, 0, 0, 2809,
		395, 1, 0, 0, 0, 2810, 2808, 1, 0, 0, 0, 2811, 2815, 3, 398, 199, 0, 2812,
		2815, 3, 404, 202, 0, 2813, 2815, 3, 410, 205, 0, 2814, 2811, 1, 0, 0,
		0, 2814, 2812, 1, 0, 0, 0, 2814, 2813, 1, 0, 0, 0, 2815, 397, 1, 0, 0,
		0, 2816, 2817, 3, 410, 205, 0, 2817, 2819, 5, 154, 0, 0, 2818, 2820, 5,
		195, 0, 0, 2819, 2818, 1, 0, 0, 0, 2819, 2820, 1, 0, 0, 0, 2820, 2821,
		1, 0, 0, 0, 2821, 2822, 5, 197, 0, 0, 2822, 2840, 1, 0, 0, 0, 2823, 2824,
		3, 410, 205, 0, 2824, 2825, 5, 21, 0, 0, 2825, 2826, 3, 410, 205, 0, 2826,
		2827, 5, 10, 0, 0, 2827, 2828, 3, 410, 205, 0, 2828, 2840, 1, 0, 0, 0,
		2829, 2831, 5, 195, 0, 0, 2830, 2829, 1, 0, 0, 0, 2830, 2831, 1, 0, 0,
		0, 2831, 2832, 1, 0, 0, 0, 2832, 2833, 5, 107, 0, 0, 2833, 2834, 5, 366,
		0, 0, 2834, 2835, 3, 304, 152, 0, 2835, 2836, 5, 369, 0, 0, 2836, 2840,
		1, 0, 0, 0, 2837, 2840, 3, 400, 200, 0, 2838, 2840, 3, 402, 201, 0, 2839,
		2816, 1, 0, 0, 0, 2839, 2823, 1, 0, 0, 0, 2839, 2830, 1, 0, 0, 0, 2839,
		2837, 1, 0, 0, 0, 2839, 2838, 1, 0, 0, 0, 2840, 399, 1, 0, 0, 0, 2841,
		2843, 3, 410, 205, 0, 2842, 2844, 5, 195, 0, 0, 2843, 2842, 1, 0, 0, 0,
		2843, 2844, 1, 0, 0, 0, 2844, 2845, 1, 0, 0, 0, 2845, 2846, 5, 138, 0,
		0, 2846, 2856, 5, 366, 0, 0, 2847, 2852, 3, 410, 205, 0, 2848, 2849, 5,
		351, 0, 0, 2849, 2851, 3, 410, 205, 0, 2850, 2848, 1, 0, 0, 0, 2851, 2854,
		1, 0, 0, 0, 2852, 2850, 1, 0, 0, 0, 2852, 2853, 1, 0, 0, 0, 2853, 2857,
		1, 0, 0, 0, 2854, 2852, 1, 0, 0, 0, 2855, 2857, 3, 304, 152, 0, 2856, 2847,
		1, 0, 0, 0, 2856, 2855, 1, 0, 0, 0, 2857, 2858, 1, 0, 0, 0, 2858, 2859,
		5, 369, 0, 0, 2859, 401, 1, 0, 0, 0, 2860, 2861, 5, 366, 0, 0, 2861, 2866,
		3, 410, 205, 0, 2862, 2863, 5, 351, 0, 0, 2863, 2865, 3, 410, 205, 0, 2864,
		2862, 1, 0, 0, 0, 2865, 2868, 1, 0, 0, 0, 2866, 2864, 1, 0, 0, 0, 2866,
		2867, 1, 0, 0, 0, 2867, 2869, 1, 0, 0, 0, 2868, 2866, 1, 0, 0, 0, 2869,
		2871, 5, 369, 0, 0, 2870, 2872, 5, 195, 0, 0, 2871, 2870, 1, 0, 0, 0, 2871,
		2872, 1, 0, 0, 0, 2872, 2873, 1, 0, 0, 0, 2873, 2874, 5, 138, 0, 0, 2874,
		2875, 5, 366, 0, 0, 2875, 2876, 3, 304, 152, 0, 2876, 2877, 5, 369, 0,
		0, 2877, 403, 1, 0, 0, 0, 2878, 2879, 3, 410, 205, 0, 2879, 2880, 3, 408,
		204, 0, 2880, 2881, 3, 410, 205, 0, 2881, 405, 1, 0, 0, 0, 2882, 2883,
		7, 41, 0, 0, 2883, 407, 1, 0, 0, 0, 2884, 2897, 5, 356, 0, 0, 2885, 2897,
		5, 357, 0, 0, 2886, 2897, 5, 358, 0, 0, 2887, 2897, 5, 359, 0, 0, 2888,
		2897, 5, 362, 0, 0, 2889, 2897, 5, 363, 0, 0, 2890, 2897, 5, 360, 0, 0,
		2891, 2897, 5, 361, 0, 0, 2892, 2894, 5, 195, 0, 0, 2893, 2892, 1, 0, 0,
		0, 2893, 2894, 1, 0, 0, 0, 2894, 2895, 1, 0, 0, 0, 2895, 2897, 7, 42, 0,
		0, 2896, 2884, 1, 0, 0, 0, 2896, 2885, 1, 0, 0, 0, 2896, 2886, 1, 0, 0,
		0, 2896, 2887, 1, 0, 0, 0, 2896, 2888, 1, 0, 0, 0, 2896, 2889, 1, 0, 0,
		0, 2896, 2890, 1, 0, 0, 0, 2896, 2891, 1, 0, 0, 0, 2896, 2893, 1, 0, 0,
		0, 2897, 409, 1, 0, 0, 0, 2898, 2899, 6, 205, -1, 0, 2899, 2900, 5, 366,
		0, 0, 2900, 2901, 3, 304, 152, 0, 2901, 2902, 5, 369, 0, 0, 2902, 2917,
		1, 0, 0, 0, 2903, 2904, 5, 366, 0, 0, 2904, 2905, 3, 410, 205, 0, 2905,
		2906, 5, 369, 0, 0, 2906, 2917, 1, 0, 0, 0, 2907, 2917, 3, 414, 207, 0,
		2908, 2917, 3, 418, 209, 0, 2909, 2917, 3, 442, 221, 0, 2910, 2917, 3,
		422, 211, 0, 2911, 2917, 3, 428, 214, 0, 2912, 2917, 3, 430, 215, 0, 2913,
		2917, 3, 438, 219, 0, 2914, 2917, 3, 440, 220, 0, 2915, 2917, 3, 412, 206,
		0, 2916, 2898, 1, 0, 0, 0, 2916, 2903, 1, 0, 0, 0, 2916, 2907, 1, 0, 0,
		0, 2916, 2908, 1, 0, 0, 0, 2916, 2909, 1, 0, 0, 0, 2916, 2910, 1, 0, 0,
		0, 2916, 2911, 1, 0, 0, 0, 2916, 2912, 1, 0, 0, 0, 2916, 2913, 1, 0, 0,
		0, 2916, 2914, 1, 0, 0, 0, 2916, 2915, 1, 0, 0, 0, 2917, 2928, 1, 0, 0,
		0, 2918, 2919, 10, 13, 0, 0, 2919, 2920, 7, 43, 0, 0, 2920, 2927, 3, 410,
		205, 14, 2921, 2922, 10, 12, 0, 0, 2922, 2923, 7, 44, 0, 0, 2923, 2927,
		3, 410, 205, 13, 2924, 2925, 10, 14, 0, 0, 2925, 2927, 3, 416, 208, 0,
		2926, 2918, 1, 0, 0, 0, 2926, 2921, 1, 0, 0, 0, 2926, 2924, 1, 0, 0, 0,
		2927, 2930, 1, 0, 0, 0, 2928, 2926, 1, 0, 0, 0, 2928, 2929, 1, 0, 0, 0,
		2929, 411, 1, 0, 0, 0, 2930, 2928, 1, 0, 0, 0, 2931, 2940, 3, 468, 234,
		0, 2932, 2940, 3, 470, 235, 0, 2933, 2940, 3, 482, 241, 0, 2934, 2940,
		3, 474, 237, 0, 2935, 2940, 3, 476, 238, 0, 2936, 2940, 3, 480, 240, 0,
		2937, 2940, 3, 478, 239, 0, 2938, 2940, 3, 484, 242, 0, 2939, 2931, 1,
		0, 0, 0, 2939, 2932, 1, 0, 0, 0, 2939, 2933, 1, 0, 0, 0, 2939, 2934, 1,
		0, 0, 0, 2939, 2935, 1, 0, 0, 0, 2939, 2936, 1, 0, 0, 0, 2939, 2937, 1,
		0, 0, 0, 2939, 2938, 1, 0, 0, 0, 2940, 413, 1, 0, 0, 0, 2941, 2942, 5,
		151, 0, 0, 2942, 2943, 3, 410, 205, 0, 2943, 2944, 3, 416, 208, 0, 2944,
		415, 1, 0, 0, 0, 2945, 2946, 7, 45, 0, 0, 2946, 417, 1, 0, 0, 0, 2947,
		2948, 3, 420, 210, 0, 2948, 2949, 7, 46, 0, 0, 2949, 2954, 3, 420, 210,
		0, 2950, 2951, 7, 46, 0, 0, 2951, 2953, 3, 420, 210, 0, 2952, 2950, 1,
		0, 0, 0, 2953, 2956, 1, 0, 0, 0, 2954, 2952, 1, 0, 0, 0, 2954, 2955, 1,
		0, 0, 0, 2955, 419, 1, 0, 0, 0, 2956, 2954, 1, 0, 0, 0, 2957, 2958, 5,
		366, 0, 0, 2958, 2959, 3, 410, 205, 0, 2959, 2960, 5, 369, 0, 0, 2960,
		2968, 1, 0, 0, 0, 2961, 2968, 3, 422, 211, 0, 2962, 2968, 3, 430, 215,
		0, 2963, 2968, 3, 438, 219, 0, 2964, 2968, 3, 442, 221, 0, 2965, 2968,
		3, 440, 220, 0, 2966, 2968, 3, 412, 206, 0, 2967, 2957, 1, 0, 0, 0, 2967,
		2961, 1, 0, 0, 0, 2967, 2962, 1, 0, 0, 0, 2967, 2963, 1, 0, 0, 0, 2967,
		2964, 1, 0, 0, 0, 2967, 2965, 1, 0, 0, 0, 2967, 2966, 1, 0, 0, 0, 2968,
		421, 1, 0, 0, 0, 2969, 2972, 3, 424, 212, 0, 2970, 2972, 3, 426, 213, 0,
		2971, 2969, 1, 0, 0, 0, 2971, 2970, 1, 0, 0, 0, 2972, 423, 1, 0, 0, 0,
		2973, 2974, 5, 36, 0, 0, 2974, 2980, 3, 410, 205, 0, 2975, 2976, 5, 315,
		0, 0, 2976, 2977, 3, 410, 205, 0, 2977, 2978, 5, 292, 0, 0, 2978, 2979,
		3, 410, 205, 0, 2979, 2981, 1, 0, 0, 0, 2980, 2975, 1, 0, 0, 0, 2981, 2982,
		1, 0, 0, 0, 2982, 2980, 1, 0, 0, 0, 2982, 2983, 1, 0, 0, 0, 2983, 2986,
		1, 0, 0, 0, 2984, 2985, 5, 95, 0, 0, 2985, 2987, 3, 410, 205, 0, 2986,
		2984, 1, 0, 0, 0, 2986, 2987, 1, 0, 0, 0, 2987, 2988, 1, 0, 0, 0, 2988,
		2989, 5, 99, 0, 0, 2989, 425, 1, 0, 0, 0, 2990, 2996, 5, 36, 0, 0, 2991,
		2992, 5, 315, 0, 0, 2992, 2993, 3, 394, 197, 0, 2993, 2994, 5, 292, 0,
		0, 2994, 2995, 3, 410, 205, 0, 2995, 2997, 1, 0, 0, 0, 2996, 2991, 1, 0,
		0, 0, 2997, 2998, 1, 0, 0, 0, 2998, 2996, 1, 0, 0, 0, 2998, 2999, 1, 0,
		0, 0, 2999, 3002, 1, 0, 0, 0, 3000, 3001, 5, 95, 0, 0, 3001, 3003, 3, 410,
		205, 0, 3002, 3000, 1, 0, 0, 0, 3002, 3003, 1, 0, 0, 0, 3003, 3004, 1,
		0, 0, 0, 3004, 3005, 5, 99, 0, 0, 3005, 427, 1, 0, 0, 0, 3006, 3007, 3,
		472, 236, 0, 3007, 3008, 5, 3, 0, 0, 3008, 3009, 7, 47, 0, 0, 3009, 429,
		1, 0, 0, 0, 3010, 3011, 5, 18, 0, 0, 3011, 3013, 5, 366, 0, 0, 3012, 3014,
		3, 432, 216, 0, 3013, 3012, 1, 0, 0, 0, 3013, 3014, 1, 0, 0, 0, 3014, 3015,
		1, 0, 0, 0, 3015, 3016, 3, 410, 205, 0, 3016, 3018, 5, 369, 0, 0, 3017,
		3019, 3, 434, 217, 0, 3018, 3017, 1, 0, 0, 0, 3018, 3019, 1, 0, 0, 0, 3019,
		3163, 1, 0, 0, 0, 3020, 3021, 5, 58, 0, 0, 3021, 3027, 5, 366, 0, 0, 3022,
		3024, 3, 432, 216, 0, 3023, 3022, 1, 0, 0, 0, 3023, 3024, 1, 0, 0, 0, 3024,
		3025, 1, 0, 0, 0, 3025, 3028, 3, 410, 205, 0, 3026, 3028, 5, 364, 0, 0,
		3027, 3023, 1, 0, 0, 0, 3027, 3026, 1, 0, 0, 0, 3028, 3029, 1, 0, 0, 0,
		3029, 3031, 5, 369, 0, 0, 3030, 3032, 3, 434, 217, 0, 3031, 3030, 1, 0,
		0, 0, 3031, 3032, 1, 0, 0, 0, 3032, 3163, 1, 0, 0, 0, 3033, 3034, 5, 59,
		0, 0, 3034, 3040, 5, 366, 0, 0, 3035, 3037, 3, 432, 216, 0, 3036, 3035,
		1, 0, 0, 0, 3036, 3037, 1, 0, 0, 0, 3037, 3038, 1, 0, 0, 0, 3038, 3041,
		3, 410, 205, 0, 3039, 3041, 5, 364, 0, 0, 3040, 3036, 1, 0, 0, 0, 3040,
		3039, 1, 0, 0, 0, 3041, 3042, 1, 0, 0, 0, 3042, 3044, 5, 369, 0, 0, 3043,
		3045, 3, 434, 217, 0, 3044, 3043, 1, 0, 0, 0, 3044, 3045, 1, 0, 0, 0, 3045,
		3163, 1, 0, 0, 0, 3046, 3047, 5, 325, 0, 0, 3047, 3048, 5, 366, 0, 0, 3048,
		3049, 5, 369, 0, 0, 3049, 3163, 3, 434, 217, 0, 3050, 3051, 5, 330, 0,
		0, 3051, 3052, 5, 366, 0, 0, 3052, 3053, 5, 369, 0, 0, 3053, 3163, 3, 434,
		217, 0, 3054, 3055, 5, 331, 0, 0, 3055, 3056, 5, 366, 0, 0, 3056, 3057,
		3, 410, 205, 0, 3057, 3058, 5, 369, 0, 0, 3058, 3059, 3, 434, 217, 0, 3059,
		3163, 1, 0, 0, 0, 3060, 3061, 5, 332, 0, 0, 3061, 3062, 5, 366, 0, 0, 3062,
		3069, 3, 410, 205, 0, 3063, 3064, 5, 351, 0, 0, 3064, 3067, 3, 410, 205,
		0, 3065, 3066, 5, 351, 0, 0, 3066, 3068, 3, 410, 205, 0, 3067, 3065, 1,
		0, 0, 0, 3067, 3068, 1, 0, 0, 0, 3068, 3070, 1, 0, 0, 0, 3069, 3063, 1,
		0, 0, 0, 3069, 3070, 1, 0, 0, 0, 3070, 3071, 1, 0, 0, 0, 3071, 3072, 5,
		369, 0, 0, 3072, 3073, 3, 434, 217, 0, 3073, 3163, 1, 0, 0, 0, 3074, 3075,
		5, 333, 0, 0, 3075, 3076, 5, 366, 0, 0, 3076, 3077, 3, 410, 205, 0, 3077,
		3078, 5, 369, 0, 0, 3078, 3079, 3, 434, 217, 0, 3079, 3163, 1, 0, 0, 0,
		3080, 3081, 5, 334, 0, 0, 3081, 3082, 5, 366, 0, 0, 3082, 3089, 3, 410,
		205, 0, 3083, 3084, 5, 351, 0, 0, 3084, 3087, 3, 410, 205, 0, 3085, 3086,
		5, 351, 0, 0, 3086, 3088, 3, 410, 205, 0, 3087, 3085, 1, 0, 0, 0, 3087,
		3088, 1, 0, 0, 0, 3088, 3090, 1, 0, 0, 0, 3089, 3083, 1, 0, 0, 0, 3089,
		3090, 1, 0, 0, 0, 3090, 3091, 1, 0, 0, 0, 3091, 3092, 5, 369, 0, 0, 3092,
		3093, 3, 434, 217, 0, 3093, 3163, 1, 0, 0, 0, 3094, 3095, 5, 178, 0, 0,
		3095, 3097, 5, 366, 0, 0, 3096, 3098, 3, 432, 216, 0, 3097, 3096, 1, 0,
		0, 0, 3097, 3098, 1, 0, 0, 0, 3098, 3099, 1, 0, 0, 0, 3099, 3100, 3, 410,
		205, 0, 3100, 3102, 5, 369, 0, 0, 3101, 3103, 3, 434, 217, 0, 3102, 3101,
		1, 0, 0, 0, 3102, 3103, 1, 0, 0, 0, 3103, 3163, 1, 0, 0, 0, 3104, 3105,
		5, 185, 0, 0, 3105, 3107, 5, 366, 0, 0, 3106, 3108, 3, 432, 216, 0, 3107,
		3106, 1, 0, 0, 0, 3107, 3108, 1, 0, 0, 0, 3108, 3109, 1, 0, 0, 0, 3109,
		3110, 3, 410, 205, 0, 3110, 3112, 5, 369, 0, 0, 3111, 3113, 3, 434, 217,
		0, 3112, 3111, 1, 0, 0, 0, 3112, 3113, 1, 0, 0, 0, 3113, 3163, 1, 0, 0,
		0, 3114, 3115, 5, 343, 0, 0, 3115, 3116, 5, 366, 0, 0, 3116, 3117, 5, 369,
		0, 0, 3117, 3163, 3, 434, 217, 0, 3118, 3119, 5, 344, 0, 0, 3119, 3120,
		5, 366, 0, 0, 3120, 3121, 5, 369, 0, 0, 3121, 3163, 3, 434, 217, 0, 3122,
		3123, 5, 345, 0, 0, 3123, 3125, 5, 366, 0, 0, 3124, 3126, 3, 432, 216,
		0, 3125, 3124, 1, 0, 0, 0, 3125, 3126, 1, 0, 0, 0, 3126, 3127, 1, 0, 0,
		0, 3127, 3128, 3, 410, 205, 0, 3128, 3130, 5, 369, 0, 0, 3129, 3131, 3,
		434, 217, 0, 3130, 3129, 1, 0, 0, 0, 3130, 3131, 1, 0, 0, 0, 3131, 3163,
		1, 0, 0, 0, 3132, 3133, 5, 284, 0, 0, 3133, 3135, 5, 366, 0, 0, 3134, 3136,
		3, 432, 216, 0, 3135, 3134, 1, 0, 0, 0, 3135, 3136, 1, 0, 0, 0, 3136, 3137,
		1, 0, 0, 0, 3137, 3138, 3, 410, 205, 0, 3138, 3140, 5, 369, 0, 0, 3139,
		3141, 3, 434, 217, 0, 3140, 3139, 1, 0, 0, 0, 3140, 3141, 1, 0, 0, 0, 3141,
		3163, 1, 0, 0, 0, 3142, 3143, 5, 310, 0, 0, 3143, 3145, 5, 366, 0, 0, 3144,
		3146, 3, 432, 216, 0, 3145, 3144, 1, 0, 0, 0, 3145, 3146, 1, 0, 0, 0, 3146,
		3147, 1, 0, 0, 0, 3147, 3148, 3, 410, 205, 0, 3148, 3150, 5, 369, 0, 0,
		3149, 3151, 3, 434, 217, 0, 3150, 3149, 1, 0, 0, 0, 3150, 3151, 1, 0, 0,
		0, 3151, 3163, 1, 0, 0, 0, 3152, 3153, 5, 347, 0, 0, 3153, 3155, 5, 366,
		0, 0, 3154, 3156, 3, 432, 216, 0, 3155, 3154, 1, 0, 0, 0, 3155, 3156, 1,
		0, 0, 0, 3156, 3157, 1, 0, 0, 0, 3157, 3158, 3, 410, 205, 0, 3158, 3160,
		5, 369, 0, 0, 3159, 3161, 3, 434, 217, 0, 3160, 3159, 1, 0, 0, 0, 3160,
		3161, 1, 0, 0, 0, 3161, 3163, 1, 0, 0, 0, 3162, 3010, 1, 0, 0, 0, 3162,
		3020, 1, 0, 0, 0, 3162, 3033, 1, 0, 0, 0, 3162, 3046, 1, 0, 0, 0, 3162,
		3050, 1, 0, 0, 0, 3162, 3054, 1, 0, 0, 0, 3162, 3060, 1, 0, 0, 0, 3162,
		3074, 1, 0, 0, 0, 3162, 3080, 1, 0, 0, 0, 3162, 3094, 1, 0, 0, 0, 3162,
		3104, 1, 0, 0, 0, 3162, 3114, 1, 0, 0, 0, 3162, 3118, 1, 0, 0, 0, 3162,
		3122, 1, 0, 0, 0, 3162, 3132, 1, 0, 0, 0, 3162, 3142, 1, 0, 0, 0, 3162,
		3152, 1, 0, 0, 0, 3163, 431, 1, 0, 0, 0, 3164, 3165, 7, 36, 0, 0, 3165,
		433, 1, 0, 0, 0, 3166, 3167, 5, 210, 0, 0, 3167, 3169, 5, 366, 0, 0, 3168,
		3170, 3, 436, 218, 0, 3169, 3168, 1, 0, 0, 0, 3169, 3170, 1, 0, 0, 0, 3170,
		3172, 1, 0, 0, 0, 3171, 3173, 3, 366, 183, 0, 3172, 3171, 1, 0, 0, 0, 3172,
		3173, 1, 0, 0, 0, 3173, 3174, 1, 0, 0, 0, 3174, 3175, 5, 369, 0, 0, 3175,
		435, 1, 0, 0, 0, 3176, 3177, 5, 214, 0, 0, 3177, 3178, 5, 30, 0, 0, 3178,
		3183, 3, 410, 205, 0, 3179, 3180, 5, 351, 0, 0, 3180, 3182, 3, 410, 205,
		0, 3181, 3179, 1, 0, 0, 0, 3182, 3185, 1, 0, 0, 0, 3183, 3181, 1, 0, 0,
		0, 3183, 3184, 1, 0, 0, 0, 3184, 437, 1, 0, 0, 0, 3185, 3183, 1, 0, 0,
		0, 3186, 3387, 5, 324, 0, 0, 3187, 3188, 5, 38, 0, 0, 3188, 3189, 5, 366,
		0, 0, 3189, 3190, 3, 410, 205, 0, 3190, 3191, 5, 13, 0, 0, 3191, 3193,
		3, 138, 69, 0, 3192, 3194, 3, 140, 70, 0, 3193, 3192, 1, 0, 0, 0, 3193,
		3194, 1, 0, 0, 0, 3194, 3195, 1, 0, 0, 0, 3195, 3196, 5, 369, 0, 0, 3196,
		3387, 1, 0, 0, 0, 3197, 3198, 5, 58, 0, 0, 3198, 3201, 5, 366, 0, 0, 3199,
		3202, 3, 410, 205, 0, 3200, 3202, 5, 364, 0, 0, 3201, 3199, 1, 0, 0, 0,
		3201, 3200, 1, 0, 0, 0, 3202, 3203, 1, 0, 0, 0, 3203, 3387, 5, 369, 0,
		0, 3204, 3387, 5, 326, 0, 0, 3205, 3206, 5, 64, 0, 0, 3206, 3387, 5, 69,
		0, 0, 3207, 3211, 5, 328, 0, 0, 3208, 3209, 5, 64, 0, 0, 3209, 3211, 5,
		294, 0, 0, 3210, 3207, 1, 0, 0, 0, 3210, 3208, 1, 0, 0, 0, 3211, 3216,
		1, 0, 0, 0, 3212, 3213, 5, 366, 0, 0, 3213, 3214, 3, 410, 205, 0, 3214,
		3215, 5, 369, 0, 0, 3215, 3217, 1, 0, 0, 0, 3216, 3212, 1, 0, 0, 0, 3216,
		3217, 1, 0, 0, 0, 3217, 3387, 1, 0, 0, 0, 3218, 3387, 5, 329, 0, 0, 3219,
		3220, 5, 64, 0, 0, 3220, 3387, 5, 348, 0, 0, 3221, 3222, 5, 335, 0, 0,
		3222, 3223, 5, 366, 0, 0, 3223, 3236, 3, 410, 205, 0, 3224, 3225, 5, 351,
		0, 0, 3225, 3233, 3, 410, 205, 0, 3226, 3227, 5, 351, 0, 0, 3227, 3228,
		3, 410, 205, 0, 3228, 3229, 5, 356, 0, 0, 3229, 3230, 3, 410, 205, 0, 3230,
		3232, 1, 0, 0, 0, 3231, 3226, 1, 0, 0, 0, 3232, 3235, 1, 0, 0, 0, 3233,
		3231, 1, 0, 0, 0, 3233, 3234, 1, 0, 0, 0, 3234, 3237, 1, 0, 0, 0, 3235,
		3233, 1, 0, 0, 0, 3236, 3224, 1, 0, 0, 0, 3236, 3237, 1, 0, 0, 0, 3237,
		3238, 1, 0, 0, 0, 3238, 3239, 5, 369, 0, 0, 3239, 3387, 1, 0, 0, 0, 3240,
		3241, 5, 336, 0, 0, 3241, 3242, 5, 366, 0, 0, 3242, 3255, 3, 410, 205,
		0, 3243, 3244, 5, 351, 0, 0, 3244, 3252, 3, 410, 205, 0, 3245, 3246, 5,
		351, 0, 0, 3246, 3247, 3, 410, 205, 0, 3247, 3248, 5, 356, 0, 0, 3248,
		3249, 3, 410, 205, 0, 3249, 3251, 1, 0, 0, 0, 3250, 3245, 1, 0, 0, 0, 3251,
		3254, 1, 0, 0, 0, 3252, 3250, 1, 0, 0, 0, 3252, 3253, 1, 0, 0, 0, 3253,
		3256, 1, 0, 0, 0, 3254, 3252, 1, 0, 0, 0, 3255, 3243, 1, 0, 0, 0, 3255,
		3256, 1, 0, 0, 0, 3256, 3257, 1, 0, 0, 0, 3257, 3258, 5, 369, 0, 0, 3258,
		3387, 1, 0, 0, 0, 3259, 3260, 5, 337, 0, 0, 3260, 3261, 5, 366, 0, 0, 3261,
		3274, 3, 410, 205, 0, 3262, 3263, 5, 351, 0, 0, 3263, 3271, 3, 410, 205,
		0, 3264, 3265, 5, 351, 0, 0, 3265, 3266, 3, 410, 205, 0, 3266, 3267, 5,
		356, 0, 0, 3267, 3268, 3, 410, 205, 0, 3268, 3270, 1, 0, 0, 0, 3269, 3264,
		1, 0, 0, 0, 3270, 3273, 1, 0, 0, 0, 3271, 3269, 1, 0, 0, 0, 3271, 3272,
		1, 0, 0, 0, 3272, 3275, 1, 0, 0, 0, 3273, 3271, 1, 0, 0, 0, 3274, 3262,
		1, 0, 0, 0, 3274, 3275, 1, 0, 0, 0, 3275, 3276, 1, 0, 0, 0, 3276, 3277,
		5, 369, 0, 0, 3277, 3387, 1, 0, 0, 0, 3278, 3279, 5, 338, 0, 0, 3279, 3280,
		5, 366, 0, 0, 3280, 3293, 3, 410, 205, 0, 3281, 3282, 5, 351, 0, 0, 3282,
		3290, 3, 410, 205, 0, 3283, 3284, 5, 351, 0, 0, 3284, 3285, 3, 410, 205,
		0, 3285, 3286, 5, 356, 0, 0, 3286, 3287, 3, 410, 205, 0, 3287, 3289, 1,
		0, 0, 0, 3288, 3283, 1, 0, 0, 0, 3289, 3292, 1, 0, 0, 0, 3290, 3288, 1,
		0, 0, 0, 3290, 3291, 1, 0, 0, 0, 3291, 3294, 1, 0, 0, 0, 3292, 3290, 1,
		0, 0, 0, 3293, 3281, 1, 0, 0, 0, 3293, 3294, 1, 0, 0, 0, 3294, 3295, 1,
		0, 0, 0, 3295, 3296, 5, 369, 0, 0, 3296, 3387, 1, 0, 0, 0, 3297, 3298,
		5, 339, 0, 0, 3298, 3299, 5, 366, 0, 0, 3299, 3312, 3, 410, 205, 0, 3300,
		3301, 5, 351, 0, 0, 3301, 3309, 3, 410, 205, 0, 3302, 3303, 5, 351, 0,
		0, 3303, 3304, 3, 410, 205, 0, 3304, 3305, 5, 356, 0, 0, 3305, 3306, 3,
		410, 205, 0, 3306, 3308, 1, 0, 0, 0, 3307, 3302, 1, 0, 0, 0, 3308, 3311,
		1, 0, 0, 0, 3309, 3307, 1, 0, 0, 0, 3309, 3310, 1, 0, 0, 0, 3310, 3313,
		1, 0, 0, 0, 3311, 3309, 1, 0, 0, 0, 3312, 3300, 1, 0, 0, 0, 3312, 3313,
		1, 0, 0, 0, 3313, 3314, 1, 0, 0, 0, 3314, 3315, 5, 369, 0, 0, 3315, 3387,
		1, 0, 0, 0, 3316, 3317, 5, 340, 0, 0, 3317, 3318, 5, 366, 0, 0, 3318, 3331,
		3, 410, 205, 0, 3319, 3320, 5, 351, 0, 0, 3320, 3328, 3, 410, 205, 0, 3321,
		3322, 5, 351, 0, 0, 3322, 3323, 3, 410, 205, 0, 3323, 3324, 5, 356, 0,
		0, 3324, 3325, 3, 410, 205, 0, 3325, 3327, 1, 0, 0, 0, 3326, 3321, 1, 0,
		0, 0, 3327, 3330, 1, 0, 0, 0, 3328, 3326, 1, 0, 0, 0, 3328, 3329, 1, 0,
		0, 0, 3329, 3332, 1, 0, 0, 0, 3330, 3328, 1, 0, 0, 0, 3331, 3319, 1, 0,
		0, 0, 3331, 3332, 1, 0, 0, 0, 3332, 3333, 1, 0, 0, 0, 3333, 3334, 5, 369,
		0, 0, 3334, 3387, 1, 0, 0, 0, 3335, 3336, 5, 341, 0, 0, 3336, 3337, 5,
		366, 0, 0, 3337, 3345, 3, 410, 205, 0, 3338, 3339, 5, 351, 0, 0, 3339,
		3340, 3, 410, 205, 0, 3340, 3341, 5, 356, 0, 0, 3341, 3342, 3, 410, 205,
		0, 3342, 3344, 1, 0, 0, 0, 3343, 3338, 1, 0, 0, 0, 3344, 3347, 1, 0, 0,
		0, 3345, 3343, 1, 0, 0, 0, 3345, 3346, 1, 0, 0, 0, 3346, 3348, 1, 0, 0,
		0, 3347, 3345, 1, 0, 0, 0, 3348, 3349, 5, 369, 0, 0, 3349, 3387, 1, 0,
		0, 0, 3350, 3351, 5, 342, 0, 0, 3351, 3352, 5, 366, 0, 0, 3352, 3358, 3,
		410, 205, 0, 3353, 3354, 5, 351, 0, 0, 3354, 3355, 3, 410, 205, 0, 3355,
		3356, 5, 356, 0, 0, 3356, 3357, 3, 410, 205, 0, 3357, 3359, 1, 0, 0, 0,
		3358, 3353, 1, 0, 0, 0, 3359, 3360, 1, 0, 0, 0, 3360, 3358, 1, 0, 0, 0,
		3360, 3361, 1, 0, 0, 0, 3361, 3364, 1, 0, 0, 0, 3362, 3363, 5, 351, 0,
		0, 3363, 3365, 3, 410, 205, 0, 3364, 3362, 1, 0, 0, 0, 3364, 3365, 1, 0,
		0, 0, 3365, 3366, 1, 0, 0, 0, 3366, 3367, 5, 369, 0, 0, 3367, 3387, 1,
		0, 0, 0, 3368, 3369, 5, 252, 0, 0, 3369, 3370, 5, 366, 0, 0, 3370, 3371,
		3, 410, 205, 0, 3371, 3372, 5, 369, 0, 0, 3372, 3387, 1, 0, 0, 0, 3373,
		3374, 5, 283, 0, 0, 3374, 3375, 5, 366, 0, 0, 3375, 3376, 3, 410, 205,
		0, 3376, 3377, 5, 120, 0, 0, 3377, 3380, 3, 410, 205, 0, 3378, 3379, 5,
		116, 0, 0, 3379, 3381, 3, 410, 205, 0, 3380, 3378, 1, 0, 0, 0, 3380, 3381,
		1, 0, 0, 0, 3381, 3382, 1, 0, 0, 0, 3382, 3383, 5, 369, 0, 0, 3383, 3387,
		1, 0, 0, 0, 3384, 3387, 5, 346, 0, 0, 3385, 3387, 5, 348, 0, 0, 3386, 3186,
		1, 0, 0, 0, 3386, 3187, 1, 0, 0, 0, 3386, 3197, 1, 0, 0, 0, 3386, 3204,
		1, 0, 0, 0, 3386, 3205, 1, 0, 0, 0, 3386, 3210, 1, 0, 0, 0, 3386, 3218,
		1, 0, 0, 0, 3386, 3219, 1, 0, 0, 0, 3386, 3221, 1, 0, 0, 0, 3386, 3240,
		1, 0, 0, 0, 3386, 3259, 1, 0, 0, 0, 3386, 3278, 1, 0, 0, 0, 3386, 3297,
		1, 0, 0, 0, 3386, 3316, 1, 0, 0, 0, 3386, 3335, 1, 0, 0, 0, 3386, 3350,
		1, 0, 0, 0, 3386, 3368, 1, 0, 0, 0, 3386, 3373, 1, 0, 0, 0, 3386, 3384,
		1, 0, 0, 0, 3386, 3385, 1, 0, 0, 0, 3387, 439, 1, 0, 0, 0, 3388, 3389,
		3, 472, 236, 0, 3389, 3391, 5, 366, 0, 0, 3390, 3392, 3, 448, 224, 0, 3391,
		3390, 1, 0, 0, 0, 3391, 3392, 1, 0, 0, 0, 3392, 3393, 1, 0, 0, 0, 3393,
		3394, 5, 369, 0, 0, 3394, 441, 1, 0, 0, 0, 3395, 3398, 3, 444, 222, 0,
		3396, 3398, 3, 446, 223, 0, 3397, 3395, 1, 0, 0, 0, 3397, 3396, 1, 0, 0,
		0, 3398, 443, 1, 0, 0, 0, 3399, 3402, 3, 472, 236, 0, 3400, 3402, 3, 440,
		220, 0, 3401, 3399, 1, 0, 0, 0, 3401, 3400, 1, 0, 0, 0, 3402, 3403, 1,
		0, 0, 0, 3403, 3404, 5, 354, 0, 0, 3404, 3405, 3, 440, 220, 0, 3405, 445,
		1, 0, 0, 0, 3406, 3409, 3, 472, 236, 0, 3407, 3409, 3, 440, 220, 0, 3408,
		3406, 1, 0, 0, 0, 3408, 3407, 1, 0, 0, 0, 3409, 3410, 1, 0, 0, 0, 3410,
		3411, 5, 354, 0, 0, 3411, 3412, 3, 472, 236, 0, 3412, 447, 1, 0, 0, 0,
		3413, 3418, 3, 450, 225, 0, 3414, 3415, 5, 351, 0, 0, 3415, 3417, 3, 450,
		225, 0, 3416, 3414, 1, 0, 0, 0, 3417, 3420, 1, 0, 0, 0, 3418, 3416, 1,
		0, 0, 0, 3418, 3419, 1, 0, 0, 0, 3419, 449, 1, 0, 0, 0, 3420, 3418, 1,
		0, 0, 0, 3421, 3427, 4, 225, 10, 0, 3422, 3423, 3, 472, 236, 0, 3423, 3425,
		5, 356, 0, 0, 3424, 3426, 5, 360, 0, 0, 3425, 3424, 1, 0, 0, 0, 3425, 3426,
		1, 0, 0, 0, 3426, 3428, 1, 0, 0, 0, 3427, 3422, 1, 0, 0, 0, 3427, 3428,
		1, 0, 0, 0, 3428, 3429, 1, 0, 0, 0, 3429, 3430, 3, 410, 205, 0, 3430, 451,
		1, 0, 0, 0, 3431, 3434, 3, 304, 152, 0, 3432, 3434, 3, 410, 205, 0, 3433,
		3431, 1, 0, 0, 0, 3433, 3432, 1, 0, 0, 0, 3434, 453, 1, 0, 0, 0, 3435,
		3438, 3, 466, 233, 0, 3436, 3438, 3, 410, 205, 0, 3437, 3435, 1, 0, 0,
		0, 3437, 3436, 1, 0, 0, 0, 3438, 455, 1, 0, 0, 0, 3439, 3443, 5, 132, 0,
		0, 3440, 3442, 3, 458, 229, 0, 3441, 3440, 1, 0, 0, 0, 3442, 3445, 1, 0,
		0, 0, 3443, 3441, 1, 0, 0, 0, 3443, 3444, 1, 0, 0, 0, 3444, 457, 1, 0,
		0, 0, 3445, 3443, 1, 0, 0, 0, 3446, 3447, 5, 372, 0, 0, 3447, 3448, 3,
		474, 237, 0, 3448, 3449, 3, 410, 205, 0, 3449, 3459, 1, 0, 0, 0, 3450,
		3451, 5, 372, 0, 0, 3451, 3452, 3, 474, 237, 0, 3452, 3453, 5, 373, 0,
		0, 3453, 3454, 5, 356, 0, 0, 3454, 3455, 3, 410, 205, 0, 3455, 3459, 1,
		0, 0, 0, 3456, 3457, 5, 372, 0, 0, 3457, 3459, 3, 474, 237, 0, 3458, 3446,
		1, 0, 0, 0, 3458, 3450, 1, 0, 0, 0, 3458, 3456, 1, 0, 0, 0, 3459, 459,
		1, 0, 0, 0, 3460, 3461, 5, 4, 0, 0, 3461, 3462, 3, 462, 231, 0, 3462, 3463,
		5, 371, 0, 0, 3463, 3466, 1, 0, 0, 0, 3464, 3466, 3, 464, 232, 0, 3465,
		3460, 1, 0, 0, 0, 3465, 3464, 1, 0, 0, 0, 3466, 461, 1, 0, 0, 0, 3467,
		3469, 9, 0, 0, 0, 3468, 3467, 1, 0, 0, 0, 3469, 3472, 1, 0, 0, 0, 3470,
		3471, 1, 0, 0, 0, 3470, 3468, 1, 0, 0, 0, 3471, 463, 1, 0, 0, 0, 3472,
		3470, 1, 0, 0, 0, 3473, 3474, 5, 133, 0, 0, 3474, 3475, 3, 410, 205, 0,
		3475, 465, 1, 0, 0, 0, 3476, 3491, 5, 381, 0, 0, 3477, 3481, 5, 353, 0,
		0, 3478, 3479, 5, 354, 0, 0, 3479, 3481, 5, 353, 0, 0, 3480, 3477, 1, 0,
		0, 0, 3480, 3478, 1, 0, 0, 0, 3480, 3481, 1, 0, 0, 0, 3481, 3482, 1, 0,
		0, 0, 3482, 3487, 3, 474, 237, 0, 3483, 3484, 5, 353, 0, 0, 3484, 3486,
		3, 474, 237, 0, 3485, 3483, 1, 0, 0, 0, 3486, 3489, 1, 0, 0, 0, 3487, 3485,
		1, 0, 0, 0, 3487, 3488, 1, 0, 0, 0, 3488, 3491, 1, 0, 0, 0, 3489, 3487,
		1, 0, 0, 0, 3490, 3476, 1, 0, 0, 0, 3490, 3480, 1, 0, 0, 0, 3491, 467,
		1, 0, 0, 0, 3492, 3493, 5, 69, 0, 0, 3493, 3494, 3, 476, 238, 0, 3494,
		469, 1, 0, 0, 0, 3495, 3496, 5, 294, 0, 0, 3496, 3497, 3, 476, 238, 0,
		3497, 471, 1, 0, 0, 0, 3498, 3500, 5, 372, 0, 0, 3499, 3498, 1, 0, 0, 0,
		3499, 3500, 1, 0, 0, 0, 3500, 3503, 1, 0, 0, 0, 3501, 3504, 5, 373, 0,
		0, 3502, 3504, 3, 486, 243, 0, 3503, 3501, 1, 0, 0, 0, 3503, 3502, 1, 0,
		0, 0, 3504, 473, 1, 0, 0, 0, 3505, 3510, 3, 472, 236, 0, 3506, 3507, 5,
		354, 0, 0, 3507, 3509, 3, 472, 236, 0, 3508, 3506, 1, 0, 0, 0, 3509, 3512,
		1, 0, 0, 0, 3510, 3508, 1, 0, 0, 0, 3510, 3511, 1, 0, 0, 0, 3511, 475,
		1, 0, 0, 0, 3512, 3510, 1, 0, 0, 0, 3513, 3516, 5, 374, 0, 0, 3514, 3516,
		5, 375, 0, 0, 3515, 3513, 1, 0, 0, 0, 3515, 3514, 1, 0, 0, 0, 3516, 477,
		1, 0, 0, 0, 3517, 3519, 7, 44, 0, 0, 3518, 3517, 1, 0, 0, 0, 3518, 3519,
		1, 0, 0, 0, 3519, 3520, 1, 0, 0, 0, 3520, 3521, 5, 376, 0, 0, 3521, 479,
		1, 0, 0, 0, 3522, 3524, 7, 44, 0, 0, 3523, 3522, 1, 0, 0, 0, 3523, 3524,
		1, 0, 0, 0, 3524, 3525, 1, 0, 0, 0, 3525, 3526, 5, 377, 0, 0, 3526, 481,
		1, 0, 0, 0, 3527, 3528, 7, 48, 0, 0, 3528, 483, 1, 0, 0, 0, 3529, 3530,
		5, 197, 0, 0, 3530, 485, 1, 0, 0, 0, 3531, 3532, 7, 49, 0, 0, 3532, 487,
		1, 0, 0, 0, 441, 493, 496, 500, 503, 508, 515, 521, 523, 532, 535, 537,
		601, 609, 625, 632, 635, 641, 645, 654, 659, 672, 677, 686, 698, 703, 706,
		720, 727, 736, 753, 761, 772, 782, 790, 797, 801, 805, 810, 814, 819, 823,
		827, 837, 841, 846, 851, 855, 868, 873, 879, 888, 892, 900, 903, 908, 913,
		920, 929, 932, 939, 944, 948, 954, 959, 965, 970, 973, 979, 993, 1003,
		1009, 1014, 1019, 1024, 1028, 1033, 1036, 1046, 1058, 1065, 1068, 1080,
		1085, 1090, 1093, 1100, 1112, 1125, 1127, 1132, 1135, 1150, 1156, 1167,
		1170, 1180, 1187, 1204, 1233, 1238, 1242, 1249, 1256, 1261, 1265, 1283,
		1291, 1301, 1321, 1327, 1331, 1336, 1340, 1345, 1348, 1353, 1356, 1368,
		1375, 1380, 1385, 1389, 1394, 1397, 1407, 1419, 1426, 1434, 1449, 1478,
		1483, 1487, 1492, 1499, 1502, 1505, 1510, 1514, 1516, 1523, 1529, 1536,
		1542, 1545, 1550, 1554, 1557, 1564, 1570, 1573, 1583, 1592, 1599, 1606,
		1608, 1614, 1617, 1628, 1637, 1643, 1649, 1652, 1657, 1660, 1663, 1666,
		1669, 1675, 1685, 1696, 1699, 1706, 1711, 1716, 1720, 1728, 1732, 1737,
		1741, 1743, 1748, 1756, 1761, 1767, 1774, 1781, 1788, 1791, 1798, 1806,
		1814, 1817, 1820, 1825, 1834, 1838, 1848, 1867, 1874, 1876, 1880, 1884,
		1892, 1903, 1912, 1920, 1928, 1932, 1940, 1958, 1972, 1979, 1983, 1990,
		1992, 1996, 2000, 2008, 2012, 2022, 2031, 2047, 2053, 2057, 2067, 2075,
		2084, 2088, 2094, 2099, 2103, 2113, 2119, 2123, 2135, 2142, 2158, 2165,
		2175, 2178, 2182, 2189, 2196, 2198, 2202, 2206, 2211, 2214, 2218, 2221,
		2232, 2235, 2246, 2252, 2256, 2258, 2262, 2271, 2278, 2282, 2286, 2293,
		2297, 2305, 2316, 2320, 2331, 2338, 2351, 2359, 2363, 2373, 2378, 2391,
		2402, 2410, 2414, 2418, 2422, 2424, 2429, 2432, 2435, 2438, 2442, 2445,
		2448, 2451, 2454, 2461, 2472, 2476, 2479, 2483, 2490, 2494, 2504, 2509,
		2514, 2518, 2529, 2535, 2539, 2545, 2554, 2557, 2562, 2565, 2575, 2580,
		2589, 2594, 2598, 2607, 2611, 2625, 2638, 2643, 2647, 2653, 2664, 2666,
		2673, 2676, 2683, 2688, 2694, 2697, 2700, 2715, 2722, 2725, 2728, 2732,
		2737, 2743, 2747, 2758, 2762, 2765, 2769, 2773, 2777, 2781, 2787, 2793,
		2800, 2808, 2814, 2819, 2830, 2839, 2843, 2852, 2856, 2866, 2871, 2893,
		2896, 2916, 2926, 2928, 2939, 2954, 2967, 2971, 2982, 2986, 2998, 3002,
		3013, 3018, 3023, 3027, 3031, 3036, 3040, 3044, 3067, 3069, 3087, 3089,
		3097, 3102, 3107, 3112, 3125, 3130, 3135, 3140, 3145, 3150, 3155, 3160,
		3162, 3169, 3172, 3183, 3193, 3201, 3210, 3216, 3233, 3236, 3252, 3255,
		3271, 3274, 3290, 3293, 3309, 3312, 3328, 3331, 3345, 3360, 3364, 3380,
		3386, 3391, 3397, 3401, 3408, 3418, 3425, 3427, 3433, 3437, 3443, 3458,
		3465, 3470, 3480, 3487, 3490, 3499, 3503, 3510, 3515, 3518, 3523,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// HplsqlParserInit initializes any static state used to implement HplsqlParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewHplsqlParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func HplsqlParserInit() {
	staticData := &HplsqlParserStaticData
	staticData.once.Do(hplsqlParserInit)
}

// NewHplsqlParser produces a new parser instance for the optional input antlr.TokenStream.
func NewHplsqlParser(input antlr.TokenStream) *HplsqlParser {
	HplsqlParserInit()
	this := new(HplsqlParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &HplsqlParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "Hplsql.g4"

	return this
}

// HplsqlParser tokens.
const (
	HplsqlParserEOF                   = antlr.TokenEOF
	HplsqlParserT__0                  = 1
	HplsqlParserT__1                  = 2
	HplsqlParserT__2                  = 3
	HplsqlParserT__3                  = 4
	HplsqlParserT_ACTION              = 5
	HplsqlParserT_ADD2                = 6
	HplsqlParserT_ALL                 = 7
	HplsqlParserT_ALLOCATE            = 8
	HplsqlParserT_ALTER               = 9
	HplsqlParserT_AND                 = 10
	HplsqlParserT_ANSI_NULLS          = 11
	HplsqlParserT_ANSI_PADDING        = 12
	HplsqlParserT_AS                  = 13
	HplsqlParserT_ASC                 = 14
	HplsqlParserT_ASSOCIATE           = 15
	HplsqlParserT_AT                  = 16
	HplsqlParserT_AUTO_INCREMENT      = 17
	HplsqlParserT_AVG                 = 18
	HplsqlParserT_BATCHSIZE           = 19
	HplsqlParserT_BEGIN               = 20
	HplsqlParserT_BETWEEN             = 21
	HplsqlParserT_BIGINT              = 22
	HplsqlParserT_BINARY_DOUBLE       = 23
	HplsqlParserT_BINARY_FLOAT        = 24
	HplsqlParserT_BINARY_INTEGER      = 25
	HplsqlParserT_BIT                 = 26
	HplsqlParserT_BODY                = 27
	HplsqlParserT_BREAK               = 28
	HplsqlParserT_BULK                = 29
	HplsqlParserT_BY                  = 30
	HplsqlParserT_BYTE                = 31
	HplsqlParserT_BOOLEAN             = 32
	HplsqlParserT_CALL                = 33
	HplsqlParserT_CALLER              = 34
	HplsqlParserT_CASCADE             = 35
	HplsqlParserT_CASE                = 36
	HplsqlParserT_CASESPECIFIC        = 37
	HplsqlParserT_CAST                = 38
	HplsqlParserT_CHAR                = 39
	HplsqlParserT_CHARACTER           = 40
	HplsqlParserT_CHARSET             = 41
	HplsqlParserT_CLIENT              = 42
	HplsqlParserT_CLOSE               = 43
	HplsqlParserT_CLUSTERED           = 44
	HplsqlParserT_CMP                 = 45
	HplsqlParserT_COLLECT             = 46
	HplsqlParserT_COLLECTION          = 47
	HplsqlParserT_COLUMN              = 48
	HplsqlParserT_COMMENT             = 49
	HplsqlParserT_CONSTANT            = 50
	HplsqlParserT_COMMIT              = 51
	HplsqlParserT_COMPRESS            = 52
	HplsqlParserT_CONCAT              = 53
	HplsqlParserT_CONDITION           = 54
	HplsqlParserT_CONSTRAINT          = 55
	HplsqlParserT_CONTINUE            = 56
	HplsqlParserT_COPY                = 57
	HplsqlParserT_COUNT               = 58
	HplsqlParserT_COUNT_BIG           = 59
	HplsqlParserT_CREATE              = 60
	HplsqlParserT_CREATION            = 61
	HplsqlParserT_CREATOR             = 62
	HplsqlParserT_CS                  = 63
	HplsqlParserT_CURRENT             = 64
	HplsqlParserT_CURRENT_SCHEMA      = 65
	HplsqlParserT_CURSOR              = 66
	HplsqlParserT_DATABASE            = 67
	HplsqlParserT_DATA                = 68
	HplsqlParserT_DATE                = 69
	HplsqlParserT_DATETIME            = 70
	HplsqlParserT_DAY                 = 71
	HplsqlParserT_DAYS                = 72
	HplsqlParserT_DEC                 = 73
	HplsqlParserT_DECIMAL             = 74
	HplsqlParserT_DECLARE             = 75
	HplsqlParserT_DEFAULT             = 76
	HplsqlParserT_DEFERRED            = 77
	HplsqlParserT_DEFINED             = 78
	HplsqlParserT_DEFINER             = 79
	HplsqlParserT_DEFINITION          = 80
	HplsqlParserT_DELETE              = 81
	HplsqlParserT_DELIMITED           = 82
	HplsqlParserT_DELIMITER           = 83
	HplsqlParserT_DESC                = 84
	HplsqlParserT_DESCRIBE            = 85
	HplsqlParserT_DIAGNOSTICS         = 86
	HplsqlParserT_DIR                 = 87
	HplsqlParserT_DIRECTORY           = 88
	HplsqlParserT_DISTINCT            = 89
	HplsqlParserT_DISTRIBUTE          = 90
	HplsqlParserT_DO                  = 91
	HplsqlParserT_DOUBLE              = 92
	HplsqlParserT_DROP                = 93
	HplsqlParserT_DYNAMIC             = 94
	HplsqlParserT_ELSE                = 95
	HplsqlParserT_ELSEIF              = 96
	HplsqlParserT_ELSIF               = 97
	HplsqlParserT_ENABLE              = 98
	HplsqlParserT_END                 = 99
	HplsqlParserT_ENGINE              = 100
	HplsqlParserT_ESCAPED             = 101
	HplsqlParserT_EXCEPT              = 102
	HplsqlParserT_EXEC                = 103
	HplsqlParserT_EXECUTE             = 104
	HplsqlParserT_EXCEPTION           = 105
	HplsqlParserT_EXCLUSIVE           = 106
	HplsqlParserT_EXISTS              = 107
	HplsqlParserT_EXIT                = 108
	HplsqlParserT_FALLBACK            = 109
	HplsqlParserT_FALSE               = 110
	HplsqlParserT_FETCH               = 111
	HplsqlParserT_FIELDS              = 112
	HplsqlParserT_FILE                = 113
	HplsqlParserT_FILES               = 114
	HplsqlParserT_FLOAT               = 115
	HplsqlParserT_FOR                 = 116
	HplsqlParserT_FOREIGN             = 117
	HplsqlParserT_FORMAT              = 118
	HplsqlParserT_FOUND               = 119
	HplsqlParserT_FROM                = 120
	HplsqlParserT_FULL                = 121
	HplsqlParserT_FUNCTION            = 122
	HplsqlParserT_GET                 = 123
	HplsqlParserT_GLOBAL              = 124
	HplsqlParserT_GO                  = 125
	HplsqlParserT_GRANT               = 126
	HplsqlParserT_GROUP               = 127
	HplsqlParserT_HANDLER             = 128
	HplsqlParserT_HASH                = 129
	HplsqlParserT_HAVING              = 130
	HplsqlParserT_HDFS                = 131
	HplsqlParserT_HIVE                = 132
	HplsqlParserT_HOST                = 133
	HplsqlParserT_IDENTITY            = 134
	HplsqlParserT_IF                  = 135
	HplsqlParserT_IGNORE              = 136
	HplsqlParserT_IMMEDIATE           = 137
	HplsqlParserT_IN                  = 138
	HplsqlParserT_INCLUDE             = 139
	HplsqlParserT_INDEX               = 140
	HplsqlParserT_INITRANS            = 141
	HplsqlParserT_INNER               = 142
	HplsqlParserT_INOUT               = 143
	HplsqlParserT_INSERT              = 144
	HplsqlParserT_INT                 = 145
	HplsqlParserT_INT2                = 146
	HplsqlParserT_INT4                = 147
	HplsqlParserT_INT8                = 148
	HplsqlParserT_INTEGER             = 149
	HplsqlParserT_INTERSECT           = 150
	HplsqlParserT_INTERVAL            = 151
	HplsqlParserT_INTO                = 152
	HplsqlParserT_INVOKER             = 153
	HplsqlParserT_IS                  = 154
	HplsqlParserT_ISOPEN              = 155
	HplsqlParserT_ITEMS               = 156
	HplsqlParserT_JOIN                = 157
	HplsqlParserT_KEEP                = 158
	HplsqlParserT_KEY                 = 159
	HplsqlParserT_KEYS                = 160
	HplsqlParserT_LANGUAGE            = 161
	HplsqlParserT_LEAVE               = 162
	HplsqlParserT_LEFT                = 163
	HplsqlParserT_LIKE                = 164
	HplsqlParserT_LIMIT               = 165
	HplsqlParserT_LINES               = 166
	HplsqlParserT_LOCAL               = 167
	HplsqlParserT_LOCATION            = 168
	HplsqlParserT_LOCATOR             = 169
	HplsqlParserT_LOCATORS            = 170
	HplsqlParserT_LOCKS               = 171
	HplsqlParserT_LOG                 = 172
	HplsqlParserT_LOGGED              = 173
	HplsqlParserT_LOGGING             = 174
	HplsqlParserT_LOOP                = 175
	HplsqlParserT_MAP                 = 176
	HplsqlParserT_MATCHED             = 177
	HplsqlParserT_MAX                 = 178
	HplsqlParserT_MAXTRANS            = 179
	HplsqlParserT_MERGE               = 180
	HplsqlParserT_MESSAGE_TEXT        = 181
	HplsqlParserT_MICROSECOND         = 182
	HplsqlParserT_MICROSECONDS        = 183
	HplsqlParserT_MILLIS              = 184
	HplsqlParserT_MIN                 = 185
	HplsqlParserT_MULTISET            = 186
	HplsqlParserT_NCHAR               = 187
	HplsqlParserT_NEW                 = 188
	HplsqlParserT_NVARCHAR            = 189
	HplsqlParserT_NO                  = 190
	HplsqlParserT_NOCOUNT             = 191
	HplsqlParserT_NOCOMPRESS          = 192
	HplsqlParserT_NOLOGGING           = 193
	HplsqlParserT_NONE                = 194
	HplsqlParserT_NOT                 = 195
	HplsqlParserT_NOTFOUND            = 196
	HplsqlParserT_NULL                = 197
	HplsqlParserT_NUMERIC             = 198
	HplsqlParserT_NUMBER              = 199
	HplsqlParserT_OBJECT              = 200
	HplsqlParserT_OFF                 = 201
	HplsqlParserT_OF                  = 202
	HplsqlParserT_ON                  = 203
	HplsqlParserT_ONLY                = 204
	HplsqlParserT_OPEN                = 205
	HplsqlParserT_OR                  = 206
	HplsqlParserT_ORDER               = 207
	HplsqlParserT_OUT                 = 208
	HplsqlParserT_OUTER               = 209
	HplsqlParserT_OVER                = 210
	HplsqlParserT_OVERWRITE           = 211
	HplsqlParserT_OWNER               = 212
	HplsqlParserT_PACKAGE             = 213
	HplsqlParserT_PARTITION           = 214
	HplsqlParserT_PARTITIONED         = 215
	HplsqlParserT_PCTFREE             = 216
	HplsqlParserT_PCTUSED             = 217
	HplsqlParserT_PLS_INTEGER         = 218
	HplsqlParserT_PRECISION           = 219
	HplsqlParserT_PRESERVE            = 220
	HplsqlParserT_PRIMARY             = 221
	HplsqlParserT_PRINT               = 222
	HplsqlParserT_PROC                = 223
	HplsqlParserT_PROCEDURE           = 224
	HplsqlParserT_QUALIFY             = 225
	HplsqlParserT_QUERY_BAND          = 226
	HplsqlParserT_QUIT                = 227
	HplsqlParserT_QUOTED_IDENTIFIER   = 228
	HplsqlParserT_RAISE               = 229
	HplsqlParserT_REAL                = 230
	HplsqlParserT_REFERENCES          = 231
	HplsqlParserT_REGEXP              = 232
	HplsqlParserT_REPLACE             = 233
	HplsqlParserT_RESIGNAL            = 234
	HplsqlParserT_RESTRICT            = 235
	HplsqlParserT_RESULT              = 236
	HplsqlParserT_RESULT_SET_LOCATOR  = 237
	HplsqlParserT_RETURN              = 238
	HplsqlParserT_RETURNS             = 239
	HplsqlParserT_REVERSE             = 240
	HplsqlParserT_RIGHT               = 241
	HplsqlParserT_RLIKE               = 242
	HplsqlParserT_ROLE                = 243
	HplsqlParserT_ROLLBACK            = 244
	HplsqlParserT_ROW                 = 245
	HplsqlParserT_ROWS                = 246
	HplsqlParserT_ROWTYPE             = 247
	HplsqlParserT_ROW_COUNT           = 248
	HplsqlParserT_RR                  = 249
	HplsqlParserT_RS                  = 250
	HplsqlParserT_PWD                 = 251
	HplsqlParserT_TRIM                = 252
	HplsqlParserT_SCHEMA              = 253
	HplsqlParserT_SECOND              = 254
	HplsqlParserT_SECONDS             = 255
	HplsqlParserT_SECURITY            = 256
	HplsqlParserT_SEGMENT             = 257
	HplsqlParserT_SEL                 = 258
	HplsqlParserT_SELECT              = 259
	HplsqlParserT_SET                 = 260
	HplsqlParserT_SESSION             = 261
	HplsqlParserT_SESSIONS            = 262
	HplsqlParserT_SETS                = 263
	HplsqlParserT_SHARE               = 264
	HplsqlParserT_SIGNAL              = 265
	HplsqlParserT_SIMPLE_DOUBLE       = 266
	HplsqlParserT_SIMPLE_FLOAT        = 267
	HplsqlParserT_SIMPLE_INTEGER      = 268
	HplsqlParserT_SMALLDATETIME       = 269
	HplsqlParserT_SMALLINT            = 270
	HplsqlParserT_SQL                 = 271
	HplsqlParserT_SQLEXCEPTION        = 272
	HplsqlParserT_SQLINSERT           = 273
	HplsqlParserT_SQLSTATE            = 274
	HplsqlParserT_SQLWARNING          = 275
	HplsqlParserT_STATS               = 276
	HplsqlParserT_STATISTICS          = 277
	HplsqlParserT_STEP                = 278
	HplsqlParserT_STORAGE             = 279
	HplsqlParserT_STORED              = 280
	HplsqlParserT_STRING              = 281
	HplsqlParserT_SUBDIR              = 282
	HplsqlParserT_SUBSTRING           = 283
	HplsqlParserT_SUM                 = 284
	HplsqlParserT_SUMMARY             = 285
	HplsqlParserT_SYS_REFCURSOR       = 286
	HplsqlParserT_TABLE               = 287
	HplsqlParserT_TABLESPACE          = 288
	HplsqlParserT_TEMPORARY           = 289
	HplsqlParserT_TERMINATED          = 290
	HplsqlParserT_TEXTIMAGE_ON        = 291
	HplsqlParserT_THEN                = 292
	HplsqlParserT_TIME                = 293
	HplsqlParserT_TIMESTAMP           = 294
	HplsqlParserT_TINYINT             = 295
	HplsqlParserT_TITLE               = 296
	HplsqlParserT_TO                  = 297
	HplsqlParserT_TOP                 = 298
	HplsqlParserT_TRANSACTION         = 299
	HplsqlParserT_TRUE                = 300
	HplsqlParserT_TRUNCATE            = 301
	HplsqlParserT_UNION               = 302
	HplsqlParserT_UNIQUE              = 303
	HplsqlParserT_UPDATE              = 304
	HplsqlParserT_UR                  = 305
	HplsqlParserT_USE                 = 306
	HplsqlParserT_USING               = 307
	HplsqlParserT_VALUE               = 308
	HplsqlParserT_VALUES              = 309
	HplsqlParserT_VAR                 = 310
	HplsqlParserT_VARCHAR             = 311
	HplsqlParserT_VARCHAR2            = 312
	HplsqlParserT_VARYING             = 313
	HplsqlParserT_VOLATILE            = 314
	HplsqlParserT_WHEN                = 315
	HplsqlParserT_WHERE               = 316
	HplsqlParserT_WHILE               = 317
	HplsqlParserT_WITH                = 318
	HplsqlParserT_WITHOUT             = 319
	HplsqlParserT_WORK                = 320
	HplsqlParserT_XACT_ABORT          = 321
	HplsqlParserT_XML                 = 322
	HplsqlParserT_YES                 = 323
	HplsqlParserT_ACTIVITY_COUNT      = 324
	HplsqlParserT_CUME_DIST           = 325
	HplsqlParserT_CURRENT_DATE        = 326
	HplsqlParserT_CURRENT_TIME_MILLIS = 327
	HplsqlParserT_CURRENT_TIMESTAMP   = 328
	HplsqlParserT_CURRENT_USER        = 329
	HplsqlParserT_DENSE_RANK          = 330
	HplsqlParserT_FIRST_VALUE         = 331
	HplsqlParserT_LAG                 = 332
	HplsqlParserT_LAST_VALUE          = 333
	HplsqlParserT_LEAD                = 334
	HplsqlParserT_MAX_PART_STRING     = 335
	HplsqlParserT_MIN_PART_STRING     = 336
	HplsqlParserT_MAX_PART_INT        = 337
	HplsqlParserT_MIN_PART_INT        = 338
	HplsqlParserT_MAX_PART_DATE       = 339
	HplsqlParserT_MIN_PART_DATE       = 340
	HplsqlParserT_PART_COUNT          = 341
	HplsqlParserT_PART_LOC            = 342
	HplsqlParserT_RANK                = 343
	HplsqlParserT_ROW_NUMBER          = 344
	HplsqlParserT_STDEV               = 345
	HplsqlParserT_SYSDATE             = 346
	HplsqlParserT_VARIANCE            = 347
	HplsqlParserT_USER                = 348
	HplsqlParserT_ADD                 = 349
	HplsqlParserT_COLON               = 350
	HplsqlParserT_COMMA               = 351
	HplsqlParserT_PIPE                = 352
	HplsqlParserT_DIV                 = 353
	HplsqlParserT_DOT                 = 354
	HplsqlParserT_DOT2                = 355
	HplsqlParserT_EQUAL               = 356
	HplsqlParserT_EQUAL2              = 357
	HplsqlParserT_NOTEQUAL            = 358
	HplsqlParserT_NOTEQUAL2           = 359
	HplsqlParserT_GREATER             = 360
	HplsqlParserT_GREATEREQUAL        = 361
	HplsqlParserT_LESS                = 362
	HplsqlParserT_LESSEQUAL           = 363
	HplsqlParserT_MUL                 = 364
	HplsqlParserT_OPEN_B              = 365
	HplsqlParserT_OPEN_P              = 366
	HplsqlParserT_OPEN_SB             = 367
	HplsqlParserT_CLOSE_B             = 368
	HplsqlParserT_CLOSE_P             = 369
	HplsqlParserT_CLOSE_SB            = 370
	HplsqlParserT_SEMICOLON           = 371
	HplsqlParserT_SUB                 = 372
	HplsqlParserL_ID                  = 373
	HplsqlParserL_S_STRING            = 374
	HplsqlParserL_D_STRING            = 375
	HplsqlParserL_INT                 = 376
	HplsqlParserL_DEC                 = 377
	HplsqlParserL_WS                  = 378
	HplsqlParserL_M_COMMENT           = 379
	HplsqlParserL_S_COMMENT           = 380
	HplsqlParserL_FILE                = 381
	HplsqlParserL_LABEL               = 382
)

// HplsqlParser rules.
const (
	HplsqlParserRULE_program                                    = 0
	HplsqlParserRULE_block                                      = 1
	HplsqlParserRULE_begin_end_block                            = 2
	HplsqlParserRULE_single_block_stmt                          = 3
	HplsqlParserRULE_block_end                                  = 4
	HplsqlParserRULE_proc_block                                 = 5
	HplsqlParserRULE_stmt                                       = 6
	HplsqlParserRULE_semicolon_stmt                             = 7
	HplsqlParserRULE_exception_block                            = 8
	HplsqlParserRULE_exception_block_item                       = 9
	HplsqlParserRULE_null_stmt                                  = 10
	HplsqlParserRULE_expr_stmt                                  = 11
	HplsqlParserRULE_assignment_stmt                            = 12
	HplsqlParserRULE_assignment_stmt_item                       = 13
	HplsqlParserRULE_assignment_stmt_single_item                = 14
	HplsqlParserRULE_assignment_stmt_collection_item            = 15
	HplsqlParserRULE_assignment_stmt_multiple_item              = 16
	HplsqlParserRULE_assignment_stmt_select_item                = 17
	HplsqlParserRULE_allocate_cursor_stmt                       = 18
	HplsqlParserRULE_associate_locator_stmt                     = 19
	HplsqlParserRULE_begin_transaction_stmt                     = 20
	HplsqlParserRULE_break_stmt                                 = 21
	HplsqlParserRULE_call_stmt                                  = 22
	HplsqlParserRULE_declare_stmt                               = 23
	HplsqlParserRULE_declare_block                              = 24
	HplsqlParserRULE_declare_block_inplace                      = 25
	HplsqlParserRULE_declare_stmt_item                          = 26
	HplsqlParserRULE_declare_var_item                           = 27
	HplsqlParserRULE_declare_condition_item                     = 28
	HplsqlParserRULE_declare_cursor_item                        = 29
	HplsqlParserRULE_cursor_with_return                         = 30
	HplsqlParserRULE_cursor_without_return                      = 31
	HplsqlParserRULE_declare_handler_item                       = 32
	HplsqlParserRULE_declare_temporary_table_item               = 33
	HplsqlParserRULE_create_table_stmt                          = 34
	HplsqlParserRULE_create_local_temp_table_stmt               = 35
	HplsqlParserRULE_create_table_definition                    = 36
	HplsqlParserRULE_create_table_column_comment                = 37
	HplsqlParserRULE_create_table_columns                       = 38
	HplsqlParserRULE_create_table_columns_item                  = 39
	HplsqlParserRULE_column_name                                = 40
	HplsqlParserRULE_create_table_column_inline_cons            = 41
	HplsqlParserRULE_create_table_column_cons                   = 42
	HplsqlParserRULE_create_table_fk_action                     = 43
	HplsqlParserRULE_create_table_preoptions                    = 44
	HplsqlParserRULE_create_table_preoptions_item               = 45
	HplsqlParserRULE_create_table_preoptions_td_item            = 46
	HplsqlParserRULE_create_table_options                       = 47
	HplsqlParserRULE_create_table_options_item                  = 48
	HplsqlParserRULE_create_table_options_ora_item              = 49
	HplsqlParserRULE_create_table_options_db2_item              = 50
	HplsqlParserRULE_create_table_options_td_item               = 51
	HplsqlParserRULE_partition_column_name                      = 52
	HplsqlParserRULE_partition_dtype                            = 53
	HplsqlParserRULE_partition_dtype_len                        = 54
	HplsqlParserRULE_create_table_hive_partition_columns_item   = 55
	HplsqlParserRULE_create_table_hive_partition_column_comment = 56
	HplsqlParserRULE_create_table_hive_partition_columns        = 57
	HplsqlParserRULE_create_table_hive_partitiion               = 58
	HplsqlParserRULE_create_table_options_hive_comment          = 59
	HplsqlParserRULE_create_table_options_hive_item             = 60
	HplsqlParserRULE_create_table_hive_row_format               = 61
	HplsqlParserRULE_create_table_hive_row_format_fields        = 62
	HplsqlParserRULE_create_table_options_mssql_item            = 63
	HplsqlParserRULE_create_table_options_mysql_item            = 64
	HplsqlParserRULE_alter_table_stmt                           = 65
	HplsqlParserRULE_alter_table_item                           = 66
	HplsqlParserRULE_alter_table_add_constraint                 = 67
	HplsqlParserRULE_alter_table_add_constraint_item            = 68
	HplsqlParserRULE_dtype                                      = 69
	HplsqlParserRULE_dtype_len                                  = 70
	HplsqlParserRULE_dtype_attr                                 = 71
	HplsqlParserRULE_dtype_default                              = 72
	HplsqlParserRULE_create_database_stmt                       = 73
	HplsqlParserRULE_create_database_option                     = 74
	HplsqlParserRULE_create_function_stmt                       = 75
	HplsqlParserRULE_create_function_return                     = 76
	HplsqlParserRULE_create_package_stmt                        = 77
	HplsqlParserRULE_package_spec                               = 78
	HplsqlParserRULE_package_spec_item                          = 79
	HplsqlParserRULE_create_package_body_stmt                   = 80
	HplsqlParserRULE_package_body                               = 81
	HplsqlParserRULE_package_body_item                          = 82
	HplsqlParserRULE_create_procedure_stmt                      = 83
	HplsqlParserRULE_create_routine_params                      = 84
	HplsqlParserRULE_create_routine_param_item                  = 85
	HplsqlParserRULE_create_routine_options                     = 86
	HplsqlParserRULE_create_routine_option                      = 87
	HplsqlParserRULE_drop_stmt                                  = 88
	HplsqlParserRULE_end_transaction_stmt                       = 89
	HplsqlParserRULE_exec_stmt                                  = 90
	HplsqlParserRULE_if_stmt                                    = 91
	HplsqlParserRULE_if_plsql_stmt                              = 92
	HplsqlParserRULE_if_tsql_stmt                               = 93
	HplsqlParserRULE_if_bteq_stmt                               = 94
	HplsqlParserRULE_elseif_block                               = 95
	HplsqlParserRULE_else_block                                 = 96
	HplsqlParserRULE_include_stmt                               = 97
	HplsqlParserRULE_insert_stmt                                = 98
	HplsqlParserRULE_insert_stmt_cols                           = 99
	HplsqlParserRULE_insert_stmt_rows                           = 100
	HplsqlParserRULE_insert_stmt_row                            = 101
	HplsqlParserRULE_insert_directory_stmt                      = 102
	HplsqlParserRULE_exit_stmt                                  = 103
	HplsqlParserRULE_get_diag_stmt                              = 104
	HplsqlParserRULE_get_diag_stmt_item                         = 105
	HplsqlParserRULE_get_diag_stmt_exception_item               = 106
	HplsqlParserRULE_get_diag_stmt_rowcount_item                = 107
	HplsqlParserRULE_grant_stmt                                 = 108
	HplsqlParserRULE_grant_stmt_item                            = 109
	HplsqlParserRULE_leave_stmt                                 = 110
	HplsqlParserRULE_map_object_stmt                            = 111
	HplsqlParserRULE_open_stmt                                  = 112
	HplsqlParserRULE_fetch_stmt                                 = 113
	HplsqlParserRULE_fetch_limit                                = 114
	HplsqlParserRULE_collect_stats_stmt                         = 115
	HplsqlParserRULE_collect_stats_clause                       = 116
	HplsqlParserRULE_close_stmt                                 = 117
	HplsqlParserRULE_cmp_stmt                                   = 118
	HplsqlParserRULE_cmp_source                                 = 119
	HplsqlParserRULE_copy_from_local_stmt                       = 120
	HplsqlParserRULE_copy_stmt                                  = 121
	HplsqlParserRULE_copy_source                                = 122
	HplsqlParserRULE_copy_target                                = 123
	HplsqlParserRULE_copy_option                                = 124
	HplsqlParserRULE_copy_file_option                           = 125
	HplsqlParserRULE_commit_stmt                                = 126
	HplsqlParserRULE_create_index_stmt                          = 127
	HplsqlParserRULE_create_index_col                           = 128
	HplsqlParserRULE_index_storage_clause                       = 129
	HplsqlParserRULE_index_mssql_storage_clause                 = 130
	HplsqlParserRULE_print_stmt                                 = 131
	HplsqlParserRULE_quit_stmt                                  = 132
	HplsqlParserRULE_raise_stmt                                 = 133
	HplsqlParserRULE_resignal_stmt                              = 134
	HplsqlParserRULE_return_stmt                                = 135
	HplsqlParserRULE_rollback_stmt                              = 136
	HplsqlParserRULE_set_session_option                         = 137
	HplsqlParserRULE_set_current_schema_option                  = 138
	HplsqlParserRULE_set_mssql_session_option                   = 139
	HplsqlParserRULE_set_teradata_session_option                = 140
	HplsqlParserRULE_signal_stmt                                = 141
	HplsqlParserRULE_summary_stmt                               = 142
	HplsqlParserRULE_truncate_stmt                              = 143
	HplsqlParserRULE_use_stmt                                   = 144
	HplsqlParserRULE_values_into_stmt                           = 145
	HplsqlParserRULE_while_stmt                                 = 146
	HplsqlParserRULE_unconditional_loop_stmt                    = 147
	HplsqlParserRULE_for_cursor_stmt                            = 148
	HplsqlParserRULE_for_range_stmt                             = 149
	HplsqlParserRULE_label                                      = 150
	HplsqlParserRULE_using_clause                               = 151
	HplsqlParserRULE_select_stmt                                = 152
	HplsqlParserRULE_cte_select_stmt                            = 153
	HplsqlParserRULE_cte_select_stmt_item                       = 154
	HplsqlParserRULE_cte_select_cols                            = 155
	HplsqlParserRULE_fullselect_stmt                            = 156
	HplsqlParserRULE_fullselect_stmt_item                       = 157
	HplsqlParserRULE_fullselect_set_clause                      = 158
	HplsqlParserRULE_subselect_stmt                             = 159
	HplsqlParserRULE_select_list                                = 160
	HplsqlParserRULE_select_list_set                            = 161
	HplsqlParserRULE_select_list_limit                          = 162
	HplsqlParserRULE_select_list_item                           = 163
	HplsqlParserRULE_select_list_alias                          = 164
	HplsqlParserRULE_select_list_asterisk                       = 165
	HplsqlParserRULE_table_row                                  = 166
	HplsqlParserRULE_into_clause                                = 167
	HplsqlParserRULE_bulk_collect_clause                        = 168
	HplsqlParserRULE_from_clause                                = 169
	HplsqlParserRULE_from_table_clause                          = 170
	HplsqlParserRULE_from_table_name_clause                     = 171
	HplsqlParserRULE_from_subselect_clause                      = 172
	HplsqlParserRULE_from_join_clause                           = 173
	HplsqlParserRULE_from_join_type_clause                      = 174
	HplsqlParserRULE_from_table_values_clause                   = 175
	HplsqlParserRULE_from_table_values_row                      = 176
	HplsqlParserRULE_from_alias_clause                          = 177
	HplsqlParserRULE_table_name                                 = 178
	HplsqlParserRULE_where_clause                               = 179
	HplsqlParserRULE_group_by_clause                            = 180
	HplsqlParserRULE_having_clause                              = 181
	HplsqlParserRULE_qualify_clause                             = 182
	HplsqlParserRULE_order_by_clause                            = 183
	HplsqlParserRULE_select_options                             = 184
	HplsqlParserRULE_select_options_item                        = 185
	HplsqlParserRULE_update_stmt                                = 186
	HplsqlParserRULE_update_assignment                          = 187
	HplsqlParserRULE_update_table                               = 188
	HplsqlParserRULE_update_upsert                              = 189
	HplsqlParserRULE_merge_stmt                                 = 190
	HplsqlParserRULE_merge_table                                = 191
	HplsqlParserRULE_merge_condition                            = 192
	HplsqlParserRULE_merge_action                               = 193
	HplsqlParserRULE_delete_stmt                                = 194
	HplsqlParserRULE_delete_alias                               = 195
	HplsqlParserRULE_describe_stmt                              = 196
	HplsqlParserRULE_bool_expr                                  = 197
	HplsqlParserRULE_bool_expr_atom                             = 198
	HplsqlParserRULE_bool_expr_unary                            = 199
	HplsqlParserRULE_bool_expr_single_in                        = 200
	HplsqlParserRULE_bool_expr_multi_in                         = 201
	HplsqlParserRULE_bool_expr_binary                           = 202
	HplsqlParserRULE_bool_expr_logical_operator                 = 203
	HplsqlParserRULE_bool_expr_binary_operator                  = 204
	HplsqlParserRULE_expr                                       = 205
	HplsqlParserRULE_expr_atom                                  = 206
	HplsqlParserRULE_expr_interval                              = 207
	HplsqlParserRULE_interval_item                              = 208
	HplsqlParserRULE_expr_concat                                = 209
	HplsqlParserRULE_expr_concat_item                           = 210
	HplsqlParserRULE_expr_case                                  = 211
	HplsqlParserRULE_expr_case_simple                           = 212
	HplsqlParserRULE_expr_case_searched                         = 213
	HplsqlParserRULE_expr_cursor_attribute                      = 214
	HplsqlParserRULE_expr_agg_window_func                       = 215
	HplsqlParserRULE_expr_func_all_distinct                     = 216
	HplsqlParserRULE_expr_func_over_clause                      = 217
	HplsqlParserRULE_expr_func_partition_by_clause              = 218
	HplsqlParserRULE_expr_spec_func                             = 219
	HplsqlParserRULE_expr_func                                  = 220
	HplsqlParserRULE_expr_dot                                   = 221
	HplsqlParserRULE_expr_dot_method_call                       = 222
	HplsqlParserRULE_expr_dot_property_access                   = 223
	HplsqlParserRULE_expr_func_params                           = 224
	HplsqlParserRULE_func_param                                 = 225
	HplsqlParserRULE_expr_select                                = 226
	HplsqlParserRULE_expr_file                                  = 227
	HplsqlParserRULE_hive                                       = 228
	HplsqlParserRULE_hive_item                                  = 229
	HplsqlParserRULE_host                                       = 230
	HplsqlParserRULE_host_cmd                                   = 231
	HplsqlParserRULE_host_stmt                                  = 232
	HplsqlParserRULE_file_name                                  = 233
	HplsqlParserRULE_date_literal                               = 234
	HplsqlParserRULE_timestamp_literal                          = 235
	HplsqlParserRULE_ident                                      = 236
	HplsqlParserRULE_qident                                     = 237
	HplsqlParserRULE_string                                     = 238
	HplsqlParserRULE_int_number                                 = 239
	HplsqlParserRULE_dec_number                                 = 240
	HplsqlParserRULE_bool_literal                               = 241
	HplsqlParserRULE_null_const                                 = 242
	HplsqlParserRULE_non_reserved_words                         = 243
)

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	EOF() antlr.TerminalNode

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_program
	return p
}

func InitEmptyProgramContext(p *ProgramContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_program
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ProgramContext) EOF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserEOF, 0)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterProgram(s)
	}
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitProgram(s)
	}
}

func (p *HplsqlParser) Program() (localctx IProgramContext) {
	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, HplsqlParserRULE_program)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(488)
		p.Block()
	}
	{
		p.SetState(489)
		p.Match(HplsqlParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllBegin_end_block() []IBegin_end_blockContext
	Begin_end_block(i int) IBegin_end_blockContext
	AllStmt() []IStmtContext
	Stmt(i int) IStmtContext
	AllT_GO() []antlr.TerminalNode
	T_GO(i int) antlr.TerminalNode

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_block
	return p
}

func InitEmptyBlockContext(p *BlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_block
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) AllBegin_end_block() []IBegin_end_blockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBegin_end_blockContext); ok {
			len++
		}
	}

	tst := make([]IBegin_end_blockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBegin_end_blockContext); ok {
			tst[i] = t.(IBegin_end_blockContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) Begin_end_block(i int) IBegin_end_blockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBegin_end_blockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBegin_end_blockContext)
}

func (s *BlockContext) AllStmt() []IStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmtContext); ok {
			len++
		}
	}

	tst := make([]IStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmtContext); ok {
			tst[i] = t.(IStmtContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) Stmt(i int) IStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *BlockContext) AllT_GO() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_GO)
}

func (s *BlockContext) T_GO(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GO, i)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (p *HplsqlParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, HplsqlParserRULE_block)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(498)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(493)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(491)
					p.Begin_end_block()
				}

			case 2:
				{
					p.SetState(492)
					p.Stmt()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}
			p.SetState(496)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(495)
					p.Match(HplsqlParserT_GO)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(500)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBegin_end_blockContext is an interface to support dynamic dispatch.
type IBegin_end_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_BEGIN() antlr.TerminalNode
	Block() IBlockContext
	Block_end() IBlock_endContext
	Declare_block() IDeclare_blockContext
	Exception_block() IException_blockContext

	// IsBegin_end_blockContext differentiates from other interfaces.
	IsBegin_end_blockContext()
}

type Begin_end_blockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBegin_end_blockContext() *Begin_end_blockContext {
	var p = new(Begin_end_blockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_begin_end_block
	return p
}

func InitEmptyBegin_end_blockContext(p *Begin_end_blockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_begin_end_block
}

func (*Begin_end_blockContext) IsBegin_end_blockContext() {}

func NewBegin_end_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Begin_end_blockContext {
	var p = new(Begin_end_blockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_begin_end_block

	return p
}

func (s *Begin_end_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Begin_end_blockContext) T_BEGIN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BEGIN, 0)
}

func (s *Begin_end_blockContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *Begin_end_blockContext) Block_end() IBlock_endContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlock_endContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlock_endContext)
}

func (s *Begin_end_blockContext) Declare_block() IDeclare_blockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_blockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_blockContext)
}

func (s *Begin_end_blockContext) Exception_block() IException_blockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IException_blockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IException_blockContext)
}

func (s *Begin_end_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Begin_end_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Begin_end_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBegin_end_block(s)
	}
}

func (s *Begin_end_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBegin_end_block(s)
	}
}

func (p *HplsqlParser) Begin_end_block() (localctx IBegin_end_blockContext) {
	localctx = NewBegin_end_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, HplsqlParserRULE_begin_end_block)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(503)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_DECLARE {
		{
			p.SetState(502)
			p.Declare_block()
		}

	}
	{
		p.SetState(505)
		p.Match(HplsqlParserT_BEGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(506)
		p.Block()
	}
	p.SetState(508)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(507)
			p.Exception_block()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(510)
		p.Block_end()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingle_block_stmtContext is an interface to support dynamic dispatch.
type ISingle_block_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_BEGIN() antlr.TerminalNode
	Block() IBlockContext
	Block_end() IBlock_endContext
	Exception_block() IException_blockContext
	Stmt() IStmtContext
	T_SEMICOLON() antlr.TerminalNode

	// IsSingle_block_stmtContext differentiates from other interfaces.
	IsSingle_block_stmtContext()
}

type Single_block_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingle_block_stmtContext() *Single_block_stmtContext {
	var p = new(Single_block_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_single_block_stmt
	return p
}

func InitEmptySingle_block_stmtContext(p *Single_block_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_single_block_stmt
}

func (*Single_block_stmtContext) IsSingle_block_stmtContext() {}

func NewSingle_block_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Single_block_stmtContext {
	var p = new(Single_block_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_single_block_stmt

	return p
}

func (s *Single_block_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Single_block_stmtContext) T_BEGIN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BEGIN, 0)
}

func (s *Single_block_stmtContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *Single_block_stmtContext) Block_end() IBlock_endContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlock_endContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlock_endContext)
}

func (s *Single_block_stmtContext) Exception_block() IException_blockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IException_blockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IException_blockContext)
}

func (s *Single_block_stmtContext) Stmt() IStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *Single_block_stmtContext) T_SEMICOLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEMICOLON, 0)
}

func (s *Single_block_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Single_block_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Single_block_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSingle_block_stmt(s)
	}
}

func (s *Single_block_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSingle_block_stmt(s)
	}
}

func (p *HplsqlParser) Single_block_stmt() (localctx ISingle_block_stmtContext) {
	localctx = NewSingle_block_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, HplsqlParserRULE_single_block_stmt)
	p.SetState(523)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(512)
			p.Match(HplsqlParserT_BEGIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(513)
			p.Block()
		}
		p.SetState(515)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(514)
				p.Exception_block()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(517)
			p.Block_end()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(519)
			p.Stmt()
		}
		p.SetState(521)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(520)
				p.Match(HplsqlParserT_SEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlock_endContext is an interface to support dynamic dispatch.
type IBlock_endContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_END() antlr.TerminalNode

	// IsBlock_endContext differentiates from other interfaces.
	IsBlock_endContext()
}

type Block_endContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_endContext() *Block_endContext {
	var p = new(Block_endContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_block_end
	return p
}

func InitEmptyBlock_endContext(p *Block_endContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_block_end
}

func (*Block_endContext) IsBlock_endContext() {}

func NewBlock_endContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_endContext {
	var p = new(Block_endContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_block_end

	return p
}

func (s *Block_endContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_endContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *Block_endContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_endContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Block_endContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBlock_end(s)
	}
}

func (s *Block_endContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBlock_end(s)
	}
}

func (p *HplsqlParser) Block_end() (localctx IBlock_endContext) {
	localctx = NewBlock_endContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, HplsqlParserRULE_block_end)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(525)

	if !(!strings.EqualFold(p.GetTokenStream().LT(2).GetText(), "TRANSACTION")) {
		p.SetError(antlr.NewFailedPredicateException(p, "!strings.EqualFold(p.GetTokenStream().LT(2).GetText(),\"TRANSACTION\")", ""))
		goto errorExit
	}
	{
		p.SetState(526)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProc_blockContext is an interface to support dynamic dispatch.
type IProc_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Begin_end_block() IBegin_end_blockContext
	AllStmt() []IStmtContext
	Stmt(i int) IStmtContext
	T_GO() antlr.TerminalNode

	// IsProc_blockContext differentiates from other interfaces.
	IsProc_blockContext()
}

type Proc_blockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProc_blockContext() *Proc_blockContext {
	var p = new(Proc_blockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_proc_block
	return p
}

func InitEmptyProc_blockContext(p *Proc_blockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_proc_block
}

func (*Proc_blockContext) IsProc_blockContext() {}

func NewProc_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Proc_blockContext {
	var p = new(Proc_blockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_proc_block

	return p
}

func (s *Proc_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Proc_blockContext) Begin_end_block() IBegin_end_blockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBegin_end_blockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBegin_end_blockContext)
}

func (s *Proc_blockContext) AllStmt() []IStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmtContext); ok {
			len++
		}
	}

	tst := make([]IStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmtContext); ok {
			tst[i] = t.(IStmtContext)
			i++
		}
	}

	return tst
}

func (s *Proc_blockContext) Stmt(i int) IStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *Proc_blockContext) T_GO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GO, 0)
}

func (s *Proc_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Proc_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Proc_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterProc_block(s)
	}
}

func (s *Proc_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitProc_block(s)
	}
}

func (p *HplsqlParser) Proc_block() (localctx IProc_blockContext) {
	localctx = NewProc_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, HplsqlParserRULE_proc_block)
	var _alt int

	p.SetState(537)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(528)
			p.Begin_end_block()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(530)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(529)
					p.Stmt()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(532)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(535)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(534)
				p.Match(HplsqlParserT_GO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStmtContext is an interface to support dynamic dispatch.
type IStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Assignment_stmt() IAssignment_stmtContext
	Allocate_cursor_stmt() IAllocate_cursor_stmtContext
	Alter_table_stmt() IAlter_table_stmtContext
	Associate_locator_stmt() IAssociate_locator_stmtContext
	Begin_transaction_stmt() IBegin_transaction_stmtContext
	Break_stmt() IBreak_stmtContext
	Call_stmt() ICall_stmtContext
	Collect_stats_stmt() ICollect_stats_stmtContext
	Close_stmt() IClose_stmtContext
	Cmp_stmt() ICmp_stmtContext
	Copy_from_local_stmt() ICopy_from_local_stmtContext
	Copy_stmt() ICopy_stmtContext
	Commit_stmt() ICommit_stmtContext
	Create_database_stmt() ICreate_database_stmtContext
	Create_function_stmt() ICreate_function_stmtContext
	Create_index_stmt() ICreate_index_stmtContext
	Create_local_temp_table_stmt() ICreate_local_temp_table_stmtContext
	Create_package_stmt() ICreate_package_stmtContext
	Create_package_body_stmt() ICreate_package_body_stmtContext
	Create_procedure_stmt() ICreate_procedure_stmtContext
	Create_table_stmt() ICreate_table_stmtContext
	Declare_stmt() IDeclare_stmtContext
	Delete_stmt() IDelete_stmtContext
	Describe_stmt() IDescribe_stmtContext
	Drop_stmt() IDrop_stmtContext
	End_transaction_stmt() IEnd_transaction_stmtContext
	Exec_stmt() IExec_stmtContext
	Exit_stmt() IExit_stmtContext
	Fetch_stmt() IFetch_stmtContext
	For_cursor_stmt() IFor_cursor_stmtContext
	For_range_stmt() IFor_range_stmtContext
	If_stmt() IIf_stmtContext
	Include_stmt() IInclude_stmtContext
	Insert_stmt() IInsert_stmtContext
	Insert_directory_stmt() IInsert_directory_stmtContext
	Get_diag_stmt() IGet_diag_stmtContext
	Grant_stmt() IGrant_stmtContext
	Leave_stmt() ILeave_stmtContext
	Map_object_stmt() IMap_object_stmtContext
	Merge_stmt() IMerge_stmtContext
	Open_stmt() IOpen_stmtContext
	Print_stmt() IPrint_stmtContext
	Quit_stmt() IQuit_stmtContext
	Raise_stmt() IRaise_stmtContext
	Resignal_stmt() IResignal_stmtContext
	Return_stmt() IReturn_stmtContext
	Rollback_stmt() IRollback_stmtContext
	Select_stmt() ISelect_stmtContext
	Signal_stmt() ISignal_stmtContext
	Summary_stmt() ISummary_stmtContext
	Update_stmt() IUpdate_stmtContext
	Use_stmt() IUse_stmtContext
	Truncate_stmt() ITruncate_stmtContext
	Values_into_stmt() IValues_into_stmtContext
	While_stmt() IWhile_stmtContext
	Unconditional_loop_stmt() IUnconditional_loop_stmtContext
	Label() ILabelContext
	Hive() IHiveContext
	Host() IHostContext
	Null_stmt() INull_stmtContext
	Expr_stmt() IExpr_stmtContext
	Semicolon_stmt() ISemicolon_stmtContext

	// IsStmtContext differentiates from other interfaces.
	IsStmtContext()
}

type StmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmtContext() *StmtContext {
	var p = new(StmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_stmt
	return p
}

func InitEmptyStmtContext(p *StmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_stmt
}

func (*StmtContext) IsStmtContext() {}

func NewStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StmtContext {
	var p = new(StmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_stmt

	return p
}

func (s *StmtContext) GetParser() antlr.Parser { return s.parser }

func (s *StmtContext) Assignment_stmt() IAssignment_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignment_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignment_stmtContext)
}

func (s *StmtContext) Allocate_cursor_stmt() IAllocate_cursor_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAllocate_cursor_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAllocate_cursor_stmtContext)
}

func (s *StmtContext) Alter_table_stmt() IAlter_table_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_stmtContext)
}

func (s *StmtContext) Associate_locator_stmt() IAssociate_locator_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssociate_locator_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssociate_locator_stmtContext)
}

func (s *StmtContext) Begin_transaction_stmt() IBegin_transaction_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBegin_transaction_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBegin_transaction_stmtContext)
}

func (s *StmtContext) Break_stmt() IBreak_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreak_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreak_stmtContext)
}

func (s *StmtContext) Call_stmt() ICall_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICall_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICall_stmtContext)
}

func (s *StmtContext) Collect_stats_stmt() ICollect_stats_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollect_stats_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollect_stats_stmtContext)
}

func (s *StmtContext) Close_stmt() IClose_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClose_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClose_stmtContext)
}

func (s *StmtContext) Cmp_stmt() ICmp_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmp_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmp_stmtContext)
}

func (s *StmtContext) Copy_from_local_stmt() ICopy_from_local_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopy_from_local_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopy_from_local_stmtContext)
}

func (s *StmtContext) Copy_stmt() ICopy_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopy_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopy_stmtContext)
}

func (s *StmtContext) Commit_stmt() ICommit_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommit_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommit_stmtContext)
}

func (s *StmtContext) Create_database_stmt() ICreate_database_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_database_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_database_stmtContext)
}

func (s *StmtContext) Create_function_stmt() ICreate_function_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_function_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_function_stmtContext)
}

func (s *StmtContext) Create_index_stmt() ICreate_index_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_index_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_index_stmtContext)
}

func (s *StmtContext) Create_local_temp_table_stmt() ICreate_local_temp_table_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_local_temp_table_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_local_temp_table_stmtContext)
}

func (s *StmtContext) Create_package_stmt() ICreate_package_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_package_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_package_stmtContext)
}

func (s *StmtContext) Create_package_body_stmt() ICreate_package_body_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_package_body_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_package_body_stmtContext)
}

func (s *StmtContext) Create_procedure_stmt() ICreate_procedure_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_procedure_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_procedure_stmtContext)
}

func (s *StmtContext) Create_table_stmt() ICreate_table_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_stmtContext)
}

func (s *StmtContext) Declare_stmt() IDeclare_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_stmtContext)
}

func (s *StmtContext) Delete_stmt() IDelete_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelete_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelete_stmtContext)
}

func (s *StmtContext) Describe_stmt() IDescribe_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescribe_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescribe_stmtContext)
}

func (s *StmtContext) Drop_stmt() IDrop_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_stmtContext)
}

func (s *StmtContext) End_transaction_stmt() IEnd_transaction_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnd_transaction_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnd_transaction_stmtContext)
}

func (s *StmtContext) Exec_stmt() IExec_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExec_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExec_stmtContext)
}

func (s *StmtContext) Exit_stmt() IExit_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExit_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExit_stmtContext)
}

func (s *StmtContext) Fetch_stmt() IFetch_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFetch_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFetch_stmtContext)
}

func (s *StmtContext) For_cursor_stmt() IFor_cursor_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFor_cursor_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFor_cursor_stmtContext)
}

func (s *StmtContext) For_range_stmt() IFor_range_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFor_range_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFor_range_stmtContext)
}

func (s *StmtContext) If_stmt() IIf_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIf_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIf_stmtContext)
}

func (s *StmtContext) Include_stmt() IInclude_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInclude_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInclude_stmtContext)
}

func (s *StmtContext) Insert_stmt() IInsert_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_stmtContext)
}

func (s *StmtContext) Insert_directory_stmt() IInsert_directory_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_directory_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_directory_stmtContext)
}

func (s *StmtContext) Get_diag_stmt() IGet_diag_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGet_diag_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGet_diag_stmtContext)
}

func (s *StmtContext) Grant_stmt() IGrant_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrant_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrant_stmtContext)
}

func (s *StmtContext) Leave_stmt() ILeave_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILeave_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILeave_stmtContext)
}

func (s *StmtContext) Map_object_stmt() IMap_object_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMap_object_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMap_object_stmtContext)
}

func (s *StmtContext) Merge_stmt() IMerge_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMerge_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMerge_stmtContext)
}

func (s *StmtContext) Open_stmt() IOpen_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpen_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpen_stmtContext)
}

func (s *StmtContext) Print_stmt() IPrint_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrint_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrint_stmtContext)
}

func (s *StmtContext) Quit_stmt() IQuit_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuit_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuit_stmtContext)
}

func (s *StmtContext) Raise_stmt() IRaise_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRaise_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRaise_stmtContext)
}

func (s *StmtContext) Resignal_stmt() IResignal_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResignal_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResignal_stmtContext)
}

func (s *StmtContext) Return_stmt() IReturn_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturn_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturn_stmtContext)
}

func (s *StmtContext) Rollback_stmt() IRollback_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollback_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollback_stmtContext)
}

func (s *StmtContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *StmtContext) Signal_stmt() ISignal_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignal_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignal_stmtContext)
}

func (s *StmtContext) Summary_stmt() ISummary_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISummary_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISummary_stmtContext)
}

func (s *StmtContext) Update_stmt() IUpdate_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdate_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdate_stmtContext)
}

func (s *StmtContext) Use_stmt() IUse_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUse_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUse_stmtContext)
}

func (s *StmtContext) Truncate_stmt() ITruncate_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITruncate_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITruncate_stmtContext)
}

func (s *StmtContext) Values_into_stmt() IValues_into_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValues_into_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValues_into_stmtContext)
}

func (s *StmtContext) While_stmt() IWhile_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhile_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhile_stmtContext)
}

func (s *StmtContext) Unconditional_loop_stmt() IUnconditional_loop_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnconditional_loop_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnconditional_loop_stmtContext)
}

func (s *StmtContext) Label() ILabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *StmtContext) Hive() IHiveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHiveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHiveContext)
}

func (s *StmtContext) Host() IHostContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHostContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHostContext)
}

func (s *StmtContext) Null_stmt() INull_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INull_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INull_stmtContext)
}

func (s *StmtContext) Expr_stmt() IExpr_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_stmtContext)
}

func (s *StmtContext) Semicolon_stmt() ISemicolon_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISemicolon_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISemicolon_stmtContext)
}

func (s *StmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterStmt(s)
	}
}

func (s *StmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitStmt(s)
	}
}

func (p *HplsqlParser) Stmt() (localctx IStmtContext) {
	localctx = NewStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, HplsqlParserRULE_stmt)
	p.SetState(601)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(539)
			p.Assignment_stmt()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(540)
			p.Allocate_cursor_stmt()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(541)
			p.Alter_table_stmt()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(542)
			p.Associate_locator_stmt()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(543)
			p.Begin_transaction_stmt()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(544)
			p.Break_stmt()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(545)
			p.Call_stmt()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(546)
			p.Collect_stats_stmt()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(547)
			p.Close_stmt()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(548)
			p.Cmp_stmt()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(549)
			p.Copy_from_local_stmt()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(550)
			p.Copy_stmt()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(551)
			p.Commit_stmt()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(552)
			p.Create_database_stmt()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(553)
			p.Create_function_stmt()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(554)
			p.Create_index_stmt()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(555)
			p.Create_local_temp_table_stmt()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(556)
			p.Create_package_stmt()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(557)
			p.Create_package_body_stmt()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(558)
			p.Create_procedure_stmt()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(559)
			p.Create_table_stmt()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(560)
			p.Declare_stmt()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(561)
			p.Delete_stmt()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(562)
			p.Describe_stmt()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(563)
			p.Drop_stmt()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(564)
			p.End_transaction_stmt()
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(565)
			p.Exec_stmt()
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(566)
			p.Exit_stmt()
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(567)
			p.Fetch_stmt()
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(568)
			p.For_cursor_stmt()
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(569)
			p.For_range_stmt()
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(570)
			p.If_stmt()
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(571)
			p.Include_stmt()
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(572)
			p.Insert_stmt()
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(573)
			p.Insert_directory_stmt()
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(574)
			p.Get_diag_stmt()
		}

	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(575)
			p.Grant_stmt()
		}

	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(576)
			p.Leave_stmt()
		}

	case 39:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(577)
			p.Map_object_stmt()
		}

	case 40:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(578)
			p.Merge_stmt()
		}

	case 41:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(579)
			p.Open_stmt()
		}

	case 42:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(580)
			p.Print_stmt()
		}

	case 43:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(581)
			p.Quit_stmt()
		}

	case 44:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(582)
			p.Raise_stmt()
		}

	case 45:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(583)
			p.Resignal_stmt()
		}

	case 46:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(584)
			p.Return_stmt()
		}

	case 47:
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(585)
			p.Rollback_stmt()
		}

	case 48:
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(586)
			p.Select_stmt()
		}

	case 49:
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(587)
			p.Signal_stmt()
		}

	case 50:
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(588)
			p.Summary_stmt()
		}

	case 51:
		p.EnterOuterAlt(localctx, 51)
		{
			p.SetState(589)
			p.Update_stmt()
		}

	case 52:
		p.EnterOuterAlt(localctx, 52)
		{
			p.SetState(590)
			p.Use_stmt()
		}

	case 53:
		p.EnterOuterAlt(localctx, 53)
		{
			p.SetState(591)
			p.Truncate_stmt()
		}

	case 54:
		p.EnterOuterAlt(localctx, 54)
		{
			p.SetState(592)
			p.Values_into_stmt()
		}

	case 55:
		p.EnterOuterAlt(localctx, 55)
		{
			p.SetState(593)
			p.While_stmt()
		}

	case 56:
		p.EnterOuterAlt(localctx, 56)
		{
			p.SetState(594)
			p.Unconditional_loop_stmt()
		}

	case 57:
		p.EnterOuterAlt(localctx, 57)
		{
			p.SetState(595)
			p.Label()
		}

	case 58:
		p.EnterOuterAlt(localctx, 58)
		{
			p.SetState(596)
			p.Hive()
		}

	case 59:
		p.EnterOuterAlt(localctx, 59)
		{
			p.SetState(597)
			p.Host()
		}

	case 60:
		p.EnterOuterAlt(localctx, 60)
		{
			p.SetState(598)
			p.Null_stmt()
		}

	case 61:
		p.EnterOuterAlt(localctx, 61)
		{
			p.SetState(599)
			p.Expr_stmt()
		}

	case 62:
		p.EnterOuterAlt(localctx, 62)
		{
			p.SetState(600)
			p.Semicolon_stmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISemicolon_stmtContext is an interface to support dynamic dispatch.
type ISemicolon_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_SEMICOLON() antlr.TerminalNode
	T_DIV() antlr.TerminalNode

	// IsSemicolon_stmtContext differentiates from other interfaces.
	IsSemicolon_stmtContext()
}

type Semicolon_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySemicolon_stmtContext() *Semicolon_stmtContext {
	var p = new(Semicolon_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_semicolon_stmt
	return p
}

func InitEmptySemicolon_stmtContext(p *Semicolon_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_semicolon_stmt
}

func (*Semicolon_stmtContext) IsSemicolon_stmtContext() {}

func NewSemicolon_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Semicolon_stmtContext {
	var p = new(Semicolon_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_semicolon_stmt

	return p
}

func (s *Semicolon_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Semicolon_stmtContext) T_SEMICOLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEMICOLON, 0)
}

func (s *Semicolon_stmtContext) T_DIV() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DIV, 0)
}

func (s *Semicolon_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Semicolon_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Semicolon_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSemicolon_stmt(s)
	}
}

func (s *Semicolon_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSemicolon_stmt(s)
	}
}

func (p *HplsqlParser) Semicolon_stmt() (localctx ISemicolon_stmtContext) {
	localctx = NewSemicolon_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, HplsqlParserRULE_semicolon_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(603)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT__0 || _la == HplsqlParserT__1 || _la == HplsqlParserT_DIV || _la == HplsqlParserT_SEMICOLON) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IException_blockContext is an interface to support dynamic dispatch.
type IException_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_EXCEPTION() antlr.TerminalNode
	AllException_block_item() []IException_block_itemContext
	Exception_block_item(i int) IException_block_itemContext

	// IsException_blockContext differentiates from other interfaces.
	IsException_blockContext()
}

type Exception_blockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyException_blockContext() *Exception_blockContext {
	var p = new(Exception_blockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_exception_block
	return p
}

func InitEmptyException_blockContext(p *Exception_blockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_exception_block
}

func (*Exception_blockContext) IsException_blockContext() {}

func NewException_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exception_blockContext {
	var p = new(Exception_blockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_exception_block

	return p
}

func (s *Exception_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Exception_blockContext) T_EXCEPTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXCEPTION, 0)
}

func (s *Exception_blockContext) AllException_block_item() []IException_block_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IException_block_itemContext); ok {
			len++
		}
	}

	tst := make([]IException_block_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IException_block_itemContext); ok {
			tst[i] = t.(IException_block_itemContext)
			i++
		}
	}

	return tst
}

func (s *Exception_blockContext) Exception_block_item(i int) IException_block_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IException_block_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IException_block_itemContext)
}

func (s *Exception_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exception_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Exception_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterException_block(s)
	}
}

func (s *Exception_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitException_block(s)
	}
}

func (p *HplsqlParser) Exception_block() (localctx IException_blockContext) {
	localctx = NewException_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, HplsqlParserRULE_exception_block)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(605)
		p.Match(HplsqlParserT_EXCEPTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(607)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(606)
				p.Exception_block_item()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(609)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IException_block_itemContext is an interface to support dynamic dispatch.
type IException_block_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllT_WHEN() []antlr.TerminalNode
	T_WHEN(i int) antlr.TerminalNode
	L_ID() antlr.TerminalNode
	T_THEN() antlr.TerminalNode
	Block() IBlockContext
	T_END() antlr.TerminalNode

	// IsException_block_itemContext differentiates from other interfaces.
	IsException_block_itemContext()
}

type Exception_block_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyException_block_itemContext() *Exception_block_itemContext {
	var p = new(Exception_block_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_exception_block_item
	return p
}

func InitEmptyException_block_itemContext(p *Exception_block_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_exception_block_item
}

func (*Exception_block_itemContext) IsException_block_itemContext() {}

func NewException_block_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exception_block_itemContext {
	var p = new(Exception_block_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_exception_block_item

	return p
}

func (s *Exception_block_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Exception_block_itemContext) AllT_WHEN() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_WHEN)
}

func (s *Exception_block_itemContext) T_WHEN(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WHEN, i)
}

func (s *Exception_block_itemContext) L_ID() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, 0)
}

func (s *Exception_block_itemContext) T_THEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_THEN, 0)
}

func (s *Exception_block_itemContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *Exception_block_itemContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *Exception_block_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exception_block_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Exception_block_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterException_block_item(s)
	}
}

func (s *Exception_block_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitException_block_item(s)
	}
}

func (p *HplsqlParser) Exception_block_item() (localctx IException_block_itemContext) {
	localctx = NewException_block_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, HplsqlParserRULE_exception_block_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(611)
		p.Match(HplsqlParserT_WHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(612)
		p.Match(HplsqlParserL_ID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(613)
		p.Match(HplsqlParserT_THEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(614)
		p.Block()
	}
	{
		p.SetState(615)
		_la = p.GetTokenStream().LA(1)

		if _la <= 0 || _la == HplsqlParserT_END || _la == HplsqlParserT_WHEN {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INull_stmtContext is an interface to support dynamic dispatch.
type INull_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_NULL() antlr.TerminalNode

	// IsNull_stmtContext differentiates from other interfaces.
	IsNull_stmtContext()
}

type Null_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNull_stmtContext() *Null_stmtContext {
	var p = new(Null_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_null_stmt
	return p
}

func InitEmptyNull_stmtContext(p *Null_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_null_stmt
}

func (*Null_stmtContext) IsNull_stmtContext() {}

func NewNull_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Null_stmtContext {
	var p = new(Null_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_null_stmt

	return p
}

func (s *Null_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Null_stmtContext) T_NULL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NULL, 0)
}

func (s *Null_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Null_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Null_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterNull_stmt(s)
	}
}

func (s *Null_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitNull_stmt(s)
	}
}

func (p *HplsqlParser) Null_stmt() (localctx INull_stmtContext) {
	localctx = NewNull_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, HplsqlParserRULE_null_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(617)
		p.Match(HplsqlParserT_NULL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_stmtContext is an interface to support dynamic dispatch.
type IExpr_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext

	// IsExpr_stmtContext differentiates from other interfaces.
	IsExpr_stmtContext()
}

type Expr_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_stmtContext() *Expr_stmtContext {
	var p = new(Expr_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_stmt
	return p
}

func InitEmptyExpr_stmtContext(p *Expr_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_stmt
}

func (*Expr_stmtContext) IsExpr_stmtContext() {}

func NewExpr_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_stmtContext {
	var p = new(Expr_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_stmt

	return p
}

func (s *Expr_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_stmt(s)
	}
}

func (s *Expr_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_stmt(s)
	}
}

func (p *HplsqlParser) Expr_stmt() (localctx IExpr_stmtContext) {
	localctx = NewExpr_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, HplsqlParserRULE_expr_stmt)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(619)

	if !(!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "GO")) {
		p.SetError(antlr.NewFailedPredicateException(p, "!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"GO\")", ""))
		goto errorExit
	}
	{
		p.SetState(620)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignment_stmtContext is an interface to support dynamic dispatch.
type IAssignment_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_SET() antlr.TerminalNode
	Set_session_option() ISet_session_optionContext
	AllAssignment_stmt_item() []IAssignment_stmt_itemContext
	Assignment_stmt_item(i int) IAssignment_stmt_itemContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsAssignment_stmtContext differentiates from other interfaces.
	IsAssignment_stmtContext()
}

type Assignment_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_stmtContext() *Assignment_stmtContext {
	var p = new(Assignment_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt
	return p
}

func InitEmptyAssignment_stmtContext(p *Assignment_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt
}

func (*Assignment_stmtContext) IsAssignment_stmtContext() {}

func NewAssignment_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_stmtContext {
	var p = new(Assignment_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_assignment_stmt

	return p
}

func (s *Assignment_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_stmtContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Assignment_stmtContext) Set_session_option() ISet_session_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_session_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_session_optionContext)
}

func (s *Assignment_stmtContext) AllAssignment_stmt_item() []IAssignment_stmt_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignment_stmt_itemContext); ok {
			len++
		}
	}

	tst := make([]IAssignment_stmt_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignment_stmt_itemContext); ok {
			tst[i] = t.(IAssignment_stmt_itemContext)
			i++
		}
	}

	return tst
}

func (s *Assignment_stmtContext) Assignment_stmt_item(i int) IAssignment_stmt_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignment_stmt_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignment_stmt_itemContext)
}

func (s *Assignment_stmtContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Assignment_stmtContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Assignment_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assignment_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAssignment_stmt(s)
	}
}

func (s *Assignment_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAssignment_stmt(s)
	}
}

func (p *HplsqlParser) Assignment_stmt() (localctx IAssignment_stmtContext) {
	localctx = NewAssignment_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, HplsqlParserRULE_assignment_stmt)
	var _alt int

	p.SetState(635)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(622)
			p.Match(HplsqlParserT_SET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(623)
			p.Set_session_option()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(625)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(624)
				p.Match(HplsqlParserT_SET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(627)
			p.Assignment_stmt_item()
		}
		p.SetState(632)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(628)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(629)
					p.Assignment_stmt_item()
				}

			}
			p.SetState(634)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignment_stmt_itemContext is an interface to support dynamic dispatch.
type IAssignment_stmt_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Assignment_stmt_single_item() IAssignment_stmt_single_itemContext
	Assignment_stmt_multiple_item() IAssignment_stmt_multiple_itemContext
	Assignment_stmt_select_item() IAssignment_stmt_select_itemContext
	Assignment_stmt_collection_item() IAssignment_stmt_collection_itemContext

	// IsAssignment_stmt_itemContext differentiates from other interfaces.
	IsAssignment_stmt_itemContext()
}

type Assignment_stmt_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_stmt_itemContext() *Assignment_stmt_itemContext {
	var p = new(Assignment_stmt_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_item
	return p
}

func InitEmptyAssignment_stmt_itemContext(p *Assignment_stmt_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_item
}

func (*Assignment_stmt_itemContext) IsAssignment_stmt_itemContext() {}

func NewAssignment_stmt_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_stmt_itemContext {
	var p = new(Assignment_stmt_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_item

	return p
}

func (s *Assignment_stmt_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_stmt_itemContext) Assignment_stmt_single_item() IAssignment_stmt_single_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignment_stmt_single_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignment_stmt_single_itemContext)
}

func (s *Assignment_stmt_itemContext) Assignment_stmt_multiple_item() IAssignment_stmt_multiple_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignment_stmt_multiple_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignment_stmt_multiple_itemContext)
}

func (s *Assignment_stmt_itemContext) Assignment_stmt_select_item() IAssignment_stmt_select_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignment_stmt_select_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignment_stmt_select_itemContext)
}

func (s *Assignment_stmt_itemContext) Assignment_stmt_collection_item() IAssignment_stmt_collection_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignment_stmt_collection_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignment_stmt_collection_itemContext)
}

func (s *Assignment_stmt_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_stmt_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assignment_stmt_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAssignment_stmt_item(s)
	}
}

func (s *Assignment_stmt_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAssignment_stmt_item(s)
	}
}

func (p *HplsqlParser) Assignment_stmt_item() (localctx IAssignment_stmt_itemContext) {
	localctx = NewAssignment_stmt_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, HplsqlParserRULE_assignment_stmt_item)
	p.SetState(641)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(637)
			p.Assignment_stmt_single_item()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(638)
			p.Assignment_stmt_multiple_item()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(639)
			p.Assignment_stmt_select_item()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(640)
			p.Assignment_stmt_collection_item()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignment_stmt_single_itemContext is an interface to support dynamic dispatch.
type IAssignment_stmt_single_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Qident() IQidentContext
	T_EQUAL() antlr.TerminalNode
	Expr() IExprContext
	T_COLON() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode

	// IsAssignment_stmt_single_itemContext differentiates from other interfaces.
	IsAssignment_stmt_single_itemContext()
}

type Assignment_stmt_single_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_stmt_single_itemContext() *Assignment_stmt_single_itemContext {
	var p = new(Assignment_stmt_single_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_single_item
	return p
}

func InitEmptyAssignment_stmt_single_itemContext(p *Assignment_stmt_single_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_single_item
}

func (*Assignment_stmt_single_itemContext) IsAssignment_stmt_single_itemContext() {}

func NewAssignment_stmt_single_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_stmt_single_itemContext {
	var p = new(Assignment_stmt_single_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_single_item

	return p
}

func (s *Assignment_stmt_single_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_stmt_single_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Assignment_stmt_single_itemContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Assignment_stmt_single_itemContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Assignment_stmt_single_itemContext) T_COLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLON, 0)
}

func (s *Assignment_stmt_single_itemContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Assignment_stmt_single_itemContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Assignment_stmt_single_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_stmt_single_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assignment_stmt_single_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAssignment_stmt_single_item(s)
	}
}

func (s *Assignment_stmt_single_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAssignment_stmt_single_item(s)
	}
}

func (p *HplsqlParser) Assignment_stmt_single_item() (localctx IAssignment_stmt_single_itemContext) {
	localctx = NewAssignment_stmt_single_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, HplsqlParserRULE_assignment_stmt_single_item)
	var _la int

	p.SetState(659)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_SUB, HplsqlParserL_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(643)
			p.Qident()
		}
		p.SetState(645)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_COLON {
			{
				p.SetState(644)
				p.Match(HplsqlParserT_COLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(647)
			p.Match(HplsqlParserT_EQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(648)
			p.expr(0)
		}

	case HplsqlParserT_OPEN_P:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(650)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(651)
			p.Qident()
		}
		{
			p.SetState(652)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(654)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_COLON {
			{
				p.SetState(653)
				p.Match(HplsqlParserT_COLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(656)
			p.Match(HplsqlParserT_EQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(657)
			p.expr(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignment_stmt_collection_itemContext is an interface to support dynamic dispatch.
type IAssignment_stmt_collection_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr_func() IExpr_funcContext
	T_COLON() antlr.TerminalNode
	T_EQUAL() antlr.TerminalNode
	Expr() IExprContext

	// IsAssignment_stmt_collection_itemContext differentiates from other interfaces.
	IsAssignment_stmt_collection_itemContext()
}

type Assignment_stmt_collection_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_stmt_collection_itemContext() *Assignment_stmt_collection_itemContext {
	var p = new(Assignment_stmt_collection_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_collection_item
	return p
}

func InitEmptyAssignment_stmt_collection_itemContext(p *Assignment_stmt_collection_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_collection_item
}

func (*Assignment_stmt_collection_itemContext) IsAssignment_stmt_collection_itemContext() {}

func NewAssignment_stmt_collection_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_stmt_collection_itemContext {
	var p = new(Assignment_stmt_collection_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_collection_item

	return p
}

func (s *Assignment_stmt_collection_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_stmt_collection_itemContext) Expr_func() IExpr_funcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_funcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_funcContext)
}

func (s *Assignment_stmt_collection_itemContext) T_COLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLON, 0)
}

func (s *Assignment_stmt_collection_itemContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Assignment_stmt_collection_itemContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Assignment_stmt_collection_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_stmt_collection_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assignment_stmt_collection_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAssignment_stmt_collection_item(s)
	}
}

func (s *Assignment_stmt_collection_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAssignment_stmt_collection_item(s)
	}
}

func (p *HplsqlParser) Assignment_stmt_collection_item() (localctx IAssignment_stmt_collection_itemContext) {
	localctx = NewAssignment_stmt_collection_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, HplsqlParserRULE_assignment_stmt_collection_item)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(661)
		p.Expr_func()
	}
	{
		p.SetState(662)
		p.Match(HplsqlParserT_COLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(663)
		p.Match(HplsqlParserT_EQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(664)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignment_stmt_multiple_itemContext is an interface to support dynamic dispatch.
type IAssignment_stmt_multiple_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllT_OPEN_P() []antlr.TerminalNode
	T_OPEN_P(i int) antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	AllT_CLOSE_P() []antlr.TerminalNode
	T_CLOSE_P(i int) antlr.TerminalNode
	T_EQUAL() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	T_COLON() antlr.TerminalNode

	// IsAssignment_stmt_multiple_itemContext differentiates from other interfaces.
	IsAssignment_stmt_multiple_itemContext()
}

type Assignment_stmt_multiple_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_stmt_multiple_itemContext() *Assignment_stmt_multiple_itemContext {
	var p = new(Assignment_stmt_multiple_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_multiple_item
	return p
}

func InitEmptyAssignment_stmt_multiple_itemContext(p *Assignment_stmt_multiple_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_multiple_item
}

func (*Assignment_stmt_multiple_itemContext) IsAssignment_stmt_multiple_itemContext() {}

func NewAssignment_stmt_multiple_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_stmt_multiple_itemContext {
	var p = new(Assignment_stmt_multiple_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_multiple_item

	return p
}

func (s *Assignment_stmt_multiple_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_stmt_multiple_itemContext) AllT_OPEN_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_OPEN_P)
}

func (s *Assignment_stmt_multiple_itemContext) T_OPEN_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, i)
}

func (s *Assignment_stmt_multiple_itemContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Assignment_stmt_multiple_itemContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Assignment_stmt_multiple_itemContext) AllT_CLOSE_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_CLOSE_P)
}

func (s *Assignment_stmt_multiple_itemContext) T_CLOSE_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, i)
}

func (s *Assignment_stmt_multiple_itemContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Assignment_stmt_multiple_itemContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Assignment_stmt_multiple_itemContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Assignment_stmt_multiple_itemContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Assignment_stmt_multiple_itemContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Assignment_stmt_multiple_itemContext) T_COLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLON, 0)
}

func (s *Assignment_stmt_multiple_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_stmt_multiple_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assignment_stmt_multiple_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAssignment_stmt_multiple_item(s)
	}
}

func (s *Assignment_stmt_multiple_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAssignment_stmt_multiple_item(s)
	}
}

func (p *HplsqlParser) Assignment_stmt_multiple_item() (localctx IAssignment_stmt_multiple_itemContext) {
	localctx = NewAssignment_stmt_multiple_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, HplsqlParserRULE_assignment_stmt_multiple_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(666)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(667)
		p.Ident()
	}
	p.SetState(672)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(668)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(669)
			p.Ident()
		}

		p.SetState(674)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(675)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(677)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_COLON {
		{
			p.SetState(676)
			p.Match(HplsqlParserT_COLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(679)
		p.Match(HplsqlParserT_EQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(680)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(681)
		p.expr(0)
	}
	p.SetState(686)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(682)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(683)
			p.expr(0)
		}

		p.SetState(688)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(689)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignment_stmt_select_itemContext is an interface to support dynamic dispatch.
type IAssignment_stmt_select_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_EQUAL() antlr.TerminalNode
	AllT_OPEN_P() []antlr.TerminalNode
	T_OPEN_P(i int) antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	AllT_CLOSE_P() []antlr.TerminalNode
	T_CLOSE_P(i int) antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	T_COLON() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsAssignment_stmt_select_itemContext differentiates from other interfaces.
	IsAssignment_stmt_select_itemContext()
}

type Assignment_stmt_select_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_stmt_select_itemContext() *Assignment_stmt_select_itemContext {
	var p = new(Assignment_stmt_select_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_select_item
	return p
}

func InitEmptyAssignment_stmt_select_itemContext(p *Assignment_stmt_select_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_select_item
}

func (*Assignment_stmt_select_itemContext) IsAssignment_stmt_select_itemContext() {}

func NewAssignment_stmt_select_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_stmt_select_itemContext {
	var p = new(Assignment_stmt_select_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_select_item

	return p
}

func (s *Assignment_stmt_select_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_stmt_select_itemContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Assignment_stmt_select_itemContext) AllT_OPEN_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_OPEN_P)
}

func (s *Assignment_stmt_select_itemContext) T_OPEN_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, i)
}

func (s *Assignment_stmt_select_itemContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Assignment_stmt_select_itemContext) AllT_CLOSE_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_CLOSE_P)
}

func (s *Assignment_stmt_select_itemContext) T_CLOSE_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, i)
}

func (s *Assignment_stmt_select_itemContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Assignment_stmt_select_itemContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Assignment_stmt_select_itemContext) T_COLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLON, 0)
}

func (s *Assignment_stmt_select_itemContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Assignment_stmt_select_itemContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Assignment_stmt_select_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_stmt_select_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assignment_stmt_select_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAssignment_stmt_select_item(s)
	}
}

func (s *Assignment_stmt_select_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAssignment_stmt_select_item(s)
	}
}

func (p *HplsqlParser) Assignment_stmt_select_item() (localctx IAssignment_stmt_select_itemContext) {
	localctx = NewAssignment_stmt_select_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, HplsqlParserRULE_assignment_stmt_select_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(703)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_SUB, HplsqlParserL_ID:
		{
			p.SetState(691)
			p.Ident()
		}

	case HplsqlParserT_OPEN_P:
		{
			p.SetState(692)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(693)
			p.Ident()
		}
		p.SetState(698)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(694)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(695)
				p.Ident()
			}

			p.SetState(700)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(701)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(706)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_COLON {
		{
			p.SetState(705)
			p.Match(HplsqlParserT_COLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(708)
		p.Match(HplsqlParserT_EQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(709)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(710)
		p.Select_stmt()
	}
	{
		p.SetState(711)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAllocate_cursor_stmtContext is an interface to support dynamic dispatch.
type IAllocate_cursor_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ALLOCATE() antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	T_CURSOR() antlr.TerminalNode
	T_FOR() antlr.TerminalNode
	T_PROCEDURE() antlr.TerminalNode
	T_RESULT() antlr.TerminalNode
	T_SET() antlr.TerminalNode

	// IsAllocate_cursor_stmtContext differentiates from other interfaces.
	IsAllocate_cursor_stmtContext()
}

type Allocate_cursor_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAllocate_cursor_stmtContext() *Allocate_cursor_stmtContext {
	var p = new(Allocate_cursor_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_allocate_cursor_stmt
	return p
}

func InitEmptyAllocate_cursor_stmtContext(p *Allocate_cursor_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_allocate_cursor_stmt
}

func (*Allocate_cursor_stmtContext) IsAllocate_cursor_stmtContext() {}

func NewAllocate_cursor_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Allocate_cursor_stmtContext {
	var p = new(Allocate_cursor_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_allocate_cursor_stmt

	return p
}

func (s *Allocate_cursor_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Allocate_cursor_stmtContext) T_ALLOCATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALLOCATE, 0)
}

func (s *Allocate_cursor_stmtContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Allocate_cursor_stmtContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Allocate_cursor_stmtContext) T_CURSOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURSOR, 0)
}

func (s *Allocate_cursor_stmtContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *Allocate_cursor_stmtContext) T_PROCEDURE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PROCEDURE, 0)
}

func (s *Allocate_cursor_stmtContext) T_RESULT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESULT, 0)
}

func (s *Allocate_cursor_stmtContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Allocate_cursor_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Allocate_cursor_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Allocate_cursor_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAllocate_cursor_stmt(s)
	}
}

func (s *Allocate_cursor_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAllocate_cursor_stmt(s)
	}
}

func (p *HplsqlParser) Allocate_cursor_stmt() (localctx IAllocate_cursor_stmtContext) {
	localctx = NewAllocate_cursor_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, HplsqlParserRULE_allocate_cursor_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(713)
		p.Match(HplsqlParserT_ALLOCATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(714)
		p.Ident()
	}
	{
		p.SetState(715)
		p.Match(HplsqlParserT_CURSOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(716)
		p.Match(HplsqlParserT_FOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(720)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_RESULT:
		{
			p.SetState(717)
			p.Match(HplsqlParserT_RESULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(718)
			p.Match(HplsqlParserT_SET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_PROCEDURE:
		{
			p.SetState(719)
			p.Match(HplsqlParserT_PROCEDURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(722)
		p.Ident()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssociate_locator_stmtContext is an interface to support dynamic dispatch.
type IAssociate_locator_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ASSOCIATE() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	T_CLOSE_P() antlr.TerminalNode
	T_WITH() antlr.TerminalNode
	T_PROCEDURE() antlr.TerminalNode
	T_LOCATOR() antlr.TerminalNode
	T_LOCATORS() antlr.TerminalNode
	T_RESULT() antlr.TerminalNode
	T_SET() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsAssociate_locator_stmtContext differentiates from other interfaces.
	IsAssociate_locator_stmtContext()
}

type Associate_locator_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssociate_locator_stmtContext() *Associate_locator_stmtContext {
	var p = new(Associate_locator_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_associate_locator_stmt
	return p
}

func InitEmptyAssociate_locator_stmtContext(p *Associate_locator_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_associate_locator_stmt
}

func (*Associate_locator_stmtContext) IsAssociate_locator_stmtContext() {}

func NewAssociate_locator_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Associate_locator_stmtContext {
	var p = new(Associate_locator_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_associate_locator_stmt

	return p
}

func (s *Associate_locator_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Associate_locator_stmtContext) T_ASSOCIATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ASSOCIATE, 0)
}

func (s *Associate_locator_stmtContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Associate_locator_stmtContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Associate_locator_stmtContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Associate_locator_stmtContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Associate_locator_stmtContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITH, 0)
}

func (s *Associate_locator_stmtContext) T_PROCEDURE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PROCEDURE, 0)
}

func (s *Associate_locator_stmtContext) T_LOCATOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCATOR, 0)
}

func (s *Associate_locator_stmtContext) T_LOCATORS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCATORS, 0)
}

func (s *Associate_locator_stmtContext) T_RESULT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESULT, 0)
}

func (s *Associate_locator_stmtContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Associate_locator_stmtContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Associate_locator_stmtContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Associate_locator_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Associate_locator_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Associate_locator_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAssociate_locator_stmt(s)
	}
}

func (s *Associate_locator_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAssociate_locator_stmt(s)
	}
}

func (p *HplsqlParser) Associate_locator_stmt() (localctx IAssociate_locator_stmtContext) {
	localctx = NewAssociate_locator_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, HplsqlParserRULE_associate_locator_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(724)
		p.Match(HplsqlParserT_ASSOCIATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(727)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_RESULT {
		{
			p.SetState(725)
			p.Match(HplsqlParserT_RESULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(726)
			p.Match(HplsqlParserT_SET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(729)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_LOCATOR || _la == HplsqlParserT_LOCATORS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(730)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(731)
		p.Ident()
	}
	p.SetState(736)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(732)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(733)
			p.Ident()
		}

		p.SetState(738)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(739)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(740)
		p.Match(HplsqlParserT_WITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(741)
		p.Match(HplsqlParserT_PROCEDURE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(742)
		p.Ident()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBegin_transaction_stmtContext is an interface to support dynamic dispatch.
type IBegin_transaction_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_BEGIN() antlr.TerminalNode
	T_TRANSACTION() antlr.TerminalNode

	// IsBegin_transaction_stmtContext differentiates from other interfaces.
	IsBegin_transaction_stmtContext()
}

type Begin_transaction_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBegin_transaction_stmtContext() *Begin_transaction_stmtContext {
	var p = new(Begin_transaction_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_begin_transaction_stmt
	return p
}

func InitEmptyBegin_transaction_stmtContext(p *Begin_transaction_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_begin_transaction_stmt
}

func (*Begin_transaction_stmtContext) IsBegin_transaction_stmtContext() {}

func NewBegin_transaction_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Begin_transaction_stmtContext {
	var p = new(Begin_transaction_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_begin_transaction_stmt

	return p
}

func (s *Begin_transaction_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Begin_transaction_stmtContext) T_BEGIN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BEGIN, 0)
}

func (s *Begin_transaction_stmtContext) T_TRANSACTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TRANSACTION, 0)
}

func (s *Begin_transaction_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Begin_transaction_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Begin_transaction_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBegin_transaction_stmt(s)
	}
}

func (s *Begin_transaction_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBegin_transaction_stmt(s)
	}
}

func (p *HplsqlParser) Begin_transaction_stmt() (localctx IBegin_transaction_stmtContext) {
	localctx = NewBegin_transaction_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, HplsqlParserRULE_begin_transaction_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(744)
		p.Match(HplsqlParserT_BEGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(745)
		p.Match(HplsqlParserT_TRANSACTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBreak_stmtContext is an interface to support dynamic dispatch.
type IBreak_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_BREAK() antlr.TerminalNode

	// IsBreak_stmtContext differentiates from other interfaces.
	IsBreak_stmtContext()
}

type Break_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreak_stmtContext() *Break_stmtContext {
	var p = new(Break_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_break_stmt
	return p
}

func InitEmptyBreak_stmtContext(p *Break_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_break_stmt
}

func (*Break_stmtContext) IsBreak_stmtContext() {}

func NewBreak_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Break_stmtContext {
	var p = new(Break_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_break_stmt

	return p
}

func (s *Break_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Break_stmtContext) T_BREAK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BREAK, 0)
}

func (s *Break_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Break_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Break_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBreak_stmt(s)
	}
}

func (s *Break_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBreak_stmt(s)
	}
}

func (p *HplsqlParser) Break_stmt() (localctx IBreak_stmtContext) {
	localctx = NewBreak_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, HplsqlParserRULE_break_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(747)
		p.Match(HplsqlParserT_BREAK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICall_stmtContext is an interface to support dynamic dispatch.
type ICall_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_CALL() antlr.TerminalNode
	Expr_dot() IExpr_dotContext
	Expr_func() IExpr_funcContext
	Ident() IIdentContext

	// IsCall_stmtContext differentiates from other interfaces.
	IsCall_stmtContext()
}

type Call_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCall_stmtContext() *Call_stmtContext {
	var p = new(Call_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_call_stmt
	return p
}

func InitEmptyCall_stmtContext(p *Call_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_call_stmt
}

func (*Call_stmtContext) IsCall_stmtContext() {}

func NewCall_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Call_stmtContext {
	var p = new(Call_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_call_stmt

	return p
}

func (s *Call_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Call_stmtContext) T_CALL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CALL, 0)
}

func (s *Call_stmtContext) Expr_dot() IExpr_dotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_dotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_dotContext)
}

func (s *Call_stmtContext) Expr_func() IExpr_funcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_funcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_funcContext)
}

func (s *Call_stmtContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Call_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Call_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Call_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCall_stmt(s)
	}
}

func (s *Call_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCall_stmt(s)
	}
}

func (p *HplsqlParser) Call_stmt() (localctx ICall_stmtContext) {
	localctx = NewCall_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, HplsqlParserRULE_call_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(749)
		p.Match(HplsqlParserT_CALL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(753)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(750)
			p.Expr_dot()
		}

	case 2:
		{
			p.SetState(751)
			p.Expr_func()
		}

	case 3:
		{
			p.SetState(752)
			p.Ident()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclare_stmtContext is an interface to support dynamic dispatch.
type IDeclare_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_DECLARE() antlr.TerminalNode
	AllDeclare_stmt_item() []IDeclare_stmt_itemContext
	Declare_stmt_item(i int) IDeclare_stmt_itemContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsDeclare_stmtContext differentiates from other interfaces.
	IsDeclare_stmtContext()
}

type Declare_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclare_stmtContext() *Declare_stmtContext {
	var p = new(Declare_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_stmt
	return p
}

func InitEmptyDeclare_stmtContext(p *Declare_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_stmt
}

func (*Declare_stmtContext) IsDeclare_stmtContext() {}

func NewDeclare_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declare_stmtContext {
	var p = new(Declare_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_declare_stmt

	return p
}

func (s *Declare_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Declare_stmtContext) T_DECLARE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DECLARE, 0)
}

func (s *Declare_stmtContext) AllDeclare_stmt_item() []IDeclare_stmt_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclare_stmt_itemContext); ok {
			len++
		}
	}

	tst := make([]IDeclare_stmt_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclare_stmt_itemContext); ok {
			tst[i] = t.(IDeclare_stmt_itemContext)
			i++
		}
	}

	return tst
}

func (s *Declare_stmtContext) Declare_stmt_item(i int) IDeclare_stmt_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_stmt_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_stmt_itemContext)
}

func (s *Declare_stmtContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Declare_stmtContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Declare_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declare_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declare_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDeclare_stmt(s)
	}
}

func (s *Declare_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDeclare_stmt(s)
	}
}

func (p *HplsqlParser) Declare_stmt() (localctx IDeclare_stmtContext) {
	localctx = NewDeclare_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, HplsqlParserRULE_declare_stmt)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(755)
		p.Match(HplsqlParserT_DECLARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(756)
		p.Declare_stmt_item()
	}
	p.SetState(761)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(757)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(758)
				p.Declare_stmt_item()
			}

		}
		p.SetState(763)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclare_blockContext is an interface to support dynamic dispatch.
type IDeclare_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_DECLARE() antlr.TerminalNode
	AllDeclare_stmt_item() []IDeclare_stmt_itemContext
	Declare_stmt_item(i int) IDeclare_stmt_itemContext
	AllT_SEMICOLON() []antlr.TerminalNode
	T_SEMICOLON(i int) antlr.TerminalNode

	// IsDeclare_blockContext differentiates from other interfaces.
	IsDeclare_blockContext()
}

type Declare_blockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclare_blockContext() *Declare_blockContext {
	var p = new(Declare_blockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_block
	return p
}

func InitEmptyDeclare_blockContext(p *Declare_blockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_block
}

func (*Declare_blockContext) IsDeclare_blockContext() {}

func NewDeclare_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declare_blockContext {
	var p = new(Declare_blockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_declare_block

	return p
}

func (s *Declare_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Declare_blockContext) T_DECLARE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DECLARE, 0)
}

func (s *Declare_blockContext) AllDeclare_stmt_item() []IDeclare_stmt_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclare_stmt_itemContext); ok {
			len++
		}
	}

	tst := make([]IDeclare_stmt_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclare_stmt_itemContext); ok {
			tst[i] = t.(IDeclare_stmt_itemContext)
			i++
		}
	}

	return tst
}

func (s *Declare_blockContext) Declare_stmt_item(i int) IDeclare_stmt_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_stmt_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_stmt_itemContext)
}

func (s *Declare_blockContext) AllT_SEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_SEMICOLON)
}

func (s *Declare_blockContext) T_SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEMICOLON, i)
}

func (s *Declare_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declare_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declare_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDeclare_block(s)
	}
}

func (s *Declare_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDeclare_block(s)
	}
}

func (p *HplsqlParser) Declare_block() (localctx IDeclare_blockContext) {
	localctx = NewDeclare_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, HplsqlParserRULE_declare_block)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(764)
		p.Match(HplsqlParserT_DECLARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(765)
		p.Declare_stmt_item()
	}
	{
		p.SetState(766)
		p.Match(HplsqlParserT_SEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(772)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(767)
				p.Declare_stmt_item()
			}
			{
				p.SetState(768)
				p.Match(HplsqlParserT_SEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(774)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclare_block_inplaceContext is an interface to support dynamic dispatch.
type IDeclare_block_inplaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDeclare_stmt_item() []IDeclare_stmt_itemContext
	Declare_stmt_item(i int) IDeclare_stmt_itemContext
	AllT_SEMICOLON() []antlr.TerminalNode
	T_SEMICOLON(i int) antlr.TerminalNode

	// IsDeclare_block_inplaceContext differentiates from other interfaces.
	IsDeclare_block_inplaceContext()
}

type Declare_block_inplaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclare_block_inplaceContext() *Declare_block_inplaceContext {
	var p = new(Declare_block_inplaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_block_inplace
	return p
}

func InitEmptyDeclare_block_inplaceContext(p *Declare_block_inplaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_block_inplace
}

func (*Declare_block_inplaceContext) IsDeclare_block_inplaceContext() {}

func NewDeclare_block_inplaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declare_block_inplaceContext {
	var p = new(Declare_block_inplaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_declare_block_inplace

	return p
}

func (s *Declare_block_inplaceContext) GetParser() antlr.Parser { return s.parser }

func (s *Declare_block_inplaceContext) AllDeclare_stmt_item() []IDeclare_stmt_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclare_stmt_itemContext); ok {
			len++
		}
	}

	tst := make([]IDeclare_stmt_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclare_stmt_itemContext); ok {
			tst[i] = t.(IDeclare_stmt_itemContext)
			i++
		}
	}

	return tst
}

func (s *Declare_block_inplaceContext) Declare_stmt_item(i int) IDeclare_stmt_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_stmt_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_stmt_itemContext)
}

func (s *Declare_block_inplaceContext) AllT_SEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_SEMICOLON)
}

func (s *Declare_block_inplaceContext) T_SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEMICOLON, i)
}

func (s *Declare_block_inplaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declare_block_inplaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declare_block_inplaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDeclare_block_inplace(s)
	}
}

func (s *Declare_block_inplaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDeclare_block_inplace(s)
	}
}

func (p *HplsqlParser) Declare_block_inplace() (localctx IDeclare_block_inplaceContext) {
	localctx = NewDeclare_block_inplaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, HplsqlParserRULE_declare_block_inplace)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(775)
		p.Declare_stmt_item()
	}
	{
		p.SetState(776)
		p.Match(HplsqlParserT_SEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(782)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(777)
				p.Declare_stmt_item()
			}
			{
				p.SetState(778)
				p.Match(HplsqlParserT_SEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(784)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclare_stmt_itemContext is an interface to support dynamic dispatch.
type IDeclare_stmt_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Declare_cursor_item() IDeclare_cursor_itemContext
	Declare_condition_item() IDeclare_condition_itemContext
	Declare_handler_item() IDeclare_handler_itemContext
	Declare_var_item() IDeclare_var_itemContext
	Declare_temporary_table_item() IDeclare_temporary_table_itemContext

	// IsDeclare_stmt_itemContext differentiates from other interfaces.
	IsDeclare_stmt_itemContext()
}

type Declare_stmt_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclare_stmt_itemContext() *Declare_stmt_itemContext {
	var p = new(Declare_stmt_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_stmt_item
	return p
}

func InitEmptyDeclare_stmt_itemContext(p *Declare_stmt_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_stmt_item
}

func (*Declare_stmt_itemContext) IsDeclare_stmt_itemContext() {}

func NewDeclare_stmt_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declare_stmt_itemContext {
	var p = new(Declare_stmt_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_declare_stmt_item

	return p
}

func (s *Declare_stmt_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Declare_stmt_itemContext) Declare_cursor_item() IDeclare_cursor_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_cursor_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_cursor_itemContext)
}

func (s *Declare_stmt_itemContext) Declare_condition_item() IDeclare_condition_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_condition_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_condition_itemContext)
}

func (s *Declare_stmt_itemContext) Declare_handler_item() IDeclare_handler_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_handler_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_handler_itemContext)
}

func (s *Declare_stmt_itemContext) Declare_var_item() IDeclare_var_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_var_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_var_itemContext)
}

func (s *Declare_stmt_itemContext) Declare_temporary_table_item() IDeclare_temporary_table_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_temporary_table_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_temporary_table_itemContext)
}

func (s *Declare_stmt_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declare_stmt_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declare_stmt_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDeclare_stmt_item(s)
	}
}

func (s *Declare_stmt_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDeclare_stmt_item(s)
	}
}

func (p *HplsqlParser) Declare_stmt_item() (localctx IDeclare_stmt_itemContext) {
	localctx = NewDeclare_stmt_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, HplsqlParserRULE_declare_stmt_item)
	p.SetState(790)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(785)
			p.Declare_cursor_item()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(786)
			p.Declare_condition_item()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(787)
			p.Declare_handler_item()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(788)
			p.Declare_var_item()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(789)
			p.Declare_temporary_table_item()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclare_var_itemContext is an interface to support dynamic dispatch.
type IDeclare_var_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	Dtype() IDtypeContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	T_AS() antlr.TerminalNode
	Dtype_len() IDtype_lenContext
	AllDtype_attr() []IDtype_attrContext
	Dtype_attr(i int) IDtype_attrContext
	Dtype_default() IDtype_defaultContext
	T_CONSTANT() antlr.TerminalNode

	// IsDeclare_var_itemContext differentiates from other interfaces.
	IsDeclare_var_itemContext()
}

type Declare_var_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclare_var_itemContext() *Declare_var_itemContext {
	var p = new(Declare_var_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_var_item
	return p
}

func InitEmptyDeclare_var_itemContext(p *Declare_var_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_var_item
}

func (*Declare_var_itemContext) IsDeclare_var_itemContext() {}

func NewDeclare_var_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declare_var_itemContext {
	var p = new(Declare_var_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_declare_var_item

	return p
}

func (s *Declare_var_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Declare_var_itemContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Declare_var_itemContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Declare_var_itemContext) Dtype() IDtypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *Declare_var_itemContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Declare_var_itemContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Declare_var_itemContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Declare_var_itemContext) Dtype_len() IDtype_lenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_lenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_lenContext)
}

func (s *Declare_var_itemContext) AllDtype_attr() []IDtype_attrContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDtype_attrContext); ok {
			len++
		}
	}

	tst := make([]IDtype_attrContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDtype_attrContext); ok {
			tst[i] = t.(IDtype_attrContext)
			i++
		}
	}

	return tst
}

func (s *Declare_var_itemContext) Dtype_attr(i int) IDtype_attrContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_attrContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_attrContext)
}

func (s *Declare_var_itemContext) Dtype_default() IDtype_defaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_defaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_defaultContext)
}

func (s *Declare_var_itemContext) T_CONSTANT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONSTANT, 0)
}

func (s *Declare_var_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declare_var_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declare_var_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDeclare_var_item(s)
	}
}

func (s *Declare_var_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDeclare_var_item(s)
	}
}

func (p *HplsqlParser) Declare_var_item() (localctx IDeclare_var_itemContext) {
	localctx = NewDeclare_var_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, HplsqlParserRULE_declare_var_item)
	var _la int

	var _alt int

	p.SetState(827)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 41, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(792)
			p.Ident()
		}
		p.SetState(797)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(793)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(794)
				p.Ident()
			}

			p.SetState(799)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(801)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_AS {
			{
				p.SetState(800)
				p.Match(HplsqlParserT_AS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(803)
			p.Dtype()
		}
		p.SetState(805)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(804)
				p.Dtype_len()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(810)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(807)
					p.Dtype_attr()
				}

			}
			p.SetState(812)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(814)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(813)
				p.Dtype_default()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(816)
			p.Ident()
		}
		{
			p.SetState(817)
			p.Match(HplsqlParserT_CONSTANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(819)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_AS {
			{
				p.SetState(818)
				p.Match(HplsqlParserT_AS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(821)
			p.Dtype()
		}
		p.SetState(823)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_OPEN_P {
			{
				p.SetState(822)
				p.Dtype_len()
			}

		}
		{
			p.SetState(825)
			p.Dtype_default()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclare_condition_itemContext is an interface to support dynamic dispatch.
type IDeclare_condition_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ident() IIdentContext
	T_CONDITION() antlr.TerminalNode

	// IsDeclare_condition_itemContext differentiates from other interfaces.
	IsDeclare_condition_itemContext()
}

type Declare_condition_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclare_condition_itemContext() *Declare_condition_itemContext {
	var p = new(Declare_condition_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_condition_item
	return p
}

func InitEmptyDeclare_condition_itemContext(p *Declare_condition_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_condition_item
}

func (*Declare_condition_itemContext) IsDeclare_condition_itemContext() {}

func NewDeclare_condition_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declare_condition_itemContext {
	var p = new(Declare_condition_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_declare_condition_item

	return p
}

func (s *Declare_condition_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Declare_condition_itemContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Declare_condition_itemContext) T_CONDITION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONDITION, 0)
}

func (s *Declare_condition_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declare_condition_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declare_condition_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDeclare_condition_item(s)
	}
}

func (s *Declare_condition_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDeclare_condition_item(s)
	}
}

func (p *HplsqlParser) Declare_condition_item() (localctx IDeclare_condition_itemContext) {
	localctx = NewDeclare_condition_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, HplsqlParserRULE_declare_condition_item)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(829)
		p.Ident()
	}
	{
		p.SetState(830)
		p.Match(HplsqlParserT_CONDITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclare_cursor_itemContext is an interface to support dynamic dispatch.
type IDeclare_cursor_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_IS() antlr.TerminalNode
	T_AS() antlr.TerminalNode
	T_FOR() antlr.TerminalNode
	T_CURSOR() antlr.TerminalNode
	Ident() IIdentContext
	Select_stmt() ISelect_stmtContext
	Expr() IExprContext
	Cursor_with_return() ICursor_with_returnContext
	Cursor_without_return() ICursor_without_returnContext

	// IsDeclare_cursor_itemContext differentiates from other interfaces.
	IsDeclare_cursor_itemContext()
}

type Declare_cursor_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclare_cursor_itemContext() *Declare_cursor_itemContext {
	var p = new(Declare_cursor_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_cursor_item
	return p
}

func InitEmptyDeclare_cursor_itemContext(p *Declare_cursor_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_cursor_item
}

func (*Declare_cursor_itemContext) IsDeclare_cursor_itemContext() {}

func NewDeclare_cursor_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declare_cursor_itemContext {
	var p = new(Declare_cursor_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_declare_cursor_item

	return p
}

func (s *Declare_cursor_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Declare_cursor_itemContext) T_IS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IS, 0)
}

func (s *Declare_cursor_itemContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Declare_cursor_itemContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *Declare_cursor_itemContext) T_CURSOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURSOR, 0)
}

func (s *Declare_cursor_itemContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Declare_cursor_itemContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Declare_cursor_itemContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Declare_cursor_itemContext) Cursor_with_return() ICursor_with_returnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICursor_with_returnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICursor_with_returnContext)
}

func (s *Declare_cursor_itemContext) Cursor_without_return() ICursor_without_returnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICursor_without_returnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICursor_without_returnContext)
}

func (s *Declare_cursor_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declare_cursor_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declare_cursor_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDeclare_cursor_item(s)
	}
}

func (s *Declare_cursor_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDeclare_cursor_item(s)
	}
}

func (p *HplsqlParser) Declare_cursor_item() (localctx IDeclare_cursor_itemContext) {
	localctx = NewDeclare_cursor_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, HplsqlParserRULE_declare_cursor_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(837)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 42, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(832)
			p.Match(HplsqlParserT_CURSOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(833)
			p.Ident()
		}

	case 2:
		{
			p.SetState(834)
			p.Ident()
		}
		{
			p.SetState(835)
			p.Match(HplsqlParserT_CURSOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(841)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_WITH:
		{
			p.SetState(839)
			p.Cursor_with_return()
		}

	case HplsqlParserT_WITHOUT:
		{
			p.SetState(840)
			p.Cursor_without_return()
		}

	case HplsqlParserT_AS, HplsqlParserT_FOR, HplsqlParserT_IS:

	default:
	}
	{
		p.SetState(843)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_AS || _la == HplsqlParserT_FOR || _la == HplsqlParserT_IS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(846)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(844)
			p.Select_stmt()
		}

	case 2:
		{
			p.SetState(845)
			p.expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICursor_with_returnContext is an interface to support dynamic dispatch.
type ICursor_with_returnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_WITH() antlr.TerminalNode
	T_RETURN() antlr.TerminalNode
	T_ONLY() antlr.TerminalNode
	T_TO() antlr.TerminalNode
	T_CALLER() antlr.TerminalNode
	T_CLIENT() antlr.TerminalNode

	// IsCursor_with_returnContext differentiates from other interfaces.
	IsCursor_with_returnContext()
}

type Cursor_with_returnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCursor_with_returnContext() *Cursor_with_returnContext {
	var p = new(Cursor_with_returnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cursor_with_return
	return p
}

func InitEmptyCursor_with_returnContext(p *Cursor_with_returnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cursor_with_return
}

func (*Cursor_with_returnContext) IsCursor_with_returnContext() {}

func NewCursor_with_returnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cursor_with_returnContext {
	var p = new(Cursor_with_returnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_cursor_with_return

	return p
}

func (s *Cursor_with_returnContext) GetParser() antlr.Parser { return s.parser }

func (s *Cursor_with_returnContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITH, 0)
}

func (s *Cursor_with_returnContext) T_RETURN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RETURN, 0)
}

func (s *Cursor_with_returnContext) T_ONLY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ONLY, 0)
}

func (s *Cursor_with_returnContext) T_TO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TO, 0)
}

func (s *Cursor_with_returnContext) T_CALLER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CALLER, 0)
}

func (s *Cursor_with_returnContext) T_CLIENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLIENT, 0)
}

func (s *Cursor_with_returnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cursor_with_returnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cursor_with_returnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCursor_with_return(s)
	}
}

func (s *Cursor_with_returnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCursor_with_return(s)
	}
}

func (p *HplsqlParser) Cursor_with_return() (localctx ICursor_with_returnContext) {
	localctx = NewCursor_with_returnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, HplsqlParserRULE_cursor_with_return)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(848)
		p.Match(HplsqlParserT_WITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(849)
		p.Match(HplsqlParserT_RETURN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(851)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_ONLY {
		{
			p.SetState(850)
			p.Match(HplsqlParserT_ONLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(855)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_TO {
		{
			p.SetState(853)
			p.Match(HplsqlParserT_TO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(854)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_CALLER || _la == HplsqlParserT_CLIENT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICursor_without_returnContext is an interface to support dynamic dispatch.
type ICursor_without_returnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_WITHOUT() antlr.TerminalNode
	T_RETURN() antlr.TerminalNode

	// IsCursor_without_returnContext differentiates from other interfaces.
	IsCursor_without_returnContext()
}

type Cursor_without_returnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCursor_without_returnContext() *Cursor_without_returnContext {
	var p = new(Cursor_without_returnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cursor_without_return
	return p
}

func InitEmptyCursor_without_returnContext(p *Cursor_without_returnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cursor_without_return
}

func (*Cursor_without_returnContext) IsCursor_without_returnContext() {}

func NewCursor_without_returnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cursor_without_returnContext {
	var p = new(Cursor_without_returnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_cursor_without_return

	return p
}

func (s *Cursor_without_returnContext) GetParser() antlr.Parser { return s.parser }

func (s *Cursor_without_returnContext) T_WITHOUT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITHOUT, 0)
}

func (s *Cursor_without_returnContext) T_RETURN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RETURN, 0)
}

func (s *Cursor_without_returnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cursor_without_returnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cursor_without_returnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCursor_without_return(s)
	}
}

func (s *Cursor_without_returnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCursor_without_return(s)
	}
}

func (p *HplsqlParser) Cursor_without_return() (localctx ICursor_without_returnContext) {
	localctx = NewCursor_without_returnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, HplsqlParserRULE_cursor_without_return)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(857)
		p.Match(HplsqlParserT_WITHOUT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(858)
		p.Match(HplsqlParserT_RETURN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclare_handler_itemContext is an interface to support dynamic dispatch.
type IDeclare_handler_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_HANDLER() antlr.TerminalNode
	T_FOR() antlr.TerminalNode
	Single_block_stmt() ISingle_block_stmtContext
	T_CONTINUE() antlr.TerminalNode
	T_EXIT() antlr.TerminalNode
	T_SQLEXCEPTION() antlr.TerminalNode
	T_SQLWARNING() antlr.TerminalNode
	T_NOT() antlr.TerminalNode
	T_FOUND() antlr.TerminalNode
	Ident() IIdentContext

	// IsDeclare_handler_itemContext differentiates from other interfaces.
	IsDeclare_handler_itemContext()
}

type Declare_handler_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclare_handler_itemContext() *Declare_handler_itemContext {
	var p = new(Declare_handler_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_handler_item
	return p
}

func InitEmptyDeclare_handler_itemContext(p *Declare_handler_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_handler_item
}

func (*Declare_handler_itemContext) IsDeclare_handler_itemContext() {}

func NewDeclare_handler_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declare_handler_itemContext {
	var p = new(Declare_handler_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_declare_handler_item

	return p
}

func (s *Declare_handler_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Declare_handler_itemContext) T_HANDLER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HANDLER, 0)
}

func (s *Declare_handler_itemContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *Declare_handler_itemContext) Single_block_stmt() ISingle_block_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingle_block_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingle_block_stmtContext)
}

func (s *Declare_handler_itemContext) T_CONTINUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONTINUE, 0)
}

func (s *Declare_handler_itemContext) T_EXIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXIT, 0)
}

func (s *Declare_handler_itemContext) T_SQLEXCEPTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SQLEXCEPTION, 0)
}

func (s *Declare_handler_itemContext) T_SQLWARNING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SQLWARNING, 0)
}

func (s *Declare_handler_itemContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Declare_handler_itemContext) T_FOUND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOUND, 0)
}

func (s *Declare_handler_itemContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Declare_handler_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declare_handler_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declare_handler_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDeclare_handler_item(s)
	}
}

func (s *Declare_handler_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDeclare_handler_item(s)
	}
}

func (p *HplsqlParser) Declare_handler_item() (localctx IDeclare_handler_itemContext) {
	localctx = NewDeclare_handler_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, HplsqlParserRULE_declare_handler_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(860)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_CONTINUE || _la == HplsqlParserT_EXIT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(861)
		p.Match(HplsqlParserT_HANDLER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(862)
		p.Match(HplsqlParserT_FOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(868)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(863)
			p.Match(HplsqlParserT_SQLEXCEPTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(864)
			p.Match(HplsqlParserT_SQLWARNING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(865)
			p.Match(HplsqlParserT_NOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(866)
			p.Match(HplsqlParserT_FOUND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(867)
			p.Ident()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(870)
		p.Single_block_stmt()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclare_temporary_table_itemContext is an interface to support dynamic dispatch.
type IDeclare_temporary_table_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_TEMPORARY() antlr.TerminalNode
	T_TABLE() antlr.TerminalNode
	Qident() IQidentContext
	Create_table_definition() ICreate_table_definitionContext
	T_GLOBAL() antlr.TerminalNode
	Create_table_preoptions() ICreate_table_preoptionsContext

	// IsDeclare_temporary_table_itemContext differentiates from other interfaces.
	IsDeclare_temporary_table_itemContext()
}

type Declare_temporary_table_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclare_temporary_table_itemContext() *Declare_temporary_table_itemContext {
	var p = new(Declare_temporary_table_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_temporary_table_item
	return p
}

func InitEmptyDeclare_temporary_table_itemContext(p *Declare_temporary_table_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_temporary_table_item
}

func (*Declare_temporary_table_itemContext) IsDeclare_temporary_table_itemContext() {}

func NewDeclare_temporary_table_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declare_temporary_table_itemContext {
	var p = new(Declare_temporary_table_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_declare_temporary_table_item

	return p
}

func (s *Declare_temporary_table_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Declare_temporary_table_itemContext) T_TEMPORARY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TEMPORARY, 0)
}

func (s *Declare_temporary_table_itemContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLE, 0)
}

func (s *Declare_temporary_table_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Declare_temporary_table_itemContext) Create_table_definition() ICreate_table_definitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_definitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_definitionContext)
}

func (s *Declare_temporary_table_itemContext) T_GLOBAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GLOBAL, 0)
}

func (s *Declare_temporary_table_itemContext) Create_table_preoptions() ICreate_table_preoptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_preoptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_preoptionsContext)
}

func (s *Declare_temporary_table_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declare_temporary_table_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Declare_temporary_table_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDeclare_temporary_table_item(s)
	}
}

func (s *Declare_temporary_table_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDeclare_temporary_table_item(s)
	}
}

func (p *HplsqlParser) Declare_temporary_table_item() (localctx IDeclare_temporary_table_itemContext) {
	localctx = NewDeclare_temporary_table_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, HplsqlParserRULE_declare_temporary_table_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(873)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_GLOBAL {
		{
			p.SetState(872)
			p.Match(HplsqlParserT_GLOBAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(875)
		p.Match(HplsqlParserT_TEMPORARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(876)
		p.Match(HplsqlParserT_TABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(877)
		p.Qident()
	}
	p.SetState(879)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_COMMENT || _la == HplsqlParserT_PARTITIONED || _la == HplsqlParserT_ROW || _la == HplsqlParserT_STORED || _la == HplsqlParserT_COMMA {
		{
			p.SetState(878)
			p.Create_table_preoptions()
		}

	}
	{
		p.SetState(881)
		p.Create_table_definition()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_stmtContext is an interface to support dynamic dispatch.
type ICreate_table_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_CREATE() antlr.TerminalNode
	T_TABLE() antlr.TerminalNode
	Table_name() ITable_nameContext
	Create_table_definition() ICreate_table_definitionContext
	T_IF() antlr.TerminalNode
	T_NOT() antlr.TerminalNode
	T_EXISTS() antlr.TerminalNode
	Create_table_preoptions() ICreate_table_preoptionsContext

	// IsCreate_table_stmtContext differentiates from other interfaces.
	IsCreate_table_stmtContext()
}

type Create_table_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_stmtContext() *Create_table_stmtContext {
	var p = new(Create_table_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_stmt
	return p
}

func InitEmptyCreate_table_stmtContext(p *Create_table_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_stmt
}

func (*Create_table_stmtContext) IsCreate_table_stmtContext() {}

func NewCreate_table_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_stmtContext {
	var p = new(Create_table_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_stmt

	return p
}

func (s *Create_table_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_stmtContext) T_CREATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATE, 0)
}

func (s *Create_table_stmtContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLE, 0)
}

func (s *Create_table_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Create_table_stmtContext) Create_table_definition() ICreate_table_definitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_definitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_definitionContext)
}

func (s *Create_table_stmtContext) T_IF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IF, 0)
}

func (s *Create_table_stmtContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Create_table_stmtContext) T_EXISTS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXISTS, 0)
}

func (s *Create_table_stmtContext) Create_table_preoptions() ICreate_table_preoptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_preoptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_preoptionsContext)
}

func (s *Create_table_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_stmt(s)
	}
}

func (s *Create_table_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_stmt(s)
	}
}

func (p *HplsqlParser) Create_table_stmt() (localctx ICreate_table_stmtContext) {
	localctx = NewCreate_table_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, HplsqlParserRULE_create_table_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(883)
		p.Match(HplsqlParserT_CREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(884)
		p.Match(HplsqlParserT_TABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(888)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 50, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(885)
			p.Match(HplsqlParserT_IF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(886)
			p.Match(HplsqlParserT_NOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(887)
			p.Match(HplsqlParserT_EXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(890)
		p.Table_name()
	}
	p.SetState(892)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_COMMENT || _la == HplsqlParserT_PARTITIONED || _la == HplsqlParserT_ROW || _la == HplsqlParserT_STORED || _la == HplsqlParserT_COMMA {
		{
			p.SetState(891)
			p.Create_table_preoptions()
		}

	}
	{
		p.SetState(894)
		p.Create_table_definition()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_local_temp_table_stmtContext is an interface to support dynamic dispatch.
type ICreate_local_temp_table_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_CREATE() antlr.TerminalNode
	T_TABLE() antlr.TerminalNode
	Qident() IQidentContext
	Create_table_definition() ICreate_table_definitionContext
	T_LOCAL() antlr.TerminalNode
	T_TEMPORARY() antlr.TerminalNode
	T_VOLATILE() antlr.TerminalNode
	Create_table_preoptions() ICreate_table_preoptionsContext
	T_SET() antlr.TerminalNode
	T_MULTISET() antlr.TerminalNode

	// IsCreate_local_temp_table_stmtContext differentiates from other interfaces.
	IsCreate_local_temp_table_stmtContext()
}

type Create_local_temp_table_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_local_temp_table_stmtContext() *Create_local_temp_table_stmtContext {
	var p = new(Create_local_temp_table_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_local_temp_table_stmt
	return p
}

func InitEmptyCreate_local_temp_table_stmtContext(p *Create_local_temp_table_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_local_temp_table_stmt
}

func (*Create_local_temp_table_stmtContext) IsCreate_local_temp_table_stmtContext() {}

func NewCreate_local_temp_table_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_local_temp_table_stmtContext {
	var p = new(Create_local_temp_table_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_local_temp_table_stmt

	return p
}

func (s *Create_local_temp_table_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_local_temp_table_stmtContext) T_CREATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATE, 0)
}

func (s *Create_local_temp_table_stmtContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLE, 0)
}

func (s *Create_local_temp_table_stmtContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_local_temp_table_stmtContext) Create_table_definition() ICreate_table_definitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_definitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_definitionContext)
}

func (s *Create_local_temp_table_stmtContext) T_LOCAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCAL, 0)
}

func (s *Create_local_temp_table_stmtContext) T_TEMPORARY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TEMPORARY, 0)
}

func (s *Create_local_temp_table_stmtContext) T_VOLATILE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VOLATILE, 0)
}

func (s *Create_local_temp_table_stmtContext) Create_table_preoptions() ICreate_table_preoptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_preoptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_preoptionsContext)
}

func (s *Create_local_temp_table_stmtContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Create_local_temp_table_stmtContext) T_MULTISET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MULTISET, 0)
}

func (s *Create_local_temp_table_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_local_temp_table_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_local_temp_table_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_local_temp_table_stmt(s)
	}
}

func (s *Create_local_temp_table_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_local_temp_table_stmt(s)
	}
}

func (p *HplsqlParser) Create_local_temp_table_stmt() (localctx ICreate_local_temp_table_stmtContext) {
	localctx = NewCreate_local_temp_table_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, HplsqlParserRULE_create_local_temp_table_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(896)
		p.Match(HplsqlParserT_CREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(903)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_LOCAL:
		{
			p.SetState(897)
			p.Match(HplsqlParserT_LOCAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(898)
			p.Match(HplsqlParserT_TEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_MULTISET, HplsqlParserT_SET, HplsqlParserT_VOLATILE:
		p.SetState(900)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_MULTISET || _la == HplsqlParserT_SET {
			{
				p.SetState(899)
				_la = p.GetTokenStream().LA(1)

				if !(_la == HplsqlParserT_MULTISET || _la == HplsqlParserT_SET) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(902)
			p.Match(HplsqlParserT_VOLATILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(905)
		p.Match(HplsqlParserT_TABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(906)
		p.Qident()
	}
	p.SetState(908)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_COMMENT || _la == HplsqlParserT_PARTITIONED || _la == HplsqlParserT_ROW || _la == HplsqlParserT_STORED || _la == HplsqlParserT_COMMA {
		{
			p.SetState(907)
			p.Create_table_preoptions()
		}

	}
	{
		p.SetState(910)
		p.Create_table_definition()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_definitionContext is an interface to support dynamic dispatch.
type ICreate_table_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN_P() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	T_CLOSE_P() antlr.TerminalNode
	Create_table_columns() ICreate_table_columnsContext
	T_LIKE() antlr.TerminalNode
	Table_name() ITable_nameContext
	Create_table_options() ICreate_table_optionsContext
	T_AS() antlr.TerminalNode

	// IsCreate_table_definitionContext differentiates from other interfaces.
	IsCreate_table_definitionContext()
}

type Create_table_definitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_definitionContext() *Create_table_definitionContext {
	var p = new(Create_table_definitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_definition
	return p
}

func InitEmptyCreate_table_definitionContext(p *Create_table_definitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_definition
}

func (*Create_table_definitionContext) IsCreate_table_definitionContext() {}

func NewCreate_table_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_definitionContext {
	var p = new(Create_table_definitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_definition

	return p
}

func (s *Create_table_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_definitionContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Create_table_definitionContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Create_table_definitionContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Create_table_definitionContext) Create_table_columns() ICreate_table_columnsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_columnsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_columnsContext)
}

func (s *Create_table_definitionContext) T_LIKE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LIKE, 0)
}

func (s *Create_table_definitionContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Create_table_definitionContext) Create_table_options() ICreate_table_optionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_optionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_optionsContext)
}

func (s *Create_table_definitionContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Create_table_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_definition(s)
	}
}

func (s *Create_table_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_definition(s)
	}
}

func (p *HplsqlParser) Create_table_definition() (localctx ICreate_table_definitionContext) {
	localctx = NewCreate_table_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, HplsqlParserRULE_create_table_definition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(929)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) {
	case 1:
		p.SetState(913)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_AS {
			{
				p.SetState(912)
				p.Match(HplsqlParserT_AS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(915)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(916)
			p.Select_stmt()
		}
		{
			p.SetState(917)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.SetState(920)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_AS {
			{
				p.SetState(919)
				p.Match(HplsqlParserT_AS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(922)
			p.Select_stmt()
		}

	case 3:
		{
			p.SetState(923)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(924)
			p.Create_table_columns()
		}
		{
			p.SetState(925)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(927)
			p.Match(HplsqlParserT_LIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(928)
			p.Table_name()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(932)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(931)
			p.Create_table_options()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_column_commentContext is an interface to support dynamic dispatch.
type ICreate_table_column_commentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_COMMENT() antlr.TerminalNode
	Expr() IExprContext

	// IsCreate_table_column_commentContext differentiates from other interfaces.
	IsCreate_table_column_commentContext()
}

type Create_table_column_commentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_column_commentContext() *Create_table_column_commentContext {
	var p = new(Create_table_column_commentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_column_comment
	return p
}

func InitEmptyCreate_table_column_commentContext(p *Create_table_column_commentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_column_comment
}

func (*Create_table_column_commentContext) IsCreate_table_column_commentContext() {}

func NewCreate_table_column_commentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_column_commentContext {
	var p = new(Create_table_column_commentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_column_comment

	return p
}

func (s *Create_table_column_commentContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_column_commentContext) T_COMMENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMENT, 0)
}

func (s *Create_table_column_commentContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Create_table_column_commentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_column_commentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_column_commentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_column_comment(s)
	}
}

func (s *Create_table_column_commentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_column_comment(s)
	}
}

func (p *HplsqlParser) Create_table_column_comment() (localctx ICreate_table_column_commentContext) {
	localctx = NewCreate_table_column_commentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, HplsqlParserRULE_create_table_column_comment)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(934)
		p.Match(HplsqlParserT_COMMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(935)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_columnsContext is an interface to support dynamic dispatch.
type ICreate_table_columnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCreate_table_columns_item() []ICreate_table_columns_itemContext
	Create_table_columns_item(i int) ICreate_table_columns_itemContext
	AllCreate_table_column_comment() []ICreate_table_column_commentContext
	Create_table_column_comment(i int) ICreate_table_column_commentContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsCreate_table_columnsContext differentiates from other interfaces.
	IsCreate_table_columnsContext()
}

type Create_table_columnsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_columnsContext() *Create_table_columnsContext {
	var p = new(Create_table_columnsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_columns
	return p
}

func InitEmptyCreate_table_columnsContext(p *Create_table_columnsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_columns
}

func (*Create_table_columnsContext) IsCreate_table_columnsContext() {}

func NewCreate_table_columnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_columnsContext {
	var p = new(Create_table_columnsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_columns

	return p
}

func (s *Create_table_columnsContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_columnsContext) AllCreate_table_columns_item() []ICreate_table_columns_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_columns_itemContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_columns_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_columns_itemContext); ok {
			tst[i] = t.(ICreate_table_columns_itemContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_columnsContext) Create_table_columns_item(i int) ICreate_table_columns_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_columns_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_columns_itemContext)
}

func (s *Create_table_columnsContext) AllCreate_table_column_comment() []ICreate_table_column_commentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_column_commentContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_column_commentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_column_commentContext); ok {
			tst[i] = t.(ICreate_table_column_commentContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_columnsContext) Create_table_column_comment(i int) ICreate_table_column_commentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_column_commentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_column_commentContext)
}

func (s *Create_table_columnsContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Create_table_columnsContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Create_table_columnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_columnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_columnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_columns(s)
	}
}

func (s *Create_table_columnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_columns(s)
	}
}

func (p *HplsqlParser) Create_table_columns() (localctx ICreate_table_columnsContext) {
	localctx = NewCreate_table_columnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, HplsqlParserRULE_create_table_columns)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(937)
		p.Create_table_columns_item()
	}
	p.SetState(939)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_COMMENT {
		{
			p.SetState(938)
			p.Create_table_column_comment()
		}

	}
	p.SetState(948)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(941)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(942)
			p.Create_table_columns_item()
		}
		p.SetState(944)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_COMMENT {
			{
				p.SetState(943)
				p.Create_table_column_comment()
			}

		}

		p.SetState(950)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_columns_itemContext is an interface to support dynamic dispatch.
type ICreate_table_columns_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column_name() IColumn_nameContext
	Dtype() IDtypeContext
	Dtype_len() IDtype_lenContext
	AllDtype_attr() []IDtype_attrContext
	Dtype_attr(i int) IDtype_attrContext
	AllCreate_table_column_inline_cons() []ICreate_table_column_inline_consContext
	Create_table_column_inline_cons(i int) ICreate_table_column_inline_consContext
	Create_table_column_cons() ICreate_table_column_consContext
	T_CONSTRAINT() antlr.TerminalNode
	Qident() IQidentContext

	// IsCreate_table_columns_itemContext differentiates from other interfaces.
	IsCreate_table_columns_itemContext()
}

type Create_table_columns_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_columns_itemContext() *Create_table_columns_itemContext {
	var p = new(Create_table_columns_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_columns_item
	return p
}

func InitEmptyCreate_table_columns_itemContext(p *Create_table_columns_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_columns_item
}

func (*Create_table_columns_itemContext) IsCreate_table_columns_itemContext() {}

func NewCreate_table_columns_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_columns_itemContext {
	var p = new(Create_table_columns_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_columns_item

	return p
}

func (s *Create_table_columns_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_columns_itemContext) Column_name() IColumn_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Create_table_columns_itemContext) Dtype() IDtypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *Create_table_columns_itemContext) Dtype_len() IDtype_lenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_lenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_lenContext)
}

func (s *Create_table_columns_itemContext) AllDtype_attr() []IDtype_attrContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDtype_attrContext); ok {
			len++
		}
	}

	tst := make([]IDtype_attrContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDtype_attrContext); ok {
			tst[i] = t.(IDtype_attrContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_columns_itemContext) Dtype_attr(i int) IDtype_attrContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_attrContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_attrContext)
}

func (s *Create_table_columns_itemContext) AllCreate_table_column_inline_cons() []ICreate_table_column_inline_consContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_column_inline_consContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_column_inline_consContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_column_inline_consContext); ok {
			tst[i] = t.(ICreate_table_column_inline_consContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_columns_itemContext) Create_table_column_inline_cons(i int) ICreate_table_column_inline_consContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_column_inline_consContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_column_inline_consContext)
}

func (s *Create_table_columns_itemContext) Create_table_column_cons() ICreate_table_column_consContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_column_consContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_column_consContext)
}

func (s *Create_table_columns_itemContext) T_CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONSTRAINT, 0)
}

func (s *Create_table_columns_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_table_columns_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_columns_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_columns_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_columns_item(s)
	}
}

func (s *Create_table_columns_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_columns_item(s)
	}
}

func (p *HplsqlParser) Create_table_columns_item() (localctx ICreate_table_columns_itemContext) {
	localctx = NewCreate_table_columns_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, HplsqlParserRULE_create_table_columns_item)
	var _la int

	var _alt int

	p.SetState(973)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(951)
			p.Column_name()
		}
		{
			p.SetState(952)
			p.Dtype()
		}
		p.SetState(954)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_OPEN_P {
			{
				p.SetState(953)
				p.Dtype_len()
			}

		}
		p.SetState(959)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(956)
					p.Dtype_attr()
				}

			}
			p.SetState(961)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(965)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_AUTO_INCREMENT || ((int64((_la-76)) & ^0x3f) == 0 && ((int64(1)<<(_la-76))&288230376155906049) != 0) || ((int64((_la-195)) & ^0x3f) == 0 && ((int64(1)<<(_la-195))&68786585605) != 0) || ((int64((_la-303)) & ^0x3f) == 0 && ((int64(1)<<(_la-303))&9147936743129089) != 0) {
			{
				p.SetState(962)
				p.Create_table_column_inline_cons()
			}

			p.SetState(967)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(970)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_CONSTRAINT {
			{
				p.SetState(968)
				p.Match(HplsqlParserT_CONSTRAINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(969)
				p.Qident()
			}

		}
		{
			p.SetState(972)
			p.Create_table_column_cons()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumn_nameContext is an interface to support dynamic dispatch.
type IColumn_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Qident() IQidentContext

	// IsColumn_nameContext differentiates from other interfaces.
	IsColumn_nameContext()
}

type Column_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_nameContext() *Column_nameContext {
	var p = new(Column_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_column_name
	return p
}

func InitEmptyColumn_nameContext(p *Column_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_column_name
}

func (*Column_nameContext) IsColumn_nameContext() {}

func NewColumn_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_nameContext {
	var p = new(Column_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_column_name

	return p
}

func (s *Column_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_nameContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Column_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Column_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterColumn_name(s)
	}
}

func (s *Column_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitColumn_name(s)
	}
}

func (p *HplsqlParser) Column_name() (localctx IColumn_nameContext) {
	localctx = NewColumn_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, HplsqlParserRULE_column_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(975)
		p.Qident()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_column_inline_consContext is an interface to support dynamic dispatch.
type ICreate_table_column_inline_consContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Dtype_default() IDtype_defaultContext
	T_NULL() antlr.TerminalNode
	T_NOT() antlr.TerminalNode
	T_PRIMARY() antlr.TerminalNode
	T_KEY() antlr.TerminalNode
	T_UNIQUE() antlr.TerminalNode
	T_REFERENCES() antlr.TerminalNode
	Table_name() ITable_nameContext
	T_OPEN_P() antlr.TerminalNode
	Qident() IQidentContext
	T_CLOSE_P() antlr.TerminalNode
	AllCreate_table_fk_action() []ICreate_table_fk_actionContext
	Create_table_fk_action(i int) ICreate_table_fk_actionContext
	T_IDENTITY() antlr.TerminalNode
	AllL_INT() []antlr.TerminalNode
	L_INT(i int) antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	T_AUTO_INCREMENT() antlr.TerminalNode
	T_ENABLE() antlr.TerminalNode

	// IsCreate_table_column_inline_consContext differentiates from other interfaces.
	IsCreate_table_column_inline_consContext()
}

type Create_table_column_inline_consContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_column_inline_consContext() *Create_table_column_inline_consContext {
	var p = new(Create_table_column_inline_consContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_column_inline_cons
	return p
}

func InitEmptyCreate_table_column_inline_consContext(p *Create_table_column_inline_consContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_column_inline_cons
}

func (*Create_table_column_inline_consContext) IsCreate_table_column_inline_consContext() {}

func NewCreate_table_column_inline_consContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_column_inline_consContext {
	var p = new(Create_table_column_inline_consContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_column_inline_cons

	return p
}

func (s *Create_table_column_inline_consContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_column_inline_consContext) Dtype_default() IDtype_defaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_defaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_defaultContext)
}

func (s *Create_table_column_inline_consContext) T_NULL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NULL, 0)
}

func (s *Create_table_column_inline_consContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Create_table_column_inline_consContext) T_PRIMARY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRIMARY, 0)
}

func (s *Create_table_column_inline_consContext) T_KEY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_KEY, 0)
}

func (s *Create_table_column_inline_consContext) T_UNIQUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UNIQUE, 0)
}

func (s *Create_table_column_inline_consContext) T_REFERENCES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REFERENCES, 0)
}

func (s *Create_table_column_inline_consContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Create_table_column_inline_consContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Create_table_column_inline_consContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_table_column_inline_consContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Create_table_column_inline_consContext) AllCreate_table_fk_action() []ICreate_table_fk_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_fk_actionContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_fk_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_fk_actionContext); ok {
			tst[i] = t.(ICreate_table_fk_actionContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_column_inline_consContext) Create_table_fk_action(i int) ICreate_table_fk_actionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_fk_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_fk_actionContext)
}

func (s *Create_table_column_inline_consContext) T_IDENTITY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IDENTITY, 0)
}

func (s *Create_table_column_inline_consContext) AllL_INT() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserL_INT)
}

func (s *Create_table_column_inline_consContext) L_INT(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_INT, i)
}

func (s *Create_table_column_inline_consContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Create_table_column_inline_consContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Create_table_column_inline_consContext) T_AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AUTO_INCREMENT, 0)
}

func (s *Create_table_column_inline_consContext) T_ENABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ENABLE, 0)
}

func (s *Create_table_column_inline_consContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_column_inline_consContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_column_inline_consContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_column_inline_cons(s)
	}
}

func (s *Create_table_column_inline_consContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_column_inline_cons(s)
	}
}

func (p *HplsqlParser) Create_table_column_inline_cons() (localctx ICreate_table_column_inline_consContext) {
	localctx = NewCreate_table_column_inline_consContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, HplsqlParserRULE_create_table_column_inline_cons)
	var _la int

	p.SetState(1009)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_DEFAULT, HplsqlParserT_WITH, HplsqlParserT_COLON, HplsqlParserT_EQUAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(977)
			p.Dtype_default()
		}

	case HplsqlParserT_NOT, HplsqlParserT_NULL:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(979)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_NOT {
			{
				p.SetState(978)
				p.Match(HplsqlParserT_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(981)
			p.Match(HplsqlParserT_NULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_PRIMARY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(982)
			p.Match(HplsqlParserT_PRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(983)
			p.Match(HplsqlParserT_KEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_UNIQUE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(984)
			p.Match(HplsqlParserT_UNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_REFERENCES:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(985)
			p.Match(HplsqlParserT_REFERENCES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(986)
			p.Table_name()
		}
		{
			p.SetState(987)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(988)
			p.Qident()
		}
		{
			p.SetState(989)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(993)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_ON {
			{
				p.SetState(990)
				p.Create_table_fk_action()
			}

			p.SetState(995)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case HplsqlParserT_IDENTITY:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(996)
			p.Match(HplsqlParserT_IDENTITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(997)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(998)
			p.Match(HplsqlParserL_INT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1003)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(999)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1000)
				p.Match(HplsqlParserL_INT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1005)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1006)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_AUTO_INCREMENT:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1007)
			p.Match(HplsqlParserT_AUTO_INCREMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_ENABLE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1008)
			p.Match(HplsqlParserT_ENABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_column_consContext is an interface to support dynamic dispatch.
type ICreate_table_column_consContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_PRIMARY() antlr.TerminalNode
	T_KEY() antlr.TerminalNode
	AllT_OPEN_P() []antlr.TerminalNode
	T_OPEN_P(i int) antlr.TerminalNode
	AllQident() []IQidentContext
	Qident(i int) IQidentContext
	AllT_CLOSE_P() []antlr.TerminalNode
	T_CLOSE_P(i int) antlr.TerminalNode
	T_CLUSTERED() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	T_ENABLE() antlr.TerminalNode
	Index_storage_clause() IIndex_storage_clauseContext
	AllT_ASC() []antlr.TerminalNode
	T_ASC(i int) antlr.TerminalNode
	AllT_DESC() []antlr.TerminalNode
	T_DESC(i int) antlr.TerminalNode
	T_FOREIGN() antlr.TerminalNode
	T_REFERENCES() antlr.TerminalNode
	Table_name() ITable_nameContext
	AllCreate_table_fk_action() []ICreate_table_fk_actionContext
	Create_table_fk_action(i int) ICreate_table_fk_actionContext

	// IsCreate_table_column_consContext differentiates from other interfaces.
	IsCreate_table_column_consContext()
}

type Create_table_column_consContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_column_consContext() *Create_table_column_consContext {
	var p = new(Create_table_column_consContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_column_cons
	return p
}

func InitEmptyCreate_table_column_consContext(p *Create_table_column_consContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_column_cons
}

func (*Create_table_column_consContext) IsCreate_table_column_consContext() {}

func NewCreate_table_column_consContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_column_consContext {
	var p = new(Create_table_column_consContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_column_cons

	return p
}

func (s *Create_table_column_consContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_column_consContext) T_PRIMARY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRIMARY, 0)
}

func (s *Create_table_column_consContext) T_KEY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_KEY, 0)
}

func (s *Create_table_column_consContext) AllT_OPEN_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_OPEN_P)
}

func (s *Create_table_column_consContext) T_OPEN_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, i)
}

func (s *Create_table_column_consContext) AllQident() []IQidentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQidentContext); ok {
			len++
		}
	}

	tst := make([]IQidentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQidentContext); ok {
			tst[i] = t.(IQidentContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_column_consContext) Qident(i int) IQidentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_table_column_consContext) AllT_CLOSE_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_CLOSE_P)
}

func (s *Create_table_column_consContext) T_CLOSE_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, i)
}

func (s *Create_table_column_consContext) T_CLUSTERED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLUSTERED, 0)
}

func (s *Create_table_column_consContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Create_table_column_consContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Create_table_column_consContext) T_ENABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ENABLE, 0)
}

func (s *Create_table_column_consContext) Index_storage_clause() IIndex_storage_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_storage_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_storage_clauseContext)
}

func (s *Create_table_column_consContext) AllT_ASC() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_ASC)
}

func (s *Create_table_column_consContext) T_ASC(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ASC, i)
}

func (s *Create_table_column_consContext) AllT_DESC() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_DESC)
}

func (s *Create_table_column_consContext) T_DESC(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DESC, i)
}

func (s *Create_table_column_consContext) T_FOREIGN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOREIGN, 0)
}

func (s *Create_table_column_consContext) T_REFERENCES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REFERENCES, 0)
}

func (s *Create_table_column_consContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Create_table_column_consContext) AllCreate_table_fk_action() []ICreate_table_fk_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_fk_actionContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_fk_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_fk_actionContext); ok {
			tst[i] = t.(ICreate_table_fk_actionContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_column_consContext) Create_table_fk_action(i int) ICreate_table_fk_actionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_fk_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_fk_actionContext)
}

func (s *Create_table_column_consContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_column_consContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_column_consContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_column_cons(s)
	}
}

func (s *Create_table_column_consContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_column_cons(s)
	}
}

func (p *HplsqlParser) Create_table_column_cons() (localctx ICreate_table_column_consContext) {
	localctx = NewCreate_table_column_consContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, HplsqlParserRULE_create_table_column_cons)
	var _la int

	p.SetState(1068)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_PRIMARY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1011)
			p.Match(HplsqlParserT_PRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1012)
			p.Match(HplsqlParserT_KEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1014)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_CLUSTERED {
			{
				p.SetState(1013)
				p.Match(HplsqlParserT_CLUSTERED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1016)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1017)
			p.Qident()
		}
		p.SetState(1019)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC {
			{
				p.SetState(1018)
				_la = p.GetTokenStream().LA(1)

				if !(_la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1028)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(1021)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1022)
				p.Qident()
			}
			p.SetState(1024)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC {
				{
					p.SetState(1023)
					_la = p.GetTokenStream().LA(1)

					if !(_la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}

			p.SetState(1030)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1031)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1033)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_ENABLE {
			{
				p.SetState(1032)
				p.Match(HplsqlParserT_ENABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1036)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_WITH {
			{
				p.SetState(1035)
				p.Index_storage_clause()
			}

		}

	case HplsqlParserT_FOREIGN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1038)
			p.Match(HplsqlParserT_FOREIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1039)
			p.Match(HplsqlParserT_KEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1040)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1041)
			p.Qident()
		}
		p.SetState(1046)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(1042)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1043)
				p.Qident()
			}

			p.SetState(1048)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1049)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1050)
			p.Match(HplsqlParserT_REFERENCES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1051)
			p.Table_name()
		}
		{
			p.SetState(1052)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1053)
			p.Qident()
		}
		p.SetState(1058)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(1054)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1055)
				p.Qident()
			}

			p.SetState(1060)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1061)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1065)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_ON {
			{
				p.SetState(1062)
				p.Create_table_fk_action()
			}

			p.SetState(1067)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_fk_actionContext is an interface to support dynamic dispatch.
type ICreate_table_fk_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ON() antlr.TerminalNode
	T_UPDATE() antlr.TerminalNode
	T_DELETE() antlr.TerminalNode
	T_NO() antlr.TerminalNode
	T_ACTION() antlr.TerminalNode
	T_RESTRICT() antlr.TerminalNode
	T_SET() antlr.TerminalNode
	T_NULL() antlr.TerminalNode
	T_DEFAULT() antlr.TerminalNode
	T_CASCADE() antlr.TerminalNode

	// IsCreate_table_fk_actionContext differentiates from other interfaces.
	IsCreate_table_fk_actionContext()
}

type Create_table_fk_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_fk_actionContext() *Create_table_fk_actionContext {
	var p = new(Create_table_fk_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_fk_action
	return p
}

func InitEmptyCreate_table_fk_actionContext(p *Create_table_fk_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_fk_action
}

func (*Create_table_fk_actionContext) IsCreate_table_fk_actionContext() {}

func NewCreate_table_fk_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_fk_actionContext {
	var p = new(Create_table_fk_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_fk_action

	return p
}

func (s *Create_table_fk_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_fk_actionContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *Create_table_fk_actionContext) T_UPDATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UPDATE, 0)
}

func (s *Create_table_fk_actionContext) T_DELETE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DELETE, 0)
}

func (s *Create_table_fk_actionContext) T_NO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NO, 0)
}

func (s *Create_table_fk_actionContext) T_ACTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ACTION, 0)
}

func (s *Create_table_fk_actionContext) T_RESTRICT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESTRICT, 0)
}

func (s *Create_table_fk_actionContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Create_table_fk_actionContext) T_NULL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NULL, 0)
}

func (s *Create_table_fk_actionContext) T_DEFAULT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFAULT, 0)
}

func (s *Create_table_fk_actionContext) T_CASCADE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CASCADE, 0)
}

func (s *Create_table_fk_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_fk_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_fk_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_fk_action(s)
	}
}

func (s *Create_table_fk_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_fk_action(s)
	}
}

func (p *HplsqlParser) Create_table_fk_action() (localctx ICreate_table_fk_actionContext) {
	localctx = NewCreate_table_fk_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, HplsqlParserRULE_create_table_fk_action)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1070)
		p.Match(HplsqlParserT_ON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1071)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_DELETE || _la == HplsqlParserT_UPDATE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1080)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1072)
			p.Match(HplsqlParserT_NO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1073)
			p.Match(HplsqlParserT_ACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(1074)
			p.Match(HplsqlParserT_RESTRICT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(1075)
			p.Match(HplsqlParserT_SET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1076)
			p.Match(HplsqlParserT_NULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(1077)
			p.Match(HplsqlParserT_SET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1078)
			p.Match(HplsqlParserT_DEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		{
			p.SetState(1079)
			p.Match(HplsqlParserT_CASCADE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_preoptionsContext is an interface to support dynamic dispatch.
type ICreate_table_preoptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCreate_table_preoptions_item() []ICreate_table_preoptions_itemContext
	Create_table_preoptions_item(i int) ICreate_table_preoptions_itemContext

	// IsCreate_table_preoptionsContext differentiates from other interfaces.
	IsCreate_table_preoptionsContext()
}

type Create_table_preoptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_preoptionsContext() *Create_table_preoptionsContext {
	var p = new(Create_table_preoptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_preoptions
	return p
}

func InitEmptyCreate_table_preoptionsContext(p *Create_table_preoptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_preoptions
}

func (*Create_table_preoptionsContext) IsCreate_table_preoptionsContext() {}

func NewCreate_table_preoptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_preoptionsContext {
	var p = new(Create_table_preoptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_preoptions

	return p
}

func (s *Create_table_preoptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_preoptionsContext) AllCreate_table_preoptions_item() []ICreate_table_preoptions_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_preoptions_itemContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_preoptions_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_preoptions_itemContext); ok {
			tst[i] = t.(ICreate_table_preoptions_itemContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_preoptionsContext) Create_table_preoptions_item(i int) ICreate_table_preoptions_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_preoptions_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_preoptions_itemContext)
}

func (s *Create_table_preoptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_preoptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_preoptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_preoptions(s)
	}
}

func (s *Create_table_preoptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_preoptions(s)
	}
}

func (p *HplsqlParser) Create_table_preoptions() (localctx ICreate_table_preoptionsContext) {
	localctx = NewCreate_table_preoptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, HplsqlParserRULE_create_table_preoptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1083)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == HplsqlParserT_COMMENT || _la == HplsqlParserT_PARTITIONED || _la == HplsqlParserT_ROW || _la == HplsqlParserT_STORED || _la == HplsqlParserT_COMMA {
		{
			p.SetState(1082)
			p.Create_table_preoptions_item()
		}

		p.SetState(1085)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_preoptions_itemContext is an interface to support dynamic dispatch.
type ICreate_table_preoptions_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_COMMA() antlr.TerminalNode
	Create_table_preoptions_td_item() ICreate_table_preoptions_td_itemContext
	Create_table_options_hive_item() ICreate_table_options_hive_itemContext

	// IsCreate_table_preoptions_itemContext differentiates from other interfaces.
	IsCreate_table_preoptions_itemContext()
}

type Create_table_preoptions_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_preoptions_itemContext() *Create_table_preoptions_itemContext {
	var p = new(Create_table_preoptions_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_preoptions_item
	return p
}

func InitEmptyCreate_table_preoptions_itemContext(p *Create_table_preoptions_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_preoptions_item
}

func (*Create_table_preoptions_itemContext) IsCreate_table_preoptions_itemContext() {}

func NewCreate_table_preoptions_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_preoptions_itemContext {
	var p = new(Create_table_preoptions_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_preoptions_item

	return p
}

func (s *Create_table_preoptions_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_preoptions_itemContext) T_COMMA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, 0)
}

func (s *Create_table_preoptions_itemContext) Create_table_preoptions_td_item() ICreate_table_preoptions_td_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_preoptions_td_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_preoptions_td_itemContext)
}

func (s *Create_table_preoptions_itemContext) Create_table_options_hive_item() ICreate_table_options_hive_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_options_hive_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_options_hive_itemContext)
}

func (s *Create_table_preoptions_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_preoptions_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_preoptions_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_preoptions_item(s)
	}
}

func (s *Create_table_preoptions_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_preoptions_item(s)
	}
}

func (p *HplsqlParser) Create_table_preoptions_item() (localctx ICreate_table_preoptions_itemContext) {
	localctx = NewCreate_table_preoptions_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, HplsqlParserRULE_create_table_preoptions_item)
	p.SetState(1090)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_COMMA:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1087)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1088)
			p.Create_table_preoptions_td_item()
		}

	case HplsqlParserT_COMMENT, HplsqlParserT_PARTITIONED, HplsqlParserT_ROW, HplsqlParserT_STORED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1089)
			p.Create_table_options_hive_item()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_preoptions_td_itemContext is an interface to support dynamic dispatch.
type ICreate_table_preoptions_td_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_LOG() antlr.TerminalNode
	T_FALLBACK() antlr.TerminalNode
	T_NO() antlr.TerminalNode

	// IsCreate_table_preoptions_td_itemContext differentiates from other interfaces.
	IsCreate_table_preoptions_td_itemContext()
}

type Create_table_preoptions_td_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_preoptions_td_itemContext() *Create_table_preoptions_td_itemContext {
	var p = new(Create_table_preoptions_td_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_preoptions_td_item
	return p
}

func InitEmptyCreate_table_preoptions_td_itemContext(p *Create_table_preoptions_td_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_preoptions_td_item
}

func (*Create_table_preoptions_td_itemContext) IsCreate_table_preoptions_td_itemContext() {}

func NewCreate_table_preoptions_td_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_preoptions_td_itemContext {
	var p = new(Create_table_preoptions_td_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_preoptions_td_item

	return p
}

func (s *Create_table_preoptions_td_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_preoptions_td_itemContext) T_LOG() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOG, 0)
}

func (s *Create_table_preoptions_td_itemContext) T_FALLBACK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FALLBACK, 0)
}

func (s *Create_table_preoptions_td_itemContext) T_NO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NO, 0)
}

func (s *Create_table_preoptions_td_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_preoptions_td_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_preoptions_td_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_preoptions_td_item(s)
	}
}

func (s *Create_table_preoptions_td_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_preoptions_td_item(s)
	}
}

func (p *HplsqlParser) Create_table_preoptions_td_item() (localctx ICreate_table_preoptions_td_itemContext) {
	localctx = NewCreate_table_preoptions_td_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, HplsqlParserRULE_create_table_preoptions_td_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1093)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_NO {
		{
			p.SetState(1092)
			p.Match(HplsqlParserT_NO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1095)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_FALLBACK || _la == HplsqlParserT_LOG) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_optionsContext is an interface to support dynamic dispatch.
type ICreate_table_optionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCreate_table_options_item() []ICreate_table_options_itemContext
	Create_table_options_item(i int) ICreate_table_options_itemContext

	// IsCreate_table_optionsContext differentiates from other interfaces.
	IsCreate_table_optionsContext()
}

type Create_table_optionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_optionsContext() *Create_table_optionsContext {
	var p = new(Create_table_optionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options
	return p
}

func InitEmptyCreate_table_optionsContext(p *Create_table_optionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options
}

func (*Create_table_optionsContext) IsCreate_table_optionsContext() {}

func NewCreate_table_optionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_optionsContext {
	var p = new(Create_table_optionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_options

	return p
}

func (s *Create_table_optionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_optionsContext) AllCreate_table_options_item() []ICreate_table_options_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_options_itemContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_options_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_options_itemContext); ok {
			tst[i] = t.(ICreate_table_options_itemContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_optionsContext) Create_table_options_item(i int) ICreate_table_options_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_options_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_options_itemContext)
}

func (s *Create_table_optionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_optionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_optionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_options(s)
	}
}

func (s *Create_table_optionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_options(s)
	}
}

func (p *HplsqlParser) Create_table_options() (localctx ICreate_table_optionsContext) {
	localctx = NewCreate_table_optionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, HplsqlParserRULE_create_table_options)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1098)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1097)
				p.Create_table_options_item()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1100)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 85, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_options_itemContext is an interface to support dynamic dispatch.
type ICreate_table_options_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ON() antlr.TerminalNode
	T_COMMIT() antlr.TerminalNode
	T_ROWS() antlr.TerminalNode
	T_DELETE() antlr.TerminalNode
	T_PRESERVE() antlr.TerminalNode
	Create_table_options_ora_item() ICreate_table_options_ora_itemContext
	Create_table_options_db2_item() ICreate_table_options_db2_itemContext
	Create_table_options_td_item() ICreate_table_options_td_itemContext
	Create_table_options_hive_item() ICreate_table_options_hive_itemContext
	Create_table_options_mssql_item() ICreate_table_options_mssql_itemContext
	Create_table_options_mysql_item() ICreate_table_options_mysql_itemContext

	// IsCreate_table_options_itemContext differentiates from other interfaces.
	IsCreate_table_options_itemContext()
}

type Create_table_options_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_options_itemContext() *Create_table_options_itemContext {
	var p = new(Create_table_options_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_item
	return p
}

func InitEmptyCreate_table_options_itemContext(p *Create_table_options_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_item
}

func (*Create_table_options_itemContext) IsCreate_table_options_itemContext() {}

func NewCreate_table_options_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_options_itemContext {
	var p = new(Create_table_options_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_options_item

	return p
}

func (s *Create_table_options_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_options_itemContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *Create_table_options_itemContext) T_COMMIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMIT, 0)
}

func (s *Create_table_options_itemContext) T_ROWS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROWS, 0)
}

func (s *Create_table_options_itemContext) T_DELETE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DELETE, 0)
}

func (s *Create_table_options_itemContext) T_PRESERVE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRESERVE, 0)
}

func (s *Create_table_options_itemContext) Create_table_options_ora_item() ICreate_table_options_ora_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_options_ora_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_options_ora_itemContext)
}

func (s *Create_table_options_itemContext) Create_table_options_db2_item() ICreate_table_options_db2_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_options_db2_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_options_db2_itemContext)
}

func (s *Create_table_options_itemContext) Create_table_options_td_item() ICreate_table_options_td_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_options_td_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_options_td_itemContext)
}

func (s *Create_table_options_itemContext) Create_table_options_hive_item() ICreate_table_options_hive_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_options_hive_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_options_hive_itemContext)
}

func (s *Create_table_options_itemContext) Create_table_options_mssql_item() ICreate_table_options_mssql_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_options_mssql_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_options_mssql_itemContext)
}

func (s *Create_table_options_itemContext) Create_table_options_mysql_item() ICreate_table_options_mysql_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_options_mysql_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_options_mysql_itemContext)
}

func (s *Create_table_options_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_options_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_options_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_options_item(s)
	}
}

func (s *Create_table_options_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_options_item(s)
	}
}

func (p *HplsqlParser) Create_table_options_item() (localctx ICreate_table_options_itemContext) {
	localctx = NewCreate_table_options_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, HplsqlParserRULE_create_table_options_item)
	var _la int

	p.SetState(1112)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1102)
			p.Match(HplsqlParserT_ON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1103)
			p.Match(HplsqlParserT_COMMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1104)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_DELETE || _la == HplsqlParserT_PRESERVE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1105)
			p.Match(HplsqlParserT_ROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1106)
			p.Create_table_options_ora_item()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1107)
			p.Create_table_options_db2_item()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1108)
			p.Create_table_options_td_item()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1109)
			p.Create_table_options_hive_item()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1110)
			p.Create_table_options_mssql_item()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1111)
			p.Create_table_options_mysql_item()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_options_ora_itemContext is an interface to support dynamic dispatch.
type ICreate_table_options_ora_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_SEGMENT() antlr.TerminalNode
	T_CREATION() antlr.TerminalNode
	T_IMMEDIATE() antlr.TerminalNode
	T_DEFERRED() antlr.TerminalNode
	AllL_INT() []antlr.TerminalNode
	L_INT(i int) antlr.TerminalNode
	T_PCTFREE() antlr.TerminalNode
	T_PCTUSED() antlr.TerminalNode
	T_INITRANS() antlr.TerminalNode
	T_MAXTRANS() antlr.TerminalNode
	T_NOCOMPRESS() antlr.TerminalNode
	T_LOGGING() antlr.TerminalNode
	T_NOLOGGING() antlr.TerminalNode
	T_STORAGE() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode
	AllQident() []IQidentContext
	Qident(i int) IQidentContext
	T_TABLESPACE() antlr.TerminalNode

	// IsCreate_table_options_ora_itemContext differentiates from other interfaces.
	IsCreate_table_options_ora_itemContext()
}

type Create_table_options_ora_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_options_ora_itemContext() *Create_table_options_ora_itemContext {
	var p = new(Create_table_options_ora_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_ora_item
	return p
}

func InitEmptyCreate_table_options_ora_itemContext(p *Create_table_options_ora_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_ora_item
}

func (*Create_table_options_ora_itemContext) IsCreate_table_options_ora_itemContext() {}

func NewCreate_table_options_ora_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_options_ora_itemContext {
	var p = new(Create_table_options_ora_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_options_ora_item

	return p
}

func (s *Create_table_options_ora_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_options_ora_itemContext) T_SEGMENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEGMENT, 0)
}

func (s *Create_table_options_ora_itemContext) T_CREATION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATION, 0)
}

func (s *Create_table_options_ora_itemContext) T_IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IMMEDIATE, 0)
}

func (s *Create_table_options_ora_itemContext) T_DEFERRED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFERRED, 0)
}

func (s *Create_table_options_ora_itemContext) AllL_INT() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserL_INT)
}

func (s *Create_table_options_ora_itemContext) L_INT(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_INT, i)
}

func (s *Create_table_options_ora_itemContext) T_PCTFREE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PCTFREE, 0)
}

func (s *Create_table_options_ora_itemContext) T_PCTUSED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PCTUSED, 0)
}

func (s *Create_table_options_ora_itemContext) T_INITRANS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INITRANS, 0)
}

func (s *Create_table_options_ora_itemContext) T_MAXTRANS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAXTRANS, 0)
}

func (s *Create_table_options_ora_itemContext) T_NOCOMPRESS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOCOMPRESS, 0)
}

func (s *Create_table_options_ora_itemContext) T_LOGGING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOGGING, 0)
}

func (s *Create_table_options_ora_itemContext) T_NOLOGGING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOLOGGING, 0)
}

func (s *Create_table_options_ora_itemContext) T_STORAGE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STORAGE, 0)
}

func (s *Create_table_options_ora_itemContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Create_table_options_ora_itemContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Create_table_options_ora_itemContext) AllQident() []IQidentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQidentContext); ok {
			len++
		}
	}

	tst := make([]IQidentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQidentContext); ok {
			tst[i] = t.(IQidentContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_options_ora_itemContext) Qident(i int) IQidentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_table_options_ora_itemContext) T_TABLESPACE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLESPACE, 0)
}

func (s *Create_table_options_ora_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_options_ora_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_options_ora_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_options_ora_item(s)
	}
}

func (s *Create_table_options_ora_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_options_ora_item(s)
	}
}

func (p *HplsqlParser) Create_table_options_ora_item() (localctx ICreate_table_options_ora_itemContext) {
	localctx = NewCreate_table_options_ora_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, HplsqlParserRULE_create_table_options_ora_item)
	var _la int

	p.SetState(1132)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_SEGMENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1114)
			p.Match(HplsqlParserT_SEGMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1115)
			p.Match(HplsqlParserT_CREATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1116)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_DEFERRED || _la == HplsqlParserT_IMMEDIATE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case HplsqlParserT_INITRANS, HplsqlParserT_MAXTRANS, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1117)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_INITRANS || _la == HplsqlParserT_MAXTRANS || _la == HplsqlParserT_PCTFREE || _la == HplsqlParserT_PCTUSED) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1118)
			p.Match(HplsqlParserL_INT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_NOCOMPRESS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1119)
			p.Match(HplsqlParserT_NOCOMPRESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_LOGGING, HplsqlParserT_NOLOGGING:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1120)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_LOGGING || _la == HplsqlParserT_NOLOGGING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case HplsqlParserT_STORAGE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1121)
			p.Match(HplsqlParserT_STORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1122)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1125)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4328521760) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-49392123905) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-72057594037927937) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-36028797094462497) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-1729453312849219585) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&85568393454845951) != 0) {
			p.SetState(1125)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_SUB, HplsqlParserL_ID:
				{
					p.SetState(1123)
					p.Qident()
				}

			case HplsqlParserL_INT:
				{
					p.SetState(1124)
					p.Match(HplsqlParserL_INT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(1127)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1129)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_TABLESPACE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1130)
			p.Match(HplsqlParserT_TABLESPACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1131)
			p.Qident()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_options_db2_itemContext is an interface to support dynamic dispatch.
type ICreate_table_options_db2_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_IN() antlr.TerminalNode
	AllQident() []IQidentContext
	Qident(i int) IQidentContext
	T_INDEX() antlr.TerminalNode
	T_WITH() antlr.TerminalNode
	T_REPLACE() antlr.TerminalNode
	T_DISTRIBUTE() antlr.TerminalNode
	T_BY() antlr.TerminalNode
	T_HASH() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	T_LOGGED() antlr.TerminalNode
	T_NOT() antlr.TerminalNode
	T_COMPRESS() antlr.TerminalNode
	T_YES() antlr.TerminalNode
	T_NO() antlr.TerminalNode
	T_DEFINITION() antlr.TerminalNode
	T_ONLY() antlr.TerminalNode
	T_RESTRICT() antlr.TerminalNode
	T_ON() antlr.TerminalNode
	T_DROP() antlr.TerminalNode

	// IsCreate_table_options_db2_itemContext differentiates from other interfaces.
	IsCreate_table_options_db2_itemContext()
}

type Create_table_options_db2_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_options_db2_itemContext() *Create_table_options_db2_itemContext {
	var p = new(Create_table_options_db2_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_db2_item
	return p
}

func InitEmptyCreate_table_options_db2_itemContext(p *Create_table_options_db2_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_db2_item
}

func (*Create_table_options_db2_itemContext) IsCreate_table_options_db2_itemContext() {}

func NewCreate_table_options_db2_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_options_db2_itemContext {
	var p = new(Create_table_options_db2_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_options_db2_item

	return p
}

func (s *Create_table_options_db2_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_options_db2_itemContext) T_IN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IN, 0)
}

func (s *Create_table_options_db2_itemContext) AllQident() []IQidentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQidentContext); ok {
			len++
		}
	}

	tst := make([]IQidentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQidentContext); ok {
			tst[i] = t.(IQidentContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_options_db2_itemContext) Qident(i int) IQidentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_table_options_db2_itemContext) T_INDEX() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INDEX, 0)
}

func (s *Create_table_options_db2_itemContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITH, 0)
}

func (s *Create_table_options_db2_itemContext) T_REPLACE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REPLACE, 0)
}

func (s *Create_table_options_db2_itemContext) T_DISTRIBUTE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DISTRIBUTE, 0)
}

func (s *Create_table_options_db2_itemContext) T_BY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BY, 0)
}

func (s *Create_table_options_db2_itemContext) T_HASH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HASH, 0)
}

func (s *Create_table_options_db2_itemContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Create_table_options_db2_itemContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Create_table_options_db2_itemContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Create_table_options_db2_itemContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Create_table_options_db2_itemContext) T_LOGGED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOGGED, 0)
}

func (s *Create_table_options_db2_itemContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Create_table_options_db2_itemContext) T_COMPRESS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMPRESS, 0)
}

func (s *Create_table_options_db2_itemContext) T_YES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_YES, 0)
}

func (s *Create_table_options_db2_itemContext) T_NO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NO, 0)
}

func (s *Create_table_options_db2_itemContext) T_DEFINITION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFINITION, 0)
}

func (s *Create_table_options_db2_itemContext) T_ONLY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ONLY, 0)
}

func (s *Create_table_options_db2_itemContext) T_RESTRICT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESTRICT, 0)
}

func (s *Create_table_options_db2_itemContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *Create_table_options_db2_itemContext) T_DROP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DROP, 0)
}

func (s *Create_table_options_db2_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_options_db2_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_options_db2_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_options_db2_item(s)
	}
}

func (s *Create_table_options_db2_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_options_db2_item(s)
	}
}

func (p *HplsqlParser) Create_table_options_db2_item() (localctx ICreate_table_options_db2_itemContext) {
	localctx = NewCreate_table_options_db2_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, HplsqlParserRULE_create_table_options_db2_item)
	var _la int

	p.SetState(1167)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1135)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_INDEX {
			{
				p.SetState(1134)
				p.Match(HplsqlParserT_INDEX)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1137)
			p.Match(HplsqlParserT_IN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1138)
			p.Qident()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1139)
			p.Match(HplsqlParserT_WITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1140)
			p.Match(HplsqlParserT_REPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1141)
			p.Match(HplsqlParserT_DISTRIBUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1142)
			p.Match(HplsqlParserT_BY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1143)
			p.Match(HplsqlParserT_HASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1144)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1145)
			p.Qident()
		}
		p.SetState(1150)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(1146)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1147)
				p.Qident()
			}

			p.SetState(1152)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1153)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1156)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_NOT {
			{
				p.SetState(1155)
				p.Match(HplsqlParserT_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1158)
			p.Match(HplsqlParserT_LOGGED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1159)
			p.Match(HplsqlParserT_COMPRESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1160)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_NO || _la == HplsqlParserT_YES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1161)
			p.Match(HplsqlParserT_DEFINITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1162)
			p.Match(HplsqlParserT_ONLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1163)
			p.Match(HplsqlParserT_WITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1164)
			p.Match(HplsqlParserT_RESTRICT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1165)
			p.Match(HplsqlParserT_ON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1166)
			p.Match(HplsqlParserT_DROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_options_td_itemContext is an interface to support dynamic dispatch.
type ICreate_table_options_td_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_PRIMARY() antlr.TerminalNode
	T_INDEX() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	AllQident() []IQidentContext
	Qident(i int) IQidentContext
	T_CLOSE_P() antlr.TerminalNode
	T_UNIQUE() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	T_WITH() antlr.TerminalNode
	T_DATA() antlr.TerminalNode

	// IsCreate_table_options_td_itemContext differentiates from other interfaces.
	IsCreate_table_options_td_itemContext()
}

type Create_table_options_td_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_options_td_itemContext() *Create_table_options_td_itemContext {
	var p = new(Create_table_options_td_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_td_item
	return p
}

func InitEmptyCreate_table_options_td_itemContext(p *Create_table_options_td_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_td_item
}

func (*Create_table_options_td_itemContext) IsCreate_table_options_td_itemContext() {}

func NewCreate_table_options_td_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_options_td_itemContext {
	var p = new(Create_table_options_td_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_options_td_item

	return p
}

func (s *Create_table_options_td_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_options_td_itemContext) T_PRIMARY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRIMARY, 0)
}

func (s *Create_table_options_td_itemContext) T_INDEX() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INDEX, 0)
}

func (s *Create_table_options_td_itemContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Create_table_options_td_itemContext) AllQident() []IQidentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQidentContext); ok {
			len++
		}
	}

	tst := make([]IQidentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQidentContext); ok {
			tst[i] = t.(IQidentContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_options_td_itemContext) Qident(i int) IQidentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_table_options_td_itemContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Create_table_options_td_itemContext) T_UNIQUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UNIQUE, 0)
}

func (s *Create_table_options_td_itemContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Create_table_options_td_itemContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Create_table_options_td_itemContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITH, 0)
}

func (s *Create_table_options_td_itemContext) T_DATA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATA, 0)
}

func (s *Create_table_options_td_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_options_td_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_options_td_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_options_td_item(s)
	}
}

func (s *Create_table_options_td_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_options_td_item(s)
	}
}

func (p *HplsqlParser) Create_table_options_td_item() (localctx ICreate_table_options_td_itemContext) {
	localctx = NewCreate_table_options_td_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, HplsqlParserRULE_create_table_options_td_item)
	var _la int

	p.SetState(1187)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_PRIMARY, HplsqlParserT_UNIQUE:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1170)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_UNIQUE {
			{
				p.SetState(1169)
				p.Match(HplsqlParserT_UNIQUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1172)
			p.Match(HplsqlParserT_PRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1173)
			p.Match(HplsqlParserT_INDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1174)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1175)
			p.Qident()
		}
		p.SetState(1180)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(1176)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1177)
				p.Qident()
			}

			p.SetState(1182)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1183)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_WITH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1185)
			p.Match(HplsqlParserT_WITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1186)
			p.Match(HplsqlParserT_DATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartition_column_nameContext is an interface to support dynamic dispatch.
type IPartition_column_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Qident() IQidentContext

	// IsPartition_column_nameContext differentiates from other interfaces.
	IsPartition_column_nameContext()
}

type Partition_column_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartition_column_nameContext() *Partition_column_nameContext {
	var p = new(Partition_column_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_partition_column_name
	return p
}

func InitEmptyPartition_column_nameContext(p *Partition_column_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_partition_column_name
}

func (*Partition_column_nameContext) IsPartition_column_nameContext() {}

func NewPartition_column_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Partition_column_nameContext {
	var p = new(Partition_column_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_partition_column_name

	return p
}

func (s *Partition_column_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Partition_column_nameContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Partition_column_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Partition_column_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Partition_column_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterPartition_column_name(s)
	}
}

func (s *Partition_column_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitPartition_column_name(s)
	}
}

func (p *HplsqlParser) Partition_column_name() (localctx IPartition_column_nameContext) {
	localctx = NewPartition_column_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, HplsqlParserRULE_partition_column_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1189)
		p.Qident()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartition_dtypeContext is an interface to support dynamic dispatch.
type IPartition_dtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_CHAR() antlr.TerminalNode
	T_CHARACTER() antlr.TerminalNode
	T_BIGINT() antlr.TerminalNode
	T_BINARY_DOUBLE() antlr.TerminalNode
	T_BINARY_FLOAT() antlr.TerminalNode
	T_BINARY_INTEGER() antlr.TerminalNode
	T_BIT() antlr.TerminalNode
	T_DATE() antlr.TerminalNode
	T_DATETIME() antlr.TerminalNode
	T_DEC() antlr.TerminalNode
	T_DECIMAL() antlr.TerminalNode
	T_DOUBLE() antlr.TerminalNode
	T_PRECISION() antlr.TerminalNode
	T_FLOAT() antlr.TerminalNode
	T_INT() antlr.TerminalNode
	T_INT2() antlr.TerminalNode
	T_INT4() antlr.TerminalNode
	T_INT8() antlr.TerminalNode
	T_INTEGER() antlr.TerminalNode
	T_NCHAR() antlr.TerminalNode
	T_NVARCHAR() antlr.TerminalNode
	T_NUMBER() antlr.TerminalNode
	T_NUMERIC() antlr.TerminalNode
	T_PLS_INTEGER() antlr.TerminalNode
	T_REAL() antlr.TerminalNode
	T_RESULT_SET_LOCATOR() antlr.TerminalNode
	T_VARYING() antlr.TerminalNode
	T_SIMPLE_FLOAT() antlr.TerminalNode
	T_SIMPLE_DOUBLE() antlr.TerminalNode
	T_SIMPLE_INTEGER() antlr.TerminalNode
	T_SMALLINT() antlr.TerminalNode
	T_SMALLDATETIME() antlr.TerminalNode
	T_STRING() antlr.TerminalNode
	T_SYS_REFCURSOR() antlr.TerminalNode
	T_TIMESTAMP() antlr.TerminalNode
	T_TINYINT() antlr.TerminalNode
	T_VARCHAR() antlr.TerminalNode
	T_VARCHAR2() antlr.TerminalNode
	T_XML() antlr.TerminalNode
	T_BOOLEAN() antlr.TerminalNode

	// IsPartition_dtypeContext differentiates from other interfaces.
	IsPartition_dtypeContext()
}

type Partition_dtypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartition_dtypeContext() *Partition_dtypeContext {
	var p = new(Partition_dtypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_partition_dtype
	return p
}

func InitEmptyPartition_dtypeContext(p *Partition_dtypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_partition_dtype
}

func (*Partition_dtypeContext) IsPartition_dtypeContext() {}

func NewPartition_dtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Partition_dtypeContext {
	var p = new(Partition_dtypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_partition_dtype

	return p
}

func (s *Partition_dtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *Partition_dtypeContext) T_CHAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CHAR, 0)
}

func (s *Partition_dtypeContext) T_CHARACTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CHARACTER, 0)
}

func (s *Partition_dtypeContext) T_BIGINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BIGINT, 0)
}

func (s *Partition_dtypeContext) T_BINARY_DOUBLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BINARY_DOUBLE, 0)
}

func (s *Partition_dtypeContext) T_BINARY_FLOAT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BINARY_FLOAT, 0)
}

func (s *Partition_dtypeContext) T_BINARY_INTEGER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BINARY_INTEGER, 0)
}

func (s *Partition_dtypeContext) T_BIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BIT, 0)
}

func (s *Partition_dtypeContext) T_DATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATE, 0)
}

func (s *Partition_dtypeContext) T_DATETIME() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATETIME, 0)
}

func (s *Partition_dtypeContext) T_DEC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEC, 0)
}

func (s *Partition_dtypeContext) T_DECIMAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DECIMAL, 0)
}

func (s *Partition_dtypeContext) T_DOUBLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DOUBLE, 0)
}

func (s *Partition_dtypeContext) T_PRECISION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRECISION, 0)
}

func (s *Partition_dtypeContext) T_FLOAT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FLOAT, 0)
}

func (s *Partition_dtypeContext) T_INT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INT, 0)
}

func (s *Partition_dtypeContext) T_INT2() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INT2, 0)
}

func (s *Partition_dtypeContext) T_INT4() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INT4, 0)
}

func (s *Partition_dtypeContext) T_INT8() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INT8, 0)
}

func (s *Partition_dtypeContext) T_INTEGER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTEGER, 0)
}

func (s *Partition_dtypeContext) T_NCHAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NCHAR, 0)
}

func (s *Partition_dtypeContext) T_NVARCHAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NVARCHAR, 0)
}

func (s *Partition_dtypeContext) T_NUMBER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NUMBER, 0)
}

func (s *Partition_dtypeContext) T_NUMERIC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NUMERIC, 0)
}

func (s *Partition_dtypeContext) T_PLS_INTEGER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PLS_INTEGER, 0)
}

func (s *Partition_dtypeContext) T_REAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REAL, 0)
}

func (s *Partition_dtypeContext) T_RESULT_SET_LOCATOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESULT_SET_LOCATOR, 0)
}

func (s *Partition_dtypeContext) T_VARYING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VARYING, 0)
}

func (s *Partition_dtypeContext) T_SIMPLE_FLOAT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SIMPLE_FLOAT, 0)
}

func (s *Partition_dtypeContext) T_SIMPLE_DOUBLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SIMPLE_DOUBLE, 0)
}

func (s *Partition_dtypeContext) T_SIMPLE_INTEGER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SIMPLE_INTEGER, 0)
}

func (s *Partition_dtypeContext) T_SMALLINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SMALLINT, 0)
}

func (s *Partition_dtypeContext) T_SMALLDATETIME() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SMALLDATETIME, 0)
}

func (s *Partition_dtypeContext) T_STRING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STRING, 0)
}

func (s *Partition_dtypeContext) T_SYS_REFCURSOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SYS_REFCURSOR, 0)
}

func (s *Partition_dtypeContext) T_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TIMESTAMP, 0)
}

func (s *Partition_dtypeContext) T_TINYINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TINYINT, 0)
}

func (s *Partition_dtypeContext) T_VARCHAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VARCHAR, 0)
}

func (s *Partition_dtypeContext) T_VARCHAR2() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VARCHAR2, 0)
}

func (s *Partition_dtypeContext) T_XML() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_XML, 0)
}

func (s *Partition_dtypeContext) T_BOOLEAN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BOOLEAN, 0)
}

func (s *Partition_dtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Partition_dtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Partition_dtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterPartition_dtype(s)
	}
}

func (s *Partition_dtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitPartition_dtype(s)
	}
}

func (p *HplsqlParser) Partition_dtype() (localctx IPartition_dtypeContext) {
	localctx = NewPartition_dtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, HplsqlParserRULE_partition_dtype)
	var _la int

	p.SetState(1233)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_CHAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1191)
			p.Match(HplsqlParserT_CHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_CHARACTER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1192)
			p.Match(HplsqlParserT_CHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_BIGINT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1193)
			p.Match(HplsqlParserT_BIGINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_BINARY_DOUBLE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1194)
			p.Match(HplsqlParserT_BINARY_DOUBLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_BINARY_FLOAT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1195)
			p.Match(HplsqlParserT_BINARY_FLOAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_BINARY_INTEGER:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1196)
			p.Match(HplsqlParserT_BINARY_INTEGER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_BIT:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1197)
			p.Match(HplsqlParserT_BIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_DATE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1198)
			p.Match(HplsqlParserT_DATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_DATETIME:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1199)
			p.Match(HplsqlParserT_DATETIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_DEC:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1200)
			p.Match(HplsqlParserT_DEC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_DECIMAL:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1201)
			p.Match(HplsqlParserT_DECIMAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_DOUBLE:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1202)
			p.Match(HplsqlParserT_DOUBLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1204)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_PRECISION {
			{
				p.SetState(1203)
				p.Match(HplsqlParserT_PRECISION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case HplsqlParserT_FLOAT:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1206)
			p.Match(HplsqlParserT_FLOAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_INT:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1207)
			p.Match(HplsqlParserT_INT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_INT2:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1208)
			p.Match(HplsqlParserT_INT2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_INT4:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1209)
			p.Match(HplsqlParserT_INT4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_INT8:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1210)
			p.Match(HplsqlParserT_INT8)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_INTEGER:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1211)
			p.Match(HplsqlParserT_INTEGER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_NCHAR:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1212)
			p.Match(HplsqlParserT_NCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_NVARCHAR:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1213)
			p.Match(HplsqlParserT_NVARCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_NUMBER:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1214)
			p.Match(HplsqlParserT_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_NUMERIC:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1215)
			p.Match(HplsqlParserT_NUMERIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_PLS_INTEGER:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1216)
			p.Match(HplsqlParserT_PLS_INTEGER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_REAL:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1217)
			p.Match(HplsqlParserT_REAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_RESULT_SET_LOCATOR:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(1218)
			p.Match(HplsqlParserT_RESULT_SET_LOCATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1219)
			p.Match(HplsqlParserT_VARYING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_SIMPLE_FLOAT:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1220)
			p.Match(HplsqlParserT_SIMPLE_FLOAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_SIMPLE_DOUBLE:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(1221)
			p.Match(HplsqlParserT_SIMPLE_DOUBLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_SIMPLE_INTEGER:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(1222)
			p.Match(HplsqlParserT_SIMPLE_INTEGER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_SMALLINT:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(1223)
			p.Match(HplsqlParserT_SMALLINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_SMALLDATETIME:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(1224)
			p.Match(HplsqlParserT_SMALLDATETIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_STRING:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(1225)
			p.Match(HplsqlParserT_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_SYS_REFCURSOR:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(1226)
			p.Match(HplsqlParserT_SYS_REFCURSOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_TIMESTAMP:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(1227)
			p.Match(HplsqlParserT_TIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_TINYINT:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(1228)
			p.Match(HplsqlParserT_TINYINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_VARCHAR:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(1229)
			p.Match(HplsqlParserT_VARCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_VARCHAR2:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(1230)
			p.Match(HplsqlParserT_VARCHAR2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_XML:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(1231)
			p.Match(HplsqlParserT_XML)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_BOOLEAN:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(1232)
			p.Match(HplsqlParserT_BOOLEAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartition_dtype_lenContext is an interface to support dynamic dispatch.
type IPartition_dtype_lenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode
	AllL_INT() []antlr.TerminalNode
	L_INT(i int) antlr.TerminalNode
	T_MAX() antlr.TerminalNode
	T_COMMA() antlr.TerminalNode
	T_CHAR() antlr.TerminalNode
	T_BYTE() antlr.TerminalNode

	// IsPartition_dtype_lenContext differentiates from other interfaces.
	IsPartition_dtype_lenContext()
}

type Partition_dtype_lenContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartition_dtype_lenContext() *Partition_dtype_lenContext {
	var p = new(Partition_dtype_lenContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_partition_dtype_len
	return p
}

func InitEmptyPartition_dtype_lenContext(p *Partition_dtype_lenContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_partition_dtype_len
}

func (*Partition_dtype_lenContext) IsPartition_dtype_lenContext() {}

func NewPartition_dtype_lenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Partition_dtype_lenContext {
	var p = new(Partition_dtype_lenContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_partition_dtype_len

	return p
}

func (s *Partition_dtype_lenContext) GetParser() antlr.Parser { return s.parser }

func (s *Partition_dtype_lenContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Partition_dtype_lenContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Partition_dtype_lenContext) AllL_INT() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserL_INT)
}

func (s *Partition_dtype_lenContext) L_INT(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_INT, i)
}

func (s *Partition_dtype_lenContext) T_MAX() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAX, 0)
}

func (s *Partition_dtype_lenContext) T_COMMA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, 0)
}

func (s *Partition_dtype_lenContext) T_CHAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CHAR, 0)
}

func (s *Partition_dtype_lenContext) T_BYTE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BYTE, 0)
}

func (s *Partition_dtype_lenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Partition_dtype_lenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Partition_dtype_lenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterPartition_dtype_len(s)
	}
}

func (s *Partition_dtype_lenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitPartition_dtype_len(s)
	}
}

func (p *HplsqlParser) Partition_dtype_len() (localctx IPartition_dtype_lenContext) {
	localctx = NewPartition_dtype_lenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, HplsqlParserRULE_partition_dtype_len)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1235)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1236)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_MAX || _la == HplsqlParserL_INT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1238)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_BYTE || _la == HplsqlParserT_CHAR {
		{
			p.SetState(1237)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_BYTE || _la == HplsqlParserT_CHAR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1242)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_COMMA {
		{
			p.SetState(1240)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1241)
			p.Match(HplsqlParserL_INT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1244)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_hive_partition_columns_itemContext is an interface to support dynamic dispatch.
type ICreate_table_hive_partition_columns_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Partition_column_name() IPartition_column_nameContext
	Partition_dtype() IPartition_dtypeContext
	Partition_dtype_len() IPartition_dtype_lenContext

	// IsCreate_table_hive_partition_columns_itemContext differentiates from other interfaces.
	IsCreate_table_hive_partition_columns_itemContext()
}

type Create_table_hive_partition_columns_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_hive_partition_columns_itemContext() *Create_table_hive_partition_columns_itemContext {
	var p = new(Create_table_hive_partition_columns_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_hive_partition_columns_item
	return p
}

func InitEmptyCreate_table_hive_partition_columns_itemContext(p *Create_table_hive_partition_columns_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_hive_partition_columns_item
}

func (*Create_table_hive_partition_columns_itemContext) IsCreate_table_hive_partition_columns_itemContext() {
}

func NewCreate_table_hive_partition_columns_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_hive_partition_columns_itemContext {
	var p = new(Create_table_hive_partition_columns_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_hive_partition_columns_item

	return p
}

func (s *Create_table_hive_partition_columns_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_hive_partition_columns_itemContext) Partition_column_name() IPartition_column_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartition_column_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartition_column_nameContext)
}

func (s *Create_table_hive_partition_columns_itemContext) Partition_dtype() IPartition_dtypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartition_dtypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartition_dtypeContext)
}

func (s *Create_table_hive_partition_columns_itemContext) Partition_dtype_len() IPartition_dtype_lenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartition_dtype_lenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartition_dtype_lenContext)
}

func (s *Create_table_hive_partition_columns_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_hive_partition_columns_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_hive_partition_columns_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_hive_partition_columns_item(s)
	}
}

func (s *Create_table_hive_partition_columns_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_hive_partition_columns_item(s)
	}
}

func (p *HplsqlParser) Create_table_hive_partition_columns_item() (localctx ICreate_table_hive_partition_columns_itemContext) {
	localctx = NewCreate_table_hive_partition_columns_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, HplsqlParserRULE_create_table_hive_partition_columns_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1246)
		p.Partition_column_name()
	}
	{
		p.SetState(1247)
		p.Partition_dtype()
	}
	p.SetState(1249)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_OPEN_P {
		{
			p.SetState(1248)
			p.Partition_dtype_len()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_hive_partition_column_commentContext is an interface to support dynamic dispatch.
type ICreate_table_hive_partition_column_commentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_COMMENT() antlr.TerminalNode
	Expr() IExprContext

	// IsCreate_table_hive_partition_column_commentContext differentiates from other interfaces.
	IsCreate_table_hive_partition_column_commentContext()
}

type Create_table_hive_partition_column_commentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_hive_partition_column_commentContext() *Create_table_hive_partition_column_commentContext {
	var p = new(Create_table_hive_partition_column_commentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_hive_partition_column_comment
	return p
}

func InitEmptyCreate_table_hive_partition_column_commentContext(p *Create_table_hive_partition_column_commentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_hive_partition_column_comment
}

func (*Create_table_hive_partition_column_commentContext) IsCreate_table_hive_partition_column_commentContext() {
}

func NewCreate_table_hive_partition_column_commentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_hive_partition_column_commentContext {
	var p = new(Create_table_hive_partition_column_commentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_hive_partition_column_comment

	return p
}

func (s *Create_table_hive_partition_column_commentContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_hive_partition_column_commentContext) T_COMMENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMENT, 0)
}

func (s *Create_table_hive_partition_column_commentContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Create_table_hive_partition_column_commentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_hive_partition_column_commentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_hive_partition_column_commentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_hive_partition_column_comment(s)
	}
}

func (s *Create_table_hive_partition_column_commentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_hive_partition_column_comment(s)
	}
}

func (p *HplsqlParser) Create_table_hive_partition_column_comment() (localctx ICreate_table_hive_partition_column_commentContext) {
	localctx = NewCreate_table_hive_partition_column_commentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, HplsqlParserRULE_create_table_hive_partition_column_comment)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1251)
		p.Match(HplsqlParserT_COMMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1252)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_hive_partition_columnsContext is an interface to support dynamic dispatch.
type ICreate_table_hive_partition_columnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCreate_table_hive_partition_columns_item() []ICreate_table_hive_partition_columns_itemContext
	Create_table_hive_partition_columns_item(i int) ICreate_table_hive_partition_columns_itemContext
	AllCreate_table_hive_partition_column_comment() []ICreate_table_hive_partition_column_commentContext
	Create_table_hive_partition_column_comment(i int) ICreate_table_hive_partition_column_commentContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsCreate_table_hive_partition_columnsContext differentiates from other interfaces.
	IsCreate_table_hive_partition_columnsContext()
}

type Create_table_hive_partition_columnsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_hive_partition_columnsContext() *Create_table_hive_partition_columnsContext {
	var p = new(Create_table_hive_partition_columnsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_hive_partition_columns
	return p
}

func InitEmptyCreate_table_hive_partition_columnsContext(p *Create_table_hive_partition_columnsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_hive_partition_columns
}

func (*Create_table_hive_partition_columnsContext) IsCreate_table_hive_partition_columnsContext() {}

func NewCreate_table_hive_partition_columnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_hive_partition_columnsContext {
	var p = new(Create_table_hive_partition_columnsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_hive_partition_columns

	return p
}

func (s *Create_table_hive_partition_columnsContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_hive_partition_columnsContext) AllCreate_table_hive_partition_columns_item() []ICreate_table_hive_partition_columns_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_hive_partition_columns_itemContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_hive_partition_columns_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_hive_partition_columns_itemContext); ok {
			tst[i] = t.(ICreate_table_hive_partition_columns_itemContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_hive_partition_columnsContext) Create_table_hive_partition_columns_item(i int) ICreate_table_hive_partition_columns_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_hive_partition_columns_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_hive_partition_columns_itemContext)
}

func (s *Create_table_hive_partition_columnsContext) AllCreate_table_hive_partition_column_comment() []ICreate_table_hive_partition_column_commentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_hive_partition_column_commentContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_hive_partition_column_commentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_hive_partition_column_commentContext); ok {
			tst[i] = t.(ICreate_table_hive_partition_column_commentContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_hive_partition_columnsContext) Create_table_hive_partition_column_comment(i int) ICreate_table_hive_partition_column_commentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_hive_partition_column_commentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_hive_partition_column_commentContext)
}

func (s *Create_table_hive_partition_columnsContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Create_table_hive_partition_columnsContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Create_table_hive_partition_columnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_hive_partition_columnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_hive_partition_columnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_hive_partition_columns(s)
	}
}

func (s *Create_table_hive_partition_columnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_hive_partition_columns(s)
	}
}

func (p *HplsqlParser) Create_table_hive_partition_columns() (localctx ICreate_table_hive_partition_columnsContext) {
	localctx = NewCreate_table_hive_partition_columnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, HplsqlParserRULE_create_table_hive_partition_columns)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1254)
		p.Create_table_hive_partition_columns_item()
	}
	p.SetState(1256)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_COMMENT {
		{
			p.SetState(1255)
			p.Create_table_hive_partition_column_comment()
		}

	}
	p.SetState(1265)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(1258)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1259)
			p.Create_table_hive_partition_columns_item()
		}
		p.SetState(1261)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_COMMENT {
			{
				p.SetState(1260)
				p.Create_table_hive_partition_column_comment()
			}

		}

		p.SetState(1267)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_hive_partitiionContext is an interface to support dynamic dispatch.
type ICreate_table_hive_partitiionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_PARTITIONED() antlr.TerminalNode
	T_BY() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	Create_table_hive_partition_columns() ICreate_table_hive_partition_columnsContext
	T_CLOSE_P() antlr.TerminalNode

	// IsCreate_table_hive_partitiionContext differentiates from other interfaces.
	IsCreate_table_hive_partitiionContext()
}

type Create_table_hive_partitiionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_hive_partitiionContext() *Create_table_hive_partitiionContext {
	var p = new(Create_table_hive_partitiionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_hive_partitiion
	return p
}

func InitEmptyCreate_table_hive_partitiionContext(p *Create_table_hive_partitiionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_hive_partitiion
}

func (*Create_table_hive_partitiionContext) IsCreate_table_hive_partitiionContext() {}

func NewCreate_table_hive_partitiionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_hive_partitiionContext {
	var p = new(Create_table_hive_partitiionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_hive_partitiion

	return p
}

func (s *Create_table_hive_partitiionContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_hive_partitiionContext) T_PARTITIONED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PARTITIONED, 0)
}

func (s *Create_table_hive_partitiionContext) T_BY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BY, 0)
}

func (s *Create_table_hive_partitiionContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Create_table_hive_partitiionContext) Create_table_hive_partition_columns() ICreate_table_hive_partition_columnsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_hive_partition_columnsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_hive_partition_columnsContext)
}

func (s *Create_table_hive_partitiionContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Create_table_hive_partitiionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_hive_partitiionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_hive_partitiionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_hive_partitiion(s)
	}
}

func (s *Create_table_hive_partitiionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_hive_partitiion(s)
	}
}

func (p *HplsqlParser) Create_table_hive_partitiion() (localctx ICreate_table_hive_partitiionContext) {
	localctx = NewCreate_table_hive_partitiionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, HplsqlParserRULE_create_table_hive_partitiion)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1268)
		p.Match(HplsqlParserT_PARTITIONED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1269)
		p.Match(HplsqlParserT_BY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1270)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1271)
		p.Create_table_hive_partition_columns()
	}
	{
		p.SetState(1272)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_options_hive_commentContext is an interface to support dynamic dispatch.
type ICreate_table_options_hive_commentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_COMMENT() antlr.TerminalNode
	Expr() IExprContext

	// IsCreate_table_options_hive_commentContext differentiates from other interfaces.
	IsCreate_table_options_hive_commentContext()
}

type Create_table_options_hive_commentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_options_hive_commentContext() *Create_table_options_hive_commentContext {
	var p = new(Create_table_options_hive_commentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_hive_comment
	return p
}

func InitEmptyCreate_table_options_hive_commentContext(p *Create_table_options_hive_commentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_hive_comment
}

func (*Create_table_options_hive_commentContext) IsCreate_table_options_hive_commentContext() {}

func NewCreate_table_options_hive_commentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_options_hive_commentContext {
	var p = new(Create_table_options_hive_commentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_options_hive_comment

	return p
}

func (s *Create_table_options_hive_commentContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_options_hive_commentContext) T_COMMENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMENT, 0)
}

func (s *Create_table_options_hive_commentContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Create_table_options_hive_commentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_options_hive_commentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_options_hive_commentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_options_hive_comment(s)
	}
}

func (s *Create_table_options_hive_commentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_options_hive_comment(s)
	}
}

func (p *HplsqlParser) Create_table_options_hive_comment() (localctx ICreate_table_options_hive_commentContext) {
	localctx = NewCreate_table_options_hive_commentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, HplsqlParserRULE_create_table_options_hive_comment)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1274)
		p.Match(HplsqlParserT_COMMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1275)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_options_hive_itemContext is an interface to support dynamic dispatch.
type ICreate_table_options_hive_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Create_table_options_hive_comment() ICreate_table_options_hive_commentContext
	Create_table_hive_partitiion() ICreate_table_hive_partitiionContext
	Create_table_hive_row_format() ICreate_table_hive_row_formatContext
	T_STORED() antlr.TerminalNode
	T_AS() antlr.TerminalNode
	Qident() IQidentContext

	// IsCreate_table_options_hive_itemContext differentiates from other interfaces.
	IsCreate_table_options_hive_itemContext()
}

type Create_table_options_hive_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_options_hive_itemContext() *Create_table_options_hive_itemContext {
	var p = new(Create_table_options_hive_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_hive_item
	return p
}

func InitEmptyCreate_table_options_hive_itemContext(p *Create_table_options_hive_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_hive_item
}

func (*Create_table_options_hive_itemContext) IsCreate_table_options_hive_itemContext() {}

func NewCreate_table_options_hive_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_options_hive_itemContext {
	var p = new(Create_table_options_hive_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_options_hive_item

	return p
}

func (s *Create_table_options_hive_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_options_hive_itemContext) Create_table_options_hive_comment() ICreate_table_options_hive_commentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_options_hive_commentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_options_hive_commentContext)
}

func (s *Create_table_options_hive_itemContext) Create_table_hive_partitiion() ICreate_table_hive_partitiionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_hive_partitiionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_hive_partitiionContext)
}

func (s *Create_table_options_hive_itemContext) Create_table_hive_row_format() ICreate_table_hive_row_formatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_hive_row_formatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_hive_row_formatContext)
}

func (s *Create_table_options_hive_itemContext) T_STORED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STORED, 0)
}

func (s *Create_table_options_hive_itemContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Create_table_options_hive_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_table_options_hive_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_options_hive_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_options_hive_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_options_hive_item(s)
	}
}

func (s *Create_table_options_hive_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_options_hive_item(s)
	}
}

func (p *HplsqlParser) Create_table_options_hive_item() (localctx ICreate_table_options_hive_itemContext) {
	localctx = NewCreate_table_options_hive_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, HplsqlParserRULE_create_table_options_hive_item)
	p.SetState(1283)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_COMMENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1277)
			p.Create_table_options_hive_comment()
		}

	case HplsqlParserT_PARTITIONED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1278)
			p.Create_table_hive_partitiion()
		}

	case HplsqlParserT_ROW:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1279)
			p.Create_table_hive_row_format()
		}

	case HplsqlParserT_STORED:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1280)
			p.Match(HplsqlParserT_STORED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1281)
			p.Match(HplsqlParserT_AS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1282)
			p.Qident()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_hive_row_formatContext is an interface to support dynamic dispatch.
type ICreate_table_hive_row_formatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ROW() antlr.TerminalNode
	T_FORMAT() antlr.TerminalNode
	T_DELIMITED() antlr.TerminalNode
	AllCreate_table_hive_row_format_fields() []ICreate_table_hive_row_format_fieldsContext
	Create_table_hive_row_format_fields(i int) ICreate_table_hive_row_format_fieldsContext

	// IsCreate_table_hive_row_formatContext differentiates from other interfaces.
	IsCreate_table_hive_row_formatContext()
}

type Create_table_hive_row_formatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_hive_row_formatContext() *Create_table_hive_row_formatContext {
	var p = new(Create_table_hive_row_formatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_hive_row_format
	return p
}

func InitEmptyCreate_table_hive_row_formatContext(p *Create_table_hive_row_formatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_hive_row_format
}

func (*Create_table_hive_row_formatContext) IsCreate_table_hive_row_formatContext() {}

func NewCreate_table_hive_row_formatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_hive_row_formatContext {
	var p = new(Create_table_hive_row_formatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_hive_row_format

	return p
}

func (s *Create_table_hive_row_formatContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_hive_row_formatContext) T_ROW() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROW, 0)
}

func (s *Create_table_hive_row_formatContext) T_FORMAT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FORMAT, 0)
}

func (s *Create_table_hive_row_formatContext) T_DELIMITED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DELIMITED, 0)
}

func (s *Create_table_hive_row_formatContext) AllCreate_table_hive_row_format_fields() []ICreate_table_hive_row_format_fieldsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_hive_row_format_fieldsContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_hive_row_format_fieldsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_hive_row_format_fieldsContext); ok {
			tst[i] = t.(ICreate_table_hive_row_format_fieldsContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_hive_row_formatContext) Create_table_hive_row_format_fields(i int) ICreate_table_hive_row_format_fieldsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_hive_row_format_fieldsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_hive_row_format_fieldsContext)
}

func (s *Create_table_hive_row_formatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_hive_row_formatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_hive_row_formatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_hive_row_format(s)
	}
}

func (s *Create_table_hive_row_formatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_hive_row_format(s)
	}
}

func (p *HplsqlParser) Create_table_hive_row_format() (localctx ICreate_table_hive_row_formatContext) {
	localctx = NewCreate_table_hive_row_formatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, HplsqlParserRULE_create_table_hive_row_format)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1285)
		p.Match(HplsqlParserT_ROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1286)
		p.Match(HplsqlParserT_FORMAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1287)
		p.Match(HplsqlParserT_DELIMITED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1291)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 106, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1288)
				p.Create_table_hive_row_format_fields()
			}

		}
		p.SetState(1293)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 106, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_hive_row_format_fieldsContext is an interface to support dynamic dispatch.
type ICreate_table_hive_row_format_fieldsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_FIELDS() antlr.TerminalNode
	T_TERMINATED() antlr.TerminalNode
	AllT_BY() []antlr.TerminalNode
	T_BY(i int) antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_ESCAPED() antlr.TerminalNode
	T_COLLECTION() antlr.TerminalNode
	T_ITEMS() antlr.TerminalNode
	T_MAP() antlr.TerminalNode
	T_KEYS() antlr.TerminalNode
	T_LINES() antlr.TerminalNode
	T_NULL() antlr.TerminalNode
	T_DEFINED() antlr.TerminalNode
	T_AS() antlr.TerminalNode

	// IsCreate_table_hive_row_format_fieldsContext differentiates from other interfaces.
	IsCreate_table_hive_row_format_fieldsContext()
}

type Create_table_hive_row_format_fieldsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_hive_row_format_fieldsContext() *Create_table_hive_row_format_fieldsContext {
	var p = new(Create_table_hive_row_format_fieldsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_hive_row_format_fields
	return p
}

func InitEmptyCreate_table_hive_row_format_fieldsContext(p *Create_table_hive_row_format_fieldsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_hive_row_format_fields
}

func (*Create_table_hive_row_format_fieldsContext) IsCreate_table_hive_row_format_fieldsContext() {}

func NewCreate_table_hive_row_format_fieldsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_hive_row_format_fieldsContext {
	var p = new(Create_table_hive_row_format_fieldsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_hive_row_format_fields

	return p
}

func (s *Create_table_hive_row_format_fieldsContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_hive_row_format_fieldsContext) T_FIELDS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FIELDS, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) T_TERMINATED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TERMINATED, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) AllT_BY() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_BY)
}

func (s *Create_table_hive_row_format_fieldsContext) T_BY(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BY, i)
}

func (s *Create_table_hive_row_format_fieldsContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_hive_row_format_fieldsContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Create_table_hive_row_format_fieldsContext) T_ESCAPED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ESCAPED, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) T_COLLECTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLLECTION, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) T_ITEMS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ITEMS, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) T_MAP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAP, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) T_KEYS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_KEYS, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) T_LINES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LINES, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) T_NULL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NULL, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) T_DEFINED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFINED, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_hive_row_format_fieldsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_hive_row_format_fieldsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_hive_row_format_fields(s)
	}
}

func (s *Create_table_hive_row_format_fieldsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_hive_row_format_fields(s)
	}
}

func (p *HplsqlParser) Create_table_hive_row_format_fields() (localctx ICreate_table_hive_row_format_fieldsContext) {
	localctx = NewCreate_table_hive_row_format_fieldsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, HplsqlParserRULE_create_table_hive_row_format_fields)
	p.SetState(1321)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_FIELDS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1294)
			p.Match(HplsqlParserT_FIELDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1295)
			p.Match(HplsqlParserT_TERMINATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1296)
			p.Match(HplsqlParserT_BY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1297)
			p.expr(0)
		}
		p.SetState(1301)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 107, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1298)
				p.Match(HplsqlParserT_ESCAPED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1299)
				p.Match(HplsqlParserT_BY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1300)
				p.expr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case HplsqlParserT_COLLECTION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1303)
			p.Match(HplsqlParserT_COLLECTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1304)
			p.Match(HplsqlParserT_ITEMS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1305)
			p.Match(HplsqlParserT_TERMINATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1306)
			p.Match(HplsqlParserT_BY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1307)
			p.expr(0)
		}

	case HplsqlParserT_MAP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1308)
			p.Match(HplsqlParserT_MAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1309)
			p.Match(HplsqlParserT_KEYS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1310)
			p.Match(HplsqlParserT_TERMINATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1311)
			p.Match(HplsqlParserT_BY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1312)
			p.expr(0)
		}

	case HplsqlParserT_LINES:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1313)
			p.Match(HplsqlParserT_LINES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1314)
			p.Match(HplsqlParserT_TERMINATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1315)
			p.Match(HplsqlParserT_BY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1316)
			p.expr(0)
		}

	case HplsqlParserT_NULL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1317)
			p.Match(HplsqlParserT_NULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1318)
			p.Match(HplsqlParserT_DEFINED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1319)
			p.Match(HplsqlParserT_AS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1320)
			p.expr(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_options_mssql_itemContext is an interface to support dynamic dispatch.
type ICreate_table_options_mssql_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ON() antlr.TerminalNode
	Qident() IQidentContext
	T_TEXTIMAGE_ON() antlr.TerminalNode

	// IsCreate_table_options_mssql_itemContext differentiates from other interfaces.
	IsCreate_table_options_mssql_itemContext()
}

type Create_table_options_mssql_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_options_mssql_itemContext() *Create_table_options_mssql_itemContext {
	var p = new(Create_table_options_mssql_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_mssql_item
	return p
}

func InitEmptyCreate_table_options_mssql_itemContext(p *Create_table_options_mssql_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_mssql_item
}

func (*Create_table_options_mssql_itemContext) IsCreate_table_options_mssql_itemContext() {}

func NewCreate_table_options_mssql_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_options_mssql_itemContext {
	var p = new(Create_table_options_mssql_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_options_mssql_item

	return p
}

func (s *Create_table_options_mssql_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_options_mssql_itemContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *Create_table_options_mssql_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_table_options_mssql_itemContext) T_TEXTIMAGE_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TEXTIMAGE_ON, 0)
}

func (s *Create_table_options_mssql_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_options_mssql_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_options_mssql_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_options_mssql_item(s)
	}
}

func (s *Create_table_options_mssql_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_options_mssql_item(s)
	}
}

func (p *HplsqlParser) Create_table_options_mssql_item() (localctx ICreate_table_options_mssql_itemContext) {
	localctx = NewCreate_table_options_mssql_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, HplsqlParserRULE_create_table_options_mssql_item)
	p.SetState(1327)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1323)
			p.Match(HplsqlParserT_ON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1324)
			p.Qident()
		}

	case HplsqlParserT_TEXTIMAGE_ON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1325)
			p.Match(HplsqlParserT_TEXTIMAGE_ON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1326)
			p.Qident()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_table_options_mysql_itemContext is an interface to support dynamic dispatch.
type ICreate_table_options_mysql_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_AUTO_INCREMENT() antlr.TerminalNode
	Expr() IExprContext
	T_EQUAL() antlr.TerminalNode
	T_COMMENT() antlr.TerminalNode
	T_CHARACTER() antlr.TerminalNode
	T_SET() antlr.TerminalNode
	T_CHARSET() antlr.TerminalNode
	T_DEFAULT() antlr.TerminalNode
	T_ENGINE() antlr.TerminalNode

	// IsCreate_table_options_mysql_itemContext differentiates from other interfaces.
	IsCreate_table_options_mysql_itemContext()
}

type Create_table_options_mysql_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_options_mysql_itemContext() *Create_table_options_mysql_itemContext {
	var p = new(Create_table_options_mysql_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_mysql_item
	return p
}

func InitEmptyCreate_table_options_mysql_itemContext(p *Create_table_options_mysql_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_mysql_item
}

func (*Create_table_options_mysql_itemContext) IsCreate_table_options_mysql_itemContext() {}

func NewCreate_table_options_mysql_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_options_mysql_itemContext {
	var p = new(Create_table_options_mysql_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_options_mysql_item

	return p
}

func (s *Create_table_options_mysql_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_options_mysql_itemContext) T_AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AUTO_INCREMENT, 0)
}

func (s *Create_table_options_mysql_itemContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Create_table_options_mysql_itemContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Create_table_options_mysql_itemContext) T_COMMENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMENT, 0)
}

func (s *Create_table_options_mysql_itemContext) T_CHARACTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CHARACTER, 0)
}

func (s *Create_table_options_mysql_itemContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Create_table_options_mysql_itemContext) T_CHARSET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CHARSET, 0)
}

func (s *Create_table_options_mysql_itemContext) T_DEFAULT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFAULT, 0)
}

func (s *Create_table_options_mysql_itemContext) T_ENGINE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ENGINE, 0)
}

func (s *Create_table_options_mysql_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_options_mysql_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_table_options_mysql_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_options_mysql_item(s)
	}
}

func (s *Create_table_options_mysql_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_options_mysql_item(s)
	}
}

func (p *HplsqlParser) Create_table_options_mysql_item() (localctx ICreate_table_options_mysql_itemContext) {
	localctx = NewCreate_table_options_mysql_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, HplsqlParserRULE_create_table_options_mysql_item)
	var _la int

	p.SetState(1356)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_AUTO_INCREMENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1329)
			p.Match(HplsqlParserT_AUTO_INCREMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1331)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_EQUAL {
			{
				p.SetState(1330)
				p.Match(HplsqlParserT_EQUAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1333)
			p.expr(0)
		}

	case HplsqlParserT_COMMENT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1334)
			p.Match(HplsqlParserT_COMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1336)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_EQUAL {
			{
				p.SetState(1335)
				p.Match(HplsqlParserT_EQUAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1338)
			p.expr(0)
		}

	case HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_DEFAULT:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1340)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_DEFAULT {
			{
				p.SetState(1339)
				p.Match(HplsqlParserT_DEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1345)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case HplsqlParserT_CHARACTER:
			{
				p.SetState(1342)
				p.Match(HplsqlParserT_CHARACTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1343)
				p.Match(HplsqlParserT_SET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case HplsqlParserT_CHARSET:
			{
				p.SetState(1344)
				p.Match(HplsqlParserT_CHARSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(1348)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_EQUAL {
			{
				p.SetState(1347)
				p.Match(HplsqlParserT_EQUAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1350)
			p.expr(0)
		}

	case HplsqlParserT_ENGINE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1351)
			p.Match(HplsqlParserT_ENGINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1353)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_EQUAL {
			{
				p.SetState(1352)
				p.Match(HplsqlParserT_EQUAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1355)
			p.expr(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_stmtContext is an interface to support dynamic dispatch.
type IAlter_table_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ALTER() antlr.TerminalNode
	T_TABLE() antlr.TerminalNode
	Table_name() ITable_nameContext
	Alter_table_item() IAlter_table_itemContext

	// IsAlter_table_stmtContext differentiates from other interfaces.
	IsAlter_table_stmtContext()
}

type Alter_table_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_stmtContext() *Alter_table_stmtContext {
	var p = new(Alter_table_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_alter_table_stmt
	return p
}

func InitEmptyAlter_table_stmtContext(p *Alter_table_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_alter_table_stmt
}

func (*Alter_table_stmtContext) IsAlter_table_stmtContext() {}

func NewAlter_table_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_stmtContext {
	var p = new(Alter_table_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_alter_table_stmt

	return p
}

func (s *Alter_table_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_stmtContext) T_ALTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALTER, 0)
}

func (s *Alter_table_stmtContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLE, 0)
}

func (s *Alter_table_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Alter_table_stmtContext) Alter_table_item() IAlter_table_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_itemContext)
}

func (s *Alter_table_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAlter_table_stmt(s)
	}
}

func (s *Alter_table_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAlter_table_stmt(s)
	}
}

func (p *HplsqlParser) Alter_table_stmt() (localctx IAlter_table_stmtContext) {
	localctx = NewAlter_table_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, HplsqlParserRULE_alter_table_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1358)
		p.Match(HplsqlParserT_ALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1359)
		p.Match(HplsqlParserT_TABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1360)
		p.Table_name()
	}
	{
		p.SetState(1361)
		p.Alter_table_item()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_itemContext is an interface to support dynamic dispatch.
type IAlter_table_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Alter_table_add_constraint() IAlter_table_add_constraintContext

	// IsAlter_table_itemContext differentiates from other interfaces.
	IsAlter_table_itemContext()
}

type Alter_table_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_itemContext() *Alter_table_itemContext {
	var p = new(Alter_table_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_alter_table_item
	return p
}

func InitEmptyAlter_table_itemContext(p *Alter_table_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_alter_table_item
}

func (*Alter_table_itemContext) IsAlter_table_itemContext() {}

func NewAlter_table_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_itemContext {
	var p = new(Alter_table_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_alter_table_item

	return p
}

func (s *Alter_table_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_itemContext) Alter_table_add_constraint() IAlter_table_add_constraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_add_constraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_add_constraintContext)
}

func (s *Alter_table_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAlter_table_item(s)
	}
}

func (s *Alter_table_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAlter_table_item(s)
	}
}

func (p *HplsqlParser) Alter_table_item() (localctx IAlter_table_itemContext) {
	localctx = NewAlter_table_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, HplsqlParserRULE_alter_table_item)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1363)
		p.Alter_table_add_constraint()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_add_constraintContext is an interface to support dynamic dispatch.
type IAlter_table_add_constraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ADD2() antlr.TerminalNode
	Alter_table_add_constraint_item() IAlter_table_add_constraint_itemContext
	T_CONSTRAINT() antlr.TerminalNode
	Qident() IQidentContext

	// IsAlter_table_add_constraintContext differentiates from other interfaces.
	IsAlter_table_add_constraintContext()
}

type Alter_table_add_constraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_add_constraintContext() *Alter_table_add_constraintContext {
	var p = new(Alter_table_add_constraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_alter_table_add_constraint
	return p
}

func InitEmptyAlter_table_add_constraintContext(p *Alter_table_add_constraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_alter_table_add_constraint
}

func (*Alter_table_add_constraintContext) IsAlter_table_add_constraintContext() {}

func NewAlter_table_add_constraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_add_constraintContext {
	var p = new(Alter_table_add_constraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_alter_table_add_constraint

	return p
}

func (s *Alter_table_add_constraintContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_add_constraintContext) T_ADD2() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ADD2, 0)
}

func (s *Alter_table_add_constraintContext) Alter_table_add_constraint_item() IAlter_table_add_constraint_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_add_constraint_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_add_constraint_itemContext)
}

func (s *Alter_table_add_constraintContext) T_CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONSTRAINT, 0)
}

func (s *Alter_table_add_constraintContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Alter_table_add_constraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_add_constraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_add_constraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAlter_table_add_constraint(s)
	}
}

func (s *Alter_table_add_constraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAlter_table_add_constraint(s)
	}
}

func (p *HplsqlParser) Alter_table_add_constraint() (localctx IAlter_table_add_constraintContext) {
	localctx = NewAlter_table_add_constraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, HplsqlParserRULE_alter_table_add_constraint)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1365)
		p.Match(HplsqlParserT_ADD2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1368)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_CONSTRAINT {
		{
			p.SetState(1366)
			p.Match(HplsqlParserT_CONSTRAINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1367)
			p.Qident()
		}

	}
	{
		p.SetState(1370)
		p.Alter_table_add_constraint_item()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlter_table_add_constraint_itemContext is an interface to support dynamic dispatch.
type IAlter_table_add_constraint_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_PRIMARY() antlr.TerminalNode
	T_KEY() antlr.TerminalNode
	AllT_OPEN_P() []antlr.TerminalNode
	T_OPEN_P(i int) antlr.TerminalNode
	AllQident() []IQidentContext
	Qident(i int) IQidentContext
	AllT_CLOSE_P() []antlr.TerminalNode
	T_CLOSE_P(i int) antlr.TerminalNode
	T_CLUSTERED() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	T_ENABLE() antlr.TerminalNode
	Index_storage_clause() IIndex_storage_clauseContext
	AllT_ASC() []antlr.TerminalNode
	T_ASC(i int) antlr.TerminalNode
	AllT_DESC() []antlr.TerminalNode
	T_DESC(i int) antlr.TerminalNode
	T_FOREIGN() antlr.TerminalNode
	T_REFERENCES() antlr.TerminalNode
	Table_name() ITable_nameContext
	AllCreate_table_fk_action() []ICreate_table_fk_actionContext
	Create_table_fk_action(i int) ICreate_table_fk_actionContext
	T_DEFAULT() antlr.TerminalNode
	Expr() IExprContext
	T_FOR() antlr.TerminalNode

	// IsAlter_table_add_constraint_itemContext differentiates from other interfaces.
	IsAlter_table_add_constraint_itemContext()
}

type Alter_table_add_constraint_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_add_constraint_itemContext() *Alter_table_add_constraint_itemContext {
	var p = new(Alter_table_add_constraint_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_alter_table_add_constraint_item
	return p
}

func InitEmptyAlter_table_add_constraint_itemContext(p *Alter_table_add_constraint_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_alter_table_add_constraint_item
}

func (*Alter_table_add_constraint_itemContext) IsAlter_table_add_constraint_itemContext() {}

func NewAlter_table_add_constraint_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_add_constraint_itemContext {
	var p = new(Alter_table_add_constraint_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_alter_table_add_constraint_item

	return p
}

func (s *Alter_table_add_constraint_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_add_constraint_itemContext) T_PRIMARY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRIMARY, 0)
}

func (s *Alter_table_add_constraint_itemContext) T_KEY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_KEY, 0)
}

func (s *Alter_table_add_constraint_itemContext) AllT_OPEN_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_OPEN_P)
}

func (s *Alter_table_add_constraint_itemContext) T_OPEN_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, i)
}

func (s *Alter_table_add_constraint_itemContext) AllQident() []IQidentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQidentContext); ok {
			len++
		}
	}

	tst := make([]IQidentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQidentContext); ok {
			tst[i] = t.(IQidentContext)
			i++
		}
	}

	return tst
}

func (s *Alter_table_add_constraint_itemContext) Qident(i int) IQidentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Alter_table_add_constraint_itemContext) AllT_CLOSE_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_CLOSE_P)
}

func (s *Alter_table_add_constraint_itemContext) T_CLOSE_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, i)
}

func (s *Alter_table_add_constraint_itemContext) T_CLUSTERED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLUSTERED, 0)
}

func (s *Alter_table_add_constraint_itemContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Alter_table_add_constraint_itemContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Alter_table_add_constraint_itemContext) T_ENABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ENABLE, 0)
}

func (s *Alter_table_add_constraint_itemContext) Index_storage_clause() IIndex_storage_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_storage_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_storage_clauseContext)
}

func (s *Alter_table_add_constraint_itemContext) AllT_ASC() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_ASC)
}

func (s *Alter_table_add_constraint_itemContext) T_ASC(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ASC, i)
}

func (s *Alter_table_add_constraint_itemContext) AllT_DESC() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_DESC)
}

func (s *Alter_table_add_constraint_itemContext) T_DESC(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DESC, i)
}

func (s *Alter_table_add_constraint_itemContext) T_FOREIGN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOREIGN, 0)
}

func (s *Alter_table_add_constraint_itemContext) T_REFERENCES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REFERENCES, 0)
}

func (s *Alter_table_add_constraint_itemContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Alter_table_add_constraint_itemContext) AllCreate_table_fk_action() []ICreate_table_fk_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_fk_actionContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_fk_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_fk_actionContext); ok {
			tst[i] = t.(ICreate_table_fk_actionContext)
			i++
		}
	}

	return tst
}

func (s *Alter_table_add_constraint_itemContext) Create_table_fk_action(i int) ICreate_table_fk_actionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_fk_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_fk_actionContext)
}

func (s *Alter_table_add_constraint_itemContext) T_DEFAULT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFAULT, 0)
}

func (s *Alter_table_add_constraint_itemContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Alter_table_add_constraint_itemContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *Alter_table_add_constraint_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_add_constraint_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Alter_table_add_constraint_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAlter_table_add_constraint_item(s)
	}
}

func (s *Alter_table_add_constraint_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAlter_table_add_constraint_item(s)
	}
}

func (p *HplsqlParser) Alter_table_add_constraint_item() (localctx IAlter_table_add_constraint_itemContext) {
	localctx = NewAlter_table_add_constraint_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, HplsqlParserRULE_alter_table_add_constraint_item)
	var _la int

	var _alt int

	p.SetState(1434)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_PRIMARY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1372)
			p.Match(HplsqlParserT_PRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1373)
			p.Match(HplsqlParserT_KEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1375)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_CLUSTERED {
			{
				p.SetState(1374)
				p.Match(HplsqlParserT_CLUSTERED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1377)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1378)
			p.Qident()
		}
		p.SetState(1380)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC {
			{
				p.SetState(1379)
				_la = p.GetTokenStream().LA(1)

				if !(_la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1389)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(1382)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1383)
				p.Qident()
			}
			p.SetState(1385)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC {
				{
					p.SetState(1384)
					_la = p.GetTokenStream().LA(1)

					if !(_la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}

			p.SetState(1391)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1392)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1394)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 122, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1393)
				p.Match(HplsqlParserT_ENABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1397)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 123, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1396)
				p.Index_storage_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case HplsqlParserT_FOREIGN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1399)
			p.Match(HplsqlParserT_FOREIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1400)
			p.Match(HplsqlParserT_KEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1401)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1402)
			p.Qident()
		}
		p.SetState(1407)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(1403)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1404)
				p.Qident()
			}

			p.SetState(1409)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1410)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1411)
			p.Match(HplsqlParserT_REFERENCES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1412)
			p.Table_name()
		}
		{
			p.SetState(1413)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1414)
			p.Qident()
		}
		p.SetState(1419)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(1415)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1416)
				p.Qident()
			}

			p.SetState(1421)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1422)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1426)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1423)
					p.Create_table_fk_action()
				}

			}
			p.SetState(1428)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case HplsqlParserT_DEFAULT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1429)
			p.Match(HplsqlParserT_DEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1430)
			p.expr(0)
		}
		{
			p.SetState(1431)
			p.Match(HplsqlParserT_FOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1432)
			p.Qident()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDtypeContext is an interface to support dynamic dispatch.
type IDtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_CHAR() antlr.TerminalNode
	T_CHARACTER() antlr.TerminalNode
	T_BIGINT() antlr.TerminalNode
	T_BINARY_DOUBLE() antlr.TerminalNode
	T_BINARY_FLOAT() antlr.TerminalNode
	T_BINARY_INTEGER() antlr.TerminalNode
	T_BIT() antlr.TerminalNode
	T_DATE() antlr.TerminalNode
	T_DATETIME() antlr.TerminalNode
	T_DEC() antlr.TerminalNode
	T_DECIMAL() antlr.TerminalNode
	T_DOUBLE() antlr.TerminalNode
	T_PRECISION() antlr.TerminalNode
	T_FLOAT() antlr.TerminalNode
	T_INT() antlr.TerminalNode
	T_INT2() antlr.TerminalNode
	T_INT4() antlr.TerminalNode
	T_INT8() antlr.TerminalNode
	T_INTEGER() antlr.TerminalNode
	T_NCHAR() antlr.TerminalNode
	T_NVARCHAR() antlr.TerminalNode
	T_NUMBER() antlr.TerminalNode
	T_NUMERIC() antlr.TerminalNode
	T_PLS_INTEGER() antlr.TerminalNode
	T_REAL() antlr.TerminalNode
	T_RESULT_SET_LOCATOR() antlr.TerminalNode
	T_VARYING() antlr.TerminalNode
	T_SIMPLE_FLOAT() antlr.TerminalNode
	T_SIMPLE_DOUBLE() antlr.TerminalNode
	T_SIMPLE_INTEGER() antlr.TerminalNode
	T_SMALLINT() antlr.TerminalNode
	T_SMALLDATETIME() antlr.TerminalNode
	T_STRING() antlr.TerminalNode
	T_SYS_REFCURSOR() antlr.TerminalNode
	T_TIMESTAMP() antlr.TerminalNode
	T_TINYINT() antlr.TerminalNode
	T_VARCHAR() antlr.TerminalNode
	T_VARCHAR2() antlr.TerminalNode
	T_XML() antlr.TerminalNode
	T_BOOLEAN() antlr.TerminalNode

	// IsDtypeContext differentiates from other interfaces.
	IsDtypeContext()
}

type DtypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDtypeContext() *DtypeContext {
	var p = new(DtypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_dtype
	return p
}

func InitEmptyDtypeContext(p *DtypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_dtype
}

func (*DtypeContext) IsDtypeContext() {}

func NewDtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DtypeContext {
	var p = new(DtypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_dtype

	return p
}

func (s *DtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DtypeContext) T_CHAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CHAR, 0)
}

func (s *DtypeContext) T_CHARACTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CHARACTER, 0)
}

func (s *DtypeContext) T_BIGINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BIGINT, 0)
}

func (s *DtypeContext) T_BINARY_DOUBLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BINARY_DOUBLE, 0)
}

func (s *DtypeContext) T_BINARY_FLOAT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BINARY_FLOAT, 0)
}

func (s *DtypeContext) T_BINARY_INTEGER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BINARY_INTEGER, 0)
}

func (s *DtypeContext) T_BIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BIT, 0)
}

func (s *DtypeContext) T_DATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATE, 0)
}

func (s *DtypeContext) T_DATETIME() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATETIME, 0)
}

func (s *DtypeContext) T_DEC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEC, 0)
}

func (s *DtypeContext) T_DECIMAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DECIMAL, 0)
}

func (s *DtypeContext) T_DOUBLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DOUBLE, 0)
}

func (s *DtypeContext) T_PRECISION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRECISION, 0)
}

func (s *DtypeContext) T_FLOAT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FLOAT, 0)
}

func (s *DtypeContext) T_INT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INT, 0)
}

func (s *DtypeContext) T_INT2() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INT2, 0)
}

func (s *DtypeContext) T_INT4() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INT4, 0)
}

func (s *DtypeContext) T_INT8() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INT8, 0)
}

func (s *DtypeContext) T_INTEGER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTEGER, 0)
}

func (s *DtypeContext) T_NCHAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NCHAR, 0)
}

func (s *DtypeContext) T_NVARCHAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NVARCHAR, 0)
}

func (s *DtypeContext) T_NUMBER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NUMBER, 0)
}

func (s *DtypeContext) T_NUMERIC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NUMERIC, 0)
}

func (s *DtypeContext) T_PLS_INTEGER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PLS_INTEGER, 0)
}

func (s *DtypeContext) T_REAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REAL, 0)
}

func (s *DtypeContext) T_RESULT_SET_LOCATOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESULT_SET_LOCATOR, 0)
}

func (s *DtypeContext) T_VARYING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VARYING, 0)
}

func (s *DtypeContext) T_SIMPLE_FLOAT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SIMPLE_FLOAT, 0)
}

func (s *DtypeContext) T_SIMPLE_DOUBLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SIMPLE_DOUBLE, 0)
}

func (s *DtypeContext) T_SIMPLE_INTEGER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SIMPLE_INTEGER, 0)
}

func (s *DtypeContext) T_SMALLINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SMALLINT, 0)
}

func (s *DtypeContext) T_SMALLDATETIME() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SMALLDATETIME, 0)
}

func (s *DtypeContext) T_STRING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STRING, 0)
}

func (s *DtypeContext) T_SYS_REFCURSOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SYS_REFCURSOR, 0)
}

func (s *DtypeContext) T_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TIMESTAMP, 0)
}

func (s *DtypeContext) T_TINYINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TINYINT, 0)
}

func (s *DtypeContext) T_VARCHAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VARCHAR, 0)
}

func (s *DtypeContext) T_VARCHAR2() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VARCHAR2, 0)
}

func (s *DtypeContext) T_XML() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_XML, 0)
}

func (s *DtypeContext) T_BOOLEAN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BOOLEAN, 0)
}

func (s *DtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDtype(s)
	}
}

func (s *DtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDtype(s)
	}
}

func (p *HplsqlParser) Dtype() (localctx IDtypeContext) {
	localctx = NewDtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, HplsqlParserRULE_dtype)
	p.SetState(1478)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_CHAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1436)
			p.Match(HplsqlParserT_CHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_CHARACTER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1437)
			p.Match(HplsqlParserT_CHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_BIGINT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1438)
			p.Match(HplsqlParserT_BIGINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_BINARY_DOUBLE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1439)
			p.Match(HplsqlParserT_BINARY_DOUBLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_BINARY_FLOAT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1440)
			p.Match(HplsqlParserT_BINARY_FLOAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_BINARY_INTEGER:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1441)
			p.Match(HplsqlParserT_BINARY_INTEGER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_BIT:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1442)
			p.Match(HplsqlParserT_BIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_DATE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1443)
			p.Match(HplsqlParserT_DATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_DATETIME:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1444)
			p.Match(HplsqlParserT_DATETIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_DEC:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1445)
			p.Match(HplsqlParserT_DEC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_DECIMAL:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1446)
			p.Match(HplsqlParserT_DECIMAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_DOUBLE:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1447)
			p.Match(HplsqlParserT_DOUBLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1449)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 128, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1448)
				p.Match(HplsqlParserT_PRECISION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case HplsqlParserT_FLOAT:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1451)
			p.Match(HplsqlParserT_FLOAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_INT:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1452)
			p.Match(HplsqlParserT_INT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_INT2:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1453)
			p.Match(HplsqlParserT_INT2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_INT4:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1454)
			p.Match(HplsqlParserT_INT4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_INT8:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1455)
			p.Match(HplsqlParserT_INT8)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_INTEGER:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1456)
			p.Match(HplsqlParserT_INTEGER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_NCHAR:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1457)
			p.Match(HplsqlParserT_NCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_NVARCHAR:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1458)
			p.Match(HplsqlParserT_NVARCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_NUMBER:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1459)
			p.Match(HplsqlParserT_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_NUMERIC:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1460)
			p.Match(HplsqlParserT_NUMERIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_PLS_INTEGER:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1461)
			p.Match(HplsqlParserT_PLS_INTEGER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_REAL:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1462)
			p.Match(HplsqlParserT_REAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_RESULT_SET_LOCATOR:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(1463)
			p.Match(HplsqlParserT_RESULT_SET_LOCATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1464)
			p.Match(HplsqlParserT_VARYING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_SIMPLE_FLOAT:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1465)
			p.Match(HplsqlParserT_SIMPLE_FLOAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_SIMPLE_DOUBLE:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(1466)
			p.Match(HplsqlParserT_SIMPLE_DOUBLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_SIMPLE_INTEGER:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(1467)
			p.Match(HplsqlParserT_SIMPLE_INTEGER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_SMALLINT:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(1468)
			p.Match(HplsqlParserT_SMALLINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_SMALLDATETIME:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(1469)
			p.Match(HplsqlParserT_SMALLDATETIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_STRING:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(1470)
			p.Match(HplsqlParserT_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_SYS_REFCURSOR:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(1471)
			p.Match(HplsqlParserT_SYS_REFCURSOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_TIMESTAMP:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(1472)
			p.Match(HplsqlParserT_TIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_TINYINT:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(1473)
			p.Match(HplsqlParserT_TINYINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_VARCHAR:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(1474)
			p.Match(HplsqlParserT_VARCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_VARCHAR2:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(1475)
			p.Match(HplsqlParserT_VARCHAR2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_XML:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(1476)
			p.Match(HplsqlParserT_XML)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_BOOLEAN:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(1477)
			p.Match(HplsqlParserT_BOOLEAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDtype_lenContext is an interface to support dynamic dispatch.
type IDtype_lenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode
	AllL_INT() []antlr.TerminalNode
	L_INT(i int) antlr.TerminalNode
	T_MAX() antlr.TerminalNode
	T_COMMA() antlr.TerminalNode
	T_CHAR() antlr.TerminalNode
	T_BYTE() antlr.TerminalNode

	// IsDtype_lenContext differentiates from other interfaces.
	IsDtype_lenContext()
}

type Dtype_lenContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDtype_lenContext() *Dtype_lenContext {
	var p = new(Dtype_lenContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_dtype_len
	return p
}

func InitEmptyDtype_lenContext(p *Dtype_lenContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_dtype_len
}

func (*Dtype_lenContext) IsDtype_lenContext() {}

func NewDtype_lenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dtype_lenContext {
	var p = new(Dtype_lenContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_dtype_len

	return p
}

func (s *Dtype_lenContext) GetParser() antlr.Parser { return s.parser }

func (s *Dtype_lenContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Dtype_lenContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Dtype_lenContext) AllL_INT() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserL_INT)
}

func (s *Dtype_lenContext) L_INT(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_INT, i)
}

func (s *Dtype_lenContext) T_MAX() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAX, 0)
}

func (s *Dtype_lenContext) T_COMMA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, 0)
}

func (s *Dtype_lenContext) T_CHAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CHAR, 0)
}

func (s *Dtype_lenContext) T_BYTE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BYTE, 0)
}

func (s *Dtype_lenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dtype_lenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dtype_lenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDtype_len(s)
	}
}

func (s *Dtype_lenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDtype_len(s)
	}
}

func (p *HplsqlParser) Dtype_len() (localctx IDtype_lenContext) {
	localctx = NewDtype_lenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, HplsqlParserRULE_dtype_len)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1480)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1481)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_MAX || _la == HplsqlParserL_INT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1483)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_BYTE || _la == HplsqlParserT_CHAR {
		{
			p.SetState(1482)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_BYTE || _la == HplsqlParserT_CHAR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1487)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_COMMA {
		{
			p.SetState(1485)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1486)
			p.Match(HplsqlParserL_INT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1489)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDtype_attrContext is an interface to support dynamic dispatch.
type IDtype_attrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_NULL() antlr.TerminalNode
	T_NOT() antlr.TerminalNode
	T_CHARACTER() antlr.TerminalNode
	T_SET() antlr.TerminalNode
	Ident() IIdentContext
	T_CASESPECIFIC() antlr.TerminalNode
	T_CS() antlr.TerminalNode

	// IsDtype_attrContext differentiates from other interfaces.
	IsDtype_attrContext()
}

type Dtype_attrContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDtype_attrContext() *Dtype_attrContext {
	var p = new(Dtype_attrContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_dtype_attr
	return p
}

func InitEmptyDtype_attrContext(p *Dtype_attrContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_dtype_attr
}

func (*Dtype_attrContext) IsDtype_attrContext() {}

func NewDtype_attrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dtype_attrContext {
	var p = new(Dtype_attrContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_dtype_attr

	return p
}

func (s *Dtype_attrContext) GetParser() antlr.Parser { return s.parser }

func (s *Dtype_attrContext) T_NULL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NULL, 0)
}

func (s *Dtype_attrContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Dtype_attrContext) T_CHARACTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CHARACTER, 0)
}

func (s *Dtype_attrContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Dtype_attrContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Dtype_attrContext) T_CASESPECIFIC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CASESPECIFIC, 0)
}

func (s *Dtype_attrContext) T_CS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CS, 0)
}

func (s *Dtype_attrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dtype_attrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dtype_attrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDtype_attr(s)
	}
}

func (s *Dtype_attrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDtype_attr(s)
	}
}

func (p *HplsqlParser) Dtype_attr() (localctx IDtype_attrContext) {
	localctx = NewDtype_attrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, HplsqlParserRULE_dtype_attr)
	var _la int

	p.SetState(1502)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 134, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1492)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_NOT {
			{
				p.SetState(1491)
				p.Match(HplsqlParserT_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1494)
			p.Match(HplsqlParserT_NULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1495)
			p.Match(HplsqlParserT_CHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1496)
			p.Match(HplsqlParserT_SET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1497)
			p.Ident()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1499)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_NOT {
			{
				p.SetState(1498)
				p.Match(HplsqlParserT_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1501)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_CASESPECIFIC || _la == HplsqlParserT_CS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDtype_defaultContext is an interface to support dynamic dispatch.
type IDtype_defaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_EQUAL() antlr.TerminalNode
	Expr() IExprContext
	T_COLON() antlr.TerminalNode
	T_DEFAULT() antlr.TerminalNode
	T_WITH() antlr.TerminalNode

	// IsDtype_defaultContext differentiates from other interfaces.
	IsDtype_defaultContext()
}

type Dtype_defaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDtype_defaultContext() *Dtype_defaultContext {
	var p = new(Dtype_defaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_dtype_default
	return p
}

func InitEmptyDtype_defaultContext(p *Dtype_defaultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_dtype_default
}

func (*Dtype_defaultContext) IsDtype_defaultContext() {}

func NewDtype_defaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dtype_defaultContext {
	var p = new(Dtype_defaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_dtype_default

	return p
}

func (s *Dtype_defaultContext) GetParser() antlr.Parser { return s.parser }

func (s *Dtype_defaultContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Dtype_defaultContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Dtype_defaultContext) T_COLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLON, 0)
}

func (s *Dtype_defaultContext) T_DEFAULT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFAULT, 0)
}

func (s *Dtype_defaultContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITH, 0)
}

func (s *Dtype_defaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dtype_defaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dtype_defaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDtype_default(s)
	}
}

func (s *Dtype_defaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDtype_default(s)
	}
}

func (p *HplsqlParser) Dtype_default() (localctx IDtype_defaultContext) {
	localctx = NewDtype_defaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, HplsqlParserRULE_dtype_default)
	var _la int

	p.SetState(1516)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_COLON, HplsqlParserT_EQUAL:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1505)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_COLON {
			{
				p.SetState(1504)
				p.Match(HplsqlParserT_COLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1507)
			p.Match(HplsqlParserT_EQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1508)
			p.expr(0)
		}

	case HplsqlParserT_DEFAULT, HplsqlParserT_WITH:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1510)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_WITH {
			{
				p.SetState(1509)
				p.Match(HplsqlParserT_WITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1512)
			p.Match(HplsqlParserT_DEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1514)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 137, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1513)
				p.expr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_database_stmtContext is an interface to support dynamic dispatch.
type ICreate_database_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_CREATE() antlr.TerminalNode
	Expr() IExprContext
	T_DATABASE() antlr.TerminalNode
	T_SCHEMA() antlr.TerminalNode
	T_IF() antlr.TerminalNode
	T_NOT() antlr.TerminalNode
	T_EXISTS() antlr.TerminalNode
	AllCreate_database_option() []ICreate_database_optionContext
	Create_database_option(i int) ICreate_database_optionContext

	// IsCreate_database_stmtContext differentiates from other interfaces.
	IsCreate_database_stmtContext()
}

type Create_database_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_database_stmtContext() *Create_database_stmtContext {
	var p = new(Create_database_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_database_stmt
	return p
}

func InitEmptyCreate_database_stmtContext(p *Create_database_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_database_stmt
}

func (*Create_database_stmtContext) IsCreate_database_stmtContext() {}

func NewCreate_database_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_database_stmtContext {
	var p = new(Create_database_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_database_stmt

	return p
}

func (s *Create_database_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_database_stmtContext) T_CREATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATE, 0)
}

func (s *Create_database_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Create_database_stmtContext) T_DATABASE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATABASE, 0)
}

func (s *Create_database_stmtContext) T_SCHEMA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SCHEMA, 0)
}

func (s *Create_database_stmtContext) T_IF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IF, 0)
}

func (s *Create_database_stmtContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Create_database_stmtContext) T_EXISTS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXISTS, 0)
}

func (s *Create_database_stmtContext) AllCreate_database_option() []ICreate_database_optionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_database_optionContext); ok {
			len++
		}
	}

	tst := make([]ICreate_database_optionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_database_optionContext); ok {
			tst[i] = t.(ICreate_database_optionContext)
			i++
		}
	}

	return tst
}

func (s *Create_database_stmtContext) Create_database_option(i int) ICreate_database_optionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_database_optionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_database_optionContext)
}

func (s *Create_database_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_database_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_database_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_database_stmt(s)
	}
}

func (s *Create_database_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_database_stmt(s)
	}
}

func (p *HplsqlParser) Create_database_stmt() (localctx ICreate_database_stmtContext) {
	localctx = NewCreate_database_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, HplsqlParserRULE_create_database_stmt)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1518)
		p.Match(HplsqlParserT_CREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1519)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_DATABASE || _la == HplsqlParserT_SCHEMA) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1523)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 139, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1520)
			p.Match(HplsqlParserT_IF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1521)
			p.Match(HplsqlParserT_NOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1522)
			p.Match(HplsqlParserT_EXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1525)
		p.expr(0)
	}
	p.SetState(1529)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 140, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1526)
				p.Create_database_option()
			}

		}
		p.SetState(1531)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 140, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_database_optionContext is an interface to support dynamic dispatch.
type ICreate_database_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_COMMENT() antlr.TerminalNode
	Expr() IExprContext
	T_LOCATION() antlr.TerminalNode

	// IsCreate_database_optionContext differentiates from other interfaces.
	IsCreate_database_optionContext()
}

type Create_database_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_database_optionContext() *Create_database_optionContext {
	var p = new(Create_database_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_database_option
	return p
}

func InitEmptyCreate_database_optionContext(p *Create_database_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_database_option
}

func (*Create_database_optionContext) IsCreate_database_optionContext() {}

func NewCreate_database_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_database_optionContext {
	var p = new(Create_database_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_database_option

	return p
}

func (s *Create_database_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_database_optionContext) T_COMMENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMENT, 0)
}

func (s *Create_database_optionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Create_database_optionContext) T_LOCATION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCATION, 0)
}

func (s *Create_database_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_database_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_database_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_database_option(s)
	}
}

func (s *Create_database_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_database_option(s)
	}
}

func (p *HplsqlParser) Create_database_option() (localctx ICreate_database_optionContext) {
	localctx = NewCreate_database_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, HplsqlParserRULE_create_database_option)
	p.SetState(1536)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_COMMENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1532)
			p.Match(HplsqlParserT_COMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1533)
			p.expr(0)
		}

	case HplsqlParserT_LOCATION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1534)
			p.Match(HplsqlParserT_LOCATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1535)
			p.expr(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_function_stmtContext is an interface to support dynamic dispatch.
type ICreate_function_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_FUNCTION() antlr.TerminalNode
	Ident() IIdentContext
	Create_function_return() ICreate_function_returnContext
	Single_block_stmt() ISingle_block_stmtContext
	T_ALTER() antlr.TerminalNode
	T_CREATE() antlr.TerminalNode
	T_REPLACE() antlr.TerminalNode
	Create_routine_params() ICreate_routine_paramsContext
	Declare_block_inplace() IDeclare_block_inplaceContext
	T_AS() antlr.TerminalNode
	T_IS() antlr.TerminalNode
	T_OR() antlr.TerminalNode

	// IsCreate_function_stmtContext differentiates from other interfaces.
	IsCreate_function_stmtContext()
}

type Create_function_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_function_stmtContext() *Create_function_stmtContext {
	var p = new(Create_function_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_function_stmt
	return p
}

func InitEmptyCreate_function_stmtContext(p *Create_function_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_function_stmt
}

func (*Create_function_stmtContext) IsCreate_function_stmtContext() {}

func NewCreate_function_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_function_stmtContext {
	var p = new(Create_function_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_function_stmt

	return p
}

func (s *Create_function_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_function_stmtContext) T_FUNCTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FUNCTION, 0)
}

func (s *Create_function_stmtContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Create_function_stmtContext) Create_function_return() ICreate_function_returnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_function_returnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_function_returnContext)
}

func (s *Create_function_stmtContext) Single_block_stmt() ISingle_block_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingle_block_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingle_block_stmtContext)
}

func (s *Create_function_stmtContext) T_ALTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALTER, 0)
}

func (s *Create_function_stmtContext) T_CREATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATE, 0)
}

func (s *Create_function_stmtContext) T_REPLACE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REPLACE, 0)
}

func (s *Create_function_stmtContext) Create_routine_params() ICreate_routine_paramsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_routine_paramsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_routine_paramsContext)
}

func (s *Create_function_stmtContext) Declare_block_inplace() IDeclare_block_inplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_block_inplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_block_inplaceContext)
}

func (s *Create_function_stmtContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Create_function_stmtContext) T_IS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IS, 0)
}

func (s *Create_function_stmtContext) T_OR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OR, 0)
}

func (s *Create_function_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_function_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_function_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_function_stmt(s)
	}
}

func (s *Create_function_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_function_stmt(s)
	}
}

func (p *HplsqlParser) Create_function_stmt() (localctx ICreate_function_stmtContext) {
	localctx = NewCreate_function_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, HplsqlParserRULE_create_function_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1545)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ALTER:
		{
			p.SetState(1538)
			p.Match(HplsqlParserT_ALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_CREATE:
		{
			p.SetState(1539)
			p.Match(HplsqlParserT_CREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1542)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_OR {
			{
				p.SetState(1540)
				p.Match(HplsqlParserT_OR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1541)
				p.Match(HplsqlParserT_REPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case HplsqlParserT_REPLACE:
		{
			p.SetState(1544)
			p.Match(HplsqlParserT_REPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_FUNCTION:

	default:
	}
	{
		p.SetState(1547)
		p.Match(HplsqlParserT_FUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1548)
		p.Ident()
	}
	p.SetState(1550)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 144, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1549)
			p.Create_routine_params()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1552)
		p.Create_function_return()
	}
	p.SetState(1554)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 145, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1553)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_AS || _la == HplsqlParserT_IS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1557)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 146, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1556)
			p.Declare_block_inplace()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1559)
		p.Single_block_stmt()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_function_returnContext is an interface to support dynamic dispatch.
type ICreate_function_returnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Dtype() IDtypeContext
	T_RETURN() antlr.TerminalNode
	T_RETURNS() antlr.TerminalNode
	Dtype_len() IDtype_lenContext

	// IsCreate_function_returnContext differentiates from other interfaces.
	IsCreate_function_returnContext()
}

type Create_function_returnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_function_returnContext() *Create_function_returnContext {
	var p = new(Create_function_returnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_function_return
	return p
}

func InitEmptyCreate_function_returnContext(p *Create_function_returnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_function_return
}

func (*Create_function_returnContext) IsCreate_function_returnContext() {}

func NewCreate_function_returnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_function_returnContext {
	var p = new(Create_function_returnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_function_return

	return p
}

func (s *Create_function_returnContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_function_returnContext) Dtype() IDtypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *Create_function_returnContext) T_RETURN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RETURN, 0)
}

func (s *Create_function_returnContext) T_RETURNS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RETURNS, 0)
}

func (s *Create_function_returnContext) Dtype_len() IDtype_lenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_lenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_lenContext)
}

func (s *Create_function_returnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_function_returnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_function_returnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_function_return(s)
	}
}

func (s *Create_function_returnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_function_return(s)
	}
}

func (p *HplsqlParser) Create_function_return() (localctx ICreate_function_returnContext) {
	localctx = NewCreate_function_returnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, HplsqlParserRULE_create_function_return)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1561)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_RETURN || _la == HplsqlParserT_RETURNS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1562)
		p.Dtype()
	}
	p.SetState(1564)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 147, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1563)
			p.Dtype_len()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_package_stmtContext is an interface to support dynamic dispatch.
type ICreate_package_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_PACKAGE() antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	Package_spec() IPackage_specContext
	T_END() antlr.TerminalNode
	T_AS() antlr.TerminalNode
	T_IS() antlr.TerminalNode
	T_ALTER() antlr.TerminalNode
	T_CREATE() antlr.TerminalNode
	T_REPLACE() antlr.TerminalNode
	T_SEMICOLON() antlr.TerminalNode
	T_OR() antlr.TerminalNode

	// IsCreate_package_stmtContext differentiates from other interfaces.
	IsCreate_package_stmtContext()
}

type Create_package_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_package_stmtContext() *Create_package_stmtContext {
	var p = new(Create_package_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_package_stmt
	return p
}

func InitEmptyCreate_package_stmtContext(p *Create_package_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_package_stmt
}

func (*Create_package_stmtContext) IsCreate_package_stmtContext() {}

func NewCreate_package_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_package_stmtContext {
	var p = new(Create_package_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_package_stmt

	return p
}

func (s *Create_package_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_package_stmtContext) T_PACKAGE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PACKAGE, 0)
}

func (s *Create_package_stmtContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Create_package_stmtContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Create_package_stmtContext) Package_spec() IPackage_specContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackage_specContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackage_specContext)
}

func (s *Create_package_stmtContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *Create_package_stmtContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Create_package_stmtContext) T_IS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IS, 0)
}

func (s *Create_package_stmtContext) T_ALTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALTER, 0)
}

func (s *Create_package_stmtContext) T_CREATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATE, 0)
}

func (s *Create_package_stmtContext) T_REPLACE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REPLACE, 0)
}

func (s *Create_package_stmtContext) T_SEMICOLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEMICOLON, 0)
}

func (s *Create_package_stmtContext) T_OR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OR, 0)
}

func (s *Create_package_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_package_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_package_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_package_stmt(s)
	}
}

func (s *Create_package_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_package_stmt(s)
	}
}

func (p *HplsqlParser) Create_package_stmt() (localctx ICreate_package_stmtContext) {
	localctx = NewCreate_package_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, HplsqlParserRULE_create_package_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1573)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ALTER:
		{
			p.SetState(1566)
			p.Match(HplsqlParserT_ALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_CREATE:
		{
			p.SetState(1567)
			p.Match(HplsqlParserT_CREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1570)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_OR {
			{
				p.SetState(1568)
				p.Match(HplsqlParserT_OR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1569)
				p.Match(HplsqlParserT_REPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case HplsqlParserT_REPLACE:
		{
			p.SetState(1572)
			p.Match(HplsqlParserT_REPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_PACKAGE:

	default:
	}
	{
		p.SetState(1575)
		p.Match(HplsqlParserT_PACKAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1576)
		p.Ident()
	}
	{
		p.SetState(1577)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_AS || _la == HplsqlParserT_IS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1578)
		p.Package_spec()
	}
	{
		p.SetState(1579)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1583)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 150, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1580)
			p.Ident()
		}
		{
			p.SetState(1581)
			p.Match(HplsqlParserT_SEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPackage_specContext is an interface to support dynamic dispatch.
type IPackage_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPackage_spec_item() []IPackage_spec_itemContext
	Package_spec_item(i int) IPackage_spec_itemContext
	AllT_SEMICOLON() []antlr.TerminalNode
	T_SEMICOLON(i int) antlr.TerminalNode

	// IsPackage_specContext differentiates from other interfaces.
	IsPackage_specContext()
}

type Package_specContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_specContext() *Package_specContext {
	var p = new(Package_specContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_package_spec
	return p
}

func InitEmptyPackage_specContext(p *Package_specContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_package_spec
}

func (*Package_specContext) IsPackage_specContext() {}

func NewPackage_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_specContext {
	var p = new(Package_specContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_package_spec

	return p
}

func (s *Package_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_specContext) AllPackage_spec_item() []IPackage_spec_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPackage_spec_itemContext); ok {
			len++
		}
	}

	tst := make([]IPackage_spec_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPackage_spec_itemContext); ok {
			tst[i] = t.(IPackage_spec_itemContext)
			i++
		}
	}

	return tst
}

func (s *Package_specContext) Package_spec_item(i int) IPackage_spec_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackage_spec_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackage_spec_itemContext)
}

func (s *Package_specContext) AllT_SEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_SEMICOLON)
}

func (s *Package_specContext) T_SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEMICOLON, i)
}

func (s *Package_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterPackage_spec(s)
	}
}

func (s *Package_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitPackage_spec(s)
	}
}

func (p *HplsqlParser) Package_spec() (localctx IPackage_specContext) {
	localctx = NewPackage_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, HplsqlParserRULE_package_spec)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1585)
		p.Package_spec_item()
	}
	{
		p.SetState(1586)
		p.Match(HplsqlParserT_SEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1592)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4328521760) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-49392123905) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-72057594037927937) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-36028797094462497) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-1729453312849219585) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&13510799416918015) != 0) {
		{
			p.SetState(1587)
			p.Package_spec_item()
		}
		{
			p.SetState(1588)
			p.Match(HplsqlParserT_SEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1594)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPackage_spec_itemContext is an interface to support dynamic dispatch.
type IPackage_spec_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Declare_stmt_item() IDeclare_stmt_itemContext
	T_FUNCTION() antlr.TerminalNode
	Ident() IIdentContext
	Create_function_return() ICreate_function_returnContext
	Create_routine_params() ICreate_routine_paramsContext
	T_PROCEDURE() antlr.TerminalNode
	T_PROC() antlr.TerminalNode

	// IsPackage_spec_itemContext differentiates from other interfaces.
	IsPackage_spec_itemContext()
}

type Package_spec_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_spec_itemContext() *Package_spec_itemContext {
	var p = new(Package_spec_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_package_spec_item
	return p
}

func InitEmptyPackage_spec_itemContext(p *Package_spec_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_package_spec_item
}

func (*Package_spec_itemContext) IsPackage_spec_itemContext() {}

func NewPackage_spec_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_spec_itemContext {
	var p = new(Package_spec_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_package_spec_item

	return p
}

func (s *Package_spec_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_spec_itemContext) Declare_stmt_item() IDeclare_stmt_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_stmt_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_stmt_itemContext)
}

func (s *Package_spec_itemContext) T_FUNCTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FUNCTION, 0)
}

func (s *Package_spec_itemContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Package_spec_itemContext) Create_function_return() ICreate_function_returnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_function_returnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_function_returnContext)
}

func (s *Package_spec_itemContext) Create_routine_params() ICreate_routine_paramsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_routine_paramsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_routine_paramsContext)
}

func (s *Package_spec_itemContext) T_PROCEDURE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PROCEDURE, 0)
}

func (s *Package_spec_itemContext) T_PROC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PROC, 0)
}

func (s *Package_spec_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_spec_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_spec_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterPackage_spec_item(s)
	}
}

func (s *Package_spec_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitPackage_spec_item(s)
	}
}

func (p *HplsqlParser) Package_spec_item() (localctx IPackage_spec_itemContext) {
	localctx = NewPackage_spec_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, HplsqlParserRULE_package_spec_item)
	var _la int

	p.SetState(1608)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 154, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1595)
			p.Declare_stmt_item()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1596)
			p.Match(HplsqlParserT_FUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1597)
			p.Ident()
		}
		p.SetState(1599)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 152, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1598)
				p.Create_routine_params()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1601)
			p.Create_function_return()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1603)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_PROC || _la == HplsqlParserT_PROCEDURE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1604)
			p.Ident()
		}
		p.SetState(1606)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 153, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1605)
				p.Create_routine_params()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_package_body_stmtContext is an interface to support dynamic dispatch.
type ICreate_package_body_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_PACKAGE() antlr.TerminalNode
	T_BODY() antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	Package_body() IPackage_bodyContext
	T_END() antlr.TerminalNode
	T_AS() antlr.TerminalNode
	T_IS() antlr.TerminalNode
	T_ALTER() antlr.TerminalNode
	T_CREATE() antlr.TerminalNode
	T_REPLACE() antlr.TerminalNode
	T_SEMICOLON() antlr.TerminalNode
	T_OR() antlr.TerminalNode

	// IsCreate_package_body_stmtContext differentiates from other interfaces.
	IsCreate_package_body_stmtContext()
}

type Create_package_body_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_package_body_stmtContext() *Create_package_body_stmtContext {
	var p = new(Create_package_body_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_package_body_stmt
	return p
}

func InitEmptyCreate_package_body_stmtContext(p *Create_package_body_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_package_body_stmt
}

func (*Create_package_body_stmtContext) IsCreate_package_body_stmtContext() {}

func NewCreate_package_body_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_package_body_stmtContext {
	var p = new(Create_package_body_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_package_body_stmt

	return p
}

func (s *Create_package_body_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_package_body_stmtContext) T_PACKAGE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PACKAGE, 0)
}

func (s *Create_package_body_stmtContext) T_BODY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BODY, 0)
}

func (s *Create_package_body_stmtContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Create_package_body_stmtContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Create_package_body_stmtContext) Package_body() IPackage_bodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackage_bodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackage_bodyContext)
}

func (s *Create_package_body_stmtContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *Create_package_body_stmtContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Create_package_body_stmtContext) T_IS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IS, 0)
}

func (s *Create_package_body_stmtContext) T_ALTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALTER, 0)
}

func (s *Create_package_body_stmtContext) T_CREATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATE, 0)
}

func (s *Create_package_body_stmtContext) T_REPLACE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REPLACE, 0)
}

func (s *Create_package_body_stmtContext) T_SEMICOLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEMICOLON, 0)
}

func (s *Create_package_body_stmtContext) T_OR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OR, 0)
}

func (s *Create_package_body_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_package_body_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_package_body_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_package_body_stmt(s)
	}
}

func (s *Create_package_body_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_package_body_stmt(s)
	}
}

func (p *HplsqlParser) Create_package_body_stmt() (localctx ICreate_package_body_stmtContext) {
	localctx = NewCreate_package_body_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, HplsqlParserRULE_create_package_body_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1617)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ALTER:
		{
			p.SetState(1610)
			p.Match(HplsqlParserT_ALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_CREATE:
		{
			p.SetState(1611)
			p.Match(HplsqlParserT_CREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1614)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_OR {
			{
				p.SetState(1612)
				p.Match(HplsqlParserT_OR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1613)
				p.Match(HplsqlParserT_REPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case HplsqlParserT_REPLACE:
		{
			p.SetState(1616)
			p.Match(HplsqlParserT_REPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_PACKAGE:

	default:
	}
	{
		p.SetState(1619)
		p.Match(HplsqlParserT_PACKAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1620)
		p.Match(HplsqlParserT_BODY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1621)
		p.Ident()
	}
	{
		p.SetState(1622)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_AS || _la == HplsqlParserT_IS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1623)
		p.Package_body()
	}
	{
		p.SetState(1624)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1628)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 157, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1625)
			p.Ident()
		}
		{
			p.SetState(1626)
			p.Match(HplsqlParserT_SEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPackage_bodyContext is an interface to support dynamic dispatch.
type IPackage_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPackage_body_item() []IPackage_body_itemContext
	Package_body_item(i int) IPackage_body_itemContext
	AllT_SEMICOLON() []antlr.TerminalNode
	T_SEMICOLON(i int) antlr.TerminalNode

	// IsPackage_bodyContext differentiates from other interfaces.
	IsPackage_bodyContext()
}

type Package_bodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_bodyContext() *Package_bodyContext {
	var p = new(Package_bodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_package_body
	return p
}

func InitEmptyPackage_bodyContext(p *Package_bodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_package_body
}

func (*Package_bodyContext) IsPackage_bodyContext() {}

func NewPackage_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_bodyContext {
	var p = new(Package_bodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_package_body

	return p
}

func (s *Package_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_bodyContext) AllPackage_body_item() []IPackage_body_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPackage_body_itemContext); ok {
			len++
		}
	}

	tst := make([]IPackage_body_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPackage_body_itemContext); ok {
			tst[i] = t.(IPackage_body_itemContext)
			i++
		}
	}

	return tst
}

func (s *Package_bodyContext) Package_body_item(i int) IPackage_body_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackage_body_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackage_body_itemContext)
}

func (s *Package_bodyContext) AllT_SEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_SEMICOLON)
}

func (s *Package_bodyContext) T_SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEMICOLON, i)
}

func (s *Package_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterPackage_body(s)
	}
}

func (s *Package_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitPackage_body(s)
	}
}

func (p *HplsqlParser) Package_body() (localctx IPackage_bodyContext) {
	localctx = NewPackage_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, HplsqlParserRULE_package_body)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1630)
		p.Package_body_item()
	}
	{
		p.SetState(1631)
		p.Match(HplsqlParserT_SEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1637)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4328521760) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-49392123905) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-72057594037927937) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-36028797094462497) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-1729453312849219585) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&13510799416918015) != 0) {
		{
			p.SetState(1632)
			p.Package_body_item()
		}
		{
			p.SetState(1633)
			p.Match(HplsqlParserT_SEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1639)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPackage_body_itemContext is an interface to support dynamic dispatch.
type IPackage_body_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Declare_stmt_item() IDeclare_stmt_itemContext
	Create_function_stmt() ICreate_function_stmtContext
	Create_procedure_stmt() ICreate_procedure_stmtContext

	// IsPackage_body_itemContext differentiates from other interfaces.
	IsPackage_body_itemContext()
}

type Package_body_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_body_itemContext() *Package_body_itemContext {
	var p = new(Package_body_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_package_body_item
	return p
}

func InitEmptyPackage_body_itemContext(p *Package_body_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_package_body_item
}

func (*Package_body_itemContext) IsPackage_body_itemContext() {}

func NewPackage_body_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_body_itemContext {
	var p = new(Package_body_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_package_body_item

	return p
}

func (s *Package_body_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_body_itemContext) Declare_stmt_item() IDeclare_stmt_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_stmt_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_stmt_itemContext)
}

func (s *Package_body_itemContext) Create_function_stmt() ICreate_function_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_function_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_function_stmtContext)
}

func (s *Package_body_itemContext) Create_procedure_stmt() ICreate_procedure_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_procedure_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_procedure_stmtContext)
}

func (s *Package_body_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_body_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Package_body_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterPackage_body_item(s)
	}
}

func (s *Package_body_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitPackage_body_item(s)
	}
}

func (p *HplsqlParser) Package_body_item() (localctx IPackage_body_itemContext) {
	localctx = NewPackage_body_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, HplsqlParserRULE_package_body_item)
	p.SetState(1643)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1640)
			p.Declare_stmt_item()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1641)
			p.Create_function_stmt()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1642)
			p.Create_procedure_stmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_procedure_stmtContext is an interface to support dynamic dispatch.
type ICreate_procedure_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	Proc_block() IProc_blockContext
	T_PROCEDURE() antlr.TerminalNode
	T_PROC() antlr.TerminalNode
	T_ALTER() antlr.TerminalNode
	T_CREATE() antlr.TerminalNode
	T_REPLACE() antlr.TerminalNode
	Create_routine_params() ICreate_routine_paramsContext
	Create_routine_options() ICreate_routine_optionsContext
	Declare_block_inplace() IDeclare_block_inplaceContext
	Label() ILabelContext
	T_SEMICOLON() antlr.TerminalNode
	T_AS() antlr.TerminalNode
	T_IS() antlr.TerminalNode
	T_OR() antlr.TerminalNode

	// IsCreate_procedure_stmtContext differentiates from other interfaces.
	IsCreate_procedure_stmtContext()
}

type Create_procedure_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_procedure_stmtContext() *Create_procedure_stmtContext {
	var p = new(Create_procedure_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_procedure_stmt
	return p
}

func InitEmptyCreate_procedure_stmtContext(p *Create_procedure_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_procedure_stmt
}

func (*Create_procedure_stmtContext) IsCreate_procedure_stmtContext() {}

func NewCreate_procedure_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_procedure_stmtContext {
	var p = new(Create_procedure_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_procedure_stmt

	return p
}

func (s *Create_procedure_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_procedure_stmtContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Create_procedure_stmtContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Create_procedure_stmtContext) Proc_block() IProc_blockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProc_blockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProc_blockContext)
}

func (s *Create_procedure_stmtContext) T_PROCEDURE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PROCEDURE, 0)
}

func (s *Create_procedure_stmtContext) T_PROC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PROC, 0)
}

func (s *Create_procedure_stmtContext) T_ALTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALTER, 0)
}

func (s *Create_procedure_stmtContext) T_CREATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATE, 0)
}

func (s *Create_procedure_stmtContext) T_REPLACE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REPLACE, 0)
}

func (s *Create_procedure_stmtContext) Create_routine_params() ICreate_routine_paramsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_routine_paramsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_routine_paramsContext)
}

func (s *Create_procedure_stmtContext) Create_routine_options() ICreate_routine_optionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_routine_optionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_routine_optionsContext)
}

func (s *Create_procedure_stmtContext) Declare_block_inplace() IDeclare_block_inplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_block_inplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_block_inplaceContext)
}

func (s *Create_procedure_stmtContext) Label() ILabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *Create_procedure_stmtContext) T_SEMICOLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEMICOLON, 0)
}

func (s *Create_procedure_stmtContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Create_procedure_stmtContext) T_IS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IS, 0)
}

func (s *Create_procedure_stmtContext) T_OR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OR, 0)
}

func (s *Create_procedure_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_procedure_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_procedure_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_procedure_stmt(s)
	}
}

func (s *Create_procedure_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_procedure_stmt(s)
	}
}

func (p *HplsqlParser) Create_procedure_stmt() (localctx ICreate_procedure_stmtContext) {
	localctx = NewCreate_procedure_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, HplsqlParserRULE_create_procedure_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1652)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ALTER:
		{
			p.SetState(1645)
			p.Match(HplsqlParserT_ALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_CREATE:
		{
			p.SetState(1646)
			p.Match(HplsqlParserT_CREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1649)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_OR {
			{
				p.SetState(1647)
				p.Match(HplsqlParserT_OR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1648)
				p.Match(HplsqlParserT_REPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case HplsqlParserT_REPLACE:
		{
			p.SetState(1651)
			p.Match(HplsqlParserT_REPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_PROC, HplsqlParserT_PROCEDURE:

	default:
	}
	{
		p.SetState(1654)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_PROC || _la == HplsqlParserT_PROCEDURE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1655)
		p.Ident()
	}
	p.SetState(1657)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 162, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1656)
			p.Create_routine_params()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1660)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 163, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1659)
			p.Create_routine_options()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1663)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 164, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1662)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_AS || _la == HplsqlParserT_IS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1666)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 165, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1665)
			p.Declare_block_inplace()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1669)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 166, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1668)
			p.Label()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1671)
		p.Proc_block()
	}
	p.SetState(1675)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 167, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1672)
			p.Ident()
		}
		{
			p.SetState(1673)
			p.Match(HplsqlParserT_SEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_routine_paramsContext is an interface to support dynamic dispatch.
type ICreate_routine_paramsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode
	AllCreate_routine_param_item() []ICreate_routine_param_itemContext
	Create_routine_param_item(i int) ICreate_routine_param_itemContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsCreate_routine_paramsContext differentiates from other interfaces.
	IsCreate_routine_paramsContext()
}

type Create_routine_paramsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_routine_paramsContext() *Create_routine_paramsContext {
	var p = new(Create_routine_paramsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_routine_params
	return p
}

func InitEmptyCreate_routine_paramsContext(p *Create_routine_paramsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_routine_params
}

func (*Create_routine_paramsContext) IsCreate_routine_paramsContext() {}

func NewCreate_routine_paramsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_routine_paramsContext {
	var p = new(Create_routine_paramsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_routine_params

	return p
}

func (s *Create_routine_paramsContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_routine_paramsContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Create_routine_paramsContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Create_routine_paramsContext) AllCreate_routine_param_item() []ICreate_routine_param_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_routine_param_itemContext); ok {
			len++
		}
	}

	tst := make([]ICreate_routine_param_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_routine_param_itemContext); ok {
			tst[i] = t.(ICreate_routine_param_itemContext)
			i++
		}
	}

	return tst
}

func (s *Create_routine_paramsContext) Create_routine_param_item(i int) ICreate_routine_param_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_routine_param_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_routine_param_itemContext)
}

func (s *Create_routine_paramsContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Create_routine_paramsContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Create_routine_paramsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_routine_paramsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_routine_paramsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_routine_params(s)
	}
}

func (s *Create_routine_paramsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_routine_params(s)
	}
}

func (p *HplsqlParser) Create_routine_params() (localctx ICreate_routine_paramsContext) {
	localctx = NewCreate_routine_paramsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, HplsqlParserRULE_create_routine_params)
	var _la int

	var _alt int

	p.SetState(1699)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 170, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1677)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1678)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1679)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1680)
			p.Create_routine_param_item()
		}
		p.SetState(1685)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(1681)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1682)
				p.Create_routine_param_item()
			}

			p.SetState(1687)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1688)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1690)

		if !(!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "IS") &&
			!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "AS") &&
			!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "DYNAMIC") && strings.EqualFold(p.GetTokenStream().LT(2).GetText(), "RESULT")) {
			p.SetError(antlr.NewFailedPredicateException(p, "!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"IS\") &&\n        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"AS\") &&\n        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"DYNAMIC\") && strings.EqualFold(p.GetTokenStream().LT(2).GetText(), \"RESULT\")\n        ", ""))
			goto errorExit
		}
		{
			p.SetState(1691)
			p.Create_routine_param_item()
		}
		p.SetState(1696)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 169, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1692)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1693)
					p.Create_routine_param_item()
				}

			}
			p.SetState(1698)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 169, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_routine_param_itemContext is an interface to support dynamic dispatch.
type ICreate_routine_param_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ident() IIdentContext
	Dtype() IDtypeContext
	T_IN() antlr.TerminalNode
	T_OUT() antlr.TerminalNode
	T_INOUT() antlr.TerminalNode
	Dtype_len() IDtype_lenContext
	AllDtype_attr() []IDtype_attrContext
	Dtype_attr(i int) IDtype_attrContext
	Dtype_default() IDtype_defaultContext

	// IsCreate_routine_param_itemContext differentiates from other interfaces.
	IsCreate_routine_param_itemContext()
}

type Create_routine_param_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_routine_param_itemContext() *Create_routine_param_itemContext {
	var p = new(Create_routine_param_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_routine_param_item
	return p
}

func InitEmptyCreate_routine_param_itemContext(p *Create_routine_param_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_routine_param_item
}

func (*Create_routine_param_itemContext) IsCreate_routine_param_itemContext() {}

func NewCreate_routine_param_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_routine_param_itemContext {
	var p = new(Create_routine_param_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_routine_param_item

	return p
}

func (s *Create_routine_param_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_routine_param_itemContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Create_routine_param_itemContext) Dtype() IDtypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *Create_routine_param_itemContext) T_IN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IN, 0)
}

func (s *Create_routine_param_itemContext) T_OUT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OUT, 0)
}

func (s *Create_routine_param_itemContext) T_INOUT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INOUT, 0)
}

func (s *Create_routine_param_itemContext) Dtype_len() IDtype_lenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_lenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_lenContext)
}

func (s *Create_routine_param_itemContext) AllDtype_attr() []IDtype_attrContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDtype_attrContext); ok {
			len++
		}
	}

	tst := make([]IDtype_attrContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDtype_attrContext); ok {
			tst[i] = t.(IDtype_attrContext)
			i++
		}
	}

	return tst
}

func (s *Create_routine_param_itemContext) Dtype_attr(i int) IDtype_attrContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_attrContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_attrContext)
}

func (s *Create_routine_param_itemContext) Dtype_default() IDtype_defaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_defaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_defaultContext)
}

func (s *Create_routine_param_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_routine_param_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_routine_param_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_routine_param_item(s)
	}
}

func (s *Create_routine_param_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_routine_param_item(s)
	}
}

func (p *HplsqlParser) Create_routine_param_item() (localctx ICreate_routine_param_itemContext) {
	localctx = NewCreate_routine_param_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, HplsqlParserRULE_create_routine_param_item)
	var _alt int

	p.SetState(1743)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 179, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1706)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 171, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1701)
				p.Match(HplsqlParserT_IN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 171, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(1702)
				p.Match(HplsqlParserT_OUT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 171, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(1703)
				p.Match(HplsqlParserT_INOUT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 171, p.GetParserRuleContext()) == 4 {
			{
				p.SetState(1704)
				p.Match(HplsqlParserT_IN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1705)
				p.Match(HplsqlParserT_OUT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1708)
			p.Ident()
		}
		{
			p.SetState(1709)
			p.Dtype()
		}
		p.SetState(1711)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 172, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1710)
				p.Dtype_len()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1716)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 173, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1713)
					p.Dtype_attr()
				}

			}
			p.SetState(1718)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 173, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1720)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 174, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1719)
				p.Dtype_default()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1722)
			p.Ident()
		}
		p.SetState(1728)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 175, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1723)
				p.Match(HplsqlParserT_IN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 175, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(1724)
				p.Match(HplsqlParserT_OUT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 175, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(1725)
				p.Match(HplsqlParserT_INOUT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 175, p.GetParserRuleContext()) == 4 {
			{
				p.SetState(1726)
				p.Match(HplsqlParserT_IN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1727)
				p.Match(HplsqlParserT_OUT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1730)
			p.Dtype()
		}
		p.SetState(1732)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 176, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1731)
				p.Dtype_len()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1737)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 177, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1734)
					p.Dtype_attr()
				}

			}
			p.SetState(1739)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 177, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1741)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 178, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1740)
				p.Dtype_default()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_routine_optionsContext is an interface to support dynamic dispatch.
type ICreate_routine_optionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCreate_routine_option() []ICreate_routine_optionContext
	Create_routine_option(i int) ICreate_routine_optionContext

	// IsCreate_routine_optionsContext differentiates from other interfaces.
	IsCreate_routine_optionsContext()
}

type Create_routine_optionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_routine_optionsContext() *Create_routine_optionsContext {
	var p = new(Create_routine_optionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_routine_options
	return p
}

func InitEmptyCreate_routine_optionsContext(p *Create_routine_optionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_routine_options
}

func (*Create_routine_optionsContext) IsCreate_routine_optionsContext() {}

func NewCreate_routine_optionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_routine_optionsContext {
	var p = new(Create_routine_optionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_routine_options

	return p
}

func (s *Create_routine_optionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_routine_optionsContext) AllCreate_routine_option() []ICreate_routine_optionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_routine_optionContext); ok {
			len++
		}
	}

	tst := make([]ICreate_routine_optionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_routine_optionContext); ok {
			tst[i] = t.(ICreate_routine_optionContext)
			i++
		}
	}

	return tst
}

func (s *Create_routine_optionsContext) Create_routine_option(i int) ICreate_routine_optionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_routine_optionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_routine_optionContext)
}

func (s *Create_routine_optionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_routine_optionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_routine_optionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_routine_options(s)
	}
}

func (s *Create_routine_optionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_routine_options(s)
	}
}

func (p *HplsqlParser) Create_routine_options() (localctx ICreate_routine_optionsContext) {
	localctx = NewCreate_routine_optionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, HplsqlParserRULE_create_routine_options)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1746)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1745)
				p.Create_routine_option()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1748)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 180, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_routine_optionContext is an interface to support dynamic dispatch.
type ICreate_routine_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_LANGUAGE() antlr.TerminalNode
	T_SQL() antlr.TerminalNode
	T_SECURITY() antlr.TerminalNode
	T_CREATOR() antlr.TerminalNode
	T_DEFINER() antlr.TerminalNode
	T_INVOKER() antlr.TerminalNode
	T_OWNER() antlr.TerminalNode
	T_RESULT() antlr.TerminalNode
	T_SETS() antlr.TerminalNode
	L_INT() antlr.TerminalNode
	T_DYNAMIC() antlr.TerminalNode

	// IsCreate_routine_optionContext differentiates from other interfaces.
	IsCreate_routine_optionContext()
}

type Create_routine_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_routine_optionContext() *Create_routine_optionContext {
	var p = new(Create_routine_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_routine_option
	return p
}

func InitEmptyCreate_routine_optionContext(p *Create_routine_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_routine_option
}

func (*Create_routine_optionContext) IsCreate_routine_optionContext() {}

func NewCreate_routine_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_routine_optionContext {
	var p = new(Create_routine_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_routine_option

	return p
}

func (s *Create_routine_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_routine_optionContext) T_LANGUAGE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LANGUAGE, 0)
}

func (s *Create_routine_optionContext) T_SQL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SQL, 0)
}

func (s *Create_routine_optionContext) T_SECURITY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SECURITY, 0)
}

func (s *Create_routine_optionContext) T_CREATOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATOR, 0)
}

func (s *Create_routine_optionContext) T_DEFINER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFINER, 0)
}

func (s *Create_routine_optionContext) T_INVOKER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INVOKER, 0)
}

func (s *Create_routine_optionContext) T_OWNER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OWNER, 0)
}

func (s *Create_routine_optionContext) T_RESULT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESULT, 0)
}

func (s *Create_routine_optionContext) T_SETS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SETS, 0)
}

func (s *Create_routine_optionContext) L_INT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_INT, 0)
}

func (s *Create_routine_optionContext) T_DYNAMIC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DYNAMIC, 0)
}

func (s *Create_routine_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_routine_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_routine_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_routine_option(s)
	}
}

func (s *Create_routine_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_routine_option(s)
	}
}

func (p *HplsqlParser) Create_routine_option() (localctx ICreate_routine_optionContext) {
	localctx = NewCreate_routine_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, HplsqlParserRULE_create_routine_option)
	var _la int

	p.SetState(1761)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_LANGUAGE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1750)
			p.Match(HplsqlParserT_LANGUAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1751)
			p.Match(HplsqlParserT_SQL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_SQL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1752)
			p.Match(HplsqlParserT_SQL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1753)
			p.Match(HplsqlParserT_SECURITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1754)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_CREATOR || _la == HplsqlParserT_DEFINER || _la == HplsqlParserT_INVOKER || _la == HplsqlParserT_OWNER) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case HplsqlParserT_DYNAMIC, HplsqlParserT_RESULT:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1756)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_DYNAMIC {
			{
				p.SetState(1755)
				p.Match(HplsqlParserT_DYNAMIC)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1758)
			p.Match(HplsqlParserT_RESULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1759)
			p.Match(HplsqlParserT_SETS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1760)
			p.Match(HplsqlParserL_INT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDrop_stmtContext is an interface to support dynamic dispatch.
type IDrop_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_DROP() antlr.TerminalNode
	T_TABLE() antlr.TerminalNode
	Table_name() ITable_nameContext
	T_IF() antlr.TerminalNode
	T_EXISTS() antlr.TerminalNode
	T_PACKAGE() antlr.TerminalNode
	Ident() IIdentContext
	T_PROCEDURE() antlr.TerminalNode
	T_FUNCTION() antlr.TerminalNode
	Expr() IExprContext
	T_DATABASE() antlr.TerminalNode
	T_SCHEMA() antlr.TerminalNode

	// IsDrop_stmtContext differentiates from other interfaces.
	IsDrop_stmtContext()
}

type Drop_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_stmtContext() *Drop_stmtContext {
	var p = new(Drop_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_drop_stmt
	return p
}

func InitEmptyDrop_stmtContext(p *Drop_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_drop_stmt
}

func (*Drop_stmtContext) IsDrop_stmtContext() {}

func NewDrop_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_stmtContext {
	var p = new(Drop_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_drop_stmt

	return p
}

func (s *Drop_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_stmtContext) T_DROP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DROP, 0)
}

func (s *Drop_stmtContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLE, 0)
}

func (s *Drop_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Drop_stmtContext) T_IF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IF, 0)
}

func (s *Drop_stmtContext) T_EXISTS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXISTS, 0)
}

func (s *Drop_stmtContext) T_PACKAGE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PACKAGE, 0)
}

func (s *Drop_stmtContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Drop_stmtContext) T_PROCEDURE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PROCEDURE, 0)
}

func (s *Drop_stmtContext) T_FUNCTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FUNCTION, 0)
}

func (s *Drop_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Drop_stmtContext) T_DATABASE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATABASE, 0)
}

func (s *Drop_stmtContext) T_SCHEMA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SCHEMA, 0)
}

func (s *Drop_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Drop_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDrop_stmt(s)
	}
}

func (s *Drop_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDrop_stmt(s)
	}
}

func (p *HplsqlParser) Drop_stmt() (localctx IDrop_stmtContext) {
	localctx = NewDrop_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, HplsqlParserRULE_drop_stmt)
	var _la int

	p.SetState(1791)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 187, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1763)
			p.Match(HplsqlParserT_DROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1764)
			p.Match(HplsqlParserT_TABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1767)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 183, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1765)
				p.Match(HplsqlParserT_IF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1766)
				p.Match(HplsqlParserT_EXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1769)
			p.Table_name()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1770)
			p.Match(HplsqlParserT_DROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1771)
			p.Match(HplsqlParserT_PACKAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1774)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 184, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1772)
				p.Match(HplsqlParserT_IF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1773)
				p.Match(HplsqlParserT_EXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1776)
			p.Ident()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1777)
			p.Match(HplsqlParserT_DROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1778)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_FUNCTION || _la == HplsqlParserT_PROCEDURE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1781)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 185, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1779)
				p.Match(HplsqlParserT_IF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1780)
				p.Match(HplsqlParserT_EXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1783)
			p.Ident()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1784)
			p.Match(HplsqlParserT_DROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1785)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_DATABASE || _la == HplsqlParserT_SCHEMA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1788)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 186, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1786)
				p.Match(HplsqlParserT_IF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1787)
				p.Match(HplsqlParserT_EXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1790)
			p.expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnd_transaction_stmtContext is an interface to support dynamic dispatch.
type IEnd_transaction_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_END() antlr.TerminalNode
	T_TRANSACTION() antlr.TerminalNode

	// IsEnd_transaction_stmtContext differentiates from other interfaces.
	IsEnd_transaction_stmtContext()
}

type End_transaction_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnd_transaction_stmtContext() *End_transaction_stmtContext {
	var p = new(End_transaction_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_end_transaction_stmt
	return p
}

func InitEmptyEnd_transaction_stmtContext(p *End_transaction_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_end_transaction_stmt
}

func (*End_transaction_stmtContext) IsEnd_transaction_stmtContext() {}

func NewEnd_transaction_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *End_transaction_stmtContext {
	var p = new(End_transaction_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_end_transaction_stmt

	return p
}

func (s *End_transaction_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *End_transaction_stmtContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *End_transaction_stmtContext) T_TRANSACTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TRANSACTION, 0)
}

func (s *End_transaction_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *End_transaction_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *End_transaction_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterEnd_transaction_stmt(s)
	}
}

func (s *End_transaction_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitEnd_transaction_stmt(s)
	}
}

func (p *HplsqlParser) End_transaction_stmt() (localctx IEnd_transaction_stmtContext) {
	localctx = NewEnd_transaction_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, HplsqlParserRULE_end_transaction_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1793)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1794)
		p.Match(HplsqlParserT_TRANSACTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExec_stmtContext is an interface to support dynamic dispatch.
type IExec_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	T_EXEC() antlr.TerminalNode
	T_EXECUTE() antlr.TerminalNode
	T_IMMEDIATE() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	Expr_func_params() IExpr_func_paramsContext
	T_CLOSE_P() antlr.TerminalNode
	T_INTO() antlr.TerminalNode
	AllL_ID() []antlr.TerminalNode
	L_ID(i int) antlr.TerminalNode
	Using_clause() IUsing_clauseContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsExec_stmtContext differentiates from other interfaces.
	IsExec_stmtContext()
}

type Exec_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExec_stmtContext() *Exec_stmtContext {
	var p = new(Exec_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_exec_stmt
	return p
}

func InitEmptyExec_stmtContext(p *Exec_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_exec_stmt
}

func (*Exec_stmtContext) IsExec_stmtContext() {}

func NewExec_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exec_stmtContext {
	var p = new(Exec_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_exec_stmt

	return p
}

func (s *Exec_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Exec_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Exec_stmtContext) T_EXEC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXEC, 0)
}

func (s *Exec_stmtContext) T_EXECUTE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXECUTE, 0)
}

func (s *Exec_stmtContext) T_IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IMMEDIATE, 0)
}

func (s *Exec_stmtContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Exec_stmtContext) Expr_func_params() IExpr_func_paramsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_func_paramsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_func_paramsContext)
}

func (s *Exec_stmtContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Exec_stmtContext) T_INTO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTO, 0)
}

func (s *Exec_stmtContext) AllL_ID() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserL_ID)
}

func (s *Exec_stmtContext) L_ID(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, i)
}

func (s *Exec_stmtContext) Using_clause() IUsing_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsing_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsing_clauseContext)
}

func (s *Exec_stmtContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Exec_stmtContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Exec_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exec_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Exec_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExec_stmt(s)
	}
}

func (s *Exec_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExec_stmt(s)
	}
}

func (p *HplsqlParser) Exec_stmt() (localctx IExec_stmtContext) {
	localctx = NewExec_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, HplsqlParserRULE_exec_stmt)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1796)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_EXEC || _la == HplsqlParserT_EXECUTE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1798)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 188, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1797)
			p.Match(HplsqlParserT_IMMEDIATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1800)
		p.expr(0)
	}
	p.SetState(1806)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 189, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1801)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1802)
			p.Expr_func_params()
		}
		{
			p.SetState(1803)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 189, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1805)
			p.Expr_func_params()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1817)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 191, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1808)
			p.Match(HplsqlParserT_INTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1809)
			p.Match(HplsqlParserL_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1814)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 190, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1810)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1811)
					p.Match(HplsqlParserL_ID)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1816)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 190, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1820)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 192, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1819)
			p.Using_clause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIf_stmtContext is an interface to support dynamic dispatch.
type IIf_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	If_plsql_stmt() IIf_plsql_stmtContext
	If_tsql_stmt() IIf_tsql_stmtContext
	If_bteq_stmt() IIf_bteq_stmtContext

	// IsIf_stmtContext differentiates from other interfaces.
	IsIf_stmtContext()
}

type If_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_stmtContext() *If_stmtContext {
	var p = new(If_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_if_stmt
	return p
}

func InitEmptyIf_stmtContext(p *If_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_if_stmt
}

func (*If_stmtContext) IsIf_stmtContext() {}

func NewIf_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_stmtContext {
	var p = new(If_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_if_stmt

	return p
}

func (s *If_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *If_stmtContext) If_plsql_stmt() IIf_plsql_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIf_plsql_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIf_plsql_stmtContext)
}

func (s *If_stmtContext) If_tsql_stmt() IIf_tsql_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIf_tsql_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIf_tsql_stmtContext)
}

func (s *If_stmtContext) If_bteq_stmt() IIf_bteq_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIf_bteq_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIf_bteq_stmtContext)
}

func (s *If_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterIf_stmt(s)
	}
}

func (s *If_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitIf_stmt(s)
	}
}

func (p *HplsqlParser) If_stmt() (localctx IIf_stmtContext) {
	localctx = NewIf_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, HplsqlParserRULE_if_stmt)
	p.SetState(1825)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 193, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1822)
			p.If_plsql_stmt()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1823)
			p.If_tsql_stmt()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1824)
			p.If_bteq_stmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIf_plsql_stmtContext is an interface to support dynamic dispatch.
type IIf_plsql_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllT_IF() []antlr.TerminalNode
	T_IF(i int) antlr.TerminalNode
	Bool_expr() IBool_exprContext
	T_THEN() antlr.TerminalNode
	Block() IBlockContext
	T_END() antlr.TerminalNode
	AllElseif_block() []IElseif_blockContext
	Elseif_block(i int) IElseif_blockContext
	Else_block() IElse_blockContext

	// IsIf_plsql_stmtContext differentiates from other interfaces.
	IsIf_plsql_stmtContext()
}

type If_plsql_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_plsql_stmtContext() *If_plsql_stmtContext {
	var p = new(If_plsql_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_if_plsql_stmt
	return p
}

func InitEmptyIf_plsql_stmtContext(p *If_plsql_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_if_plsql_stmt
}

func (*If_plsql_stmtContext) IsIf_plsql_stmtContext() {}

func NewIf_plsql_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_plsql_stmtContext {
	var p = new(If_plsql_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_if_plsql_stmt

	return p
}

func (s *If_plsql_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *If_plsql_stmtContext) AllT_IF() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_IF)
}

func (s *If_plsql_stmtContext) T_IF(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IF, i)
}

func (s *If_plsql_stmtContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *If_plsql_stmtContext) T_THEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_THEN, 0)
}

func (s *If_plsql_stmtContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *If_plsql_stmtContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *If_plsql_stmtContext) AllElseif_block() []IElseif_blockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElseif_blockContext); ok {
			len++
		}
	}

	tst := make([]IElseif_blockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElseif_blockContext); ok {
			tst[i] = t.(IElseif_blockContext)
			i++
		}
	}

	return tst
}

func (s *If_plsql_stmtContext) Elseif_block(i int) IElseif_blockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElseif_blockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElseif_blockContext)
}

func (s *If_plsql_stmtContext) Else_block() IElse_blockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElse_blockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElse_blockContext)
}

func (s *If_plsql_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_plsql_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_plsql_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterIf_plsql_stmt(s)
	}
}

func (s *If_plsql_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitIf_plsql_stmt(s)
	}
}

func (p *HplsqlParser) If_plsql_stmt() (localctx IIf_plsql_stmtContext) {
	localctx = NewIf_plsql_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, HplsqlParserRULE_if_plsql_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1827)
		p.Match(HplsqlParserT_IF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1828)
		p.bool_expr(0)
	}
	{
		p.SetState(1829)
		p.Match(HplsqlParserT_THEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1830)
		p.Block()
	}
	p.SetState(1834)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_ELSEIF || _la == HplsqlParserT_ELSIF {
		{
			p.SetState(1831)
			p.Elseif_block()
		}

		p.SetState(1836)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1838)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_ELSE {
		{
			p.SetState(1837)
			p.Else_block()
		}

	}
	{
		p.SetState(1840)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1841)
		p.Match(HplsqlParserT_IF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIf_tsql_stmtContext is an interface to support dynamic dispatch.
type IIf_tsql_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_IF() antlr.TerminalNode
	Bool_expr() IBool_exprContext
	AllSingle_block_stmt() []ISingle_block_stmtContext
	Single_block_stmt(i int) ISingle_block_stmtContext
	T_ELSE() antlr.TerminalNode

	// IsIf_tsql_stmtContext differentiates from other interfaces.
	IsIf_tsql_stmtContext()
}

type If_tsql_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_tsql_stmtContext() *If_tsql_stmtContext {
	var p = new(If_tsql_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_if_tsql_stmt
	return p
}

func InitEmptyIf_tsql_stmtContext(p *If_tsql_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_if_tsql_stmt
}

func (*If_tsql_stmtContext) IsIf_tsql_stmtContext() {}

func NewIf_tsql_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_tsql_stmtContext {
	var p = new(If_tsql_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_if_tsql_stmt

	return p
}

func (s *If_tsql_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *If_tsql_stmtContext) T_IF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IF, 0)
}

func (s *If_tsql_stmtContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *If_tsql_stmtContext) AllSingle_block_stmt() []ISingle_block_stmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingle_block_stmtContext); ok {
			len++
		}
	}

	tst := make([]ISingle_block_stmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingle_block_stmtContext); ok {
			tst[i] = t.(ISingle_block_stmtContext)
			i++
		}
	}

	return tst
}

func (s *If_tsql_stmtContext) Single_block_stmt(i int) ISingle_block_stmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingle_block_stmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingle_block_stmtContext)
}

func (s *If_tsql_stmtContext) T_ELSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ELSE, 0)
}

func (s *If_tsql_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_tsql_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_tsql_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterIf_tsql_stmt(s)
	}
}

func (s *If_tsql_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitIf_tsql_stmt(s)
	}
}

func (p *HplsqlParser) If_tsql_stmt() (localctx IIf_tsql_stmtContext) {
	localctx = NewIf_tsql_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, HplsqlParserRULE_if_tsql_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1843)
		p.Match(HplsqlParserT_IF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1844)
		p.bool_expr(0)
	}
	{
		p.SetState(1845)
		p.Single_block_stmt()
	}
	p.SetState(1848)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 196, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1846)
			p.Match(HplsqlParserT_ELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1847)
			p.Single_block_stmt()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIf_bteq_stmtContext is an interface to support dynamic dispatch.
type IIf_bteq_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_DOT() antlr.TerminalNode
	T_IF() antlr.TerminalNode
	Bool_expr() IBool_exprContext
	T_THEN() antlr.TerminalNode
	Single_block_stmt() ISingle_block_stmtContext

	// IsIf_bteq_stmtContext differentiates from other interfaces.
	IsIf_bteq_stmtContext()
}

type If_bteq_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_bteq_stmtContext() *If_bteq_stmtContext {
	var p = new(If_bteq_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_if_bteq_stmt
	return p
}

func InitEmptyIf_bteq_stmtContext(p *If_bteq_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_if_bteq_stmt
}

func (*If_bteq_stmtContext) IsIf_bteq_stmtContext() {}

func NewIf_bteq_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_bteq_stmtContext {
	var p = new(If_bteq_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_if_bteq_stmt

	return p
}

func (s *If_bteq_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *If_bteq_stmtContext) T_DOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DOT, 0)
}

func (s *If_bteq_stmtContext) T_IF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IF, 0)
}

func (s *If_bteq_stmtContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *If_bteq_stmtContext) T_THEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_THEN, 0)
}

func (s *If_bteq_stmtContext) Single_block_stmt() ISingle_block_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingle_block_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingle_block_stmtContext)
}

func (s *If_bteq_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_bteq_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_bteq_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterIf_bteq_stmt(s)
	}
}

func (s *If_bteq_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitIf_bteq_stmt(s)
	}
}

func (p *HplsqlParser) If_bteq_stmt() (localctx IIf_bteq_stmtContext) {
	localctx = NewIf_bteq_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, HplsqlParserRULE_if_bteq_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1850)
		p.Match(HplsqlParserT_DOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1851)
		p.Match(HplsqlParserT_IF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1852)
		p.bool_expr(0)
	}
	{
		p.SetState(1853)
		p.Match(HplsqlParserT_THEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1854)
		p.Single_block_stmt()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElseif_blockContext is an interface to support dynamic dispatch.
type IElseif_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Bool_expr() IBool_exprContext
	T_THEN() antlr.TerminalNode
	Block() IBlockContext
	T_ELSIF() antlr.TerminalNode
	T_ELSEIF() antlr.TerminalNode

	// IsElseif_blockContext differentiates from other interfaces.
	IsElseif_blockContext()
}

type Elseif_blockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElseif_blockContext() *Elseif_blockContext {
	var p = new(Elseif_blockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_elseif_block
	return p
}

func InitEmptyElseif_blockContext(p *Elseif_blockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_elseif_block
}

func (*Elseif_blockContext) IsElseif_blockContext() {}

func NewElseif_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Elseif_blockContext {
	var p = new(Elseif_blockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_elseif_block

	return p
}

func (s *Elseif_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Elseif_blockContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *Elseif_blockContext) T_THEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_THEN, 0)
}

func (s *Elseif_blockContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *Elseif_blockContext) T_ELSIF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ELSIF, 0)
}

func (s *Elseif_blockContext) T_ELSEIF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ELSEIF, 0)
}

func (s *Elseif_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Elseif_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Elseif_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterElseif_block(s)
	}
}

func (s *Elseif_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitElseif_block(s)
	}
}

func (p *HplsqlParser) Elseif_block() (localctx IElseif_blockContext) {
	localctx = NewElseif_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, HplsqlParserRULE_elseif_block)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1856)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_ELSEIF || _la == HplsqlParserT_ELSIF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1857)
		p.bool_expr(0)
	}
	{
		p.SetState(1858)
		p.Match(HplsqlParserT_THEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1859)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElse_blockContext is an interface to support dynamic dispatch.
type IElse_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ELSE() antlr.TerminalNode
	Block() IBlockContext

	// IsElse_blockContext differentiates from other interfaces.
	IsElse_blockContext()
}

type Else_blockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElse_blockContext() *Else_blockContext {
	var p = new(Else_blockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_else_block
	return p
}

func InitEmptyElse_blockContext(p *Else_blockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_else_block
}

func (*Else_blockContext) IsElse_blockContext() {}

func NewElse_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Else_blockContext {
	var p = new(Else_blockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_else_block

	return p
}

func (s *Else_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Else_blockContext) T_ELSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ELSE, 0)
}

func (s *Else_blockContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *Else_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Else_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Else_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterElse_block(s)
	}
}

func (s *Else_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitElse_block(s)
	}
}

func (p *HplsqlParser) Else_block() (localctx IElse_blockContext) {
	localctx = NewElse_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, HplsqlParserRULE_else_block)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1861)
		p.Match(HplsqlParserT_ELSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1862)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInclude_stmtContext is an interface to support dynamic dispatch.
type IInclude_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_INCLUDE() antlr.TerminalNode
	File_name() IFile_nameContext
	Expr() IExprContext

	// IsInclude_stmtContext differentiates from other interfaces.
	IsInclude_stmtContext()
}

type Include_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInclude_stmtContext() *Include_stmtContext {
	var p = new(Include_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_include_stmt
	return p
}

func InitEmptyInclude_stmtContext(p *Include_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_include_stmt
}

func (*Include_stmtContext) IsInclude_stmtContext() {}

func NewInclude_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Include_stmtContext {
	var p = new(Include_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_include_stmt

	return p
}

func (s *Include_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Include_stmtContext) T_INCLUDE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INCLUDE, 0)
}

func (s *Include_stmtContext) File_name() IFile_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFile_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFile_nameContext)
}

func (s *Include_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Include_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Include_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Include_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterInclude_stmt(s)
	}
}

func (s *Include_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitInclude_stmt(s)
	}
}

func (p *HplsqlParser) Include_stmt() (localctx IInclude_stmtContext) {
	localctx = NewInclude_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, HplsqlParserRULE_include_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1864)
		p.Match(HplsqlParserT_INCLUDE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1867)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 197, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1865)
			p.File_name()
		}

	case 2:
		{
			p.SetState(1866)
			p.expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsert_stmtContext is an interface to support dynamic dispatch.
type IInsert_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_INSERT() antlr.TerminalNode
	Table_name() ITable_nameContext
	T_OVERWRITE() antlr.TerminalNode
	T_TABLE() antlr.TerminalNode
	T_INTO() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	Insert_stmt_rows() IInsert_stmt_rowsContext
	Insert_stmt_cols() IInsert_stmt_colsContext

	// IsInsert_stmtContext differentiates from other interfaces.
	IsInsert_stmtContext()
}

type Insert_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsert_stmtContext() *Insert_stmtContext {
	var p = new(Insert_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_insert_stmt
	return p
}

func InitEmptyInsert_stmtContext(p *Insert_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_insert_stmt
}

func (*Insert_stmtContext) IsInsert_stmtContext() {}

func NewInsert_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Insert_stmtContext {
	var p = new(Insert_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_insert_stmt

	return p
}

func (s *Insert_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Insert_stmtContext) T_INSERT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INSERT, 0)
}

func (s *Insert_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Insert_stmtContext) T_OVERWRITE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OVERWRITE, 0)
}

func (s *Insert_stmtContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLE, 0)
}

func (s *Insert_stmtContext) T_INTO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTO, 0)
}

func (s *Insert_stmtContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Insert_stmtContext) Insert_stmt_rows() IInsert_stmt_rowsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_stmt_rowsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_stmt_rowsContext)
}

func (s *Insert_stmtContext) Insert_stmt_cols() IInsert_stmt_colsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_stmt_colsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_stmt_colsContext)
}

func (s *Insert_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Insert_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Insert_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterInsert_stmt(s)
	}
}

func (s *Insert_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitInsert_stmt(s)
	}
}

func (p *HplsqlParser) Insert_stmt() (localctx IInsert_stmtContext) {
	localctx = NewInsert_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, HplsqlParserRULE_insert_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1869)
		p.Match(HplsqlParserT_INSERT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1876)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_OVERWRITE:
		{
			p.SetState(1870)
			p.Match(HplsqlParserT_OVERWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1871)
			p.Match(HplsqlParserT_TABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_INTO:
		{
			p.SetState(1872)
			p.Match(HplsqlParserT_INTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1874)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 198, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1873)
				p.Match(HplsqlParserT_TABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1878)
		p.Table_name()
	}
	p.SetState(1880)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 200, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1879)
			p.Insert_stmt_cols()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1884)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_WITH, HplsqlParserT_OPEN_P:
		{
			p.SetState(1882)
			p.Select_stmt()
		}

	case HplsqlParserT_VALUES:
		{
			p.SetState(1883)
			p.Insert_stmt_rows()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsert_stmt_colsContext is an interface to support dynamic dispatch.
type IInsert_stmt_colsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN_P() antlr.TerminalNode
	AllQident() []IQidentContext
	Qident(i int) IQidentContext
	T_CLOSE_P() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsInsert_stmt_colsContext differentiates from other interfaces.
	IsInsert_stmt_colsContext()
}

type Insert_stmt_colsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsert_stmt_colsContext() *Insert_stmt_colsContext {
	var p = new(Insert_stmt_colsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_insert_stmt_cols
	return p
}

func InitEmptyInsert_stmt_colsContext(p *Insert_stmt_colsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_insert_stmt_cols
}

func (*Insert_stmt_colsContext) IsInsert_stmt_colsContext() {}

func NewInsert_stmt_colsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Insert_stmt_colsContext {
	var p = new(Insert_stmt_colsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_insert_stmt_cols

	return p
}

func (s *Insert_stmt_colsContext) GetParser() antlr.Parser { return s.parser }

func (s *Insert_stmt_colsContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Insert_stmt_colsContext) AllQident() []IQidentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQidentContext); ok {
			len++
		}
	}

	tst := make([]IQidentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQidentContext); ok {
			tst[i] = t.(IQidentContext)
			i++
		}
	}

	return tst
}

func (s *Insert_stmt_colsContext) Qident(i int) IQidentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Insert_stmt_colsContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Insert_stmt_colsContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Insert_stmt_colsContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Insert_stmt_colsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Insert_stmt_colsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Insert_stmt_colsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterInsert_stmt_cols(s)
	}
}

func (s *Insert_stmt_colsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitInsert_stmt_cols(s)
	}
}

func (p *HplsqlParser) Insert_stmt_cols() (localctx IInsert_stmt_colsContext) {
	localctx = NewInsert_stmt_colsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, HplsqlParserRULE_insert_stmt_cols)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1886)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1887)
		p.Qident()
	}
	p.SetState(1892)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(1888)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1889)
			p.Qident()
		}

		p.SetState(1894)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1895)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsert_stmt_rowsContext is an interface to support dynamic dispatch.
type IInsert_stmt_rowsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_VALUES() antlr.TerminalNode
	AllInsert_stmt_row() []IInsert_stmt_rowContext
	Insert_stmt_row(i int) IInsert_stmt_rowContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsInsert_stmt_rowsContext differentiates from other interfaces.
	IsInsert_stmt_rowsContext()
}

type Insert_stmt_rowsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsert_stmt_rowsContext() *Insert_stmt_rowsContext {
	var p = new(Insert_stmt_rowsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_insert_stmt_rows
	return p
}

func InitEmptyInsert_stmt_rowsContext(p *Insert_stmt_rowsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_insert_stmt_rows
}

func (*Insert_stmt_rowsContext) IsInsert_stmt_rowsContext() {}

func NewInsert_stmt_rowsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Insert_stmt_rowsContext {
	var p = new(Insert_stmt_rowsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_insert_stmt_rows

	return p
}

func (s *Insert_stmt_rowsContext) GetParser() antlr.Parser { return s.parser }

func (s *Insert_stmt_rowsContext) T_VALUES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VALUES, 0)
}

func (s *Insert_stmt_rowsContext) AllInsert_stmt_row() []IInsert_stmt_rowContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInsert_stmt_rowContext); ok {
			len++
		}
	}

	tst := make([]IInsert_stmt_rowContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInsert_stmt_rowContext); ok {
			tst[i] = t.(IInsert_stmt_rowContext)
			i++
		}
	}

	return tst
}

func (s *Insert_stmt_rowsContext) Insert_stmt_row(i int) IInsert_stmt_rowContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_stmt_rowContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_stmt_rowContext)
}

func (s *Insert_stmt_rowsContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Insert_stmt_rowsContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Insert_stmt_rowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Insert_stmt_rowsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Insert_stmt_rowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterInsert_stmt_rows(s)
	}
}

func (s *Insert_stmt_rowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitInsert_stmt_rows(s)
	}
}

func (p *HplsqlParser) Insert_stmt_rows() (localctx IInsert_stmt_rowsContext) {
	localctx = NewInsert_stmt_rowsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, HplsqlParserRULE_insert_stmt_rows)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1897)
		p.Match(HplsqlParserT_VALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1898)
		p.Insert_stmt_row()
	}
	p.SetState(1903)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 203, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1899)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1900)
				p.Insert_stmt_row()
			}

		}
		p.SetState(1905)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 203, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsert_stmt_rowContext is an interface to support dynamic dispatch.
type IInsert_stmt_rowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN_P() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_CLOSE_P() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsInsert_stmt_rowContext differentiates from other interfaces.
	IsInsert_stmt_rowContext()
}

type Insert_stmt_rowContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsert_stmt_rowContext() *Insert_stmt_rowContext {
	var p = new(Insert_stmt_rowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_insert_stmt_row
	return p
}

func InitEmptyInsert_stmt_rowContext(p *Insert_stmt_rowContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_insert_stmt_row
}

func (*Insert_stmt_rowContext) IsInsert_stmt_rowContext() {}

func NewInsert_stmt_rowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Insert_stmt_rowContext {
	var p = new(Insert_stmt_rowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_insert_stmt_row

	return p
}

func (s *Insert_stmt_rowContext) GetParser() antlr.Parser { return s.parser }

func (s *Insert_stmt_rowContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Insert_stmt_rowContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Insert_stmt_rowContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Insert_stmt_rowContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Insert_stmt_rowContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Insert_stmt_rowContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Insert_stmt_rowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Insert_stmt_rowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Insert_stmt_rowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterInsert_stmt_row(s)
	}
}

func (s *Insert_stmt_rowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitInsert_stmt_row(s)
	}
}

func (p *HplsqlParser) Insert_stmt_row() (localctx IInsert_stmt_rowContext) {
	localctx = NewInsert_stmt_rowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, HplsqlParserRULE_insert_stmt_row)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1906)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1907)
		p.expr(0)
	}
	p.SetState(1912)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(1908)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1909)
			p.expr(0)
		}

		p.SetState(1914)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1915)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsert_directory_stmtContext is an interface to support dynamic dispatch.
type IInsert_directory_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_INSERT() antlr.TerminalNode
	T_OVERWRITE() antlr.TerminalNode
	T_DIRECTORY() antlr.TerminalNode
	Expr_file() IExpr_fileContext
	Expr_select() IExpr_selectContext
	T_LOCAL() antlr.TerminalNode

	// IsInsert_directory_stmtContext differentiates from other interfaces.
	IsInsert_directory_stmtContext()
}

type Insert_directory_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsert_directory_stmtContext() *Insert_directory_stmtContext {
	var p = new(Insert_directory_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_insert_directory_stmt
	return p
}

func InitEmptyInsert_directory_stmtContext(p *Insert_directory_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_insert_directory_stmt
}

func (*Insert_directory_stmtContext) IsInsert_directory_stmtContext() {}

func NewInsert_directory_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Insert_directory_stmtContext {
	var p = new(Insert_directory_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_insert_directory_stmt

	return p
}

func (s *Insert_directory_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Insert_directory_stmtContext) T_INSERT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INSERT, 0)
}

func (s *Insert_directory_stmtContext) T_OVERWRITE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OVERWRITE, 0)
}

func (s *Insert_directory_stmtContext) T_DIRECTORY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DIRECTORY, 0)
}

func (s *Insert_directory_stmtContext) Expr_file() IExpr_fileContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_fileContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_fileContext)
}

func (s *Insert_directory_stmtContext) Expr_select() IExpr_selectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_selectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_selectContext)
}

func (s *Insert_directory_stmtContext) T_LOCAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCAL, 0)
}

func (s *Insert_directory_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Insert_directory_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Insert_directory_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterInsert_directory_stmt(s)
	}
}

func (s *Insert_directory_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitInsert_directory_stmt(s)
	}
}

func (p *HplsqlParser) Insert_directory_stmt() (localctx IInsert_directory_stmtContext) {
	localctx = NewInsert_directory_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, HplsqlParserRULE_insert_directory_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1917)
		p.Match(HplsqlParserT_INSERT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1918)
		p.Match(HplsqlParserT_OVERWRITE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1920)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_LOCAL {
		{
			p.SetState(1919)
			p.Match(HplsqlParserT_LOCAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1922)
		p.Match(HplsqlParserT_DIRECTORY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1923)
		p.Expr_file()
	}
	{
		p.SetState(1924)
		p.Expr_select()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExit_stmtContext is an interface to support dynamic dispatch.
type IExit_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_EXIT() antlr.TerminalNode
	L_ID() antlr.TerminalNode
	T_WHEN() antlr.TerminalNode
	Bool_expr() IBool_exprContext

	// IsExit_stmtContext differentiates from other interfaces.
	IsExit_stmtContext()
}

type Exit_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExit_stmtContext() *Exit_stmtContext {
	var p = new(Exit_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_exit_stmt
	return p
}

func InitEmptyExit_stmtContext(p *Exit_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_exit_stmt
}

func (*Exit_stmtContext) IsExit_stmtContext() {}

func NewExit_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exit_stmtContext {
	var p = new(Exit_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_exit_stmt

	return p
}

func (s *Exit_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Exit_stmtContext) T_EXIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXIT, 0)
}

func (s *Exit_stmtContext) L_ID() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, 0)
}

func (s *Exit_stmtContext) T_WHEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WHEN, 0)
}

func (s *Exit_stmtContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *Exit_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exit_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Exit_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExit_stmt(s)
	}
}

func (s *Exit_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExit_stmt(s)
	}
}

func (p *HplsqlParser) Exit_stmt() (localctx IExit_stmtContext) {
	localctx = NewExit_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, HplsqlParserRULE_exit_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1926)
		p.Match(HplsqlParserT_EXIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1928)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 206, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1927)
			p.Match(HplsqlParserL_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1932)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 207, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1930)
			p.Match(HplsqlParserT_WHEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1931)
			p.bool_expr(0)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGet_diag_stmtContext is an interface to support dynamic dispatch.
type IGet_diag_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_GET() antlr.TerminalNode
	T_DIAGNOSTICS() antlr.TerminalNode
	Get_diag_stmt_item() IGet_diag_stmt_itemContext

	// IsGet_diag_stmtContext differentiates from other interfaces.
	IsGet_diag_stmtContext()
}

type Get_diag_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_diag_stmtContext() *Get_diag_stmtContext {
	var p = new(Get_diag_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt
	return p
}

func InitEmptyGet_diag_stmtContext(p *Get_diag_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt
}

func (*Get_diag_stmtContext) IsGet_diag_stmtContext() {}

func NewGet_diag_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_diag_stmtContext {
	var p = new(Get_diag_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt

	return p
}

func (s *Get_diag_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_diag_stmtContext) T_GET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GET, 0)
}

func (s *Get_diag_stmtContext) T_DIAGNOSTICS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DIAGNOSTICS, 0)
}

func (s *Get_diag_stmtContext) Get_diag_stmt_item() IGet_diag_stmt_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGet_diag_stmt_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGet_diag_stmt_itemContext)
}

func (s *Get_diag_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_diag_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_diag_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterGet_diag_stmt(s)
	}
}

func (s *Get_diag_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitGet_diag_stmt(s)
	}
}

func (p *HplsqlParser) Get_diag_stmt() (localctx IGet_diag_stmtContext) {
	localctx = NewGet_diag_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, HplsqlParserRULE_get_diag_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1934)
		p.Match(HplsqlParserT_GET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1935)
		p.Match(HplsqlParserT_DIAGNOSTICS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1936)
		p.Get_diag_stmt_item()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGet_diag_stmt_itemContext is an interface to support dynamic dispatch.
type IGet_diag_stmt_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Get_diag_stmt_exception_item() IGet_diag_stmt_exception_itemContext
	Get_diag_stmt_rowcount_item() IGet_diag_stmt_rowcount_itemContext

	// IsGet_diag_stmt_itemContext differentiates from other interfaces.
	IsGet_diag_stmt_itemContext()
}

type Get_diag_stmt_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_diag_stmt_itemContext() *Get_diag_stmt_itemContext {
	var p = new(Get_diag_stmt_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt_item
	return p
}

func InitEmptyGet_diag_stmt_itemContext(p *Get_diag_stmt_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt_item
}

func (*Get_diag_stmt_itemContext) IsGet_diag_stmt_itemContext() {}

func NewGet_diag_stmt_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_diag_stmt_itemContext {
	var p = new(Get_diag_stmt_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt_item

	return p
}

func (s *Get_diag_stmt_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_diag_stmt_itemContext) Get_diag_stmt_exception_item() IGet_diag_stmt_exception_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGet_diag_stmt_exception_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGet_diag_stmt_exception_itemContext)
}

func (s *Get_diag_stmt_itemContext) Get_diag_stmt_rowcount_item() IGet_diag_stmt_rowcount_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGet_diag_stmt_rowcount_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGet_diag_stmt_rowcount_itemContext)
}

func (s *Get_diag_stmt_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_diag_stmt_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_diag_stmt_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterGet_diag_stmt_item(s)
	}
}

func (s *Get_diag_stmt_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitGet_diag_stmt_item(s)
	}
}

func (p *HplsqlParser) Get_diag_stmt_item() (localctx IGet_diag_stmt_itemContext) {
	localctx = NewGet_diag_stmt_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, HplsqlParserRULE_get_diag_stmt_item)
	p.SetState(1940)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 208, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1938)
			p.Get_diag_stmt_exception_item()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1939)
			p.Get_diag_stmt_rowcount_item()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGet_diag_stmt_exception_itemContext is an interface to support dynamic dispatch.
type IGet_diag_stmt_exception_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_EXCEPTION() antlr.TerminalNode
	L_INT() antlr.TerminalNode
	Qident() IQidentContext
	T_EQUAL() antlr.TerminalNode
	T_MESSAGE_TEXT() antlr.TerminalNode

	// IsGet_diag_stmt_exception_itemContext differentiates from other interfaces.
	IsGet_diag_stmt_exception_itemContext()
}

type Get_diag_stmt_exception_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_diag_stmt_exception_itemContext() *Get_diag_stmt_exception_itemContext {
	var p = new(Get_diag_stmt_exception_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt_exception_item
	return p
}

func InitEmptyGet_diag_stmt_exception_itemContext(p *Get_diag_stmt_exception_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt_exception_item
}

func (*Get_diag_stmt_exception_itemContext) IsGet_diag_stmt_exception_itemContext() {}

func NewGet_diag_stmt_exception_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_diag_stmt_exception_itemContext {
	var p = new(Get_diag_stmt_exception_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt_exception_item

	return p
}

func (s *Get_diag_stmt_exception_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_diag_stmt_exception_itemContext) T_EXCEPTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXCEPTION, 0)
}

func (s *Get_diag_stmt_exception_itemContext) L_INT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_INT, 0)
}

func (s *Get_diag_stmt_exception_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Get_diag_stmt_exception_itemContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Get_diag_stmt_exception_itemContext) T_MESSAGE_TEXT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MESSAGE_TEXT, 0)
}

func (s *Get_diag_stmt_exception_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_diag_stmt_exception_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_diag_stmt_exception_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterGet_diag_stmt_exception_item(s)
	}
}

func (s *Get_diag_stmt_exception_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitGet_diag_stmt_exception_item(s)
	}
}

func (p *HplsqlParser) Get_diag_stmt_exception_item() (localctx IGet_diag_stmt_exception_itemContext) {
	localctx = NewGet_diag_stmt_exception_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, HplsqlParserRULE_get_diag_stmt_exception_item)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1942)
		p.Match(HplsqlParserT_EXCEPTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1943)
		p.Match(HplsqlParserL_INT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1944)
		p.Qident()
	}
	{
		p.SetState(1945)
		p.Match(HplsqlParserT_EQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1946)
		p.Match(HplsqlParserT_MESSAGE_TEXT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGet_diag_stmt_rowcount_itemContext is an interface to support dynamic dispatch.
type IGet_diag_stmt_rowcount_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Qident() IQidentContext
	T_EQUAL() antlr.TerminalNode
	T_ROW_COUNT() antlr.TerminalNode

	// IsGet_diag_stmt_rowcount_itemContext differentiates from other interfaces.
	IsGet_diag_stmt_rowcount_itemContext()
}

type Get_diag_stmt_rowcount_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_diag_stmt_rowcount_itemContext() *Get_diag_stmt_rowcount_itemContext {
	var p = new(Get_diag_stmt_rowcount_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt_rowcount_item
	return p
}

func InitEmptyGet_diag_stmt_rowcount_itemContext(p *Get_diag_stmt_rowcount_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt_rowcount_item
}

func (*Get_diag_stmt_rowcount_itemContext) IsGet_diag_stmt_rowcount_itemContext() {}

func NewGet_diag_stmt_rowcount_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_diag_stmt_rowcount_itemContext {
	var p = new(Get_diag_stmt_rowcount_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt_rowcount_item

	return p
}

func (s *Get_diag_stmt_rowcount_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_diag_stmt_rowcount_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Get_diag_stmt_rowcount_itemContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Get_diag_stmt_rowcount_itemContext) T_ROW_COUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROW_COUNT, 0)
}

func (s *Get_diag_stmt_rowcount_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_diag_stmt_rowcount_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_diag_stmt_rowcount_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterGet_diag_stmt_rowcount_item(s)
	}
}

func (s *Get_diag_stmt_rowcount_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitGet_diag_stmt_rowcount_item(s)
	}
}

func (p *HplsqlParser) Get_diag_stmt_rowcount_item() (localctx IGet_diag_stmt_rowcount_itemContext) {
	localctx = NewGet_diag_stmt_rowcount_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, HplsqlParserRULE_get_diag_stmt_rowcount_item)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1948)
		p.Qident()
	}
	{
		p.SetState(1949)
		p.Match(HplsqlParserT_EQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1950)
		p.Match(HplsqlParserT_ROW_COUNT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrant_stmtContext is an interface to support dynamic dispatch.
type IGrant_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_GRANT() antlr.TerminalNode
	AllGrant_stmt_item() []IGrant_stmt_itemContext
	Grant_stmt_item(i int) IGrant_stmt_itemContext
	T_TO() antlr.TerminalNode
	T_ROLE() antlr.TerminalNode
	Qident() IQidentContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsGrant_stmtContext differentiates from other interfaces.
	IsGrant_stmtContext()
}

type Grant_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrant_stmtContext() *Grant_stmtContext {
	var p = new(Grant_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_grant_stmt
	return p
}

func InitEmptyGrant_stmtContext(p *Grant_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_grant_stmt
}

func (*Grant_stmtContext) IsGrant_stmtContext() {}

func NewGrant_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Grant_stmtContext {
	var p = new(Grant_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_grant_stmt

	return p
}

func (s *Grant_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Grant_stmtContext) T_GRANT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GRANT, 0)
}

func (s *Grant_stmtContext) AllGrant_stmt_item() []IGrant_stmt_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGrant_stmt_itemContext); ok {
			len++
		}
	}

	tst := make([]IGrant_stmt_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGrant_stmt_itemContext); ok {
			tst[i] = t.(IGrant_stmt_itemContext)
			i++
		}
	}

	return tst
}

func (s *Grant_stmtContext) Grant_stmt_item(i int) IGrant_stmt_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrant_stmt_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrant_stmt_itemContext)
}

func (s *Grant_stmtContext) T_TO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TO, 0)
}

func (s *Grant_stmtContext) T_ROLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROLE, 0)
}

func (s *Grant_stmtContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Grant_stmtContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Grant_stmtContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Grant_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Grant_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Grant_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterGrant_stmt(s)
	}
}

func (s *Grant_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitGrant_stmt(s)
	}
}

func (p *HplsqlParser) Grant_stmt() (localctx IGrant_stmtContext) {
	localctx = NewGrant_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, HplsqlParserRULE_grant_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1952)
		p.Match(HplsqlParserT_GRANT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1953)
		p.Grant_stmt_item()
	}
	p.SetState(1958)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(1954)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1955)
			p.Grant_stmt_item()
		}

		p.SetState(1960)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1961)
		p.Match(HplsqlParserT_TO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1962)
		p.Match(HplsqlParserT_ROLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1963)
		p.Qident()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrant_stmt_itemContext is an interface to support dynamic dispatch.
type IGrant_stmt_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_EXECUTE() antlr.TerminalNode
	T_ON() antlr.TerminalNode
	T_PROCEDURE() antlr.TerminalNode
	Qident() IQidentContext

	// IsGrant_stmt_itemContext differentiates from other interfaces.
	IsGrant_stmt_itemContext()
}

type Grant_stmt_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrant_stmt_itemContext() *Grant_stmt_itemContext {
	var p = new(Grant_stmt_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_grant_stmt_item
	return p
}

func InitEmptyGrant_stmt_itemContext(p *Grant_stmt_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_grant_stmt_item
}

func (*Grant_stmt_itemContext) IsGrant_stmt_itemContext() {}

func NewGrant_stmt_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Grant_stmt_itemContext {
	var p = new(Grant_stmt_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_grant_stmt_item

	return p
}

func (s *Grant_stmt_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Grant_stmt_itemContext) T_EXECUTE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXECUTE, 0)
}

func (s *Grant_stmt_itemContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *Grant_stmt_itemContext) T_PROCEDURE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PROCEDURE, 0)
}

func (s *Grant_stmt_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Grant_stmt_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Grant_stmt_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Grant_stmt_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterGrant_stmt_item(s)
	}
}

func (s *Grant_stmt_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitGrant_stmt_item(s)
	}
}

func (p *HplsqlParser) Grant_stmt_item() (localctx IGrant_stmt_itemContext) {
	localctx = NewGrant_stmt_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, HplsqlParserRULE_grant_stmt_item)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1965)
		p.Match(HplsqlParserT_EXECUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1966)
		p.Match(HplsqlParserT_ON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1967)
		p.Match(HplsqlParserT_PROCEDURE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1968)
		p.Qident()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILeave_stmtContext is an interface to support dynamic dispatch.
type ILeave_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_LEAVE() antlr.TerminalNode
	L_ID() antlr.TerminalNode

	// IsLeave_stmtContext differentiates from other interfaces.
	IsLeave_stmtContext()
}

type Leave_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLeave_stmtContext() *Leave_stmtContext {
	var p = new(Leave_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_leave_stmt
	return p
}

func InitEmptyLeave_stmtContext(p *Leave_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_leave_stmt
}

func (*Leave_stmtContext) IsLeave_stmtContext() {}

func NewLeave_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Leave_stmtContext {
	var p = new(Leave_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_leave_stmt

	return p
}

func (s *Leave_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Leave_stmtContext) T_LEAVE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LEAVE, 0)
}

func (s *Leave_stmtContext) L_ID() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, 0)
}

func (s *Leave_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Leave_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Leave_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterLeave_stmt(s)
	}
}

func (s *Leave_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitLeave_stmt(s)
	}
}

func (p *HplsqlParser) Leave_stmt() (localctx ILeave_stmtContext) {
	localctx = NewLeave_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, HplsqlParserRULE_leave_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1970)
		p.Match(HplsqlParserT_LEAVE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1972)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 210, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1971)
			p.Match(HplsqlParserL_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMap_object_stmtContext is an interface to support dynamic dispatch.
type IMap_object_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_MAP() antlr.TerminalNode
	T_OBJECT() antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	T_TO() antlr.TerminalNode
	T_AT() antlr.TerminalNode

	// IsMap_object_stmtContext differentiates from other interfaces.
	IsMap_object_stmtContext()
}

type Map_object_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMap_object_stmtContext() *Map_object_stmtContext {
	var p = new(Map_object_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_map_object_stmt
	return p
}

func InitEmptyMap_object_stmtContext(p *Map_object_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_map_object_stmt
}

func (*Map_object_stmtContext) IsMap_object_stmtContext() {}

func NewMap_object_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Map_object_stmtContext {
	var p = new(Map_object_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_map_object_stmt

	return p
}

func (s *Map_object_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Map_object_stmtContext) T_MAP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAP, 0)
}

func (s *Map_object_stmtContext) T_OBJECT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OBJECT, 0)
}

func (s *Map_object_stmtContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Map_object_stmtContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Map_object_stmtContext) T_TO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TO, 0)
}

func (s *Map_object_stmtContext) T_AT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AT, 0)
}

func (s *Map_object_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Map_object_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Map_object_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterMap_object_stmt(s)
	}
}

func (s *Map_object_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitMap_object_stmt(s)
	}
}

func (p *HplsqlParser) Map_object_stmt() (localctx IMap_object_stmtContext) {
	localctx = NewMap_object_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, HplsqlParserRULE_map_object_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1974)
		p.Match(HplsqlParserT_MAP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1975)
		p.Match(HplsqlParserT_OBJECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1976)
		p.Ident()
	}
	p.SetState(1979)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 211, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1977)
			p.Match(HplsqlParserT_TO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1978)
			p.Ident()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1983)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 212, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1981)
			p.Match(HplsqlParserT_AT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1982)
			p.Ident()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpen_stmtContext is an interface to support dynamic dispatch.
type IOpen_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN() antlr.TerminalNode
	Ident() IIdentContext
	T_FOR() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	Expr() IExprContext

	// IsOpen_stmtContext differentiates from other interfaces.
	IsOpen_stmtContext()
}

type Open_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpen_stmtContext() *Open_stmtContext {
	var p = new(Open_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_open_stmt
	return p
}

func InitEmptyOpen_stmtContext(p *Open_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_open_stmt
}

func (*Open_stmtContext) IsOpen_stmtContext() {}

func NewOpen_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Open_stmtContext {
	var p = new(Open_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_open_stmt

	return p
}

func (s *Open_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Open_stmtContext) T_OPEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN, 0)
}

func (s *Open_stmtContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Open_stmtContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *Open_stmtContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Open_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Open_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Open_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Open_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterOpen_stmt(s)
	}
}

func (s *Open_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitOpen_stmt(s)
	}
}

func (p *HplsqlParser) Open_stmt() (localctx IOpen_stmtContext) {
	localctx = NewOpen_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, HplsqlParserRULE_open_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1985)
		p.Match(HplsqlParserT_OPEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1986)
		p.Ident()
	}
	p.SetState(1992)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 214, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1987)
			p.Match(HplsqlParserT_FOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1990)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 213, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1988)
				p.Select_stmt()
			}

		case 2:
			{
				p.SetState(1989)
				p.expr(0)
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFetch_stmtContext is an interface to support dynamic dispatch.
type IFetch_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_FETCH() antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	T_INTO() antlr.TerminalNode
	T_FROM() antlr.TerminalNode
	Bulk_collect_clause() IBulk_collect_clauseContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	Fetch_limit() IFetch_limitContext

	// IsFetch_stmtContext differentiates from other interfaces.
	IsFetch_stmtContext()
}

type Fetch_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFetch_stmtContext() *Fetch_stmtContext {
	var p = new(Fetch_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_fetch_stmt
	return p
}

func InitEmptyFetch_stmtContext(p *Fetch_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_fetch_stmt
}

func (*Fetch_stmtContext) IsFetch_stmtContext() {}

func NewFetch_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fetch_stmtContext {
	var p = new(Fetch_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_fetch_stmt

	return p
}

func (s *Fetch_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Fetch_stmtContext) T_FETCH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FETCH, 0)
}

func (s *Fetch_stmtContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Fetch_stmtContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Fetch_stmtContext) T_INTO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTO, 0)
}

func (s *Fetch_stmtContext) T_FROM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FROM, 0)
}

func (s *Fetch_stmtContext) Bulk_collect_clause() IBulk_collect_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBulk_collect_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBulk_collect_clauseContext)
}

func (s *Fetch_stmtContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Fetch_stmtContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Fetch_stmtContext) Fetch_limit() IFetch_limitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFetch_limitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFetch_limitContext)
}

func (s *Fetch_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fetch_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fetch_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFetch_stmt(s)
	}
}

func (s *Fetch_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFetch_stmt(s)
	}
}

func (p *HplsqlParser) Fetch_stmt() (localctx IFetch_stmtContext) {
	localctx = NewFetch_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, HplsqlParserRULE_fetch_stmt)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1994)
		p.Match(HplsqlParserT_FETCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1996)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 215, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1995)
			p.Match(HplsqlParserT_FROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1998)
		p.Ident()
	}
	p.SetState(2000)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_BULK {
		{
			p.SetState(1999)
			p.Bulk_collect_clause()
		}

	}
	{
		p.SetState(2002)
		p.Match(HplsqlParserT_INTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2003)
		p.Ident()
	}
	p.SetState(2008)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 217, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2004)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2005)
				p.Ident()
			}

		}
		p.SetState(2010)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 217, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2012)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 218, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2011)
			p.Fetch_limit()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFetch_limitContext is an interface to support dynamic dispatch.
type IFetch_limitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_LIMIT() antlr.TerminalNode
	Expr() IExprContext

	// IsFetch_limitContext differentiates from other interfaces.
	IsFetch_limitContext()
}

type Fetch_limitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFetch_limitContext() *Fetch_limitContext {
	var p = new(Fetch_limitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_fetch_limit
	return p
}

func InitEmptyFetch_limitContext(p *Fetch_limitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_fetch_limit
}

func (*Fetch_limitContext) IsFetch_limitContext() {}

func NewFetch_limitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fetch_limitContext {
	var p = new(Fetch_limitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_fetch_limit

	return p
}

func (s *Fetch_limitContext) GetParser() antlr.Parser { return s.parser }

func (s *Fetch_limitContext) T_LIMIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LIMIT, 0)
}

func (s *Fetch_limitContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Fetch_limitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fetch_limitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fetch_limitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFetch_limit(s)
	}
}

func (s *Fetch_limitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFetch_limit(s)
	}
}

func (p *HplsqlParser) Fetch_limit() (localctx IFetch_limitContext) {
	localctx = NewFetch_limitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, HplsqlParserRULE_fetch_limit)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2014)
		p.Match(HplsqlParserT_LIMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2015)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICollect_stats_stmtContext is an interface to support dynamic dispatch.
type ICollect_stats_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_COLLECT() antlr.TerminalNode
	T_ON() antlr.TerminalNode
	Table_name() ITable_nameContext
	T_STATISTICS() antlr.TerminalNode
	T_STATS() antlr.TerminalNode
	Collect_stats_clause() ICollect_stats_clauseContext

	// IsCollect_stats_stmtContext differentiates from other interfaces.
	IsCollect_stats_stmtContext()
}

type Collect_stats_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollect_stats_stmtContext() *Collect_stats_stmtContext {
	var p = new(Collect_stats_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_collect_stats_stmt
	return p
}

func InitEmptyCollect_stats_stmtContext(p *Collect_stats_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_collect_stats_stmt
}

func (*Collect_stats_stmtContext) IsCollect_stats_stmtContext() {}

func NewCollect_stats_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collect_stats_stmtContext {
	var p = new(Collect_stats_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_collect_stats_stmt

	return p
}

func (s *Collect_stats_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Collect_stats_stmtContext) T_COLLECT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLLECT, 0)
}

func (s *Collect_stats_stmtContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *Collect_stats_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Collect_stats_stmtContext) T_STATISTICS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STATISTICS, 0)
}

func (s *Collect_stats_stmtContext) T_STATS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STATS, 0)
}

func (s *Collect_stats_stmtContext) Collect_stats_clause() ICollect_stats_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollect_stats_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollect_stats_clauseContext)
}

func (s *Collect_stats_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collect_stats_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collect_stats_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCollect_stats_stmt(s)
	}
}

func (s *Collect_stats_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCollect_stats_stmt(s)
	}
}

func (p *HplsqlParser) Collect_stats_stmt() (localctx ICollect_stats_stmtContext) {
	localctx = NewCollect_stats_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, HplsqlParserRULE_collect_stats_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2017)
		p.Match(HplsqlParserT_COLLECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2018)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_STATS || _la == HplsqlParserT_STATISTICS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2019)
		p.Match(HplsqlParserT_ON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2020)
		p.Table_name()
	}
	p.SetState(2022)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 219, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2021)
			p.Collect_stats_clause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICollect_stats_clauseContext is an interface to support dynamic dispatch.
type ICollect_stats_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_COLUMN() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	AllQident() []IQidentContext
	Qident(i int) IQidentContext
	T_CLOSE_P() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsCollect_stats_clauseContext differentiates from other interfaces.
	IsCollect_stats_clauseContext()
}

type Collect_stats_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollect_stats_clauseContext() *Collect_stats_clauseContext {
	var p = new(Collect_stats_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_collect_stats_clause
	return p
}

func InitEmptyCollect_stats_clauseContext(p *Collect_stats_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_collect_stats_clause
}

func (*Collect_stats_clauseContext) IsCollect_stats_clauseContext() {}

func NewCollect_stats_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collect_stats_clauseContext {
	var p = new(Collect_stats_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_collect_stats_clause

	return p
}

func (s *Collect_stats_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Collect_stats_clauseContext) T_COLUMN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLUMN, 0)
}

func (s *Collect_stats_clauseContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Collect_stats_clauseContext) AllQident() []IQidentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQidentContext); ok {
			len++
		}
	}

	tst := make([]IQidentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQidentContext); ok {
			tst[i] = t.(IQidentContext)
			i++
		}
	}

	return tst
}

func (s *Collect_stats_clauseContext) Qident(i int) IQidentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Collect_stats_clauseContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Collect_stats_clauseContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Collect_stats_clauseContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Collect_stats_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collect_stats_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Collect_stats_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCollect_stats_clause(s)
	}
}

func (s *Collect_stats_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCollect_stats_clause(s)
	}
}

func (p *HplsqlParser) Collect_stats_clause() (localctx ICollect_stats_clauseContext) {
	localctx = NewCollect_stats_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, HplsqlParserRULE_collect_stats_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2024)
		p.Match(HplsqlParserT_COLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2025)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2026)
		p.Qident()
	}
	p.SetState(2031)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(2027)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2028)
			p.Qident()
		}

		p.SetState(2033)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2034)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClose_stmtContext is an interface to support dynamic dispatch.
type IClose_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_CLOSE() antlr.TerminalNode
	L_ID() antlr.TerminalNode

	// IsClose_stmtContext differentiates from other interfaces.
	IsClose_stmtContext()
}

type Close_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClose_stmtContext() *Close_stmtContext {
	var p = new(Close_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_close_stmt
	return p
}

func InitEmptyClose_stmtContext(p *Close_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_close_stmt
}

func (*Close_stmtContext) IsClose_stmtContext() {}

func NewClose_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Close_stmtContext {
	var p = new(Close_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_close_stmt

	return p
}

func (s *Close_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Close_stmtContext) T_CLOSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE, 0)
}

func (s *Close_stmtContext) L_ID() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, 0)
}

func (s *Close_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Close_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Close_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterClose_stmt(s)
	}
}

func (s *Close_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitClose_stmt(s)
	}
}

func (p *HplsqlParser) Close_stmt() (localctx IClose_stmtContext) {
	localctx = NewClose_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, HplsqlParserRULE_close_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2036)
		p.Match(HplsqlParserT_CLOSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2037)
		p.Match(HplsqlParserL_ID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmp_stmtContext is an interface to support dynamic dispatch.
type ICmp_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_CMP() antlr.TerminalNode
	AllCmp_source() []ICmp_sourceContext
	Cmp_source(i int) ICmp_sourceContext
	T_COMMA() antlr.TerminalNode
	T_ROW_COUNT() antlr.TerminalNode
	T_SUM() antlr.TerminalNode

	// IsCmp_stmtContext differentiates from other interfaces.
	IsCmp_stmtContext()
}

type Cmp_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmp_stmtContext() *Cmp_stmtContext {
	var p = new(Cmp_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cmp_stmt
	return p
}

func InitEmptyCmp_stmtContext(p *Cmp_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cmp_stmt
}

func (*Cmp_stmtContext) IsCmp_stmtContext() {}

func NewCmp_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmp_stmtContext {
	var p = new(Cmp_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_cmp_stmt

	return p
}

func (s *Cmp_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmp_stmtContext) T_CMP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CMP, 0)
}

func (s *Cmp_stmtContext) AllCmp_source() []ICmp_sourceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICmp_sourceContext); ok {
			len++
		}
	}

	tst := make([]ICmp_sourceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICmp_sourceContext); ok {
			tst[i] = t.(ICmp_sourceContext)
			i++
		}
	}

	return tst
}

func (s *Cmp_stmtContext) Cmp_source(i int) ICmp_sourceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmp_sourceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmp_sourceContext)
}

func (s *Cmp_stmtContext) T_COMMA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, 0)
}

func (s *Cmp_stmtContext) T_ROW_COUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROW_COUNT, 0)
}

func (s *Cmp_stmtContext) T_SUM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUM, 0)
}

func (s *Cmp_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmp_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmp_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCmp_stmt(s)
	}
}

func (s *Cmp_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCmp_stmt(s)
	}
}

func (p *HplsqlParser) Cmp_stmt() (localctx ICmp_stmtContext) {
	localctx = NewCmp_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, HplsqlParserRULE_cmp_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2039)
		p.Match(HplsqlParserT_CMP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2040)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_ROW_COUNT || _la == HplsqlParserT_SUM) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2041)
		p.Cmp_source()
	}
	{
		p.SetState(2042)
		p.Match(HplsqlParserT_COMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2043)
		p.Cmp_source()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICmp_sourceContext is an interface to support dynamic dispatch.
type ICmp_sourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Table_name() ITable_nameContext
	T_OPEN_P() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	T_CLOSE_P() antlr.TerminalNode
	T_AT() antlr.TerminalNode
	Qident() IQidentContext
	Where_clause() IWhere_clauseContext

	// IsCmp_sourceContext differentiates from other interfaces.
	IsCmp_sourceContext()
}

type Cmp_sourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmp_sourceContext() *Cmp_sourceContext {
	var p = new(Cmp_sourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cmp_source
	return p
}

func InitEmptyCmp_sourceContext(p *Cmp_sourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cmp_source
}

func (*Cmp_sourceContext) IsCmp_sourceContext() {}

func NewCmp_sourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmp_sourceContext {
	var p = new(Cmp_sourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_cmp_source

	return p
}

func (s *Cmp_sourceContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmp_sourceContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Cmp_sourceContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Cmp_sourceContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Cmp_sourceContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Cmp_sourceContext) T_AT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AT, 0)
}

func (s *Cmp_sourceContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Cmp_sourceContext) Where_clause() IWhere_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhere_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhere_clauseContext)
}

func (s *Cmp_sourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmp_sourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cmp_sourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCmp_source(s)
	}
}

func (s *Cmp_sourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCmp_source(s)
	}
}

func (p *HplsqlParser) Cmp_source() (localctx ICmp_sourceContext) {
	localctx = NewCmp_sourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, HplsqlParserRULE_cmp_source)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(2053)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_SUB, HplsqlParserL_ID:
		{
			p.SetState(2045)
			p.Table_name()
		}
		p.SetState(2047)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 221, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2046)
				p.Where_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case HplsqlParserT_OPEN_P:
		{
			p.SetState(2049)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2050)
			p.Select_stmt()
		}
		{
			p.SetState(2051)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(2057)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 223, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2055)
			p.Match(HplsqlParserT_AT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2056)
			p.Qident()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICopy_from_local_stmtContext is an interface to support dynamic dispatch.
type ICopy_from_local_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_COPY() antlr.TerminalNode
	T_FROM() antlr.TerminalNode
	T_LOCAL() antlr.TerminalNode
	AllCopy_source() []ICopy_sourceContext
	Copy_source(i int) ICopy_sourceContext
	T_TO() antlr.TerminalNode
	Copy_target() ICopy_targetContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	AllCopy_file_option() []ICopy_file_optionContext
	Copy_file_option(i int) ICopy_file_optionContext

	// IsCopy_from_local_stmtContext differentiates from other interfaces.
	IsCopy_from_local_stmtContext()
}

type Copy_from_local_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCopy_from_local_stmtContext() *Copy_from_local_stmtContext {
	var p = new(Copy_from_local_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_from_local_stmt
	return p
}

func InitEmptyCopy_from_local_stmtContext(p *Copy_from_local_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_from_local_stmt
}

func (*Copy_from_local_stmtContext) IsCopy_from_local_stmtContext() {}

func NewCopy_from_local_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Copy_from_local_stmtContext {
	var p = new(Copy_from_local_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_copy_from_local_stmt

	return p
}

func (s *Copy_from_local_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Copy_from_local_stmtContext) T_COPY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COPY, 0)
}

func (s *Copy_from_local_stmtContext) T_FROM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FROM, 0)
}

func (s *Copy_from_local_stmtContext) T_LOCAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCAL, 0)
}

func (s *Copy_from_local_stmtContext) AllCopy_source() []ICopy_sourceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICopy_sourceContext); ok {
			len++
		}
	}

	tst := make([]ICopy_sourceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICopy_sourceContext); ok {
			tst[i] = t.(ICopy_sourceContext)
			i++
		}
	}

	return tst
}

func (s *Copy_from_local_stmtContext) Copy_source(i int) ICopy_sourceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopy_sourceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopy_sourceContext)
}

func (s *Copy_from_local_stmtContext) T_TO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TO, 0)
}

func (s *Copy_from_local_stmtContext) Copy_target() ICopy_targetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopy_targetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopy_targetContext)
}

func (s *Copy_from_local_stmtContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Copy_from_local_stmtContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Copy_from_local_stmtContext) AllCopy_file_option() []ICopy_file_optionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICopy_file_optionContext); ok {
			len++
		}
	}

	tst := make([]ICopy_file_optionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICopy_file_optionContext); ok {
			tst[i] = t.(ICopy_file_optionContext)
			i++
		}
	}

	return tst
}

func (s *Copy_from_local_stmtContext) Copy_file_option(i int) ICopy_file_optionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopy_file_optionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopy_file_optionContext)
}

func (s *Copy_from_local_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Copy_from_local_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Copy_from_local_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCopy_from_local_stmt(s)
	}
}

func (s *Copy_from_local_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCopy_from_local_stmt(s)
	}
}

func (p *HplsqlParser) Copy_from_local_stmt() (localctx ICopy_from_local_stmtContext) {
	localctx = NewCopy_from_local_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, HplsqlParserRULE_copy_from_local_stmt)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2059)
		p.Match(HplsqlParserT_COPY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2060)
		p.Match(HplsqlParserT_FROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2061)
		p.Match(HplsqlParserT_LOCAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2062)
		p.Copy_source()
	}
	p.SetState(2067)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(2063)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2064)
			p.Copy_source()
		}

		p.SetState(2069)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2070)
		p.Match(HplsqlParserT_TO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2071)
		p.Copy_target()
	}
	p.SetState(2075)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 225, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2072)
				p.Copy_file_option()
			}

		}
		p.SetState(2077)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 225, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICopy_stmtContext is an interface to support dynamic dispatch.
type ICopy_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_COPY() antlr.TerminalNode
	T_TO() antlr.TerminalNode
	Copy_target() ICopy_targetContext
	Table_name() ITable_nameContext
	T_OPEN_P() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	T_CLOSE_P() antlr.TerminalNode
	T_HDFS() antlr.TerminalNode
	AllCopy_option() []ICopy_optionContext
	Copy_option(i int) ICopy_optionContext

	// IsCopy_stmtContext differentiates from other interfaces.
	IsCopy_stmtContext()
}

type Copy_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCopy_stmtContext() *Copy_stmtContext {
	var p = new(Copy_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_stmt
	return p
}

func InitEmptyCopy_stmtContext(p *Copy_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_stmt
}

func (*Copy_stmtContext) IsCopy_stmtContext() {}

func NewCopy_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Copy_stmtContext {
	var p = new(Copy_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_copy_stmt

	return p
}

func (s *Copy_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Copy_stmtContext) T_COPY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COPY, 0)
}

func (s *Copy_stmtContext) T_TO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TO, 0)
}

func (s *Copy_stmtContext) Copy_target() ICopy_targetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopy_targetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopy_targetContext)
}

func (s *Copy_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Copy_stmtContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Copy_stmtContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Copy_stmtContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Copy_stmtContext) T_HDFS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HDFS, 0)
}

func (s *Copy_stmtContext) AllCopy_option() []ICopy_optionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICopy_optionContext); ok {
			len++
		}
	}

	tst := make([]ICopy_optionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICopy_optionContext); ok {
			tst[i] = t.(ICopy_optionContext)
			i++
		}
	}

	return tst
}

func (s *Copy_stmtContext) Copy_option(i int) ICopy_optionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopy_optionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopy_optionContext)
}

func (s *Copy_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Copy_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Copy_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCopy_stmt(s)
	}
}

func (s *Copy_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCopy_stmt(s)
	}
}

func (p *HplsqlParser) Copy_stmt() (localctx ICopy_stmtContext) {
	localctx = NewCopy_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, HplsqlParserRULE_copy_stmt)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2078)
		p.Match(HplsqlParserT_COPY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2084)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_SUB, HplsqlParserL_ID:
		{
			p.SetState(2079)
			p.Table_name()
		}

	case HplsqlParserT_OPEN_P:
		{
			p.SetState(2080)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2081)
			p.Select_stmt()
		}
		{
			p.SetState(2082)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(2086)
		p.Match(HplsqlParserT_TO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2088)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 227, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2087)
			p.Match(HplsqlParserT_HDFS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2090)
		p.Copy_target()
	}
	p.SetState(2094)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 228, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2091)
				p.Copy_option()
			}

		}
		p.SetState(2096)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 228, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICopy_sourceContext is an interface to support dynamic dispatch.
type ICopy_sourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	File_name() IFile_nameContext
	Expr() IExprContext

	// IsCopy_sourceContext differentiates from other interfaces.
	IsCopy_sourceContext()
}

type Copy_sourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCopy_sourceContext() *Copy_sourceContext {
	var p = new(Copy_sourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_source
	return p
}

func InitEmptyCopy_sourceContext(p *Copy_sourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_source
}

func (*Copy_sourceContext) IsCopy_sourceContext() {}

func NewCopy_sourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Copy_sourceContext {
	var p = new(Copy_sourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_copy_source

	return p
}

func (s *Copy_sourceContext) GetParser() antlr.Parser { return s.parser }

func (s *Copy_sourceContext) File_name() IFile_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFile_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFile_nameContext)
}

func (s *Copy_sourceContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Copy_sourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Copy_sourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Copy_sourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCopy_source(s)
	}
}

func (s *Copy_sourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCopy_source(s)
	}
}

func (p *HplsqlParser) Copy_source() (localctx ICopy_sourceContext) {
	localctx = NewCopy_sourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, HplsqlParserRULE_copy_source)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(2099)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 229, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2097)
			p.File_name()
		}

	case 2:
		{
			p.SetState(2098)
			p.expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICopy_targetContext is an interface to support dynamic dispatch.
type ICopy_targetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	File_name() IFile_nameContext
	Expr() IExprContext

	// IsCopy_targetContext differentiates from other interfaces.
	IsCopy_targetContext()
}

type Copy_targetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCopy_targetContext() *Copy_targetContext {
	var p = new(Copy_targetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_target
	return p
}

func InitEmptyCopy_targetContext(p *Copy_targetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_target
}

func (*Copy_targetContext) IsCopy_targetContext() {}

func NewCopy_targetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Copy_targetContext {
	var p = new(Copy_targetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_copy_target

	return p
}

func (s *Copy_targetContext) GetParser() antlr.Parser { return s.parser }

func (s *Copy_targetContext) File_name() IFile_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFile_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFile_nameContext)
}

func (s *Copy_targetContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Copy_targetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Copy_targetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Copy_targetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCopy_target(s)
	}
}

func (s *Copy_targetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCopy_target(s)
	}
}

func (p *HplsqlParser) Copy_target() (localctx ICopy_targetContext) {
	localctx = NewCopy_targetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, HplsqlParserRULE_copy_target)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(2103)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 230, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2101)
			p.File_name()
		}

	case 2:
		{
			p.SetState(2102)
			p.expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICopy_optionContext is an interface to support dynamic dispatch.
type ICopy_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_AT() antlr.TerminalNode
	Qident() IQidentContext
	T_BATCHSIZE() antlr.TerminalNode
	Expr() IExprContext
	T_DELIMITER() antlr.TerminalNode
	T_SQLINSERT() antlr.TerminalNode

	// IsCopy_optionContext differentiates from other interfaces.
	IsCopy_optionContext()
}

type Copy_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCopy_optionContext() *Copy_optionContext {
	var p = new(Copy_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_option
	return p
}

func InitEmptyCopy_optionContext(p *Copy_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_option
}

func (*Copy_optionContext) IsCopy_optionContext() {}

func NewCopy_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Copy_optionContext {
	var p = new(Copy_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_copy_option

	return p
}

func (s *Copy_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Copy_optionContext) T_AT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AT, 0)
}

func (s *Copy_optionContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Copy_optionContext) T_BATCHSIZE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BATCHSIZE, 0)
}

func (s *Copy_optionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Copy_optionContext) T_DELIMITER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DELIMITER, 0)
}

func (s *Copy_optionContext) T_SQLINSERT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SQLINSERT, 0)
}

func (s *Copy_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Copy_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Copy_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCopy_option(s)
	}
}

func (s *Copy_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCopy_option(s)
	}
}

func (p *HplsqlParser) Copy_option() (localctx ICopy_optionContext) {
	localctx = NewCopy_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, HplsqlParserRULE_copy_option)
	p.SetState(2113)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_AT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2105)
			p.Match(HplsqlParserT_AT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2106)
			p.Qident()
		}

	case HplsqlParserT_BATCHSIZE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2107)
			p.Match(HplsqlParserT_BATCHSIZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2108)
			p.expr(0)
		}

	case HplsqlParserT_DELIMITER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2109)
			p.Match(HplsqlParserT_DELIMITER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2110)
			p.expr(0)
		}

	case HplsqlParserT_SQLINSERT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2111)
			p.Match(HplsqlParserT_SQLINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2112)
			p.Qident()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICopy_file_optionContext is an interface to support dynamic dispatch.
type ICopy_file_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_DELETE() antlr.TerminalNode
	T_IGNORE() antlr.TerminalNode
	T_OVERWRITE() antlr.TerminalNode

	// IsCopy_file_optionContext differentiates from other interfaces.
	IsCopy_file_optionContext()
}

type Copy_file_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCopy_file_optionContext() *Copy_file_optionContext {
	var p = new(Copy_file_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_file_option
	return p
}

func InitEmptyCopy_file_optionContext(p *Copy_file_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_file_option
}

func (*Copy_file_optionContext) IsCopy_file_optionContext() {}

func NewCopy_file_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Copy_file_optionContext {
	var p = new(Copy_file_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_copy_file_option

	return p
}

func (s *Copy_file_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Copy_file_optionContext) T_DELETE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DELETE, 0)
}

func (s *Copy_file_optionContext) T_IGNORE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IGNORE, 0)
}

func (s *Copy_file_optionContext) T_OVERWRITE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OVERWRITE, 0)
}

func (s *Copy_file_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Copy_file_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Copy_file_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCopy_file_option(s)
	}
}

func (s *Copy_file_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCopy_file_option(s)
	}
}

func (p *HplsqlParser) Copy_file_option() (localctx ICopy_file_optionContext) {
	localctx = NewCopy_file_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, HplsqlParserRULE_copy_file_option)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2115)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_DELETE || _la == HplsqlParserT_IGNORE || _la == HplsqlParserT_OVERWRITE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommit_stmtContext is an interface to support dynamic dispatch.
type ICommit_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_COMMIT() antlr.TerminalNode
	T_WORK() antlr.TerminalNode

	// IsCommit_stmtContext differentiates from other interfaces.
	IsCommit_stmtContext()
}

type Commit_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommit_stmtContext() *Commit_stmtContext {
	var p = new(Commit_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_commit_stmt
	return p
}

func InitEmptyCommit_stmtContext(p *Commit_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_commit_stmt
}

func (*Commit_stmtContext) IsCommit_stmtContext() {}

func NewCommit_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Commit_stmtContext {
	var p = new(Commit_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_commit_stmt

	return p
}

func (s *Commit_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Commit_stmtContext) T_COMMIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMIT, 0)
}

func (s *Commit_stmtContext) T_WORK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WORK, 0)
}

func (s *Commit_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Commit_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Commit_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCommit_stmt(s)
	}
}

func (s *Commit_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCommit_stmt(s)
	}
}

func (p *HplsqlParser) Commit_stmt() (localctx ICommit_stmtContext) {
	localctx = NewCommit_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, HplsqlParserRULE_commit_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2117)
		p.Match(HplsqlParserT_COMMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2119)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 232, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2118)
			p.Match(HplsqlParserT_WORK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_index_stmtContext is an interface to support dynamic dispatch.
type ICreate_index_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_CREATE() antlr.TerminalNode
	T_INDEX() antlr.TerminalNode
	Qident() IQidentContext
	T_ON() antlr.TerminalNode
	Table_name() ITable_nameContext
	T_OPEN_P() antlr.TerminalNode
	AllCreate_index_col() []ICreate_index_colContext
	Create_index_col(i int) ICreate_index_colContext
	T_CLOSE_P() antlr.TerminalNode
	T_UNIQUE() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsCreate_index_stmtContext differentiates from other interfaces.
	IsCreate_index_stmtContext()
}

type Create_index_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_index_stmtContext() *Create_index_stmtContext {
	var p = new(Create_index_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_index_stmt
	return p
}

func InitEmptyCreate_index_stmtContext(p *Create_index_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_index_stmt
}

func (*Create_index_stmtContext) IsCreate_index_stmtContext() {}

func NewCreate_index_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_index_stmtContext {
	var p = new(Create_index_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_index_stmt

	return p
}

func (s *Create_index_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_index_stmtContext) T_CREATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATE, 0)
}

func (s *Create_index_stmtContext) T_INDEX() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INDEX, 0)
}

func (s *Create_index_stmtContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_index_stmtContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *Create_index_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Create_index_stmtContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Create_index_stmtContext) AllCreate_index_col() []ICreate_index_colContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_index_colContext); ok {
			len++
		}
	}

	tst := make([]ICreate_index_colContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_index_colContext); ok {
			tst[i] = t.(ICreate_index_colContext)
			i++
		}
	}

	return tst
}

func (s *Create_index_stmtContext) Create_index_col(i int) ICreate_index_colContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_index_colContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_index_colContext)
}

func (s *Create_index_stmtContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Create_index_stmtContext) T_UNIQUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UNIQUE, 0)
}

func (s *Create_index_stmtContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Create_index_stmtContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Create_index_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_index_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_index_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_index_stmt(s)
	}
}

func (s *Create_index_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_index_stmt(s)
	}
}

func (p *HplsqlParser) Create_index_stmt() (localctx ICreate_index_stmtContext) {
	localctx = NewCreate_index_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, HplsqlParserRULE_create_index_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2121)
		p.Match(HplsqlParserT_CREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2123)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_UNIQUE {
		{
			p.SetState(2122)
			p.Match(HplsqlParserT_UNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2125)
		p.Match(HplsqlParserT_INDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2126)
		p.Qident()
	}
	{
		p.SetState(2127)
		p.Match(HplsqlParserT_ON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2128)
		p.Table_name()
	}
	{
		p.SetState(2129)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2130)
		p.Create_index_col()
	}
	p.SetState(2135)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(2131)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2132)
			p.Create_index_col()
		}

		p.SetState(2137)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2138)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreate_index_colContext is an interface to support dynamic dispatch.
type ICreate_index_colContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Qident() IQidentContext
	T_ASC() antlr.TerminalNode
	T_DESC() antlr.TerminalNode

	// IsCreate_index_colContext differentiates from other interfaces.
	IsCreate_index_colContext()
}

type Create_index_colContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_index_colContext() *Create_index_colContext {
	var p = new(Create_index_colContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_index_col
	return p
}

func InitEmptyCreate_index_colContext(p *Create_index_colContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_index_col
}

func (*Create_index_colContext) IsCreate_index_colContext() {}

func NewCreate_index_colContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_index_colContext {
	var p = new(Create_index_colContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_index_col

	return p
}

func (s *Create_index_colContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_index_colContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_index_colContext) T_ASC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ASC, 0)
}

func (s *Create_index_colContext) T_DESC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DESC, 0)
}

func (s *Create_index_colContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_index_colContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_index_colContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_index_col(s)
	}
}

func (s *Create_index_colContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_index_col(s)
	}
}

func (p *HplsqlParser) Create_index_col() (localctx ICreate_index_colContext) {
	localctx = NewCreate_index_colContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, HplsqlParserRULE_create_index_col)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2140)
		p.Qident()
	}
	p.SetState(2142)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC {
		{
			p.SetState(2141)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndex_storage_clauseContext is an interface to support dynamic dispatch.
type IIndex_storage_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Index_mssql_storage_clause() IIndex_mssql_storage_clauseContext

	// IsIndex_storage_clauseContext differentiates from other interfaces.
	IsIndex_storage_clauseContext()
}

type Index_storage_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_storage_clauseContext() *Index_storage_clauseContext {
	var p = new(Index_storage_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_index_storage_clause
	return p
}

func InitEmptyIndex_storage_clauseContext(p *Index_storage_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_index_storage_clause
}

func (*Index_storage_clauseContext) IsIndex_storage_clauseContext() {}

func NewIndex_storage_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_storage_clauseContext {
	var p = new(Index_storage_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_index_storage_clause

	return p
}

func (s *Index_storage_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_storage_clauseContext) Index_mssql_storage_clause() IIndex_mssql_storage_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_mssql_storage_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_mssql_storage_clauseContext)
}

func (s *Index_storage_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_storage_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Index_storage_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterIndex_storage_clause(s)
	}
}

func (s *Index_storage_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitIndex_storage_clause(s)
	}
}

func (p *HplsqlParser) Index_storage_clause() (localctx IIndex_storage_clauseContext) {
	localctx = NewIndex_storage_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, HplsqlParserRULE_index_storage_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2144)
		p.Index_mssql_storage_clause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndex_mssql_storage_clauseContext is an interface to support dynamic dispatch.
type IIndex_mssql_storage_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_WITH() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	AllQident() []IQidentContext
	Qident(i int) IQidentContext
	AllT_EQUAL() []antlr.TerminalNode
	T_EQUAL(i int) antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	AllCreate_table_options_mssql_item() []ICreate_table_options_mssql_itemContext
	Create_table_options_mssql_item(i int) ICreate_table_options_mssql_itemContext

	// IsIndex_mssql_storage_clauseContext differentiates from other interfaces.
	IsIndex_mssql_storage_clauseContext()
}

type Index_mssql_storage_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_mssql_storage_clauseContext() *Index_mssql_storage_clauseContext {
	var p = new(Index_mssql_storage_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_index_mssql_storage_clause
	return p
}

func InitEmptyIndex_mssql_storage_clauseContext(p *Index_mssql_storage_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_index_mssql_storage_clause
}

func (*Index_mssql_storage_clauseContext) IsIndex_mssql_storage_clauseContext() {}

func NewIndex_mssql_storage_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_mssql_storage_clauseContext {
	var p = new(Index_mssql_storage_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_index_mssql_storage_clause

	return p
}

func (s *Index_mssql_storage_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_mssql_storage_clauseContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITH, 0)
}

func (s *Index_mssql_storage_clauseContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Index_mssql_storage_clauseContext) AllQident() []IQidentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQidentContext); ok {
			len++
		}
	}

	tst := make([]IQidentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQidentContext); ok {
			tst[i] = t.(IQidentContext)
			i++
		}
	}

	return tst
}

func (s *Index_mssql_storage_clauseContext) Qident(i int) IQidentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Index_mssql_storage_clauseContext) AllT_EQUAL() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_EQUAL)
}

func (s *Index_mssql_storage_clauseContext) T_EQUAL(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, i)
}

func (s *Index_mssql_storage_clauseContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Index_mssql_storage_clauseContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Index_mssql_storage_clauseContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Index_mssql_storage_clauseContext) AllCreate_table_options_mssql_item() []ICreate_table_options_mssql_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_options_mssql_itemContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_options_mssql_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_options_mssql_itemContext); ok {
			tst[i] = t.(ICreate_table_options_mssql_itemContext)
			i++
		}
	}

	return tst
}

func (s *Index_mssql_storage_clauseContext) Create_table_options_mssql_item(i int) ICreate_table_options_mssql_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_options_mssql_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_options_mssql_itemContext)
}

func (s *Index_mssql_storage_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_mssql_storage_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Index_mssql_storage_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterIndex_mssql_storage_clause(s)
	}
}

func (s *Index_mssql_storage_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitIndex_mssql_storage_clause(s)
	}
}

func (p *HplsqlParser) Index_mssql_storage_clause() (localctx IIndex_mssql_storage_clauseContext) {
	localctx = NewIndex_mssql_storage_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, HplsqlParserRULE_index_mssql_storage_clause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2146)
		p.Match(HplsqlParserT_WITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2147)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2148)
		p.Qident()
	}
	{
		p.SetState(2149)
		p.Match(HplsqlParserT_EQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2150)
		p.Qident()
	}
	p.SetState(2158)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(2151)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2152)
			p.Qident()
		}
		{
			p.SetState(2153)
			p.Match(HplsqlParserT_EQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2154)
			p.Qident()
		}

		p.SetState(2160)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2161)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2165)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 237, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2162)
				p.Create_table_options_mssql_item()
			}

		}
		p.SetState(2167)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 237, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrint_stmtContext is an interface to support dynamic dispatch.
type IPrint_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_PRINT() antlr.TerminalNode
	Expr() IExprContext
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode

	// IsPrint_stmtContext differentiates from other interfaces.
	IsPrint_stmtContext()
}

type Print_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrint_stmtContext() *Print_stmtContext {
	var p = new(Print_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_print_stmt
	return p
}

func InitEmptyPrint_stmtContext(p *Print_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_print_stmt
}

func (*Print_stmtContext) IsPrint_stmtContext() {}

func NewPrint_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Print_stmtContext {
	var p = new(Print_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_print_stmt

	return p
}

func (s *Print_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Print_stmtContext) T_PRINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRINT, 0)
}

func (s *Print_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Print_stmtContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Print_stmtContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Print_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Print_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Print_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterPrint_stmt(s)
	}
}

func (s *Print_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitPrint_stmt(s)
	}
}

func (p *HplsqlParser) Print_stmt() (localctx IPrint_stmtContext) {
	localctx = NewPrint_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, HplsqlParserRULE_print_stmt)
	p.SetState(2175)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 238, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2168)
			p.Match(HplsqlParserT_PRINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2169)
			p.expr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2170)
			p.Match(HplsqlParserT_PRINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2171)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2172)
			p.expr(0)
		}
		{
			p.SetState(2173)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuit_stmtContext is an interface to support dynamic dispatch.
type IQuit_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_QUIT() antlr.TerminalNode
	T_DOT() antlr.TerminalNode
	Expr() IExprContext

	// IsQuit_stmtContext differentiates from other interfaces.
	IsQuit_stmtContext()
}

type Quit_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuit_stmtContext() *Quit_stmtContext {
	var p = new(Quit_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_quit_stmt
	return p
}

func InitEmptyQuit_stmtContext(p *Quit_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_quit_stmt
}

func (*Quit_stmtContext) IsQuit_stmtContext() {}

func NewQuit_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Quit_stmtContext {
	var p = new(Quit_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_quit_stmt

	return p
}

func (s *Quit_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Quit_stmtContext) T_QUIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_QUIT, 0)
}

func (s *Quit_stmtContext) T_DOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DOT, 0)
}

func (s *Quit_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Quit_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Quit_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Quit_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterQuit_stmt(s)
	}
}

func (s *Quit_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitQuit_stmt(s)
	}
}

func (p *HplsqlParser) Quit_stmt() (localctx IQuit_stmtContext) {
	localctx = NewQuit_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, HplsqlParserRULE_quit_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2178)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_DOT {
		{
			p.SetState(2177)
			p.Match(HplsqlParserT_DOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2180)
		p.Match(HplsqlParserT_QUIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2182)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 240, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2181)
			p.expr(0)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRaise_stmtContext is an interface to support dynamic dispatch.
type IRaise_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_RAISE() antlr.TerminalNode

	// IsRaise_stmtContext differentiates from other interfaces.
	IsRaise_stmtContext()
}

type Raise_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRaise_stmtContext() *Raise_stmtContext {
	var p = new(Raise_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_raise_stmt
	return p
}

func InitEmptyRaise_stmtContext(p *Raise_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_raise_stmt
}

func (*Raise_stmtContext) IsRaise_stmtContext() {}

func NewRaise_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Raise_stmtContext {
	var p = new(Raise_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_raise_stmt

	return p
}

func (s *Raise_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Raise_stmtContext) T_RAISE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RAISE, 0)
}

func (s *Raise_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Raise_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Raise_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterRaise_stmt(s)
	}
}

func (s *Raise_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitRaise_stmt(s)
	}
}

func (p *HplsqlParser) Raise_stmt() (localctx IRaise_stmtContext) {
	localctx = NewRaise_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, HplsqlParserRULE_raise_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2184)
		p.Match(HplsqlParserT_RAISE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResignal_stmtContext is an interface to support dynamic dispatch.
type IResignal_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_RESIGNAL() antlr.TerminalNode
	T_SQLSTATE() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_VALUE() antlr.TerminalNode
	T_SET() antlr.TerminalNode
	T_MESSAGE_TEXT() antlr.TerminalNode
	T_EQUAL() antlr.TerminalNode

	// IsResignal_stmtContext differentiates from other interfaces.
	IsResignal_stmtContext()
}

type Resignal_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResignal_stmtContext() *Resignal_stmtContext {
	var p = new(Resignal_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_resignal_stmt
	return p
}

func InitEmptyResignal_stmtContext(p *Resignal_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_resignal_stmt
}

func (*Resignal_stmtContext) IsResignal_stmtContext() {}

func NewResignal_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Resignal_stmtContext {
	var p = new(Resignal_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_resignal_stmt

	return p
}

func (s *Resignal_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Resignal_stmtContext) T_RESIGNAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESIGNAL, 0)
}

func (s *Resignal_stmtContext) T_SQLSTATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SQLSTATE, 0)
}

func (s *Resignal_stmtContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Resignal_stmtContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Resignal_stmtContext) T_VALUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VALUE, 0)
}

func (s *Resignal_stmtContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Resignal_stmtContext) T_MESSAGE_TEXT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MESSAGE_TEXT, 0)
}

func (s *Resignal_stmtContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Resignal_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Resignal_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Resignal_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterResignal_stmt(s)
	}
}

func (s *Resignal_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitResignal_stmt(s)
	}
}

func (p *HplsqlParser) Resignal_stmt() (localctx IResignal_stmtContext) {
	localctx = NewResignal_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, HplsqlParserRULE_resignal_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2186)
		p.Match(HplsqlParserT_RESIGNAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2198)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 243, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2187)
			p.Match(HplsqlParserT_SQLSTATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2189)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 241, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2188)
				p.Match(HplsqlParserT_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2191)
			p.expr(0)
		}
		p.SetState(2196)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 242, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2192)
				p.Match(HplsqlParserT_SET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2193)
				p.Match(HplsqlParserT_MESSAGE_TEXT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2194)
				p.Match(HplsqlParserT_EQUAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2195)
				p.expr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturn_stmtContext is an interface to support dynamic dispatch.
type IReturn_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_RETURN() antlr.TerminalNode
	Expr() IExprContext

	// IsReturn_stmtContext differentiates from other interfaces.
	IsReturn_stmtContext()
}

type Return_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturn_stmtContext() *Return_stmtContext {
	var p = new(Return_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_return_stmt
	return p
}

func InitEmptyReturn_stmtContext(p *Return_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_return_stmt
}

func (*Return_stmtContext) IsReturn_stmtContext() {}

func NewReturn_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Return_stmtContext {
	var p = new(Return_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_return_stmt

	return p
}

func (s *Return_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Return_stmtContext) T_RETURN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RETURN, 0)
}

func (s *Return_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Return_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Return_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Return_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterReturn_stmt(s)
	}
}

func (s *Return_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitReturn_stmt(s)
	}
}

func (p *HplsqlParser) Return_stmt() (localctx IReturn_stmtContext) {
	localctx = NewReturn_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, HplsqlParserRULE_return_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2200)
		p.Match(HplsqlParserT_RETURN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2202)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 244, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2201)
			p.expr(0)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollback_stmtContext is an interface to support dynamic dispatch.
type IRollback_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ROLLBACK() antlr.TerminalNode
	T_WORK() antlr.TerminalNode

	// IsRollback_stmtContext differentiates from other interfaces.
	IsRollback_stmtContext()
}

type Rollback_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRollback_stmtContext() *Rollback_stmtContext {
	var p = new(Rollback_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_rollback_stmt
	return p
}

func InitEmptyRollback_stmtContext(p *Rollback_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_rollback_stmt
}

func (*Rollback_stmtContext) IsRollback_stmtContext() {}

func NewRollback_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rollback_stmtContext {
	var p = new(Rollback_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_rollback_stmt

	return p
}

func (s *Rollback_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Rollback_stmtContext) T_ROLLBACK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROLLBACK, 0)
}

func (s *Rollback_stmtContext) T_WORK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WORK, 0)
}

func (s *Rollback_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rollback_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Rollback_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterRollback_stmt(s)
	}
}

func (s *Rollback_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitRollback_stmt(s)
	}
}

func (p *HplsqlParser) Rollback_stmt() (localctx IRollback_stmtContext) {
	localctx = NewRollback_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, HplsqlParserRULE_rollback_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2204)
		p.Match(HplsqlParserT_ROLLBACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2206)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 245, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2205)
			p.Match(HplsqlParserT_WORK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISet_session_optionContext is an interface to support dynamic dispatch.
type ISet_session_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Set_current_schema_option() ISet_current_schema_optionContext
	Set_mssql_session_option() ISet_mssql_session_optionContext
	Set_teradata_session_option() ISet_teradata_session_optionContext

	// IsSet_session_optionContext differentiates from other interfaces.
	IsSet_session_optionContext()
}

type Set_session_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_session_optionContext() *Set_session_optionContext {
	var p = new(Set_session_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_set_session_option
	return p
}

func InitEmptySet_session_optionContext(p *Set_session_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_set_session_option
}

func (*Set_session_optionContext) IsSet_session_optionContext() {}

func NewSet_session_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_session_optionContext {
	var p = new(Set_session_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_set_session_option

	return p
}

func (s *Set_session_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_session_optionContext) Set_current_schema_option() ISet_current_schema_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_current_schema_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_current_schema_optionContext)
}

func (s *Set_session_optionContext) Set_mssql_session_option() ISet_mssql_session_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_mssql_session_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_mssql_session_optionContext)
}

func (s *Set_session_optionContext) Set_teradata_session_option() ISet_teradata_session_optionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_teradata_session_optionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_teradata_session_optionContext)
}

func (s *Set_session_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_session_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_session_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSet_session_option(s)
	}
}

func (s *Set_session_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSet_session_option(s)
	}
}

func (p *HplsqlParser) Set_session_option() (localctx ISet_session_optionContext) {
	localctx = NewSet_session_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, HplsqlParserRULE_set_session_option)
	p.SetState(2211)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_SCHEMA:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2208)
			p.Set_current_schema_option()
		}

	case HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_NOCOUNT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_XACT_ABORT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2209)
			p.Set_mssql_session_option()
		}

	case HplsqlParserT_QUERY_BAND:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2210)
			p.Set_teradata_session_option()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISet_current_schema_optionContext is an interface to support dynamic dispatch.
type ISet_current_schema_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	T_CURRENT_SCHEMA() antlr.TerminalNode
	T_EQUAL() antlr.TerminalNode
	T_SCHEMA() antlr.TerminalNode
	T_CURRENT() antlr.TerminalNode

	// IsSet_current_schema_optionContext differentiates from other interfaces.
	IsSet_current_schema_optionContext()
}

type Set_current_schema_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_current_schema_optionContext() *Set_current_schema_optionContext {
	var p = new(Set_current_schema_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_set_current_schema_option
	return p
}

func InitEmptySet_current_schema_optionContext(p *Set_current_schema_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_set_current_schema_option
}

func (*Set_current_schema_optionContext) IsSet_current_schema_optionContext() {}

func NewSet_current_schema_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_current_schema_optionContext {
	var p = new(Set_current_schema_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_set_current_schema_option

	return p
}

func (s *Set_current_schema_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_current_schema_optionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Set_current_schema_optionContext) T_CURRENT_SCHEMA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT_SCHEMA, 0)
}

func (s *Set_current_schema_optionContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Set_current_schema_optionContext) T_SCHEMA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SCHEMA, 0)
}

func (s *Set_current_schema_optionContext) T_CURRENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT, 0)
}

func (s *Set_current_schema_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_current_schema_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_current_schema_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSet_current_schema_option(s)
	}
}

func (s *Set_current_schema_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSet_current_schema_option(s)
	}
}

func (p *HplsqlParser) Set_current_schema_option() (localctx ISet_current_schema_optionContext) {
	localctx = NewSet_current_schema_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, HplsqlParserRULE_set_current_schema_option)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2218)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_CURRENT, HplsqlParserT_SCHEMA:
		p.SetState(2214)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_CURRENT {
			{
				p.SetState(2213)
				p.Match(HplsqlParserT_CURRENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2216)
			p.Match(HplsqlParserT_SCHEMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_CURRENT_SCHEMA:
		{
			p.SetState(2217)
			p.Match(HplsqlParserT_CURRENT_SCHEMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(2221)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_EQUAL {
		{
			p.SetState(2220)
			p.Match(HplsqlParserT_EQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2223)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISet_mssql_session_optionContext is an interface to support dynamic dispatch.
type ISet_mssql_session_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ANSI_NULLS() antlr.TerminalNode
	T_ANSI_PADDING() antlr.TerminalNode
	T_NOCOUNT() antlr.TerminalNode
	T_QUOTED_IDENTIFIER() antlr.TerminalNode
	T_XACT_ABORT() antlr.TerminalNode
	T_ON() antlr.TerminalNode
	T_OFF() antlr.TerminalNode

	// IsSet_mssql_session_optionContext differentiates from other interfaces.
	IsSet_mssql_session_optionContext()
}

type Set_mssql_session_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_mssql_session_optionContext() *Set_mssql_session_optionContext {
	var p = new(Set_mssql_session_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_set_mssql_session_option
	return p
}

func InitEmptySet_mssql_session_optionContext(p *Set_mssql_session_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_set_mssql_session_option
}

func (*Set_mssql_session_optionContext) IsSet_mssql_session_optionContext() {}

func NewSet_mssql_session_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_mssql_session_optionContext {
	var p = new(Set_mssql_session_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_set_mssql_session_option

	return p
}

func (s *Set_mssql_session_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_mssql_session_optionContext) T_ANSI_NULLS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ANSI_NULLS, 0)
}

func (s *Set_mssql_session_optionContext) T_ANSI_PADDING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ANSI_PADDING, 0)
}

func (s *Set_mssql_session_optionContext) T_NOCOUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOCOUNT, 0)
}

func (s *Set_mssql_session_optionContext) T_QUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_QUOTED_IDENTIFIER, 0)
}

func (s *Set_mssql_session_optionContext) T_XACT_ABORT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_XACT_ABORT, 0)
}

func (s *Set_mssql_session_optionContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *Set_mssql_session_optionContext) T_OFF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OFF, 0)
}

func (s *Set_mssql_session_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_mssql_session_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_mssql_session_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSet_mssql_session_option(s)
	}
}

func (s *Set_mssql_session_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSet_mssql_session_option(s)
	}
}

func (p *HplsqlParser) Set_mssql_session_option() (localctx ISet_mssql_session_optionContext) {
	localctx = NewSet_mssql_session_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, HplsqlParserRULE_set_mssql_session_option)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2225)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_ANSI_NULLS || _la == HplsqlParserT_ANSI_PADDING || _la == HplsqlParserT_NOCOUNT || _la == HplsqlParserT_QUOTED_IDENTIFIER || _la == HplsqlParserT_XACT_ABORT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2226)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_OFF || _la == HplsqlParserT_ON) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISet_teradata_session_optionContext is an interface to support dynamic dispatch.
type ISet_teradata_session_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_QUERY_BAND() antlr.TerminalNode
	T_EQUAL() antlr.TerminalNode
	T_FOR() antlr.TerminalNode
	T_TRANSACTION() antlr.TerminalNode
	T_SESSION() antlr.TerminalNode
	Expr() IExprContext
	T_NONE() antlr.TerminalNode
	T_UPDATE() antlr.TerminalNode

	// IsSet_teradata_session_optionContext differentiates from other interfaces.
	IsSet_teradata_session_optionContext()
}

type Set_teradata_session_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_teradata_session_optionContext() *Set_teradata_session_optionContext {
	var p = new(Set_teradata_session_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_set_teradata_session_option
	return p
}

func InitEmptySet_teradata_session_optionContext(p *Set_teradata_session_optionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_set_teradata_session_option
}

func (*Set_teradata_session_optionContext) IsSet_teradata_session_optionContext() {}

func NewSet_teradata_session_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_teradata_session_optionContext {
	var p = new(Set_teradata_session_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_set_teradata_session_option

	return p
}

func (s *Set_teradata_session_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_teradata_session_optionContext) T_QUERY_BAND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_QUERY_BAND, 0)
}

func (s *Set_teradata_session_optionContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Set_teradata_session_optionContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *Set_teradata_session_optionContext) T_TRANSACTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TRANSACTION, 0)
}

func (s *Set_teradata_session_optionContext) T_SESSION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SESSION, 0)
}

func (s *Set_teradata_session_optionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Set_teradata_session_optionContext) T_NONE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NONE, 0)
}

func (s *Set_teradata_session_optionContext) T_UPDATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UPDATE, 0)
}

func (s *Set_teradata_session_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_teradata_session_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_teradata_session_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSet_teradata_session_option(s)
	}
}

func (s *Set_teradata_session_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSet_teradata_session_option(s)
	}
}

func (p *HplsqlParser) Set_teradata_session_option() (localctx ISet_teradata_session_optionContext) {
	localctx = NewSet_teradata_session_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, HplsqlParserRULE_set_teradata_session_option)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2228)
		p.Match(HplsqlParserT_QUERY_BAND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2229)
		p.Match(HplsqlParserT_EQUAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2232)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 250, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2230)
			p.expr(0)
		}

	case 2:
		{
			p.SetState(2231)
			p.Match(HplsqlParserT_NONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(2235)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_UPDATE {
		{
			p.SetState(2234)
			p.Match(HplsqlParserT_UPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2237)
		p.Match(HplsqlParserT_FOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2238)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_SESSION || _la == HplsqlParserT_TRANSACTION) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISignal_stmtContext is an interface to support dynamic dispatch.
type ISignal_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_SIGNAL() antlr.TerminalNode
	Ident() IIdentContext

	// IsSignal_stmtContext differentiates from other interfaces.
	IsSignal_stmtContext()
}

type Signal_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignal_stmtContext() *Signal_stmtContext {
	var p = new(Signal_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_signal_stmt
	return p
}

func InitEmptySignal_stmtContext(p *Signal_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_signal_stmt
}

func (*Signal_stmtContext) IsSignal_stmtContext() {}

func NewSignal_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Signal_stmtContext {
	var p = new(Signal_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_signal_stmt

	return p
}

func (s *Signal_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Signal_stmtContext) T_SIGNAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SIGNAL, 0)
}

func (s *Signal_stmtContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Signal_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Signal_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Signal_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSignal_stmt(s)
	}
}

func (s *Signal_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSignal_stmt(s)
	}
}

func (p *HplsqlParser) Signal_stmt() (localctx ISignal_stmtContext) {
	localctx = NewSignal_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, HplsqlParserRULE_signal_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2240)
		p.Match(HplsqlParserT_SIGNAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2241)
		p.Ident()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISummary_stmtContext is an interface to support dynamic dispatch.
type ISummary_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_SUMMARY() antlr.TerminalNode
	T_FOR() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	Table_name() ITable_nameContext
	T_TOP() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	Where_clause() IWhere_clauseContext
	T_LIMIT() antlr.TerminalNode

	// IsSummary_stmtContext differentiates from other interfaces.
	IsSummary_stmtContext()
}

type Summary_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySummary_stmtContext() *Summary_stmtContext {
	var p = new(Summary_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_summary_stmt
	return p
}

func InitEmptySummary_stmtContext(p *Summary_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_summary_stmt
}

func (*Summary_stmtContext) IsSummary_stmtContext() {}

func NewSummary_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Summary_stmtContext {
	var p = new(Summary_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_summary_stmt

	return p
}

func (s *Summary_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Summary_stmtContext) T_SUMMARY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUMMARY, 0)
}

func (s *Summary_stmtContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *Summary_stmtContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Summary_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Summary_stmtContext) T_TOP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TOP, 0)
}

func (s *Summary_stmtContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Summary_stmtContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Summary_stmtContext) Where_clause() IWhere_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhere_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhere_clauseContext)
}

func (s *Summary_stmtContext) T_LIMIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LIMIT, 0)
}

func (s *Summary_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Summary_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Summary_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSummary_stmt(s)
	}
}

func (s *Summary_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSummary_stmt(s)
	}
}

func (p *HplsqlParser) Summary_stmt() (localctx ISummary_stmtContext) {
	localctx = NewSummary_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, HplsqlParserRULE_summary_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2243)
		p.Match(HplsqlParserT_SUMMARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2246)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_TOP {
		{
			p.SetState(2244)
			p.Match(HplsqlParserT_TOP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2245)
			p.expr(0)
		}

	}
	{
		p.SetState(2248)
		p.Match(HplsqlParserT_FOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2258)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 255, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2249)
			p.Select_stmt()
		}

	case 2:
		{
			p.SetState(2250)
			p.Table_name()
		}
		p.SetState(2252)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 253, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2251)
				p.Where_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2256)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 254, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2254)
				p.Match(HplsqlParserT_LIMIT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2255)
				p.expr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITruncate_stmtContext is an interface to support dynamic dispatch.
type ITruncate_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_TRUNCATE() antlr.TerminalNode
	Table_name() ITable_nameContext
	T_TABLE() antlr.TerminalNode

	// IsTruncate_stmtContext differentiates from other interfaces.
	IsTruncate_stmtContext()
}

type Truncate_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTruncate_stmtContext() *Truncate_stmtContext {
	var p = new(Truncate_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_truncate_stmt
	return p
}

func InitEmptyTruncate_stmtContext(p *Truncate_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_truncate_stmt
}

func (*Truncate_stmtContext) IsTruncate_stmtContext() {}

func NewTruncate_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Truncate_stmtContext {
	var p = new(Truncate_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_truncate_stmt

	return p
}

func (s *Truncate_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Truncate_stmtContext) T_TRUNCATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TRUNCATE, 0)
}

func (s *Truncate_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Truncate_stmtContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLE, 0)
}

func (s *Truncate_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Truncate_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Truncate_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterTruncate_stmt(s)
	}
}

func (s *Truncate_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitTruncate_stmt(s)
	}
}

func (p *HplsqlParser) Truncate_stmt() (localctx ITruncate_stmtContext) {
	localctx = NewTruncate_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, HplsqlParserRULE_truncate_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2260)
		p.Match(HplsqlParserT_TRUNCATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2262)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 256, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2261)
			p.Match(HplsqlParserT_TABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2264)
		p.Table_name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUse_stmtContext is an interface to support dynamic dispatch.
type IUse_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_USE() antlr.TerminalNode
	Expr() IExprContext

	// IsUse_stmtContext differentiates from other interfaces.
	IsUse_stmtContext()
}

type Use_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUse_stmtContext() *Use_stmtContext {
	var p = new(Use_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_use_stmt
	return p
}

func InitEmptyUse_stmtContext(p *Use_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_use_stmt
}

func (*Use_stmtContext) IsUse_stmtContext() {}

func NewUse_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Use_stmtContext {
	var p = new(Use_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_use_stmt

	return p
}

func (s *Use_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Use_stmtContext) T_USE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_USE, 0)
}

func (s *Use_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Use_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Use_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Use_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterUse_stmt(s)
	}
}

func (s *Use_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitUse_stmt(s)
	}
}

func (p *HplsqlParser) Use_stmt() (localctx IUse_stmtContext) {
	localctx = NewUse_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, HplsqlParserRULE_use_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2266)
		p.Match(HplsqlParserT_USE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2267)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValues_into_stmtContext is an interface to support dynamic dispatch.
type IValues_into_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_VALUES() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_INTO() antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	AllT_OPEN_P() []antlr.TerminalNode
	T_OPEN_P(i int) antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	AllT_CLOSE_P() []antlr.TerminalNode
	T_CLOSE_P(i int) antlr.TerminalNode

	// IsValues_into_stmtContext differentiates from other interfaces.
	IsValues_into_stmtContext()
}

type Values_into_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValues_into_stmtContext() *Values_into_stmtContext {
	var p = new(Values_into_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_values_into_stmt
	return p
}

func InitEmptyValues_into_stmtContext(p *Values_into_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_values_into_stmt
}

func (*Values_into_stmtContext) IsValues_into_stmtContext() {}

func NewValues_into_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Values_into_stmtContext {
	var p = new(Values_into_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_values_into_stmt

	return p
}

func (s *Values_into_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Values_into_stmtContext) T_VALUES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VALUES, 0)
}

func (s *Values_into_stmtContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Values_into_stmtContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Values_into_stmtContext) T_INTO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTO, 0)
}

func (s *Values_into_stmtContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Values_into_stmtContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Values_into_stmtContext) AllT_OPEN_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_OPEN_P)
}

func (s *Values_into_stmtContext) T_OPEN_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, i)
}

func (s *Values_into_stmtContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Values_into_stmtContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Values_into_stmtContext) AllT_CLOSE_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_CLOSE_P)
}

func (s *Values_into_stmtContext) T_CLOSE_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, i)
}

func (s *Values_into_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Values_into_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Values_into_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterValues_into_stmt(s)
	}
}

func (s *Values_into_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitValues_into_stmt(s)
	}
}

func (p *HplsqlParser) Values_into_stmt() (localctx IValues_into_stmtContext) {
	localctx = NewValues_into_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, HplsqlParserRULE_values_into_stmt)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2269)
		p.Match(HplsqlParserT_VALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2271)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 257, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2270)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2273)
		p.expr(0)
	}
	p.SetState(2278)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(2274)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2275)
			p.expr(0)
		}

		p.SetState(2280)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2282)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_CLOSE_P {
		{
			p.SetState(2281)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2284)
		p.Match(HplsqlParserT_INTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2286)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_OPEN_P {
		{
			p.SetState(2285)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2288)
		p.Ident()
	}
	p.SetState(2293)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 261, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2289)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2290)
				p.Ident()
			}

		}
		p.SetState(2295)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 261, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2297)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 262, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2296)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhile_stmtContext is an interface to support dynamic dispatch.
type IWhile_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllT_WHILE() []antlr.TerminalNode
	T_WHILE(i int) antlr.TerminalNode
	Bool_expr() IBool_exprContext
	Block() IBlockContext
	T_END() antlr.TerminalNode
	T_DO() antlr.TerminalNode
	AllT_LOOP() []antlr.TerminalNode
	T_LOOP(i int) antlr.TerminalNode
	T_THEN() antlr.TerminalNode
	T_BEGIN() antlr.TerminalNode

	// IsWhile_stmtContext differentiates from other interfaces.
	IsWhile_stmtContext()
}

type While_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhile_stmtContext() *While_stmtContext {
	var p = new(While_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_while_stmt
	return p
}

func InitEmptyWhile_stmtContext(p *While_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_while_stmt
}

func (*While_stmtContext) IsWhile_stmtContext() {}

func NewWhile_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *While_stmtContext {
	var p = new(While_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_while_stmt

	return p
}

func (s *While_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *While_stmtContext) AllT_WHILE() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_WHILE)
}

func (s *While_stmtContext) T_WHILE(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WHILE, i)
}

func (s *While_stmtContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *While_stmtContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *While_stmtContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *While_stmtContext) T_DO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DO, 0)
}

func (s *While_stmtContext) AllT_LOOP() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_LOOP)
}

func (s *While_stmtContext) T_LOOP(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOOP, i)
}

func (s *While_stmtContext) T_THEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_THEN, 0)
}

func (s *While_stmtContext) T_BEGIN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BEGIN, 0)
}

func (s *While_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *While_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *While_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterWhile_stmt(s)
	}
}

func (s *While_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitWhile_stmt(s)
	}
}

func (p *HplsqlParser) While_stmt() (localctx IWhile_stmtContext) {
	localctx = NewWhile_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, HplsqlParserRULE_while_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2299)
		p.Match(HplsqlParserT_WHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2300)
		p.bool_expr(0)
	}
	{
		p.SetState(2301)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_BEGIN || _la == HplsqlParserT_DO || _la == HplsqlParserT_LOOP || _la == HplsqlParserT_THEN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2302)
		p.Block()
	}
	{
		p.SetState(2303)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2305)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 263, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2304)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_LOOP || _la == HplsqlParserT_WHILE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnconditional_loop_stmtContext is an interface to support dynamic dispatch.
type IUnconditional_loop_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllT_LOOP() []antlr.TerminalNode
	T_LOOP(i int) antlr.TerminalNode
	Block() IBlockContext
	T_END() antlr.TerminalNode

	// IsUnconditional_loop_stmtContext differentiates from other interfaces.
	IsUnconditional_loop_stmtContext()
}

type Unconditional_loop_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnconditional_loop_stmtContext() *Unconditional_loop_stmtContext {
	var p = new(Unconditional_loop_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_unconditional_loop_stmt
	return p
}

func InitEmptyUnconditional_loop_stmtContext(p *Unconditional_loop_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_unconditional_loop_stmt
}

func (*Unconditional_loop_stmtContext) IsUnconditional_loop_stmtContext() {}

func NewUnconditional_loop_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unconditional_loop_stmtContext {
	var p = new(Unconditional_loop_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_unconditional_loop_stmt

	return p
}

func (s *Unconditional_loop_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Unconditional_loop_stmtContext) AllT_LOOP() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_LOOP)
}

func (s *Unconditional_loop_stmtContext) T_LOOP(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOOP, i)
}

func (s *Unconditional_loop_stmtContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *Unconditional_loop_stmtContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *Unconditional_loop_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unconditional_loop_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unconditional_loop_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterUnconditional_loop_stmt(s)
	}
}

func (s *Unconditional_loop_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitUnconditional_loop_stmt(s)
	}
}

func (p *HplsqlParser) Unconditional_loop_stmt() (localctx IUnconditional_loop_stmtContext) {
	localctx = NewUnconditional_loop_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, HplsqlParserRULE_unconditional_loop_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2307)
		p.Match(HplsqlParserT_LOOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2308)
		p.Block()
	}
	{
		p.SetState(2309)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2310)
		p.Match(HplsqlParserT_LOOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFor_cursor_stmtContext is an interface to support dynamic dispatch.
type IFor_cursor_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_FOR() antlr.TerminalNode
	L_ID() antlr.TerminalNode
	T_IN() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	AllT_LOOP() []antlr.TerminalNode
	T_LOOP(i int) antlr.TerminalNode
	Block() IBlockContext
	T_END() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode

	// IsFor_cursor_stmtContext differentiates from other interfaces.
	IsFor_cursor_stmtContext()
}

type For_cursor_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_cursor_stmtContext() *For_cursor_stmtContext {
	var p = new(For_cursor_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_for_cursor_stmt
	return p
}

func InitEmptyFor_cursor_stmtContext(p *For_cursor_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_for_cursor_stmt
}

func (*For_cursor_stmtContext) IsFor_cursor_stmtContext() {}

func NewFor_cursor_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_cursor_stmtContext {
	var p = new(For_cursor_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_for_cursor_stmt

	return p
}

func (s *For_cursor_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *For_cursor_stmtContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *For_cursor_stmtContext) L_ID() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, 0)
}

func (s *For_cursor_stmtContext) T_IN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IN, 0)
}

func (s *For_cursor_stmtContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *For_cursor_stmtContext) AllT_LOOP() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_LOOP)
}

func (s *For_cursor_stmtContext) T_LOOP(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOOP, i)
}

func (s *For_cursor_stmtContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *For_cursor_stmtContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *For_cursor_stmtContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *For_cursor_stmtContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *For_cursor_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_cursor_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_cursor_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFor_cursor_stmt(s)
	}
}

func (s *For_cursor_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFor_cursor_stmt(s)
	}
}

func (p *HplsqlParser) For_cursor_stmt() (localctx IFor_cursor_stmtContext) {
	localctx = NewFor_cursor_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, HplsqlParserRULE_for_cursor_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2312)
		p.Match(HplsqlParserT_FOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2313)
		p.Match(HplsqlParserL_ID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2314)
		p.Match(HplsqlParserT_IN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2316)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 264, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2315)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2318)
		p.Select_stmt()
	}
	p.SetState(2320)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_CLOSE_P {
		{
			p.SetState(2319)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2322)
		p.Match(HplsqlParserT_LOOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2323)
		p.Block()
	}
	{
		p.SetState(2324)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2325)
		p.Match(HplsqlParserT_LOOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFor_range_stmtContext is an interface to support dynamic dispatch.
type IFor_range_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_FOR() antlr.TerminalNode
	L_ID() antlr.TerminalNode
	T_IN() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_DOT2() antlr.TerminalNode
	AllT_LOOP() []antlr.TerminalNode
	T_LOOP(i int) antlr.TerminalNode
	Block() IBlockContext
	T_END() antlr.TerminalNode
	T_REVERSE() antlr.TerminalNode
	T_BY() antlr.TerminalNode
	T_STEP() antlr.TerminalNode

	// IsFor_range_stmtContext differentiates from other interfaces.
	IsFor_range_stmtContext()
}

type For_range_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_range_stmtContext() *For_range_stmtContext {
	var p = new(For_range_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_for_range_stmt
	return p
}

func InitEmptyFor_range_stmtContext(p *For_range_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_for_range_stmt
}

func (*For_range_stmtContext) IsFor_range_stmtContext() {}

func NewFor_range_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_range_stmtContext {
	var p = new(For_range_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_for_range_stmt

	return p
}

func (s *For_range_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *For_range_stmtContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *For_range_stmtContext) L_ID() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, 0)
}

func (s *For_range_stmtContext) T_IN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IN, 0)
}

func (s *For_range_stmtContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *For_range_stmtContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *For_range_stmtContext) T_DOT2() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DOT2, 0)
}

func (s *For_range_stmtContext) AllT_LOOP() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_LOOP)
}

func (s *For_range_stmtContext) T_LOOP(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOOP, i)
}

func (s *For_range_stmtContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *For_range_stmtContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *For_range_stmtContext) T_REVERSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REVERSE, 0)
}

func (s *For_range_stmtContext) T_BY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BY, 0)
}

func (s *For_range_stmtContext) T_STEP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STEP, 0)
}

func (s *For_range_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_range_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_range_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFor_range_stmt(s)
	}
}

func (s *For_range_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFor_range_stmt(s)
	}
}

func (p *HplsqlParser) For_range_stmt() (localctx IFor_range_stmtContext) {
	localctx = NewFor_range_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, HplsqlParserRULE_for_range_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2327)
		p.Match(HplsqlParserT_FOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2328)
		p.Match(HplsqlParserL_ID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2329)
		p.Match(HplsqlParserT_IN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2331)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 266, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2330)
			p.Match(HplsqlParserT_REVERSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2333)
		p.expr(0)
	}
	{
		p.SetState(2334)
		p.Match(HplsqlParserT_DOT2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2335)
		p.expr(0)
	}
	p.SetState(2338)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_BY || _la == HplsqlParserT_STEP {
		{
			p.SetState(2336)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_BY || _la == HplsqlParserT_STEP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2337)
			p.expr(0)
		}

	}
	{
		p.SetState(2340)
		p.Match(HplsqlParserT_LOOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2341)
		p.Block()
	}
	{
		p.SetState(2342)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2343)
		p.Match(HplsqlParserT_LOOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelContext is an interface to support dynamic dispatch.
type ILabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_LABEL() antlr.TerminalNode
	AllT_LESS() []antlr.TerminalNode
	T_LESS(i int) antlr.TerminalNode
	L_ID() antlr.TerminalNode
	AllT_GREATER() []antlr.TerminalNode
	T_GREATER(i int) antlr.TerminalNode

	// IsLabelContext differentiates from other interfaces.
	IsLabelContext()
}

type LabelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelContext() *LabelContext {
	var p = new(LabelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_label
	return p
}

func InitEmptyLabelContext(p *LabelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_label
}

func (*LabelContext) IsLabelContext() {}

func NewLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelContext {
	var p = new(LabelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_label

	return p
}

func (s *LabelContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelContext) L_LABEL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_LABEL, 0)
}

func (s *LabelContext) AllT_LESS() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_LESS)
}

func (s *LabelContext) T_LESS(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LESS, i)
}

func (s *LabelContext) L_ID() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, 0)
}

func (s *LabelContext) AllT_GREATER() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_GREATER)
}

func (s *LabelContext) T_GREATER(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GREATER, i)
}

func (s *LabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterLabel(s)
	}
}

func (s *LabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitLabel(s)
	}
}

func (p *HplsqlParser) Label() (localctx ILabelContext) {
	localctx = NewLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, HplsqlParserRULE_label)
	p.SetState(2351)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserL_LABEL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2345)
			p.Match(HplsqlParserL_LABEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_LESS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2346)
			p.Match(HplsqlParserT_LESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2347)
			p.Match(HplsqlParserT_LESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2348)
			p.Match(HplsqlParserL_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2349)
			p.Match(HplsqlParserT_GREATER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2350)
			p.Match(HplsqlParserT_GREATER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUsing_clauseContext is an interface to support dynamic dispatch.
type IUsing_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_USING() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsUsing_clauseContext differentiates from other interfaces.
	IsUsing_clauseContext()
}

type Using_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsing_clauseContext() *Using_clauseContext {
	var p = new(Using_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_using_clause
	return p
}

func InitEmptyUsing_clauseContext(p *Using_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_using_clause
}

func (*Using_clauseContext) IsUsing_clauseContext() {}

func NewUsing_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Using_clauseContext {
	var p = new(Using_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_using_clause

	return p
}

func (s *Using_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Using_clauseContext) T_USING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_USING, 0)
}

func (s *Using_clauseContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Using_clauseContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Using_clauseContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Using_clauseContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Using_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Using_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Using_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterUsing_clause(s)
	}
}

func (s *Using_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitUsing_clause(s)
	}
}

func (p *HplsqlParser) Using_clause() (localctx IUsing_clauseContext) {
	localctx = NewUsing_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, HplsqlParserRULE_using_clause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2353)
		p.Match(HplsqlParserT_USING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2354)
		p.expr(0)
	}
	p.SetState(2359)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 269, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2355)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2356)
				p.expr(0)
			}

		}
		p.SetState(2361)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 269, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_stmtContext is an interface to support dynamic dispatch.
type ISelect_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Fullselect_stmt() IFullselect_stmtContext
	Cte_select_stmt() ICte_select_stmtContext

	// IsSelect_stmtContext differentiates from other interfaces.
	IsSelect_stmtContext()
}

type Select_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_stmtContext() *Select_stmtContext {
	var p = new(Select_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_stmt
	return p
}

func InitEmptySelect_stmtContext(p *Select_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_stmt
}

func (*Select_stmtContext) IsSelect_stmtContext() {}

func NewSelect_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_stmtContext {
	var p = new(Select_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_select_stmt

	return p
}

func (s *Select_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_stmtContext) Fullselect_stmt() IFullselect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullselect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullselect_stmtContext)
}

func (s *Select_stmtContext) Cte_select_stmt() ICte_select_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICte_select_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICte_select_stmtContext)
}

func (s *Select_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSelect_stmt(s)
	}
}

func (s *Select_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSelect_stmt(s)
	}
}

func (p *HplsqlParser) Select_stmt() (localctx ISelect_stmtContext) {
	localctx = NewSelect_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, HplsqlParserRULE_select_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2363)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_WITH {
		{
			p.SetState(2362)
			p.Cte_select_stmt()
		}

	}
	{
		p.SetState(2365)
		p.Fullselect_stmt()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICte_select_stmtContext is an interface to support dynamic dispatch.
type ICte_select_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_WITH() antlr.TerminalNode
	AllCte_select_stmt_item() []ICte_select_stmt_itemContext
	Cte_select_stmt_item(i int) ICte_select_stmt_itemContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsCte_select_stmtContext differentiates from other interfaces.
	IsCte_select_stmtContext()
}

type Cte_select_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCte_select_stmtContext() *Cte_select_stmtContext {
	var p = new(Cte_select_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cte_select_stmt
	return p
}

func InitEmptyCte_select_stmtContext(p *Cte_select_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cte_select_stmt
}

func (*Cte_select_stmtContext) IsCte_select_stmtContext() {}

func NewCte_select_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cte_select_stmtContext {
	var p = new(Cte_select_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_cte_select_stmt

	return p
}

func (s *Cte_select_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Cte_select_stmtContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITH, 0)
}

func (s *Cte_select_stmtContext) AllCte_select_stmt_item() []ICte_select_stmt_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICte_select_stmt_itemContext); ok {
			len++
		}
	}

	tst := make([]ICte_select_stmt_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICte_select_stmt_itemContext); ok {
			tst[i] = t.(ICte_select_stmt_itemContext)
			i++
		}
	}

	return tst
}

func (s *Cte_select_stmtContext) Cte_select_stmt_item(i int) ICte_select_stmt_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICte_select_stmt_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICte_select_stmt_itemContext)
}

func (s *Cte_select_stmtContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Cte_select_stmtContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Cte_select_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cte_select_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cte_select_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCte_select_stmt(s)
	}
}

func (s *Cte_select_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCte_select_stmt(s)
	}
}

func (p *HplsqlParser) Cte_select_stmt() (localctx ICte_select_stmtContext) {
	localctx = NewCte_select_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, HplsqlParserRULE_cte_select_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2367)
		p.Match(HplsqlParserT_WITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2368)
		p.Cte_select_stmt_item()
	}
	p.SetState(2373)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(2369)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2370)
			p.Cte_select_stmt_item()
		}

		p.SetState(2375)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICte_select_stmt_itemContext is an interface to support dynamic dispatch.
type ICte_select_stmt_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Qident() IQidentContext
	T_AS() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	Fullselect_stmt() IFullselect_stmtContext
	T_CLOSE_P() antlr.TerminalNode
	Cte_select_cols() ICte_select_colsContext

	// IsCte_select_stmt_itemContext differentiates from other interfaces.
	IsCte_select_stmt_itemContext()
}

type Cte_select_stmt_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCte_select_stmt_itemContext() *Cte_select_stmt_itemContext {
	var p = new(Cte_select_stmt_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cte_select_stmt_item
	return p
}

func InitEmptyCte_select_stmt_itemContext(p *Cte_select_stmt_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cte_select_stmt_item
}

func (*Cte_select_stmt_itemContext) IsCte_select_stmt_itemContext() {}

func NewCte_select_stmt_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cte_select_stmt_itemContext {
	var p = new(Cte_select_stmt_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_cte_select_stmt_item

	return p
}

func (s *Cte_select_stmt_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Cte_select_stmt_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Cte_select_stmt_itemContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Cte_select_stmt_itemContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Cte_select_stmt_itemContext) Fullselect_stmt() IFullselect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullselect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullselect_stmtContext)
}

func (s *Cte_select_stmt_itemContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Cte_select_stmt_itemContext) Cte_select_cols() ICte_select_colsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICte_select_colsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICte_select_colsContext)
}

func (s *Cte_select_stmt_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cte_select_stmt_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cte_select_stmt_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCte_select_stmt_item(s)
	}
}

func (s *Cte_select_stmt_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCte_select_stmt_item(s)
	}
}

func (p *HplsqlParser) Cte_select_stmt_item() (localctx ICte_select_stmt_itemContext) {
	localctx = NewCte_select_stmt_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, HplsqlParserRULE_cte_select_stmt_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2376)
		p.Qident()
	}
	p.SetState(2378)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_OPEN_P {
		{
			p.SetState(2377)
			p.Cte_select_cols()
		}

	}
	{
		p.SetState(2380)
		p.Match(HplsqlParserT_AS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2381)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2382)
		p.Fullselect_stmt()
	}
	{
		p.SetState(2383)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICte_select_colsContext is an interface to support dynamic dispatch.
type ICte_select_colsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN_P() antlr.TerminalNode
	AllQident() []IQidentContext
	Qident(i int) IQidentContext
	T_CLOSE_P() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsCte_select_colsContext differentiates from other interfaces.
	IsCte_select_colsContext()
}

type Cte_select_colsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCte_select_colsContext() *Cte_select_colsContext {
	var p = new(Cte_select_colsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cte_select_cols
	return p
}

func InitEmptyCte_select_colsContext(p *Cte_select_colsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cte_select_cols
}

func (*Cte_select_colsContext) IsCte_select_colsContext() {}

func NewCte_select_colsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cte_select_colsContext {
	var p = new(Cte_select_colsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_cte_select_cols

	return p
}

func (s *Cte_select_colsContext) GetParser() antlr.Parser { return s.parser }

func (s *Cte_select_colsContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Cte_select_colsContext) AllQident() []IQidentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQidentContext); ok {
			len++
		}
	}

	tst := make([]IQidentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQidentContext); ok {
			tst[i] = t.(IQidentContext)
			i++
		}
	}

	return tst
}

func (s *Cte_select_colsContext) Qident(i int) IQidentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Cte_select_colsContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Cte_select_colsContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Cte_select_colsContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Cte_select_colsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cte_select_colsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cte_select_colsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCte_select_cols(s)
	}
}

func (s *Cte_select_colsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCte_select_cols(s)
	}
}

func (p *HplsqlParser) Cte_select_cols() (localctx ICte_select_colsContext) {
	localctx = NewCte_select_colsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, HplsqlParserRULE_cte_select_cols)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2385)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2386)
		p.Qident()
	}
	p.SetState(2391)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(2387)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2388)
			p.Qident()
		}

		p.SetState(2393)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2394)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFullselect_stmtContext is an interface to support dynamic dispatch.
type IFullselect_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFullselect_stmt_item() []IFullselect_stmt_itemContext
	Fullselect_stmt_item(i int) IFullselect_stmt_itemContext
	AllFullselect_set_clause() []IFullselect_set_clauseContext
	Fullselect_set_clause(i int) IFullselect_set_clauseContext

	// IsFullselect_stmtContext differentiates from other interfaces.
	IsFullselect_stmtContext()
}

type Fullselect_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullselect_stmtContext() *Fullselect_stmtContext {
	var p = new(Fullselect_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_fullselect_stmt
	return p
}

func InitEmptyFullselect_stmtContext(p *Fullselect_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_fullselect_stmt
}

func (*Fullselect_stmtContext) IsFullselect_stmtContext() {}

func NewFullselect_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fullselect_stmtContext {
	var p = new(Fullselect_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_fullselect_stmt

	return p
}

func (s *Fullselect_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Fullselect_stmtContext) AllFullselect_stmt_item() []IFullselect_stmt_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullselect_stmt_itemContext); ok {
			len++
		}
	}

	tst := make([]IFullselect_stmt_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullselect_stmt_itemContext); ok {
			tst[i] = t.(IFullselect_stmt_itemContext)
			i++
		}
	}

	return tst
}

func (s *Fullselect_stmtContext) Fullselect_stmt_item(i int) IFullselect_stmt_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullselect_stmt_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullselect_stmt_itemContext)
}

func (s *Fullselect_stmtContext) AllFullselect_set_clause() []IFullselect_set_clauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullselect_set_clauseContext); ok {
			len++
		}
	}

	tst := make([]IFullselect_set_clauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullselect_set_clauseContext); ok {
			tst[i] = t.(IFullselect_set_clauseContext)
			i++
		}
	}

	return tst
}

func (s *Fullselect_stmtContext) Fullselect_set_clause(i int) IFullselect_set_clauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullselect_set_clauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullselect_set_clauseContext)
}

func (s *Fullselect_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fullselect_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fullselect_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFullselect_stmt(s)
	}
}

func (s *Fullselect_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFullselect_stmt(s)
	}
}

func (p *HplsqlParser) Fullselect_stmt() (localctx IFullselect_stmtContext) {
	localctx = NewFullselect_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, HplsqlParserRULE_fullselect_stmt)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2396)
		p.Fullselect_stmt_item()
	}
	p.SetState(2402)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 274, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2397)
				p.Fullselect_set_clause()
			}
			{
				p.SetState(2398)
				p.Fullselect_stmt_item()
			}

		}
		p.SetState(2404)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 274, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFullselect_stmt_itemContext is an interface to support dynamic dispatch.
type IFullselect_stmt_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Subselect_stmt() ISubselect_stmtContext
	T_OPEN_P() antlr.TerminalNode
	Fullselect_stmt() IFullselect_stmtContext
	T_CLOSE_P() antlr.TerminalNode

	// IsFullselect_stmt_itemContext differentiates from other interfaces.
	IsFullselect_stmt_itemContext()
}

type Fullselect_stmt_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullselect_stmt_itemContext() *Fullselect_stmt_itemContext {
	var p = new(Fullselect_stmt_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_fullselect_stmt_item
	return p
}

func InitEmptyFullselect_stmt_itemContext(p *Fullselect_stmt_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_fullselect_stmt_item
}

func (*Fullselect_stmt_itemContext) IsFullselect_stmt_itemContext() {}

func NewFullselect_stmt_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fullselect_stmt_itemContext {
	var p = new(Fullselect_stmt_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_fullselect_stmt_item

	return p
}

func (s *Fullselect_stmt_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Fullselect_stmt_itemContext) Subselect_stmt() ISubselect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubselect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubselect_stmtContext)
}

func (s *Fullselect_stmt_itemContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Fullselect_stmt_itemContext) Fullselect_stmt() IFullselect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullselect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullselect_stmtContext)
}

func (s *Fullselect_stmt_itemContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Fullselect_stmt_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fullselect_stmt_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fullselect_stmt_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFullselect_stmt_item(s)
	}
}

func (s *Fullselect_stmt_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFullselect_stmt_item(s)
	}
}

func (p *HplsqlParser) Fullselect_stmt_item() (localctx IFullselect_stmt_itemContext) {
	localctx = NewFullselect_stmt_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, HplsqlParserRULE_fullselect_stmt_item)
	p.SetState(2410)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_SEL, HplsqlParserT_SELECT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2405)
			p.Subselect_stmt()
		}

	case HplsqlParserT_OPEN_P:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2406)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2407)
			p.Fullselect_stmt()
		}
		{
			p.SetState(2408)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFullselect_set_clauseContext is an interface to support dynamic dispatch.
type IFullselect_set_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_UNION() antlr.TerminalNode
	T_ALL() antlr.TerminalNode
	T_EXCEPT() antlr.TerminalNode
	T_INTERSECT() antlr.TerminalNode

	// IsFullselect_set_clauseContext differentiates from other interfaces.
	IsFullselect_set_clauseContext()
}

type Fullselect_set_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullselect_set_clauseContext() *Fullselect_set_clauseContext {
	var p = new(Fullselect_set_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_fullselect_set_clause
	return p
}

func InitEmptyFullselect_set_clauseContext(p *Fullselect_set_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_fullselect_set_clause
}

func (*Fullselect_set_clauseContext) IsFullselect_set_clauseContext() {}

func NewFullselect_set_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fullselect_set_clauseContext {
	var p = new(Fullselect_set_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_fullselect_set_clause

	return p
}

func (s *Fullselect_set_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Fullselect_set_clauseContext) T_UNION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UNION, 0)
}

func (s *Fullselect_set_clauseContext) T_ALL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALL, 0)
}

func (s *Fullselect_set_clauseContext) T_EXCEPT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXCEPT, 0)
}

func (s *Fullselect_set_clauseContext) T_INTERSECT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTERSECT, 0)
}

func (s *Fullselect_set_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fullselect_set_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fullselect_set_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFullselect_set_clause(s)
	}
}

func (s *Fullselect_set_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFullselect_set_clause(s)
	}
}

func (p *HplsqlParser) Fullselect_set_clause() (localctx IFullselect_set_clauseContext) {
	localctx = NewFullselect_set_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, HplsqlParserRULE_fullselect_set_clause)
	var _la int

	p.SetState(2424)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_UNION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2412)
			p.Match(HplsqlParserT_UNION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2414)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_ALL {
			{
				p.SetState(2413)
				p.Match(HplsqlParserT_ALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case HplsqlParserT_EXCEPT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2416)
			p.Match(HplsqlParserT_EXCEPT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2418)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_ALL {
			{
				p.SetState(2417)
				p.Match(HplsqlParserT_ALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case HplsqlParserT_INTERSECT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2420)
			p.Match(HplsqlParserT_INTERSECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2422)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_ALL {
			{
				p.SetState(2421)
				p.Match(HplsqlParserT_ALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubselect_stmtContext is an interface to support dynamic dispatch.
type ISubselect_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Select_list() ISelect_listContext
	T_SELECT() antlr.TerminalNode
	T_SEL() antlr.TerminalNode
	Into_clause() IInto_clauseContext
	From_clause() IFrom_clauseContext
	Where_clause() IWhere_clauseContext
	Group_by_clause() IGroup_by_clauseContext
	Having_clause() IHaving_clauseContext
	Qualify_clause() IQualify_clauseContext
	Order_by_clause() IOrder_by_clauseContext
	Select_options() ISelect_optionsContext

	// IsSubselect_stmtContext differentiates from other interfaces.
	IsSubselect_stmtContext()
}

type Subselect_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubselect_stmtContext() *Subselect_stmtContext {
	var p = new(Subselect_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_subselect_stmt
	return p
}

func InitEmptySubselect_stmtContext(p *Subselect_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_subselect_stmt
}

func (*Subselect_stmtContext) IsSubselect_stmtContext() {}

func NewSubselect_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subselect_stmtContext {
	var p = new(Subselect_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_subselect_stmt

	return p
}

func (s *Subselect_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Subselect_stmtContext) Select_list() ISelect_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_listContext)
}

func (s *Subselect_stmtContext) T_SELECT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SELECT, 0)
}

func (s *Subselect_stmtContext) T_SEL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEL, 0)
}

func (s *Subselect_stmtContext) Into_clause() IInto_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInto_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInto_clauseContext)
}

func (s *Subselect_stmtContext) From_clause() IFrom_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_clauseContext)
}

func (s *Subselect_stmtContext) Where_clause() IWhere_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhere_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhere_clauseContext)
}

func (s *Subselect_stmtContext) Group_by_clause() IGroup_by_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroup_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroup_by_clauseContext)
}

func (s *Subselect_stmtContext) Having_clause() IHaving_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHaving_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHaving_clauseContext)
}

func (s *Subselect_stmtContext) Qualify_clause() IQualify_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualify_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualify_clauseContext)
}

func (s *Subselect_stmtContext) Order_by_clause() IOrder_by_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_by_clauseContext)
}

func (s *Subselect_stmtContext) Select_options() ISelect_optionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_optionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_optionsContext)
}

func (s *Subselect_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subselect_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subselect_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSubselect_stmt(s)
	}
}

func (s *Subselect_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSubselect_stmt(s)
	}
}

func (p *HplsqlParser) Subselect_stmt() (localctx ISubselect_stmtContext) {
	localctx = NewSubselect_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, HplsqlParserRULE_subselect_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2426)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_SEL || _la == HplsqlParserT_SELECT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2427)
		p.Select_list()
	}
	p.SetState(2429)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 280, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2428)
			p.Into_clause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2432)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 281, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2431)
			p.From_clause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2435)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 282, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2434)
			p.Where_clause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2438)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 283, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2437)
			p.Group_by_clause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2442)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 284, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2440)
			p.Having_clause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 284, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(2441)
			p.Qualify_clause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2445)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 285, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2444)
			p.Order_by_clause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2448)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 286, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2447)
			p.Select_options()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_listContext is an interface to support dynamic dispatch.
type ISelect_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSelect_list_item() []ISelect_list_itemContext
	Select_list_item(i int) ISelect_list_itemContext
	Select_list_set() ISelect_list_setContext
	Select_list_limit() ISelect_list_limitContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsSelect_listContext differentiates from other interfaces.
	IsSelect_listContext()
}

type Select_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_listContext() *Select_listContext {
	var p = new(Select_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list
	return p
}

func InitEmptySelect_listContext(p *Select_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list
}

func (*Select_listContext) IsSelect_listContext() {}

func NewSelect_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_listContext {
	var p = new(Select_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_select_list

	return p
}

func (s *Select_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_listContext) AllSelect_list_item() []ISelect_list_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelect_list_itemContext); ok {
			len++
		}
	}

	tst := make([]ISelect_list_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelect_list_itemContext); ok {
			tst[i] = t.(ISelect_list_itemContext)
			i++
		}
	}

	return tst
}

func (s *Select_listContext) Select_list_item(i int) ISelect_list_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_list_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_list_itemContext)
}

func (s *Select_listContext) Select_list_set() ISelect_list_setContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_list_setContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_list_setContext)
}

func (s *Select_listContext) Select_list_limit() ISelect_list_limitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_list_limitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_list_limitContext)
}

func (s *Select_listContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Select_listContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Select_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSelect_list(s)
	}
}

func (s *Select_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSelect_list(s)
	}
}

func (p *HplsqlParser) Select_list() (localctx ISelect_listContext) {
	localctx = NewSelect_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, HplsqlParserRULE_select_list)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2451)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 287, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2450)
			p.Select_list_set()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2454)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 288, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2453)
			p.Select_list_limit()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2456)
		p.Select_list_item()
	}
	p.SetState(2461)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 289, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2457)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2458)
				p.Select_list_item()
			}

		}
		p.SetState(2463)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 289, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_list_setContext is an interface to support dynamic dispatch.
type ISelect_list_setContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ALL() antlr.TerminalNode
	T_DISTINCT() antlr.TerminalNode

	// IsSelect_list_setContext differentiates from other interfaces.
	IsSelect_list_setContext()
}

type Select_list_setContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_list_setContext() *Select_list_setContext {
	var p = new(Select_list_setContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list_set
	return p
}

func InitEmptySelect_list_setContext(p *Select_list_setContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list_set
}

func (*Select_list_setContext) IsSelect_list_setContext() {}

func NewSelect_list_setContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_list_setContext {
	var p = new(Select_list_setContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_select_list_set

	return p
}

func (s *Select_list_setContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_list_setContext) T_ALL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALL, 0)
}

func (s *Select_list_setContext) T_DISTINCT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DISTINCT, 0)
}

func (s *Select_list_setContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_list_setContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_list_setContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSelect_list_set(s)
	}
}

func (s *Select_list_setContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSelect_list_set(s)
	}
}

func (p *HplsqlParser) Select_list_set() (localctx ISelect_list_setContext) {
	localctx = NewSelect_list_setContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, HplsqlParserRULE_select_list_set)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2464)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_ALL || _la == HplsqlParserT_DISTINCT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_list_limitContext is an interface to support dynamic dispatch.
type ISelect_list_limitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_TOP() antlr.TerminalNode
	Expr() IExprContext

	// IsSelect_list_limitContext differentiates from other interfaces.
	IsSelect_list_limitContext()
}

type Select_list_limitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_list_limitContext() *Select_list_limitContext {
	var p = new(Select_list_limitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list_limit
	return p
}

func InitEmptySelect_list_limitContext(p *Select_list_limitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list_limit
}

func (*Select_list_limitContext) IsSelect_list_limitContext() {}

func NewSelect_list_limitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_list_limitContext {
	var p = new(Select_list_limitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_select_list_limit

	return p
}

func (s *Select_list_limitContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_list_limitContext) T_TOP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TOP, 0)
}

func (s *Select_list_limitContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Select_list_limitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_list_limitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_list_limitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSelect_list_limit(s)
	}
}

func (s *Select_list_limitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSelect_list_limit(s)
	}
}

func (p *HplsqlParser) Select_list_limit() (localctx ISelect_list_limitContext) {
	localctx = NewSelect_list_limitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, HplsqlParserRULE_select_list_limit)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2466)
		p.Match(HplsqlParserT_TOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2467)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_list_itemContext is an interface to support dynamic dispatch.
type ISelect_list_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	Select_list_asterisk() ISelect_list_asteriskContext
	Qident() IQidentContext
	T_EQUAL() antlr.TerminalNode
	Select_list_alias() ISelect_list_aliasContext

	// IsSelect_list_itemContext differentiates from other interfaces.
	IsSelect_list_itemContext()
}

type Select_list_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_list_itemContext() *Select_list_itemContext {
	var p = new(Select_list_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list_item
	return p
}

func InitEmptySelect_list_itemContext(p *Select_list_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list_item
}

func (*Select_list_itemContext) IsSelect_list_itemContext() {}

func NewSelect_list_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_list_itemContext {
	var p = new(Select_list_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_select_list_item

	return p
}

func (s *Select_list_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_list_itemContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Select_list_itemContext) Select_list_asterisk() ISelect_list_asteriskContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_list_asteriskContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_list_asteriskContext)
}

func (s *Select_list_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Select_list_itemContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Select_list_itemContext) Select_list_alias() ISelect_list_aliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_list_aliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_list_aliasContext)
}

func (s *Select_list_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_list_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_list_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSelect_list_item(s)
	}
}

func (s *Select_list_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSelect_list_item(s)
	}
}

func (p *HplsqlParser) Select_list_item() (localctx ISelect_list_itemContext) {
	localctx = NewSelect_list_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, HplsqlParserRULE_select_list_item)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(2479)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 292, p.GetParserRuleContext()) {
	case 1:
		p.SetState(2472)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 290, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2469)
				p.Qident()
			}
			{
				p.SetState(2470)
				p.Match(HplsqlParserT_EQUAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2474)
			p.expr(0)
		}
		p.SetState(2476)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 291, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2475)
				p.Select_list_alias()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		{
			p.SetState(2478)
			p.Select_list_asterisk()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_list_aliasContext is an interface to support dynamic dispatch.
type ISelect_list_aliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Qident() IQidentContext
	T_AS() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	T_TITLE() antlr.TerminalNode
	L_S_STRING() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode

	// IsSelect_list_aliasContext differentiates from other interfaces.
	IsSelect_list_aliasContext()
}

type Select_list_aliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_list_aliasContext() *Select_list_aliasContext {
	var p = new(Select_list_aliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list_alias
	return p
}

func InitEmptySelect_list_aliasContext(p *Select_list_aliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list_alias
}

func (*Select_list_aliasContext) IsSelect_list_aliasContext() {}

func NewSelect_list_aliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_list_aliasContext {
	var p = new(Select_list_aliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_select_list_alias

	return p
}

func (s *Select_list_aliasContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_list_aliasContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Select_list_aliasContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Select_list_aliasContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Select_list_aliasContext) T_TITLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TITLE, 0)
}

func (s *Select_list_aliasContext) L_S_STRING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_S_STRING, 0)
}

func (s *Select_list_aliasContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Select_list_aliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_list_aliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_list_aliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSelect_list_alias(s)
	}
}

func (s *Select_list_aliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSelect_list_alias(s)
	}
}

func (p *HplsqlParser) Select_list_alias() (localctx ISelect_list_aliasContext) {
	localctx = NewSelect_list_aliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, HplsqlParserRULE_select_list_alias)
	p.SetState(2490)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 294, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2481)

		if !(!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "INTO") && !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "FROM")) {
			p.SetError(antlr.NewFailedPredicateException(p, "!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"INTO\") && !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"FROM\")", ""))
			goto errorExit
		}
		p.SetState(2483)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 293, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2482)
				p.Match(HplsqlParserT_AS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2485)
			p.Qident()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2486)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2487)
			p.Match(HplsqlParserT_TITLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2488)
			p.Match(HplsqlParserL_S_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2489)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_list_asteriskContext is an interface to support dynamic dispatch.
type ISelect_list_asteriskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_MUL() antlr.TerminalNode
	L_ID() antlr.TerminalNode
	T_DOT() antlr.TerminalNode

	// IsSelect_list_asteriskContext differentiates from other interfaces.
	IsSelect_list_asteriskContext()
}

type Select_list_asteriskContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_list_asteriskContext() *Select_list_asteriskContext {
	var p = new(Select_list_asteriskContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list_asterisk
	return p
}

func InitEmptySelect_list_asteriskContext(p *Select_list_asteriskContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list_asterisk
}

func (*Select_list_asteriskContext) IsSelect_list_asteriskContext() {}

func NewSelect_list_asteriskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_list_asteriskContext {
	var p = new(Select_list_asteriskContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_select_list_asterisk

	return p
}

func (s *Select_list_asteriskContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_list_asteriskContext) T_MUL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MUL, 0)
}

func (s *Select_list_asteriskContext) L_ID() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, 0)
}

func (s *Select_list_asteriskContext) T_DOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DOT, 0)
}

func (s *Select_list_asteriskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_list_asteriskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_list_asteriskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSelect_list_asterisk(s)
	}
}

func (s *Select_list_asteriskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSelect_list_asterisk(s)
	}
}

func (p *HplsqlParser) Select_list_asterisk() (localctx ISelect_list_asteriskContext) {
	localctx = NewSelect_list_asteriskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, HplsqlParserRULE_select_list_asterisk)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2494)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserL_ID {
		{
			p.SetState(2492)
			p.Match(HplsqlParserL_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2493)
			p.Match(HplsqlParserT_DOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2496)
		p.Match(HplsqlParserT_MUL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_rowContext is an interface to support dynamic dispatch.
type ITable_rowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ident() IIdentContext
	T_OPEN_P() antlr.TerminalNode
	L_INT() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode

	// IsTable_rowContext differentiates from other interfaces.
	IsTable_rowContext()
}

type Table_rowContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_rowContext() *Table_rowContext {
	var p = new(Table_rowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_table_row
	return p
}

func InitEmptyTable_rowContext(p *Table_rowContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_table_row
}

func (*Table_rowContext) IsTable_rowContext() {}

func NewTable_rowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_rowContext {
	var p = new(Table_rowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_table_row

	return p
}

func (s *Table_rowContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_rowContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Table_rowContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Table_rowContext) L_INT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_INT, 0)
}

func (s *Table_rowContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Table_rowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_rowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_rowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterTable_row(s)
	}
}

func (s *Table_rowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitTable_row(s)
	}
}

func (p *HplsqlParser) Table_row() (localctx ITable_rowContext) {
	localctx = NewTable_rowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, HplsqlParserRULE_table_row)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2498)
		p.Ident()
	}
	{
		p.SetState(2499)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2500)
		p.Match(HplsqlParserL_INT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2501)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInto_clauseContext is an interface to support dynamic dispatch.
type IInto_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_INTO() antlr.TerminalNode
	AllTable_row() []ITable_rowContext
	Table_row(i int) ITable_rowContext
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	Bulk_collect_clause() IBulk_collect_clauseContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsInto_clauseContext differentiates from other interfaces.
	IsInto_clauseContext()
}

type Into_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInto_clauseContext() *Into_clauseContext {
	var p = new(Into_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_into_clause
	return p
}

func InitEmptyInto_clauseContext(p *Into_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_into_clause
}

func (*Into_clauseContext) IsInto_clauseContext() {}

func NewInto_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Into_clauseContext {
	var p = new(Into_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_into_clause

	return p
}

func (s *Into_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Into_clauseContext) T_INTO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTO, 0)
}

func (s *Into_clauseContext) AllTable_row() []ITable_rowContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITable_rowContext); ok {
			len++
		}
	}

	tst := make([]ITable_rowContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITable_rowContext); ok {
			tst[i] = t.(ITable_rowContext)
			i++
		}
	}

	return tst
}

func (s *Into_clauseContext) Table_row(i int) ITable_rowContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_rowContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_rowContext)
}

func (s *Into_clauseContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Into_clauseContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Into_clauseContext) Bulk_collect_clause() IBulk_collect_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBulk_collect_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBulk_collect_clauseContext)
}

func (s *Into_clauseContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Into_clauseContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Into_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Into_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Into_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterInto_clause(s)
	}
}

func (s *Into_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitInto_clause(s)
	}
}

func (p *HplsqlParser) Into_clause() (localctx IInto_clauseContext) {
	localctx = NewInto_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, HplsqlParserRULE_into_clause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2504)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_BULK {
		{
			p.SetState(2503)
			p.Bulk_collect_clause()
		}

	}
	{
		p.SetState(2506)
		p.Match(HplsqlParserT_INTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2509)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 297, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2507)
			p.Table_row()
		}

	case 2:
		{
			p.SetState(2508)
			p.Ident()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(2518)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 299, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2511)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2514)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 298, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(2512)
					p.Table_row()
				}

			case 2:
				{
					p.SetState(2513)
					p.Ident()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(2520)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 299, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBulk_collect_clauseContext is an interface to support dynamic dispatch.
type IBulk_collect_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_BULK() antlr.TerminalNode
	T_COLLECT() antlr.TerminalNode

	// IsBulk_collect_clauseContext differentiates from other interfaces.
	IsBulk_collect_clauseContext()
}

type Bulk_collect_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBulk_collect_clauseContext() *Bulk_collect_clauseContext {
	var p = new(Bulk_collect_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bulk_collect_clause
	return p
}

func InitEmptyBulk_collect_clauseContext(p *Bulk_collect_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bulk_collect_clause
}

func (*Bulk_collect_clauseContext) IsBulk_collect_clauseContext() {}

func NewBulk_collect_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bulk_collect_clauseContext {
	var p = new(Bulk_collect_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_bulk_collect_clause

	return p
}

func (s *Bulk_collect_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Bulk_collect_clauseContext) T_BULK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BULK, 0)
}

func (s *Bulk_collect_clauseContext) T_COLLECT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLLECT, 0)
}

func (s *Bulk_collect_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bulk_collect_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bulk_collect_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBulk_collect_clause(s)
	}
}

func (s *Bulk_collect_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBulk_collect_clause(s)
	}
}

func (p *HplsqlParser) Bulk_collect_clause() (localctx IBulk_collect_clauseContext) {
	localctx = NewBulk_collect_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, HplsqlParserRULE_bulk_collect_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2521)
		p.Match(HplsqlParserT_BULK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2522)
		p.Match(HplsqlParserT_COLLECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrom_clauseContext is an interface to support dynamic dispatch.
type IFrom_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_FROM() antlr.TerminalNode
	From_table_clause() IFrom_table_clauseContext
	AllFrom_join_clause() []IFrom_join_clauseContext
	From_join_clause(i int) IFrom_join_clauseContext

	// IsFrom_clauseContext differentiates from other interfaces.
	IsFrom_clauseContext()
}

type From_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_clauseContext() *From_clauseContext {
	var p = new(From_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_clause
	return p
}

func InitEmptyFrom_clauseContext(p *From_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_clause
}

func (*From_clauseContext) IsFrom_clauseContext() {}

func NewFrom_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_clauseContext {
	var p = new(From_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_from_clause

	return p
}

func (s *From_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *From_clauseContext) T_FROM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FROM, 0)
}

func (s *From_clauseContext) From_table_clause() IFrom_table_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_table_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_table_clauseContext)
}

func (s *From_clauseContext) AllFrom_join_clause() []IFrom_join_clauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFrom_join_clauseContext); ok {
			len++
		}
	}

	tst := make([]IFrom_join_clauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFrom_join_clauseContext); ok {
			tst[i] = t.(IFrom_join_clauseContext)
			i++
		}
	}

	return tst
}

func (s *From_clauseContext) From_join_clause(i int) IFrom_join_clauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_join_clauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_join_clauseContext)
}

func (s *From_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *From_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFrom_clause(s)
	}
}

func (s *From_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFrom_clause(s)
	}
}

func (p *HplsqlParser) From_clause() (localctx IFrom_clauseContext) {
	localctx = NewFrom_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, HplsqlParserRULE_from_clause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2524)
		p.Match(HplsqlParserT_FROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2525)
		p.From_table_clause()
	}
	p.SetState(2529)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 300, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2526)
				p.From_join_clause()
			}

		}
		p.SetState(2531)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 300, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrom_table_clauseContext is an interface to support dynamic dispatch.
type IFrom_table_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	From_table_name_clause() IFrom_table_name_clauseContext
	From_subselect_clause() IFrom_subselect_clauseContext
	From_table_values_clause() IFrom_table_values_clauseContext

	// IsFrom_table_clauseContext differentiates from other interfaces.
	IsFrom_table_clauseContext()
}

type From_table_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_table_clauseContext() *From_table_clauseContext {
	var p = new(From_table_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_table_clause
	return p
}

func InitEmptyFrom_table_clauseContext(p *From_table_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_table_clause
}

func (*From_table_clauseContext) IsFrom_table_clauseContext() {}

func NewFrom_table_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_table_clauseContext {
	var p = new(From_table_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_from_table_clause

	return p
}

func (s *From_table_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *From_table_clauseContext) From_table_name_clause() IFrom_table_name_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_table_name_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_table_name_clauseContext)
}

func (s *From_table_clauseContext) From_subselect_clause() IFrom_subselect_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_subselect_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_subselect_clauseContext)
}

func (s *From_table_clauseContext) From_table_values_clause() IFrom_table_values_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_table_values_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_table_values_clauseContext)
}

func (s *From_table_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_table_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *From_table_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFrom_table_clause(s)
	}
}

func (s *From_table_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFrom_table_clause(s)
	}
}

func (p *HplsqlParser) From_table_clause() (localctx IFrom_table_clauseContext) {
	localctx = NewFrom_table_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, HplsqlParserRULE_from_table_clause)
	p.SetState(2535)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 301, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2532)
			p.From_table_name_clause()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2533)
			p.From_subselect_clause()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2534)
			p.From_table_values_clause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrom_table_name_clauseContext is an interface to support dynamic dispatch.
type IFrom_table_name_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Table_name() ITable_nameContext
	From_alias_clause() IFrom_alias_clauseContext

	// IsFrom_table_name_clauseContext differentiates from other interfaces.
	IsFrom_table_name_clauseContext()
}

type From_table_name_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_table_name_clauseContext() *From_table_name_clauseContext {
	var p = new(From_table_name_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_table_name_clause
	return p
}

func InitEmptyFrom_table_name_clauseContext(p *From_table_name_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_table_name_clause
}

func (*From_table_name_clauseContext) IsFrom_table_name_clauseContext() {}

func NewFrom_table_name_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_table_name_clauseContext {
	var p = new(From_table_name_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_from_table_name_clause

	return p
}

func (s *From_table_name_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *From_table_name_clauseContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *From_table_name_clauseContext) From_alias_clause() IFrom_alias_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_alias_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_alias_clauseContext)
}

func (s *From_table_name_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_table_name_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *From_table_name_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFrom_table_name_clause(s)
	}
}

func (s *From_table_name_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFrom_table_name_clause(s)
	}
}

func (p *HplsqlParser) From_table_name_clause() (localctx IFrom_table_name_clauseContext) {
	localctx = NewFrom_table_name_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, HplsqlParserRULE_from_table_name_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2537)
		p.Table_name()
	}
	p.SetState(2539)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 302, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2538)
			p.From_alias_clause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrom_subselect_clauseContext is an interface to support dynamic dispatch.
type IFrom_subselect_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN_P() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	T_CLOSE_P() antlr.TerminalNode
	From_alias_clause() IFrom_alias_clauseContext

	// IsFrom_subselect_clauseContext differentiates from other interfaces.
	IsFrom_subselect_clauseContext()
}

type From_subselect_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_subselect_clauseContext() *From_subselect_clauseContext {
	var p = new(From_subselect_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_subselect_clause
	return p
}

func InitEmptyFrom_subselect_clauseContext(p *From_subselect_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_subselect_clause
}

func (*From_subselect_clauseContext) IsFrom_subselect_clauseContext() {}

func NewFrom_subselect_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_subselect_clauseContext {
	var p = new(From_subselect_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_from_subselect_clause

	return p
}

func (s *From_subselect_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *From_subselect_clauseContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *From_subselect_clauseContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *From_subselect_clauseContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *From_subselect_clauseContext) From_alias_clause() IFrom_alias_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_alias_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_alias_clauseContext)
}

func (s *From_subselect_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_subselect_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *From_subselect_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFrom_subselect_clause(s)
	}
}

func (s *From_subselect_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFrom_subselect_clause(s)
	}
}

func (p *HplsqlParser) From_subselect_clause() (localctx IFrom_subselect_clauseContext) {
	localctx = NewFrom_subselect_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, HplsqlParserRULE_from_subselect_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2541)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2542)
		p.Select_stmt()
	}
	{
		p.SetState(2543)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2545)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 303, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2544)
			p.From_alias_clause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrom_join_clauseContext is an interface to support dynamic dispatch.
type IFrom_join_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_COMMA() antlr.TerminalNode
	From_table_clause() IFrom_table_clauseContext
	From_join_type_clause() IFrom_join_type_clauseContext
	T_ON() antlr.TerminalNode
	Bool_expr() IBool_exprContext

	// IsFrom_join_clauseContext differentiates from other interfaces.
	IsFrom_join_clauseContext()
}

type From_join_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_join_clauseContext() *From_join_clauseContext {
	var p = new(From_join_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_join_clause
	return p
}

func InitEmptyFrom_join_clauseContext(p *From_join_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_join_clause
}

func (*From_join_clauseContext) IsFrom_join_clauseContext() {}

func NewFrom_join_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_join_clauseContext {
	var p = new(From_join_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_from_join_clause

	return p
}

func (s *From_join_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *From_join_clauseContext) T_COMMA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, 0)
}

func (s *From_join_clauseContext) From_table_clause() IFrom_table_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_table_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_table_clauseContext)
}

func (s *From_join_clauseContext) From_join_type_clause() IFrom_join_type_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_join_type_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_join_type_clauseContext)
}

func (s *From_join_clauseContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *From_join_clauseContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *From_join_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_join_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *From_join_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFrom_join_clause(s)
	}
}

func (s *From_join_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFrom_join_clause(s)
	}
}

func (p *HplsqlParser) From_join_clause() (localctx IFrom_join_clauseContext) {
	localctx = NewFrom_join_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, HplsqlParserRULE_from_join_clause)
	p.SetState(2554)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_COMMA:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2547)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2548)
			p.From_table_clause()
		}

	case HplsqlParserT_FULL, HplsqlParserT_INNER, HplsqlParserT_JOIN, HplsqlParserT_LEFT, HplsqlParserT_RIGHT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2549)
			p.From_join_type_clause()
		}
		{
			p.SetState(2550)
			p.From_table_clause()
		}
		{
			p.SetState(2551)
			p.Match(HplsqlParserT_ON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2552)
			p.bool_expr(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrom_join_type_clauseContext is an interface to support dynamic dispatch.
type IFrom_join_type_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_JOIN() antlr.TerminalNode
	T_INNER() antlr.TerminalNode
	T_LEFT() antlr.TerminalNode
	T_RIGHT() antlr.TerminalNode
	T_FULL() antlr.TerminalNode
	T_OUTER() antlr.TerminalNode

	// IsFrom_join_type_clauseContext differentiates from other interfaces.
	IsFrom_join_type_clauseContext()
}

type From_join_type_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_join_type_clauseContext() *From_join_type_clauseContext {
	var p = new(From_join_type_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_join_type_clause
	return p
}

func InitEmptyFrom_join_type_clauseContext(p *From_join_type_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_join_type_clause
}

func (*From_join_type_clauseContext) IsFrom_join_type_clauseContext() {}

func NewFrom_join_type_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_join_type_clauseContext {
	var p = new(From_join_type_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_from_join_type_clause

	return p
}

func (s *From_join_type_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *From_join_type_clauseContext) T_JOIN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_JOIN, 0)
}

func (s *From_join_type_clauseContext) T_INNER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INNER, 0)
}

func (s *From_join_type_clauseContext) T_LEFT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LEFT, 0)
}

func (s *From_join_type_clauseContext) T_RIGHT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RIGHT, 0)
}

func (s *From_join_type_clauseContext) T_FULL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FULL, 0)
}

func (s *From_join_type_clauseContext) T_OUTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OUTER, 0)
}

func (s *From_join_type_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_join_type_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *From_join_type_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFrom_join_type_clause(s)
	}
}

func (s *From_join_type_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFrom_join_type_clause(s)
	}
}

func (p *HplsqlParser) From_join_type_clause() (localctx IFrom_join_type_clauseContext) {
	localctx = NewFrom_join_type_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, HplsqlParserRULE_from_join_type_clause)
	var _la int

	p.SetState(2565)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_INNER, HplsqlParserT_JOIN:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2557)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_INNER {
			{
				p.SetState(2556)
				p.Match(HplsqlParserT_INNER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2559)
			p.Match(HplsqlParserT_JOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_FULL, HplsqlParserT_LEFT, HplsqlParserT_RIGHT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2560)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_FULL || _la == HplsqlParserT_LEFT || _la == HplsqlParserT_RIGHT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2562)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_OUTER {
			{
				p.SetState(2561)
				p.Match(HplsqlParserT_OUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2564)
			p.Match(HplsqlParserT_JOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrom_table_values_clauseContext is an interface to support dynamic dispatch.
type IFrom_table_values_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_TABLE() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	T_VALUES() antlr.TerminalNode
	AllFrom_table_values_row() []IFrom_table_values_rowContext
	From_table_values_row(i int) IFrom_table_values_rowContext
	T_CLOSE_P() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	From_alias_clause() IFrom_alias_clauseContext

	// IsFrom_table_values_clauseContext differentiates from other interfaces.
	IsFrom_table_values_clauseContext()
}

type From_table_values_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_table_values_clauseContext() *From_table_values_clauseContext {
	var p = new(From_table_values_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_table_values_clause
	return p
}

func InitEmptyFrom_table_values_clauseContext(p *From_table_values_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_table_values_clause
}

func (*From_table_values_clauseContext) IsFrom_table_values_clauseContext() {}

func NewFrom_table_values_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_table_values_clauseContext {
	var p = new(From_table_values_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_from_table_values_clause

	return p
}

func (s *From_table_values_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *From_table_values_clauseContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLE, 0)
}

func (s *From_table_values_clauseContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *From_table_values_clauseContext) T_VALUES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VALUES, 0)
}

func (s *From_table_values_clauseContext) AllFrom_table_values_row() []IFrom_table_values_rowContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFrom_table_values_rowContext); ok {
			len++
		}
	}

	tst := make([]IFrom_table_values_rowContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFrom_table_values_rowContext); ok {
			tst[i] = t.(IFrom_table_values_rowContext)
			i++
		}
	}

	return tst
}

func (s *From_table_values_clauseContext) From_table_values_row(i int) IFrom_table_values_rowContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_table_values_rowContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_table_values_rowContext)
}

func (s *From_table_values_clauseContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *From_table_values_clauseContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *From_table_values_clauseContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *From_table_values_clauseContext) From_alias_clause() IFrom_alias_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_alias_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_alias_clauseContext)
}

func (s *From_table_values_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_table_values_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *From_table_values_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFrom_table_values_clause(s)
	}
}

func (s *From_table_values_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFrom_table_values_clause(s)
	}
}

func (p *HplsqlParser) From_table_values_clause() (localctx IFrom_table_values_clauseContext) {
	localctx = NewFrom_table_values_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, HplsqlParserRULE_from_table_values_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2567)
		p.Match(HplsqlParserT_TABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2568)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2569)
		p.Match(HplsqlParserT_VALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2570)
		p.From_table_values_row()
	}
	p.SetState(2575)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(2571)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2572)
			p.From_table_values_row()
		}

		p.SetState(2577)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2578)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2580)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 309, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2579)
			p.From_alias_clause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrom_table_values_rowContext is an interface to support dynamic dispatch.
type IFrom_table_values_rowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsFrom_table_values_rowContext differentiates from other interfaces.
	IsFrom_table_values_rowContext()
}

type From_table_values_rowContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_table_values_rowContext() *From_table_values_rowContext {
	var p = new(From_table_values_rowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_table_values_row
	return p
}

func InitEmptyFrom_table_values_rowContext(p *From_table_values_rowContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_table_values_row
}

func (*From_table_values_rowContext) IsFrom_table_values_rowContext() {}

func NewFrom_table_values_rowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_table_values_rowContext {
	var p = new(From_table_values_rowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_from_table_values_row

	return p
}

func (s *From_table_values_rowContext) GetParser() antlr.Parser { return s.parser }

func (s *From_table_values_rowContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *From_table_values_rowContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *From_table_values_rowContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *From_table_values_rowContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *From_table_values_rowContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *From_table_values_rowContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *From_table_values_rowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_table_values_rowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *From_table_values_rowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFrom_table_values_row(s)
	}
}

func (s *From_table_values_rowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFrom_table_values_row(s)
	}
}

func (p *HplsqlParser) From_table_values_row() (localctx IFrom_table_values_rowContext) {
	localctx = NewFrom_table_values_rowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, HplsqlParserRULE_from_table_values_row)
	var _la int

	p.SetState(2594)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 311, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2582)
			p.expr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2583)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2584)
			p.expr(0)
		}
		p.SetState(2589)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(2585)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2586)
				p.expr(0)
			}

			p.SetState(2591)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2592)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrom_alias_clauseContext is an interface to support dynamic dispatch.
type IFrom_alias_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Qident() IQidentContext
	T_AS() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	AllL_ID() []antlr.TerminalNode
	L_ID(i int) antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsFrom_alias_clauseContext differentiates from other interfaces.
	IsFrom_alias_clauseContext()
}

type From_alias_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_alias_clauseContext() *From_alias_clauseContext {
	var p = new(From_alias_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_alias_clause
	return p
}

func InitEmptyFrom_alias_clauseContext(p *From_alias_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_alias_clause
}

func (*From_alias_clauseContext) IsFrom_alias_clauseContext() {}

func NewFrom_alias_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_alias_clauseContext {
	var p = new(From_alias_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_from_alias_clause

	return p
}

func (s *From_alias_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *From_alias_clauseContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *From_alias_clauseContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *From_alias_clauseContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *From_alias_clauseContext) AllL_ID() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserL_ID)
}

func (s *From_alias_clauseContext) L_ID(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, i)
}

func (s *From_alias_clauseContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *From_alias_clauseContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *From_alias_clauseContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *From_alias_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_alias_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *From_alias_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFrom_alias_clause(s)
	}
}

func (s *From_alias_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFrom_alias_clause(s)
	}
}

func (p *HplsqlParser) From_alias_clause() (localctx IFrom_alias_clauseContext) {
	localctx = NewFrom_alias_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, HplsqlParserRULE_from_alias_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2596)

	if !(!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "EXEC") &&
		!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "EXECUTE") &&
		!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "INNER") &&
		!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "LEFT") &&
		!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "GROUP") &&
		!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "ORDER") &&
		!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "LIMIT") &&
		!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "WITH")) {
		p.SetError(antlr.NewFailedPredicateException(p, "!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"EXEC\") &&\n        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"EXECUTE\") && \n        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"INNER\") &&\n        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"LEFT\") &&\n        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"GROUP\") &&\n        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"ORDER\") &&\n        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"LIMIT\") &&\n        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"WITH\")", ""))
		goto errorExit
	}
	p.SetState(2598)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 312, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2597)
			p.Match(HplsqlParserT_AS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2600)
		p.Qident()
	}
	p.SetState(2611)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 314, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2601)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2602)
			p.Match(HplsqlParserL_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2607)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(2603)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2604)
				p.Match(HplsqlParserL_ID)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(2609)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2610)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITable_nameContext is an interface to support dynamic dispatch.
type ITable_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Qident() IQidentContext

	// IsTable_nameContext differentiates from other interfaces.
	IsTable_nameContext()
}

type Table_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_nameContext() *Table_nameContext {
	var p = new(Table_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_table_name
	return p
}

func InitEmptyTable_nameContext(p *Table_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_table_name
}

func (*Table_nameContext) IsTable_nameContext() {}

func NewTable_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_nameContext {
	var p = new(Table_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_table_name

	return p
}

func (s *Table_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_nameContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Table_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Table_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterTable_name(s)
	}
}

func (s *Table_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitTable_name(s)
	}
}

func (p *HplsqlParser) Table_name() (localctx ITable_nameContext) {
	localctx = NewTable_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, HplsqlParserRULE_table_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2613)
		p.Qident()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhere_clauseContext is an interface to support dynamic dispatch.
type IWhere_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_WHERE() antlr.TerminalNode
	Bool_expr() IBool_exprContext

	// IsWhere_clauseContext differentiates from other interfaces.
	IsWhere_clauseContext()
}

type Where_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhere_clauseContext() *Where_clauseContext {
	var p = new(Where_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_where_clause
	return p
}

func InitEmptyWhere_clauseContext(p *Where_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_where_clause
}

func (*Where_clauseContext) IsWhere_clauseContext() {}

func NewWhere_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Where_clauseContext {
	var p = new(Where_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_where_clause

	return p
}

func (s *Where_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Where_clauseContext) T_WHERE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WHERE, 0)
}

func (s *Where_clauseContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *Where_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Where_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Where_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterWhere_clause(s)
	}
}

func (s *Where_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitWhere_clause(s)
	}
}

func (p *HplsqlParser) Where_clause() (localctx IWhere_clauseContext) {
	localctx = NewWhere_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, HplsqlParserRULE_where_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2615)
		p.Match(HplsqlParserT_WHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2616)
		p.bool_expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroup_by_clauseContext is an interface to support dynamic dispatch.
type IGroup_by_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_GROUP() antlr.TerminalNode
	T_BY() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsGroup_by_clauseContext differentiates from other interfaces.
	IsGroup_by_clauseContext()
}

type Group_by_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroup_by_clauseContext() *Group_by_clauseContext {
	var p = new(Group_by_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_group_by_clause
	return p
}

func InitEmptyGroup_by_clauseContext(p *Group_by_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_group_by_clause
}

func (*Group_by_clauseContext) IsGroup_by_clauseContext() {}

func NewGroup_by_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Group_by_clauseContext {
	var p = new(Group_by_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_group_by_clause

	return p
}

func (s *Group_by_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Group_by_clauseContext) T_GROUP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GROUP, 0)
}

func (s *Group_by_clauseContext) T_BY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BY, 0)
}

func (s *Group_by_clauseContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Group_by_clauseContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Group_by_clauseContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Group_by_clauseContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Group_by_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Group_by_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Group_by_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterGroup_by_clause(s)
	}
}

func (s *Group_by_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitGroup_by_clause(s)
	}
}

func (p *HplsqlParser) Group_by_clause() (localctx IGroup_by_clauseContext) {
	localctx = NewGroup_by_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, HplsqlParserRULE_group_by_clause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2618)
		p.Match(HplsqlParserT_GROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2619)
		p.Match(HplsqlParserT_BY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2620)
		p.expr(0)
	}
	p.SetState(2625)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 315, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2621)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2622)
				p.expr(0)
			}

		}
		p.SetState(2627)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 315, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHaving_clauseContext is an interface to support dynamic dispatch.
type IHaving_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_HAVING() antlr.TerminalNode
	Bool_expr() IBool_exprContext

	// IsHaving_clauseContext differentiates from other interfaces.
	IsHaving_clauseContext()
}

type Having_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHaving_clauseContext() *Having_clauseContext {
	var p = new(Having_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_having_clause
	return p
}

func InitEmptyHaving_clauseContext(p *Having_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_having_clause
}

func (*Having_clauseContext) IsHaving_clauseContext() {}

func NewHaving_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Having_clauseContext {
	var p = new(Having_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_having_clause

	return p
}

func (s *Having_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Having_clauseContext) T_HAVING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HAVING, 0)
}

func (s *Having_clauseContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *Having_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Having_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Having_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterHaving_clause(s)
	}
}

func (s *Having_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitHaving_clause(s)
	}
}

func (p *HplsqlParser) Having_clause() (localctx IHaving_clauseContext) {
	localctx = NewHaving_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, HplsqlParserRULE_having_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2628)
		p.Match(HplsqlParserT_HAVING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2629)
		p.bool_expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualify_clauseContext is an interface to support dynamic dispatch.
type IQualify_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_QUALIFY() antlr.TerminalNode
	Bool_expr() IBool_exprContext

	// IsQualify_clauseContext differentiates from other interfaces.
	IsQualify_clauseContext()
}

type Qualify_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualify_clauseContext() *Qualify_clauseContext {
	var p = new(Qualify_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_qualify_clause
	return p
}

func InitEmptyQualify_clauseContext(p *Qualify_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_qualify_clause
}

func (*Qualify_clauseContext) IsQualify_clauseContext() {}

func NewQualify_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Qualify_clauseContext {
	var p = new(Qualify_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_qualify_clause

	return p
}

func (s *Qualify_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Qualify_clauseContext) T_QUALIFY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_QUALIFY, 0)
}

func (s *Qualify_clauseContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *Qualify_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Qualify_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Qualify_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterQualify_clause(s)
	}
}

func (s *Qualify_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitQualify_clause(s)
	}
}

func (p *HplsqlParser) Qualify_clause() (localctx IQualify_clauseContext) {
	localctx = NewQualify_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, HplsqlParserRULE_qualify_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2631)
		p.Match(HplsqlParserT_QUALIFY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2632)
		p.bool_expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrder_by_clauseContext is an interface to support dynamic dispatch.
type IOrder_by_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ORDER() antlr.TerminalNode
	T_BY() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	AllT_ASC() []antlr.TerminalNode
	T_ASC(i int) antlr.TerminalNode
	AllT_DESC() []antlr.TerminalNode
	T_DESC(i int) antlr.TerminalNode

	// IsOrder_by_clauseContext differentiates from other interfaces.
	IsOrder_by_clauseContext()
}

type Order_by_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrder_by_clauseContext() *Order_by_clauseContext {
	var p = new(Order_by_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_order_by_clause
	return p
}

func InitEmptyOrder_by_clauseContext(p *Order_by_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_order_by_clause
}

func (*Order_by_clauseContext) IsOrder_by_clauseContext() {}

func NewOrder_by_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Order_by_clauseContext {
	var p = new(Order_by_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_order_by_clause

	return p
}

func (s *Order_by_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Order_by_clauseContext) T_ORDER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ORDER, 0)
}

func (s *Order_by_clauseContext) T_BY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BY, 0)
}

func (s *Order_by_clauseContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Order_by_clauseContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Order_by_clauseContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Order_by_clauseContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Order_by_clauseContext) AllT_ASC() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_ASC)
}

func (s *Order_by_clauseContext) T_ASC(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ASC, i)
}

func (s *Order_by_clauseContext) AllT_DESC() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_DESC)
}

func (s *Order_by_clauseContext) T_DESC(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DESC, i)
}

func (s *Order_by_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Order_by_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Order_by_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterOrder_by_clause(s)
	}
}

func (s *Order_by_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitOrder_by_clause(s)
	}
}

func (p *HplsqlParser) Order_by_clause() (localctx IOrder_by_clauseContext) {
	localctx = NewOrder_by_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, HplsqlParserRULE_order_by_clause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2634)
		p.Match(HplsqlParserT_ORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2635)
		p.Match(HplsqlParserT_BY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2636)
		p.expr(0)
	}
	p.SetState(2638)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 316, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2637)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2647)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 318, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2640)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2641)
				p.expr(0)
			}
			p.SetState(2643)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 317, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(2642)
					_la = p.GetTokenStream().LA(1)

					if !(_la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		}
		p.SetState(2649)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 318, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_optionsContext is an interface to support dynamic dispatch.
type ISelect_optionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSelect_options_item() []ISelect_options_itemContext
	Select_options_item(i int) ISelect_options_itemContext

	// IsSelect_optionsContext differentiates from other interfaces.
	IsSelect_optionsContext()
}

type Select_optionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_optionsContext() *Select_optionsContext {
	var p = new(Select_optionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_options
	return p
}

func InitEmptySelect_optionsContext(p *Select_optionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_options
}

func (*Select_optionsContext) IsSelect_optionsContext() {}

func NewSelect_optionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_optionsContext {
	var p = new(Select_optionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_select_options

	return p
}

func (s *Select_optionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_optionsContext) AllSelect_options_item() []ISelect_options_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelect_options_itemContext); ok {
			len++
		}
	}

	tst := make([]ISelect_options_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelect_options_itemContext); ok {
			tst[i] = t.(ISelect_options_itemContext)
			i++
		}
	}

	return tst
}

func (s *Select_optionsContext) Select_options_item(i int) ISelect_options_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_options_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_options_itemContext)
}

func (s *Select_optionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_optionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_optionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSelect_options(s)
	}
}

func (s *Select_optionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSelect_options(s)
	}
}

func (p *HplsqlParser) Select_options() (localctx ISelect_optionsContext) {
	localctx = NewSelect_optionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, HplsqlParserRULE_select_options)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2651)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(2650)
				p.Select_options_item()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(2653)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 319, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_options_itemContext is an interface to support dynamic dispatch.
type ISelect_options_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_LIMIT() antlr.TerminalNode
	Expr() IExprContext
	T_WITH() antlr.TerminalNode
	T_RR() antlr.TerminalNode
	T_RS() antlr.TerminalNode
	T_CS() antlr.TerminalNode
	T_UR() antlr.TerminalNode
	T_USE() antlr.TerminalNode
	T_AND() antlr.TerminalNode
	T_KEEP() antlr.TerminalNode
	T_LOCKS() antlr.TerminalNode
	T_EXCLUSIVE() antlr.TerminalNode
	T_UPDATE() antlr.TerminalNode
	T_SHARE() antlr.TerminalNode

	// IsSelect_options_itemContext differentiates from other interfaces.
	IsSelect_options_itemContext()
}

type Select_options_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_options_itemContext() *Select_options_itemContext {
	var p = new(Select_options_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_options_item
	return p
}

func InitEmptySelect_options_itemContext(p *Select_options_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_options_item
}

func (*Select_options_itemContext) IsSelect_options_itemContext() {}

func NewSelect_options_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_options_itemContext {
	var p = new(Select_options_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_select_options_item

	return p
}

func (s *Select_options_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_options_itemContext) T_LIMIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LIMIT, 0)
}

func (s *Select_options_itemContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Select_options_itemContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITH, 0)
}

func (s *Select_options_itemContext) T_RR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RR, 0)
}

func (s *Select_options_itemContext) T_RS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RS, 0)
}

func (s *Select_options_itemContext) T_CS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CS, 0)
}

func (s *Select_options_itemContext) T_UR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UR, 0)
}

func (s *Select_options_itemContext) T_USE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_USE, 0)
}

func (s *Select_options_itemContext) T_AND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AND, 0)
}

func (s *Select_options_itemContext) T_KEEP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_KEEP, 0)
}

func (s *Select_options_itemContext) T_LOCKS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCKS, 0)
}

func (s *Select_options_itemContext) T_EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXCLUSIVE, 0)
}

func (s *Select_options_itemContext) T_UPDATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UPDATE, 0)
}

func (s *Select_options_itemContext) T_SHARE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SHARE, 0)
}

func (s *Select_options_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_options_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_options_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSelect_options_item(s)
	}
}

func (s *Select_options_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSelect_options_item(s)
	}
}

func (p *HplsqlParser) Select_options_item() (localctx ISelect_options_itemContext) {
	localctx = NewSelect_options_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, HplsqlParserRULE_select_options_item)
	var _la int

	p.SetState(2666)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_LIMIT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2655)
			p.Match(HplsqlParserT_LIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2656)
			p.expr(0)
		}

	case HplsqlParserT_WITH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2657)
			p.Match(HplsqlParserT_WITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2658)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_CS || ((int64((_la-249)) & ^0x3f) == 0 && ((int64(1)<<(_la-249))&72057594037927939) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2664)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 320, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2659)
				p.Match(HplsqlParserT_USE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2660)
				p.Match(HplsqlParserT_AND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2661)
				p.Match(HplsqlParserT_KEEP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2662)
				_la = p.GetTokenStream().LA(1)

				if !(_la == HplsqlParserT_EXCLUSIVE || _la == HplsqlParserT_SHARE || _la == HplsqlParserT_UPDATE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2663)
				p.Match(HplsqlParserT_LOCKS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdate_stmtContext is an interface to support dynamic dispatch.
type IUpdate_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_UPDATE() antlr.TerminalNode
	Update_table() IUpdate_tableContext
	T_SET() antlr.TerminalNode
	Update_assignment() IUpdate_assignmentContext
	Where_clause() IWhere_clauseContext
	Update_upsert() IUpdate_upsertContext

	// IsUpdate_stmtContext differentiates from other interfaces.
	IsUpdate_stmtContext()
}

type Update_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdate_stmtContext() *Update_stmtContext {
	var p = new(Update_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_update_stmt
	return p
}

func InitEmptyUpdate_stmtContext(p *Update_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_update_stmt
}

func (*Update_stmtContext) IsUpdate_stmtContext() {}

func NewUpdate_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Update_stmtContext {
	var p = new(Update_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_update_stmt

	return p
}

func (s *Update_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Update_stmtContext) T_UPDATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UPDATE, 0)
}

func (s *Update_stmtContext) Update_table() IUpdate_tableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdate_tableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdate_tableContext)
}

func (s *Update_stmtContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Update_stmtContext) Update_assignment() IUpdate_assignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdate_assignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdate_assignmentContext)
}

func (s *Update_stmtContext) Where_clause() IWhere_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhere_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhere_clauseContext)
}

func (s *Update_stmtContext) Update_upsert() IUpdate_upsertContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdate_upsertContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdate_upsertContext)
}

func (s *Update_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Update_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Update_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterUpdate_stmt(s)
	}
}

func (s *Update_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitUpdate_stmt(s)
	}
}

func (p *HplsqlParser) Update_stmt() (localctx IUpdate_stmtContext) {
	localctx = NewUpdate_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, HplsqlParserRULE_update_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2668)
		p.Match(HplsqlParserT_UPDATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2669)
		p.Update_table()
	}
	{
		p.SetState(2670)
		p.Match(HplsqlParserT_SET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2671)
		p.Update_assignment()
	}
	p.SetState(2673)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 322, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2672)
			p.Where_clause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2676)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 323, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2675)
			p.Update_upsert()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdate_assignmentContext is an interface to support dynamic dispatch.
type IUpdate_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAssignment_stmt_item() []IAssignment_stmt_itemContext
	Assignment_stmt_item(i int) IAssignment_stmt_itemContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsUpdate_assignmentContext differentiates from other interfaces.
	IsUpdate_assignmentContext()
}

type Update_assignmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdate_assignmentContext() *Update_assignmentContext {
	var p = new(Update_assignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_update_assignment
	return p
}

func InitEmptyUpdate_assignmentContext(p *Update_assignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_update_assignment
}

func (*Update_assignmentContext) IsUpdate_assignmentContext() {}

func NewUpdate_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Update_assignmentContext {
	var p = new(Update_assignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_update_assignment

	return p
}

func (s *Update_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Update_assignmentContext) AllAssignment_stmt_item() []IAssignment_stmt_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignment_stmt_itemContext); ok {
			len++
		}
	}

	tst := make([]IAssignment_stmt_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignment_stmt_itemContext); ok {
			tst[i] = t.(IAssignment_stmt_itemContext)
			i++
		}
	}

	return tst
}

func (s *Update_assignmentContext) Assignment_stmt_item(i int) IAssignment_stmt_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignment_stmt_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignment_stmt_itemContext)
}

func (s *Update_assignmentContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Update_assignmentContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Update_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Update_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Update_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterUpdate_assignment(s)
	}
}

func (s *Update_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitUpdate_assignment(s)
	}
}

func (p *HplsqlParser) Update_assignment() (localctx IUpdate_assignmentContext) {
	localctx = NewUpdate_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, HplsqlParserRULE_update_assignment)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2678)
		p.Assignment_stmt_item()
	}
	p.SetState(2683)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 324, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2679)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2680)
				p.Assignment_stmt_item()
			}

		}
		p.SetState(2685)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 324, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdate_tableContext is an interface to support dynamic dispatch.
type IUpdate_tableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Table_name() ITable_nameContext
	T_OPEN_P() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	T_CLOSE_P() antlr.TerminalNode
	Qident() IQidentContext
	From_clause() IFrom_clauseContext
	T_AS() antlr.TerminalNode

	// IsUpdate_tableContext differentiates from other interfaces.
	IsUpdate_tableContext()
}

type Update_tableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdate_tableContext() *Update_tableContext {
	var p = new(Update_tableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_update_table
	return p
}

func InitEmptyUpdate_tableContext(p *Update_tableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_update_table
}

func (*Update_tableContext) IsUpdate_tableContext() {}

func NewUpdate_tableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Update_tableContext {
	var p = new(Update_tableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_update_table

	return p
}

func (s *Update_tableContext) GetParser() antlr.Parser { return s.parser }

func (s *Update_tableContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Update_tableContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Update_tableContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Update_tableContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Update_tableContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Update_tableContext) From_clause() IFrom_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_clauseContext)
}

func (s *Update_tableContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Update_tableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Update_tableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Update_tableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterUpdate_table(s)
	}
}

func (s *Update_tableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitUpdate_table(s)
	}
}

func (p *HplsqlParser) Update_table() (localctx IUpdate_tableContext) {
	localctx = NewUpdate_tableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, HplsqlParserRULE_update_table)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(2694)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_SUB, HplsqlParserL_ID:
		{
			p.SetState(2686)
			p.Table_name()
		}
		p.SetState(2688)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 325, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2687)
				p.From_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case HplsqlParserT_OPEN_P:
		{
			p.SetState(2690)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2691)
			p.Select_stmt()
		}
		{
			p.SetState(2692)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(2700)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 328, p.GetParserRuleContext()) == 1 {
		p.SetState(2697)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 327, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2696)
				p.Match(HplsqlParserT_AS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2699)
			p.Qident()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdate_upsertContext is an interface to support dynamic dispatch.
type IUpdate_upsertContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ELSE() antlr.TerminalNode
	Insert_stmt() IInsert_stmtContext

	// IsUpdate_upsertContext differentiates from other interfaces.
	IsUpdate_upsertContext()
}

type Update_upsertContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdate_upsertContext() *Update_upsertContext {
	var p = new(Update_upsertContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_update_upsert
	return p
}

func InitEmptyUpdate_upsertContext(p *Update_upsertContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_update_upsert
}

func (*Update_upsertContext) IsUpdate_upsertContext() {}

func NewUpdate_upsertContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Update_upsertContext {
	var p = new(Update_upsertContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_update_upsert

	return p
}

func (s *Update_upsertContext) GetParser() antlr.Parser { return s.parser }

func (s *Update_upsertContext) T_ELSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ELSE, 0)
}

func (s *Update_upsertContext) Insert_stmt() IInsert_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_stmtContext)
}

func (s *Update_upsertContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Update_upsertContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Update_upsertContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterUpdate_upsert(s)
	}
}

func (s *Update_upsertContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitUpdate_upsert(s)
	}
}

func (p *HplsqlParser) Update_upsert() (localctx IUpdate_upsertContext) {
	localctx = NewUpdate_upsertContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, HplsqlParserRULE_update_upsert)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2702)
		p.Match(HplsqlParserT_ELSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2703)
		p.Insert_stmt()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMerge_stmtContext is an interface to support dynamic dispatch.
type IMerge_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_MERGE() antlr.TerminalNode
	T_INTO() antlr.TerminalNode
	AllMerge_table() []IMerge_tableContext
	Merge_table(i int) IMerge_tableContext
	T_USING() antlr.TerminalNode
	T_ON() antlr.TerminalNode
	Bool_expr() IBool_exprContext
	AllMerge_condition() []IMerge_conditionContext
	Merge_condition(i int) IMerge_conditionContext

	// IsMerge_stmtContext differentiates from other interfaces.
	IsMerge_stmtContext()
}

type Merge_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMerge_stmtContext() *Merge_stmtContext {
	var p = new(Merge_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_merge_stmt
	return p
}

func InitEmptyMerge_stmtContext(p *Merge_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_merge_stmt
}

func (*Merge_stmtContext) IsMerge_stmtContext() {}

func NewMerge_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Merge_stmtContext {
	var p = new(Merge_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_merge_stmt

	return p
}

func (s *Merge_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Merge_stmtContext) T_MERGE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MERGE, 0)
}

func (s *Merge_stmtContext) T_INTO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTO, 0)
}

func (s *Merge_stmtContext) AllMerge_table() []IMerge_tableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMerge_tableContext); ok {
			len++
		}
	}

	tst := make([]IMerge_tableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMerge_tableContext); ok {
			tst[i] = t.(IMerge_tableContext)
			i++
		}
	}

	return tst
}

func (s *Merge_stmtContext) Merge_table(i int) IMerge_tableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMerge_tableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMerge_tableContext)
}

func (s *Merge_stmtContext) T_USING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_USING, 0)
}

func (s *Merge_stmtContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *Merge_stmtContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *Merge_stmtContext) AllMerge_condition() []IMerge_conditionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMerge_conditionContext); ok {
			len++
		}
	}

	tst := make([]IMerge_conditionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMerge_conditionContext); ok {
			tst[i] = t.(IMerge_conditionContext)
			i++
		}
	}

	return tst
}

func (s *Merge_stmtContext) Merge_condition(i int) IMerge_conditionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMerge_conditionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMerge_conditionContext)
}

func (s *Merge_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Merge_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Merge_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterMerge_stmt(s)
	}
}

func (s *Merge_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitMerge_stmt(s)
	}
}

func (p *HplsqlParser) Merge_stmt() (localctx IMerge_stmtContext) {
	localctx = NewMerge_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, HplsqlParserRULE_merge_stmt)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2705)
		p.Match(HplsqlParserT_MERGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2706)
		p.Match(HplsqlParserT_INTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2707)
		p.Merge_table()
	}
	{
		p.SetState(2708)
		p.Match(HplsqlParserT_USING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2709)
		p.Merge_table()
	}
	{
		p.SetState(2710)
		p.Match(HplsqlParserT_ON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2711)
		p.bool_expr(0)
	}
	p.SetState(2713)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(2712)
				p.Merge_condition()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(2715)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 329, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMerge_tableContext is an interface to support dynamic dispatch.
type IMerge_tableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Table_name() ITable_nameContext
	Qident() IQidentContext
	T_OPEN_P() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	T_CLOSE_P() antlr.TerminalNode
	T_AS() antlr.TerminalNode

	// IsMerge_tableContext differentiates from other interfaces.
	IsMerge_tableContext()
}

type Merge_tableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMerge_tableContext() *Merge_tableContext {
	var p = new(Merge_tableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_merge_table
	return p
}

func InitEmptyMerge_tableContext(p *Merge_tableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_merge_table
}

func (*Merge_tableContext) IsMerge_tableContext() {}

func NewMerge_tableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Merge_tableContext {
	var p = new(Merge_tableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_merge_table

	return p
}

func (s *Merge_tableContext) GetParser() antlr.Parser { return s.parser }

func (s *Merge_tableContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Merge_tableContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Merge_tableContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Merge_tableContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Merge_tableContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Merge_tableContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Merge_tableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Merge_tableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Merge_tableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterMerge_table(s)
	}
}

func (s *Merge_tableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitMerge_table(s)
	}
}

func (p *HplsqlParser) Merge_table() (localctx IMerge_tableContext) {
	localctx = NewMerge_tableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, HplsqlParserRULE_merge_table)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(2722)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_SUB, HplsqlParserL_ID:
		{
			p.SetState(2717)
			p.Table_name()
		}

	case HplsqlParserT_OPEN_P:
		{
			p.SetState(2718)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2719)
			p.Select_stmt()
		}
		{
			p.SetState(2720)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(2728)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 332, p.GetParserRuleContext()) == 1 {
		p.SetState(2725)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 331, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2724)
				p.Match(HplsqlParserT_AS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2727)
			p.Qident()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMerge_conditionContext is an interface to support dynamic dispatch.
type IMerge_conditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_WHEN() antlr.TerminalNode
	T_MATCHED() antlr.TerminalNode
	T_THEN() antlr.TerminalNode
	Merge_action() IMerge_actionContext
	T_NOT() antlr.TerminalNode
	T_AND() antlr.TerminalNode
	Bool_expr() IBool_exprContext
	T_ELSE() antlr.TerminalNode
	T_IGNORE() antlr.TerminalNode

	// IsMerge_conditionContext differentiates from other interfaces.
	IsMerge_conditionContext()
}

type Merge_conditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMerge_conditionContext() *Merge_conditionContext {
	var p = new(Merge_conditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_merge_condition
	return p
}

func InitEmptyMerge_conditionContext(p *Merge_conditionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_merge_condition
}

func (*Merge_conditionContext) IsMerge_conditionContext() {}

func NewMerge_conditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Merge_conditionContext {
	var p = new(Merge_conditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_merge_condition

	return p
}

func (s *Merge_conditionContext) GetParser() antlr.Parser { return s.parser }

func (s *Merge_conditionContext) T_WHEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WHEN, 0)
}

func (s *Merge_conditionContext) T_MATCHED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MATCHED, 0)
}

func (s *Merge_conditionContext) T_THEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_THEN, 0)
}

func (s *Merge_conditionContext) Merge_action() IMerge_actionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMerge_actionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMerge_actionContext)
}

func (s *Merge_conditionContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Merge_conditionContext) T_AND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AND, 0)
}

func (s *Merge_conditionContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *Merge_conditionContext) T_ELSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ELSE, 0)
}

func (s *Merge_conditionContext) T_IGNORE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IGNORE, 0)
}

func (s *Merge_conditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Merge_conditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Merge_conditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterMerge_condition(s)
	}
}

func (s *Merge_conditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitMerge_condition(s)
	}
}

func (p *HplsqlParser) Merge_condition() (localctx IMerge_conditionContext) {
	localctx = NewMerge_conditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, HplsqlParserRULE_merge_condition)
	var _la int

	p.SetState(2743)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_WHEN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2730)
			p.Match(HplsqlParserT_WHEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2732)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_NOT {
			{
				p.SetState(2731)
				p.Match(HplsqlParserT_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2734)
			p.Match(HplsqlParserT_MATCHED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2737)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_AND {
			{
				p.SetState(2735)
				p.Match(HplsqlParserT_AND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2736)
				p.bool_expr(0)
			}

		}
		{
			p.SetState(2739)
			p.Match(HplsqlParserT_THEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2740)
			p.Merge_action()
		}

	case HplsqlParserT_ELSE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2741)
			p.Match(HplsqlParserT_ELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2742)
			p.Match(HplsqlParserT_IGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMerge_actionContext is an interface to support dynamic dispatch.
type IMerge_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_INSERT() antlr.TerminalNode
	T_VALUES() antlr.TerminalNode
	Insert_stmt_row() IInsert_stmt_rowContext
	Insert_stmt_cols() IInsert_stmt_colsContext
	T_UPDATE() antlr.TerminalNode
	T_SET() antlr.TerminalNode
	AllAssignment_stmt_item() []IAssignment_stmt_itemContext
	Assignment_stmt_item(i int) IAssignment_stmt_itemContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	Where_clause() IWhere_clauseContext
	T_DELETE() antlr.TerminalNode

	// IsMerge_actionContext differentiates from other interfaces.
	IsMerge_actionContext()
}

type Merge_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMerge_actionContext() *Merge_actionContext {
	var p = new(Merge_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_merge_action
	return p
}

func InitEmptyMerge_actionContext(p *Merge_actionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_merge_action
}

func (*Merge_actionContext) IsMerge_actionContext() {}

func NewMerge_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Merge_actionContext {
	var p = new(Merge_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_merge_action

	return p
}

func (s *Merge_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Merge_actionContext) T_INSERT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INSERT, 0)
}

func (s *Merge_actionContext) T_VALUES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VALUES, 0)
}

func (s *Merge_actionContext) Insert_stmt_row() IInsert_stmt_rowContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_stmt_rowContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_stmt_rowContext)
}

func (s *Merge_actionContext) Insert_stmt_cols() IInsert_stmt_colsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_stmt_colsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_stmt_colsContext)
}

func (s *Merge_actionContext) T_UPDATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UPDATE, 0)
}

func (s *Merge_actionContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Merge_actionContext) AllAssignment_stmt_item() []IAssignment_stmt_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignment_stmt_itemContext); ok {
			len++
		}
	}

	tst := make([]IAssignment_stmt_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignment_stmt_itemContext); ok {
			tst[i] = t.(IAssignment_stmt_itemContext)
			i++
		}
	}

	return tst
}

func (s *Merge_actionContext) Assignment_stmt_item(i int) IAssignment_stmt_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignment_stmt_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignment_stmt_itemContext)
}

func (s *Merge_actionContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Merge_actionContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Merge_actionContext) Where_clause() IWhere_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhere_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhere_clauseContext)
}

func (s *Merge_actionContext) T_DELETE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DELETE, 0)
}

func (s *Merge_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Merge_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Merge_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterMerge_action(s)
	}
}

func (s *Merge_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitMerge_action(s)
	}
}

func (p *HplsqlParser) Merge_action() (localctx IMerge_actionContext) {
	localctx = NewMerge_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, HplsqlParserRULE_merge_action)
	var _la int

	var _alt int

	p.SetState(2765)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_INSERT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2745)
			p.Match(HplsqlParserT_INSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2747)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_OPEN_P {
			{
				p.SetState(2746)
				p.Insert_stmt_cols()
			}

		}
		{
			p.SetState(2749)
			p.Match(HplsqlParserT_VALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2750)
			p.Insert_stmt_row()
		}

	case HplsqlParserT_UPDATE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2751)
			p.Match(HplsqlParserT_UPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2752)
			p.Match(HplsqlParserT_SET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2753)
			p.Assignment_stmt_item()
		}
		p.SetState(2758)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 337, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2754)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2755)
					p.Assignment_stmt_item()
				}

			}
			p.SetState(2760)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 337, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(2762)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 338, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2761)
				p.Where_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case HplsqlParserT_DELETE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2764)
			p.Match(HplsqlParserT_DELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDelete_stmtContext is an interface to support dynamic dispatch.
type IDelete_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_DELETE() antlr.TerminalNode
	Table_name() ITable_nameContext
	T_FROM() antlr.TerminalNode
	Delete_alias() IDelete_aliasContext
	Where_clause() IWhere_clauseContext
	T_ALL() antlr.TerminalNode

	// IsDelete_stmtContext differentiates from other interfaces.
	IsDelete_stmtContext()
}

type Delete_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelete_stmtContext() *Delete_stmtContext {
	var p = new(Delete_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_delete_stmt
	return p
}

func InitEmptyDelete_stmtContext(p *Delete_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_delete_stmt
}

func (*Delete_stmtContext) IsDelete_stmtContext() {}

func NewDelete_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delete_stmtContext {
	var p = new(Delete_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_delete_stmt

	return p
}

func (s *Delete_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Delete_stmtContext) T_DELETE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DELETE, 0)
}

func (s *Delete_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Delete_stmtContext) T_FROM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FROM, 0)
}

func (s *Delete_stmtContext) Delete_alias() IDelete_aliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelete_aliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelete_aliasContext)
}

func (s *Delete_stmtContext) Where_clause() IWhere_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhere_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhere_clauseContext)
}

func (s *Delete_stmtContext) T_ALL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALL, 0)
}

func (s *Delete_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delete_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delete_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDelete_stmt(s)
	}
}

func (s *Delete_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDelete_stmt(s)
	}
}

func (p *HplsqlParser) Delete_stmt() (localctx IDelete_stmtContext) {
	localctx = NewDelete_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, HplsqlParserRULE_delete_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2767)
		p.Match(HplsqlParserT_DELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2769)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 340, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2768)
			p.Match(HplsqlParserT_FROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2771)
		p.Table_name()
	}
	p.SetState(2773)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 341, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2772)
			p.Delete_alias()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2777)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 342, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2775)
			p.Where_clause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 342, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(2776)
			p.Match(HplsqlParserT_ALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDelete_aliasContext is an interface to support dynamic dispatch.
type IDelete_aliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Qident() IQidentContext
	T_AS() antlr.TerminalNode

	// IsDelete_aliasContext differentiates from other interfaces.
	IsDelete_aliasContext()
}

type Delete_aliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelete_aliasContext() *Delete_aliasContext {
	var p = new(Delete_aliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_delete_alias
	return p
}

func InitEmptyDelete_aliasContext(p *Delete_aliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_delete_alias
}

func (*Delete_aliasContext) IsDelete_aliasContext() {}

func NewDelete_aliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delete_aliasContext {
	var p = new(Delete_aliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_delete_alias

	return p
}

func (s *Delete_aliasContext) GetParser() antlr.Parser { return s.parser }

func (s *Delete_aliasContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Delete_aliasContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Delete_aliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delete_aliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delete_aliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDelete_alias(s)
	}
}

func (s *Delete_aliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDelete_alias(s)
	}
}

func (p *HplsqlParser) Delete_alias() (localctx IDelete_aliasContext) {
	localctx = NewDelete_aliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, HplsqlParserRULE_delete_alias)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(2779)

	if !(!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "ALL")) {
		p.SetError(antlr.NewFailedPredicateException(p, "!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"ALL\")", ""))
		goto errorExit
	}
	p.SetState(2781)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 343, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2780)
			p.Match(HplsqlParserT_AS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2783)
		p.Qident()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDescribe_stmtContext is an interface to support dynamic dispatch.
type IDescribe_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Table_name() ITable_nameContext
	T_DESCRIBE() antlr.TerminalNode
	T_DESC() antlr.TerminalNode
	T_TABLE() antlr.TerminalNode

	// IsDescribe_stmtContext differentiates from other interfaces.
	IsDescribe_stmtContext()
}

type Describe_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescribe_stmtContext() *Describe_stmtContext {
	var p = new(Describe_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_describe_stmt
	return p
}

func InitEmptyDescribe_stmtContext(p *Describe_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_describe_stmt
}

func (*Describe_stmtContext) IsDescribe_stmtContext() {}

func NewDescribe_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Describe_stmtContext {
	var p = new(Describe_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_describe_stmt

	return p
}

func (s *Describe_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Describe_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Describe_stmtContext) T_DESCRIBE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DESCRIBE, 0)
}

func (s *Describe_stmtContext) T_DESC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DESC, 0)
}

func (s *Describe_stmtContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLE, 0)
}

func (s *Describe_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Describe_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Describe_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDescribe_stmt(s)
	}
}

func (s *Describe_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDescribe_stmt(s)
	}
}

func (p *HplsqlParser) Describe_stmt() (localctx IDescribe_stmtContext) {
	localctx = NewDescribe_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, HplsqlParserRULE_describe_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2785)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_DESC || _la == HplsqlParserT_DESCRIBE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2787)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 344, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2786)
			p.Match(HplsqlParserT_TABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2789)
		p.Table_name()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBool_exprContext is an interface to support dynamic dispatch.
type IBool_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN_P() antlr.TerminalNode
	AllBool_expr() []IBool_exprContext
	Bool_expr(i int) IBool_exprContext
	T_CLOSE_P() antlr.TerminalNode
	T_NOT() antlr.TerminalNode
	Bool_expr_atom() IBool_expr_atomContext
	Bool_expr_logical_operator() IBool_expr_logical_operatorContext

	// IsBool_exprContext differentiates from other interfaces.
	IsBool_exprContext()
}

type Bool_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_exprContext() *Bool_exprContext {
	var p = new(Bool_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr
	return p
}

func InitEmptyBool_exprContext(p *Bool_exprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr
}

func (*Bool_exprContext) IsBool_exprContext() {}

func NewBool_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_exprContext {
	var p = new(Bool_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_bool_expr

	return p
}

func (s *Bool_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_exprContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Bool_exprContext) AllBool_expr() []IBool_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBool_exprContext); ok {
			len++
		}
	}

	tst := make([]IBool_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBool_exprContext); ok {
			tst[i] = t.(IBool_exprContext)
			i++
		}
	}

	return tst
}

func (s *Bool_exprContext) Bool_expr(i int) IBool_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *Bool_exprContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Bool_exprContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Bool_exprContext) Bool_expr_atom() IBool_expr_atomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_expr_atomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_expr_atomContext)
}

func (s *Bool_exprContext) Bool_expr_logical_operator() IBool_expr_logical_operatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_expr_logical_operatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_expr_logical_operatorContext)
}

func (s *Bool_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bool_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBool_expr(s)
	}
}

func (s *Bool_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBool_expr(s)
	}
}

func (p *HplsqlParser) Bool_expr() (localctx IBool_exprContext) {
	return p.bool_expr(0)
}

func (p *HplsqlParser) bool_expr(_p int) (localctx IBool_exprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBool_exprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBool_exprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 394
	p.EnterRecursionRule(localctx, 394, HplsqlParserRULE_bool_expr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2800)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 346, p.GetParserRuleContext()) {
	case 1:
		p.SetState(2793)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_NOT {
			{
				p.SetState(2792)
				p.Match(HplsqlParserT_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2795)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2796)
			p.bool_expr(0)
		}
		{
			p.SetState(2797)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(2799)
			p.Bool_expr_atom()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2808)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 347, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewBool_exprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, HplsqlParserRULE_bool_expr)
			p.SetState(2802)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(2803)
				p.Bool_expr_logical_operator()
			}
			{
				p.SetState(2804)
				p.bool_expr(3)
			}

		}
		p.SetState(2810)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 347, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBool_expr_atomContext is an interface to support dynamic dispatch.
type IBool_expr_atomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Bool_expr_unary() IBool_expr_unaryContext
	Bool_expr_binary() IBool_expr_binaryContext
	Expr() IExprContext

	// IsBool_expr_atomContext differentiates from other interfaces.
	IsBool_expr_atomContext()
}

type Bool_expr_atomContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_expr_atomContext() *Bool_expr_atomContext {
	var p = new(Bool_expr_atomContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_atom
	return p
}

func InitEmptyBool_expr_atomContext(p *Bool_expr_atomContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_atom
}

func (*Bool_expr_atomContext) IsBool_expr_atomContext() {}

func NewBool_expr_atomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_expr_atomContext {
	var p = new(Bool_expr_atomContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_bool_expr_atom

	return p
}

func (s *Bool_expr_atomContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_expr_atomContext) Bool_expr_unary() IBool_expr_unaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_expr_unaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_expr_unaryContext)
}

func (s *Bool_expr_atomContext) Bool_expr_binary() IBool_expr_binaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_expr_binaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_expr_binaryContext)
}

func (s *Bool_expr_atomContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Bool_expr_atomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_expr_atomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bool_expr_atomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBool_expr_atom(s)
	}
}

func (s *Bool_expr_atomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBool_expr_atom(s)
	}
}

func (p *HplsqlParser) Bool_expr_atom() (localctx IBool_expr_atomContext) {
	localctx = NewBool_expr_atomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, HplsqlParserRULE_bool_expr_atom)
	p.SetState(2814)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 348, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2811)
			p.Bool_expr_unary()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2812)
			p.Bool_expr_binary()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2813)
			p.expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBool_expr_unaryContext is an interface to support dynamic dispatch.
type IBool_expr_unaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_IS() antlr.TerminalNode
	T_NULL() antlr.TerminalNode
	T_NOT() antlr.TerminalNode
	T_BETWEEN() antlr.TerminalNode
	T_AND() antlr.TerminalNode
	T_EXISTS() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	T_CLOSE_P() antlr.TerminalNode
	Bool_expr_single_in() IBool_expr_single_inContext
	Bool_expr_multi_in() IBool_expr_multi_inContext

	// IsBool_expr_unaryContext differentiates from other interfaces.
	IsBool_expr_unaryContext()
}

type Bool_expr_unaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_expr_unaryContext() *Bool_expr_unaryContext {
	var p = new(Bool_expr_unaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_unary
	return p
}

func InitEmptyBool_expr_unaryContext(p *Bool_expr_unaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_unary
}

func (*Bool_expr_unaryContext) IsBool_expr_unaryContext() {}

func NewBool_expr_unaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_expr_unaryContext {
	var p = new(Bool_expr_unaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_bool_expr_unary

	return p
}

func (s *Bool_expr_unaryContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_expr_unaryContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Bool_expr_unaryContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Bool_expr_unaryContext) T_IS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IS, 0)
}

func (s *Bool_expr_unaryContext) T_NULL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NULL, 0)
}

func (s *Bool_expr_unaryContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Bool_expr_unaryContext) T_BETWEEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BETWEEN, 0)
}

func (s *Bool_expr_unaryContext) T_AND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AND, 0)
}

func (s *Bool_expr_unaryContext) T_EXISTS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXISTS, 0)
}

func (s *Bool_expr_unaryContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Bool_expr_unaryContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Bool_expr_unaryContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Bool_expr_unaryContext) Bool_expr_single_in() IBool_expr_single_inContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_expr_single_inContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_expr_single_inContext)
}

func (s *Bool_expr_unaryContext) Bool_expr_multi_in() IBool_expr_multi_inContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_expr_multi_inContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_expr_multi_inContext)
}

func (s *Bool_expr_unaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_expr_unaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bool_expr_unaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBool_expr_unary(s)
	}
}

func (s *Bool_expr_unaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBool_expr_unary(s)
	}
}

func (p *HplsqlParser) Bool_expr_unary() (localctx IBool_expr_unaryContext) {
	localctx = NewBool_expr_unaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, HplsqlParserRULE_bool_expr_unary)
	var _la int

	p.SetState(2839)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 351, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2816)
			p.expr(0)
		}
		{
			p.SetState(2817)
			p.Match(HplsqlParserT_IS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2819)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_NOT {
			{
				p.SetState(2818)
				p.Match(HplsqlParserT_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2821)
			p.Match(HplsqlParserT_NULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2823)
			p.expr(0)
		}
		{
			p.SetState(2824)
			p.Match(HplsqlParserT_BETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2825)
			p.expr(0)
		}
		{
			p.SetState(2826)
			p.Match(HplsqlParserT_AND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2827)
			p.expr(0)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(2830)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_NOT {
			{
				p.SetState(2829)
				p.Match(HplsqlParserT_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2832)
			p.Match(HplsqlParserT_EXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2833)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2834)
			p.Select_stmt()
		}
		{
			p.SetState(2835)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2837)
			p.Bool_expr_single_in()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2838)
			p.Bool_expr_multi_in()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBool_expr_single_inContext is an interface to support dynamic dispatch.
type IBool_expr_single_inContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_IN() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	T_NOT() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsBool_expr_single_inContext differentiates from other interfaces.
	IsBool_expr_single_inContext()
}

type Bool_expr_single_inContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_expr_single_inContext() *Bool_expr_single_inContext {
	var p = new(Bool_expr_single_inContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_single_in
	return p
}

func InitEmptyBool_expr_single_inContext(p *Bool_expr_single_inContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_single_in
}

func (*Bool_expr_single_inContext) IsBool_expr_single_inContext() {}

func NewBool_expr_single_inContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_expr_single_inContext {
	var p = new(Bool_expr_single_inContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_bool_expr_single_in

	return p
}

func (s *Bool_expr_single_inContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_expr_single_inContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Bool_expr_single_inContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Bool_expr_single_inContext) T_IN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IN, 0)
}

func (s *Bool_expr_single_inContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Bool_expr_single_inContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Bool_expr_single_inContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Bool_expr_single_inContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Bool_expr_single_inContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Bool_expr_single_inContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Bool_expr_single_inContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_expr_single_inContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bool_expr_single_inContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBool_expr_single_in(s)
	}
}

func (s *Bool_expr_single_inContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBool_expr_single_in(s)
	}
}

func (p *HplsqlParser) Bool_expr_single_in() (localctx IBool_expr_single_inContext) {
	localctx = NewBool_expr_single_inContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, HplsqlParserRULE_bool_expr_single_in)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2841)
		p.expr(0)
	}
	p.SetState(2843)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_NOT {
		{
			p.SetState(2842)
			p.Match(HplsqlParserT_NOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2845)
		p.Match(HplsqlParserT_IN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2846)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2856)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 354, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2847)
			p.expr(0)
		}
		p.SetState(2852)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(2848)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2849)
				p.expr(0)
			}

			p.SetState(2854)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		{
			p.SetState(2855)
			p.Select_stmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(2858)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBool_expr_multi_inContext is an interface to support dynamic dispatch.
type IBool_expr_multi_inContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllT_OPEN_P() []antlr.TerminalNode
	T_OPEN_P(i int) antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllT_CLOSE_P() []antlr.TerminalNode
	T_CLOSE_P(i int) antlr.TerminalNode
	T_IN() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	T_NOT() antlr.TerminalNode

	// IsBool_expr_multi_inContext differentiates from other interfaces.
	IsBool_expr_multi_inContext()
}

type Bool_expr_multi_inContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_expr_multi_inContext() *Bool_expr_multi_inContext {
	var p = new(Bool_expr_multi_inContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_multi_in
	return p
}

func InitEmptyBool_expr_multi_inContext(p *Bool_expr_multi_inContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_multi_in
}

func (*Bool_expr_multi_inContext) IsBool_expr_multi_inContext() {}

func NewBool_expr_multi_inContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_expr_multi_inContext {
	var p = new(Bool_expr_multi_inContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_bool_expr_multi_in

	return p
}

func (s *Bool_expr_multi_inContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_expr_multi_inContext) AllT_OPEN_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_OPEN_P)
}

func (s *Bool_expr_multi_inContext) T_OPEN_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, i)
}

func (s *Bool_expr_multi_inContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Bool_expr_multi_inContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Bool_expr_multi_inContext) AllT_CLOSE_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_CLOSE_P)
}

func (s *Bool_expr_multi_inContext) T_CLOSE_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, i)
}

func (s *Bool_expr_multi_inContext) T_IN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IN, 0)
}

func (s *Bool_expr_multi_inContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Bool_expr_multi_inContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Bool_expr_multi_inContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Bool_expr_multi_inContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Bool_expr_multi_inContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_expr_multi_inContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bool_expr_multi_inContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBool_expr_multi_in(s)
	}
}

func (s *Bool_expr_multi_inContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBool_expr_multi_in(s)
	}
}

func (p *HplsqlParser) Bool_expr_multi_in() (localctx IBool_expr_multi_inContext) {
	localctx = NewBool_expr_multi_inContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, HplsqlParserRULE_bool_expr_multi_in)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2860)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2861)
		p.expr(0)
	}
	p.SetState(2866)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(2862)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2863)
			p.expr(0)
		}

		p.SetState(2868)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2869)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2871)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_NOT {
		{
			p.SetState(2870)
			p.Match(HplsqlParserT_NOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2873)
		p.Match(HplsqlParserT_IN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2874)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2875)
		p.Select_stmt()
	}
	{
		p.SetState(2876)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBool_expr_binaryContext is an interface to support dynamic dispatch.
type IBool_expr_binaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	Bool_expr_binary_operator() IBool_expr_binary_operatorContext

	// IsBool_expr_binaryContext differentiates from other interfaces.
	IsBool_expr_binaryContext()
}

type Bool_expr_binaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_expr_binaryContext() *Bool_expr_binaryContext {
	var p = new(Bool_expr_binaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_binary
	return p
}

func InitEmptyBool_expr_binaryContext(p *Bool_expr_binaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_binary
}

func (*Bool_expr_binaryContext) IsBool_expr_binaryContext() {}

func NewBool_expr_binaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_expr_binaryContext {
	var p = new(Bool_expr_binaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_bool_expr_binary

	return p
}

func (s *Bool_expr_binaryContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_expr_binaryContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Bool_expr_binaryContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Bool_expr_binaryContext) Bool_expr_binary_operator() IBool_expr_binary_operatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_expr_binary_operatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_expr_binary_operatorContext)
}

func (s *Bool_expr_binaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_expr_binaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bool_expr_binaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBool_expr_binary(s)
	}
}

func (s *Bool_expr_binaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBool_expr_binary(s)
	}
}

func (p *HplsqlParser) Bool_expr_binary() (localctx IBool_expr_binaryContext) {
	localctx = NewBool_expr_binaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, HplsqlParserRULE_bool_expr_binary)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2878)
		p.expr(0)
	}
	{
		p.SetState(2879)
		p.Bool_expr_binary_operator()
	}
	{
		p.SetState(2880)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBool_expr_logical_operatorContext is an interface to support dynamic dispatch.
type IBool_expr_logical_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_AND() antlr.TerminalNode
	T_OR() antlr.TerminalNode

	// IsBool_expr_logical_operatorContext differentiates from other interfaces.
	IsBool_expr_logical_operatorContext()
}

type Bool_expr_logical_operatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_expr_logical_operatorContext() *Bool_expr_logical_operatorContext {
	var p = new(Bool_expr_logical_operatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_logical_operator
	return p
}

func InitEmptyBool_expr_logical_operatorContext(p *Bool_expr_logical_operatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_logical_operator
}

func (*Bool_expr_logical_operatorContext) IsBool_expr_logical_operatorContext() {}

func NewBool_expr_logical_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_expr_logical_operatorContext {
	var p = new(Bool_expr_logical_operatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_bool_expr_logical_operator

	return p
}

func (s *Bool_expr_logical_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_expr_logical_operatorContext) T_AND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AND, 0)
}

func (s *Bool_expr_logical_operatorContext) T_OR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OR, 0)
}

func (s *Bool_expr_logical_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_expr_logical_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bool_expr_logical_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBool_expr_logical_operator(s)
	}
}

func (s *Bool_expr_logical_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBool_expr_logical_operator(s)
	}
}

func (p *HplsqlParser) Bool_expr_logical_operator() (localctx IBool_expr_logical_operatorContext) {
	localctx = NewBool_expr_logical_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, HplsqlParserRULE_bool_expr_logical_operator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2882)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_AND || _la == HplsqlParserT_OR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBool_expr_binary_operatorContext is an interface to support dynamic dispatch.
type IBool_expr_binary_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_EQUAL() antlr.TerminalNode
	T_EQUAL2() antlr.TerminalNode
	T_NOTEQUAL() antlr.TerminalNode
	T_NOTEQUAL2() antlr.TerminalNode
	T_LESS() antlr.TerminalNode
	T_LESSEQUAL() antlr.TerminalNode
	T_GREATER() antlr.TerminalNode
	T_GREATEREQUAL() antlr.TerminalNode
	T_LIKE() antlr.TerminalNode
	T_RLIKE() antlr.TerminalNode
	T_REGEXP() antlr.TerminalNode
	T_NOT() antlr.TerminalNode

	// IsBool_expr_binary_operatorContext differentiates from other interfaces.
	IsBool_expr_binary_operatorContext()
}

type Bool_expr_binary_operatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_expr_binary_operatorContext() *Bool_expr_binary_operatorContext {
	var p = new(Bool_expr_binary_operatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_binary_operator
	return p
}

func InitEmptyBool_expr_binary_operatorContext(p *Bool_expr_binary_operatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_binary_operator
}

func (*Bool_expr_binary_operatorContext) IsBool_expr_binary_operatorContext() {}

func NewBool_expr_binary_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_expr_binary_operatorContext {
	var p = new(Bool_expr_binary_operatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_bool_expr_binary_operator

	return p
}

func (s *Bool_expr_binary_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_expr_binary_operatorContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Bool_expr_binary_operatorContext) T_EQUAL2() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL2, 0)
}

func (s *Bool_expr_binary_operatorContext) T_NOTEQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOTEQUAL, 0)
}

func (s *Bool_expr_binary_operatorContext) T_NOTEQUAL2() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOTEQUAL2, 0)
}

func (s *Bool_expr_binary_operatorContext) T_LESS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LESS, 0)
}

func (s *Bool_expr_binary_operatorContext) T_LESSEQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LESSEQUAL, 0)
}

func (s *Bool_expr_binary_operatorContext) T_GREATER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GREATER, 0)
}

func (s *Bool_expr_binary_operatorContext) T_GREATEREQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GREATEREQUAL, 0)
}

func (s *Bool_expr_binary_operatorContext) T_LIKE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LIKE, 0)
}

func (s *Bool_expr_binary_operatorContext) T_RLIKE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RLIKE, 0)
}

func (s *Bool_expr_binary_operatorContext) T_REGEXP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REGEXP, 0)
}

func (s *Bool_expr_binary_operatorContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Bool_expr_binary_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_expr_binary_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bool_expr_binary_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBool_expr_binary_operator(s)
	}
}

func (s *Bool_expr_binary_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBool_expr_binary_operator(s)
	}
}

func (p *HplsqlParser) Bool_expr_binary_operator() (localctx IBool_expr_binary_operatorContext) {
	localctx = NewBool_expr_binary_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, HplsqlParserRULE_bool_expr_binary_operator)
	var _la int

	p.SetState(2896)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_EQUAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2884)
			p.Match(HplsqlParserT_EQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_EQUAL2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2885)
			p.Match(HplsqlParserT_EQUAL2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_NOTEQUAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2886)
			p.Match(HplsqlParserT_NOTEQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_NOTEQUAL2:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2887)
			p.Match(HplsqlParserT_NOTEQUAL2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_LESS:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2888)
			p.Match(HplsqlParserT_LESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_LESSEQUAL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2889)
			p.Match(HplsqlParserT_LESSEQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_GREATER:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2890)
			p.Match(HplsqlParserT_GREATER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_GREATEREQUAL:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2891)
			p.Match(HplsqlParserT_GREATEREQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_LIKE, HplsqlParserT_NOT, HplsqlParserT_REGEXP, HplsqlParserT_RLIKE:
		p.EnterOuterAlt(localctx, 9)
		p.SetState(2893)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_NOT {
			{
				p.SetState(2892)
				p.Match(HplsqlParserT_NOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2895)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_LIKE || _la == HplsqlParserT_REGEXP || _la == HplsqlParserT_RLIKE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN_P() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	T_CLOSE_P() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	Expr_interval() IExpr_intervalContext
	Expr_concat() IExpr_concatContext
	Expr_dot() IExpr_dotContext
	Expr_case() IExpr_caseContext
	Expr_cursor_attribute() IExpr_cursor_attributeContext
	Expr_agg_window_func() IExpr_agg_window_funcContext
	Expr_spec_func() IExpr_spec_funcContext
	Expr_func() IExpr_funcContext
	Expr_atom() IExpr_atomContext
	T_MUL() antlr.TerminalNode
	T_DIV() antlr.TerminalNode
	T_ADD() antlr.TerminalNode
	T_SUB() antlr.TerminalNode
	Interval_item() IInterval_itemContext

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr
	return p
}

func InitEmptyExprContext(p *ExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *ExprContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *ExprContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *ExprContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ExprContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprContext) Expr_interval() IExpr_intervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_intervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_intervalContext)
}

func (s *ExprContext) Expr_concat() IExpr_concatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_concatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_concatContext)
}

func (s *ExprContext) Expr_dot() IExpr_dotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_dotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_dotContext)
}

func (s *ExprContext) Expr_case() IExpr_caseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_caseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_caseContext)
}

func (s *ExprContext) Expr_cursor_attribute() IExpr_cursor_attributeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_cursor_attributeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_cursor_attributeContext)
}

func (s *ExprContext) Expr_agg_window_func() IExpr_agg_window_funcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_agg_window_funcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_agg_window_funcContext)
}

func (s *ExprContext) Expr_spec_func() IExpr_spec_funcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_spec_funcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_spec_funcContext)
}

func (s *ExprContext) Expr_func() IExpr_funcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_funcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_funcContext)
}

func (s *ExprContext) Expr_atom() IExpr_atomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_atomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_atomContext)
}

func (s *ExprContext) T_MUL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MUL, 0)
}

func (s *ExprContext) T_DIV() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DIV, 0)
}

func (s *ExprContext) T_ADD() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ADD, 0)
}

func (s *ExprContext) T_SUB() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUB, 0)
}

func (s *ExprContext) Interval_item() IInterval_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterval_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterval_itemContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr(s)
	}
}

func (p *HplsqlParser) Expr() (localctx IExprContext) {
	return p.expr(0)
}

func (p *HplsqlParser) expr(_p int) (localctx IExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 410
	p.EnterRecursionRule(localctx, 410, HplsqlParserRULE_expr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2916)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 359, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2899)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2900)
			p.Select_stmt()
		}
		{
			p.SetState(2901)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(2903)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2904)
			p.expr(0)
		}
		{
			p.SetState(2905)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(2907)
			p.Expr_interval()
		}

	case 4:
		{
			p.SetState(2908)
			p.Expr_concat()
		}

	case 5:
		{
			p.SetState(2909)
			p.Expr_dot()
		}

	case 6:
		{
			p.SetState(2910)
			p.Expr_case()
		}

	case 7:
		{
			p.SetState(2911)
			p.Expr_cursor_attribute()
		}

	case 8:
		{
			p.SetState(2912)
			p.Expr_agg_window_func()
		}

	case 9:
		{
			p.SetState(2913)
			p.Expr_spec_func()
		}

	case 10:
		{
			p.SetState(2914)
			p.Expr_func()
		}

	case 11:
		{
			p.SetState(2915)
			p.Expr_atom()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2928)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 361, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(2926)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 360, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, HplsqlParserRULE_expr)
				p.SetState(2918)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
					goto errorExit
				}
				{
					p.SetState(2919)
					_la = p.GetTokenStream().LA(1)

					if !(_la == HplsqlParserT_DIV || _la == HplsqlParserT_MUL) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(2920)
					p.expr(14)
				}

			case 2:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, HplsqlParserRULE_expr)
				p.SetState(2921)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
					goto errorExit
				}
				{
					p.SetState(2922)
					_la = p.GetTokenStream().LA(1)

					if !(_la == HplsqlParserT_ADD || _la == HplsqlParserT_SUB) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(2923)
					p.expr(13)
				}

			case 3:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, HplsqlParserRULE_expr)
				p.SetState(2924)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
					goto errorExit
				}
				{
					p.SetState(2925)
					p.Interval_item()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(2930)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 361, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_atomContext is an interface to support dynamic dispatch.
type IExpr_atomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Date_literal() IDate_literalContext
	Timestamp_literal() ITimestamp_literalContext
	Bool_literal() IBool_literalContext
	Qident() IQidentContext
	String_() IStringContext
	Dec_number() IDec_numberContext
	Int_number() IInt_numberContext
	Null_const() INull_constContext

	// IsExpr_atomContext differentiates from other interfaces.
	IsExpr_atomContext()
}

type Expr_atomContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_atomContext() *Expr_atomContext {
	var p = new(Expr_atomContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_atom
	return p
}

func InitEmptyExpr_atomContext(p *Expr_atomContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_atom
}

func (*Expr_atomContext) IsExpr_atomContext() {}

func NewExpr_atomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_atomContext {
	var p = new(Expr_atomContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_atom

	return p
}

func (s *Expr_atomContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_atomContext) Date_literal() IDate_literalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDate_literalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDate_literalContext)
}

func (s *Expr_atomContext) Timestamp_literal() ITimestamp_literalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimestamp_literalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimestamp_literalContext)
}

func (s *Expr_atomContext) Bool_literal() IBool_literalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_literalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_literalContext)
}

func (s *Expr_atomContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Expr_atomContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *Expr_atomContext) Dec_number() IDec_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDec_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDec_numberContext)
}

func (s *Expr_atomContext) Int_number() IInt_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInt_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInt_numberContext)
}

func (s *Expr_atomContext) Null_const() INull_constContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INull_constContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INull_constContext)
}

func (s *Expr_atomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_atomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_atomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_atom(s)
	}
}

func (s *Expr_atomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_atom(s)
	}
}

func (p *HplsqlParser) Expr_atom() (localctx IExpr_atomContext) {
	localctx = NewExpr_atomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, HplsqlParserRULE_expr_atom)
	p.SetState(2939)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 362, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2931)
			p.Date_literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2932)
			p.Timestamp_literal()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2933)
			p.Bool_literal()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2934)
			p.Qident()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2935)
			p.String_()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2936)
			p.Dec_number()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2937)
			p.Int_number()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2938)
			p.Null_const()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_intervalContext is an interface to support dynamic dispatch.
type IExpr_intervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_INTERVAL() antlr.TerminalNode
	Expr() IExprContext
	Interval_item() IInterval_itemContext

	// IsExpr_intervalContext differentiates from other interfaces.
	IsExpr_intervalContext()
}

type Expr_intervalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_intervalContext() *Expr_intervalContext {
	var p = new(Expr_intervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_interval
	return p
}

func InitEmptyExpr_intervalContext(p *Expr_intervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_interval
}

func (*Expr_intervalContext) IsExpr_intervalContext() {}

func NewExpr_intervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_intervalContext {
	var p = new(Expr_intervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_interval

	return p
}

func (s *Expr_intervalContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_intervalContext) T_INTERVAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTERVAL, 0)
}

func (s *Expr_intervalContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_intervalContext) Interval_item() IInterval_itemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterval_itemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterval_itemContext)
}

func (s *Expr_intervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_intervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_intervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_interval(s)
	}
}

func (s *Expr_intervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_interval(s)
	}
}

func (p *HplsqlParser) Expr_interval() (localctx IExpr_intervalContext) {
	localctx = NewExpr_intervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, HplsqlParserRULE_expr_interval)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2941)
		p.Match(HplsqlParserT_INTERVAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2942)
		p.expr(0)
	}
	{
		p.SetState(2943)
		p.Interval_item()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterval_itemContext is an interface to support dynamic dispatch.
type IInterval_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_DAY() antlr.TerminalNode
	T_DAYS() antlr.TerminalNode
	T_MICROSECOND() antlr.TerminalNode
	T_MICROSECONDS() antlr.TerminalNode
	T_SECOND() antlr.TerminalNode
	T_SECONDS() antlr.TerminalNode

	// IsInterval_itemContext differentiates from other interfaces.
	IsInterval_itemContext()
}

type Interval_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterval_itemContext() *Interval_itemContext {
	var p = new(Interval_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_interval_item
	return p
}

func InitEmptyInterval_itemContext(p *Interval_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_interval_item
}

func (*Interval_itemContext) IsInterval_itemContext() {}

func NewInterval_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interval_itemContext {
	var p = new(Interval_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_interval_item

	return p
}

func (s *Interval_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Interval_itemContext) T_DAY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DAY, 0)
}

func (s *Interval_itemContext) T_DAYS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DAYS, 0)
}

func (s *Interval_itemContext) T_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MICROSECOND, 0)
}

func (s *Interval_itemContext) T_MICROSECONDS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MICROSECONDS, 0)
}

func (s *Interval_itemContext) T_SECOND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SECOND, 0)
}

func (s *Interval_itemContext) T_SECONDS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SECONDS, 0)
}

func (s *Interval_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interval_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interval_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterInterval_item(s)
	}
}

func (s *Interval_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitInterval_item(s)
	}
}

func (p *HplsqlParser) Interval_item() (localctx IInterval_itemContext) {
	localctx = NewInterval_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, HplsqlParserRULE_interval_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2945)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_DAY || _la == HplsqlParserT_DAYS || _la == HplsqlParserT_MICROSECOND || _la == HplsqlParserT_MICROSECONDS || _la == HplsqlParserT_SECOND || _la == HplsqlParserT_SECONDS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_concatContext is an interface to support dynamic dispatch.
type IExpr_concatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr_concat_item() []IExpr_concat_itemContext
	Expr_concat_item(i int) IExpr_concat_itemContext
	AllT_PIPE() []antlr.TerminalNode
	T_PIPE(i int) antlr.TerminalNode
	AllT_CONCAT() []antlr.TerminalNode
	T_CONCAT(i int) antlr.TerminalNode

	// IsExpr_concatContext differentiates from other interfaces.
	IsExpr_concatContext()
}

type Expr_concatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_concatContext() *Expr_concatContext {
	var p = new(Expr_concatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_concat
	return p
}

func InitEmptyExpr_concatContext(p *Expr_concatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_concat
}

func (*Expr_concatContext) IsExpr_concatContext() {}

func NewExpr_concatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_concatContext {
	var p = new(Expr_concatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_concat

	return p
}

func (s *Expr_concatContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_concatContext) AllExpr_concat_item() []IExpr_concat_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpr_concat_itemContext); ok {
			len++
		}
	}

	tst := make([]IExpr_concat_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpr_concat_itemContext); ok {
			tst[i] = t.(IExpr_concat_itemContext)
			i++
		}
	}

	return tst
}

func (s *Expr_concatContext) Expr_concat_item(i int) IExpr_concat_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_concat_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_concat_itemContext)
}

func (s *Expr_concatContext) AllT_PIPE() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_PIPE)
}

func (s *Expr_concatContext) T_PIPE(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PIPE, i)
}

func (s *Expr_concatContext) AllT_CONCAT() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_CONCAT)
}

func (s *Expr_concatContext) T_CONCAT(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONCAT, i)
}

func (s *Expr_concatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_concatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_concatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_concat(s)
	}
}

func (s *Expr_concatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_concat(s)
	}
}

func (p *HplsqlParser) Expr_concat() (localctx IExpr_concatContext) {
	localctx = NewExpr_concatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, HplsqlParserRULE_expr_concat)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2947)
		p.Expr_concat_item()
	}
	{
		p.SetState(2948)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_CONCAT || _la == HplsqlParserT_PIPE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2949)
		p.Expr_concat_item()
	}
	p.SetState(2954)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 363, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2950)
				_la = p.GetTokenStream().LA(1)

				if !(_la == HplsqlParserT_CONCAT || _la == HplsqlParserT_PIPE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2951)
				p.Expr_concat_item()
			}

		}
		p.SetState(2956)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 363, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_concat_itemContext is an interface to support dynamic dispatch.
type IExpr_concat_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN_P() antlr.TerminalNode
	Expr() IExprContext
	T_CLOSE_P() antlr.TerminalNode
	Expr_case() IExpr_caseContext
	Expr_agg_window_func() IExpr_agg_window_funcContext
	Expr_spec_func() IExpr_spec_funcContext
	Expr_dot() IExpr_dotContext
	Expr_func() IExpr_funcContext
	Expr_atom() IExpr_atomContext

	// IsExpr_concat_itemContext differentiates from other interfaces.
	IsExpr_concat_itemContext()
}

type Expr_concat_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_concat_itemContext() *Expr_concat_itemContext {
	var p = new(Expr_concat_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_concat_item
	return p
}

func InitEmptyExpr_concat_itemContext(p *Expr_concat_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_concat_item
}

func (*Expr_concat_itemContext) IsExpr_concat_itemContext() {}

func NewExpr_concat_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_concat_itemContext {
	var p = new(Expr_concat_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_concat_item

	return p
}

func (s *Expr_concat_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_concat_itemContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Expr_concat_itemContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_concat_itemContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Expr_concat_itemContext) Expr_case() IExpr_caseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_caseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_caseContext)
}

func (s *Expr_concat_itemContext) Expr_agg_window_func() IExpr_agg_window_funcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_agg_window_funcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_agg_window_funcContext)
}

func (s *Expr_concat_itemContext) Expr_spec_func() IExpr_spec_funcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_spec_funcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_spec_funcContext)
}

func (s *Expr_concat_itemContext) Expr_dot() IExpr_dotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_dotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_dotContext)
}

func (s *Expr_concat_itemContext) Expr_func() IExpr_funcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_funcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_funcContext)
}

func (s *Expr_concat_itemContext) Expr_atom() IExpr_atomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_atomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_atomContext)
}

func (s *Expr_concat_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_concat_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_concat_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_concat_item(s)
	}
}

func (s *Expr_concat_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_concat_item(s)
	}
}

func (p *HplsqlParser) Expr_concat_item() (localctx IExpr_concat_itemContext) {
	localctx = NewExpr_concat_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, HplsqlParserRULE_expr_concat_item)
	p.SetState(2967)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 364, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2957)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2958)
			p.expr(0)
		}
		{
			p.SetState(2959)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2961)
			p.Expr_case()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2962)
			p.Expr_agg_window_func()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2963)
			p.Expr_spec_func()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2964)
			p.Expr_dot()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2965)
			p.Expr_func()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2966)
			p.Expr_atom()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_caseContext is an interface to support dynamic dispatch.
type IExpr_caseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr_case_simple() IExpr_case_simpleContext
	Expr_case_searched() IExpr_case_searchedContext

	// IsExpr_caseContext differentiates from other interfaces.
	IsExpr_caseContext()
}

type Expr_caseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_caseContext() *Expr_caseContext {
	var p = new(Expr_caseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_case
	return p
}

func InitEmptyExpr_caseContext(p *Expr_caseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_case
}

func (*Expr_caseContext) IsExpr_caseContext() {}

func NewExpr_caseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_caseContext {
	var p = new(Expr_caseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_case

	return p
}

func (s *Expr_caseContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_caseContext) Expr_case_simple() IExpr_case_simpleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_case_simpleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_case_simpleContext)
}

func (s *Expr_caseContext) Expr_case_searched() IExpr_case_searchedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_case_searchedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_case_searchedContext)
}

func (s *Expr_caseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_caseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_caseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_case(s)
	}
}

func (s *Expr_caseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_case(s)
	}
}

func (p *HplsqlParser) Expr_case() (localctx IExpr_caseContext) {
	localctx = NewExpr_caseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, HplsqlParserRULE_expr_case)
	p.SetState(2971)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 365, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2969)
			p.Expr_case_simple()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2970)
			p.Expr_case_searched()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_case_simpleContext is an interface to support dynamic dispatch.
type IExpr_case_simpleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_CASE() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_END() antlr.TerminalNode
	AllT_WHEN() []antlr.TerminalNode
	T_WHEN(i int) antlr.TerminalNode
	AllT_THEN() []antlr.TerminalNode
	T_THEN(i int) antlr.TerminalNode
	T_ELSE() antlr.TerminalNode

	// IsExpr_case_simpleContext differentiates from other interfaces.
	IsExpr_case_simpleContext()
}

type Expr_case_simpleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_case_simpleContext() *Expr_case_simpleContext {
	var p = new(Expr_case_simpleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_case_simple
	return p
}

func InitEmptyExpr_case_simpleContext(p *Expr_case_simpleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_case_simple
}

func (*Expr_case_simpleContext) IsExpr_case_simpleContext() {}

func NewExpr_case_simpleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_case_simpleContext {
	var p = new(Expr_case_simpleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_case_simple

	return p
}

func (s *Expr_case_simpleContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_case_simpleContext) T_CASE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CASE, 0)
}

func (s *Expr_case_simpleContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Expr_case_simpleContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_case_simpleContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *Expr_case_simpleContext) AllT_WHEN() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_WHEN)
}

func (s *Expr_case_simpleContext) T_WHEN(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WHEN, i)
}

func (s *Expr_case_simpleContext) AllT_THEN() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_THEN)
}

func (s *Expr_case_simpleContext) T_THEN(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_THEN, i)
}

func (s *Expr_case_simpleContext) T_ELSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ELSE, 0)
}

func (s *Expr_case_simpleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_case_simpleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_case_simpleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_case_simple(s)
	}
}

func (s *Expr_case_simpleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_case_simple(s)
	}
}

func (p *HplsqlParser) Expr_case_simple() (localctx IExpr_case_simpleContext) {
	localctx = NewExpr_case_simpleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, HplsqlParserRULE_expr_case_simple)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2973)
		p.Match(HplsqlParserT_CASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2974)
		p.expr(0)
	}
	p.SetState(2980)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == HplsqlParserT_WHEN {
		{
			p.SetState(2975)
			p.Match(HplsqlParserT_WHEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2976)
			p.expr(0)
		}
		{
			p.SetState(2977)
			p.Match(HplsqlParserT_THEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2978)
			p.expr(0)
		}

		p.SetState(2982)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2986)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_ELSE {
		{
			p.SetState(2984)
			p.Match(HplsqlParserT_ELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2985)
			p.expr(0)
		}

	}
	{
		p.SetState(2988)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_case_searchedContext is an interface to support dynamic dispatch.
type IExpr_case_searchedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_CASE() antlr.TerminalNode
	T_END() antlr.TerminalNode
	AllT_WHEN() []antlr.TerminalNode
	T_WHEN(i int) antlr.TerminalNode
	AllBool_expr() []IBool_exprContext
	Bool_expr(i int) IBool_exprContext
	AllT_THEN() []antlr.TerminalNode
	T_THEN(i int) antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_ELSE() antlr.TerminalNode

	// IsExpr_case_searchedContext differentiates from other interfaces.
	IsExpr_case_searchedContext()
}

type Expr_case_searchedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_case_searchedContext() *Expr_case_searchedContext {
	var p = new(Expr_case_searchedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_case_searched
	return p
}

func InitEmptyExpr_case_searchedContext(p *Expr_case_searchedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_case_searched
}

func (*Expr_case_searchedContext) IsExpr_case_searchedContext() {}

func NewExpr_case_searchedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_case_searchedContext {
	var p = new(Expr_case_searchedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_case_searched

	return p
}

func (s *Expr_case_searchedContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_case_searchedContext) T_CASE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CASE, 0)
}

func (s *Expr_case_searchedContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *Expr_case_searchedContext) AllT_WHEN() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_WHEN)
}

func (s *Expr_case_searchedContext) T_WHEN(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WHEN, i)
}

func (s *Expr_case_searchedContext) AllBool_expr() []IBool_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBool_exprContext); ok {
			len++
		}
	}

	tst := make([]IBool_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBool_exprContext); ok {
			tst[i] = t.(IBool_exprContext)
			i++
		}
	}

	return tst
}

func (s *Expr_case_searchedContext) Bool_expr(i int) IBool_exprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *Expr_case_searchedContext) AllT_THEN() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_THEN)
}

func (s *Expr_case_searchedContext) T_THEN(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_THEN, i)
}

func (s *Expr_case_searchedContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Expr_case_searchedContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_case_searchedContext) T_ELSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ELSE, 0)
}

func (s *Expr_case_searchedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_case_searchedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_case_searchedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_case_searched(s)
	}
}

func (s *Expr_case_searchedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_case_searched(s)
	}
}

func (p *HplsqlParser) Expr_case_searched() (localctx IExpr_case_searchedContext) {
	localctx = NewExpr_case_searchedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, HplsqlParserRULE_expr_case_searched)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2990)
		p.Match(HplsqlParserT_CASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2996)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == HplsqlParserT_WHEN {
		{
			p.SetState(2991)
			p.Match(HplsqlParserT_WHEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2992)
			p.bool_expr(0)
		}
		{
			p.SetState(2993)
			p.Match(HplsqlParserT_THEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2994)
			p.expr(0)
		}

		p.SetState(2998)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3002)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_ELSE {
		{
			p.SetState(3000)
			p.Match(HplsqlParserT_ELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3001)
			p.expr(0)
		}

	}
	{
		p.SetState(3004)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_cursor_attributeContext is an interface to support dynamic dispatch.
type IExpr_cursor_attributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ident() IIdentContext
	T_ISOPEN() antlr.TerminalNode
	T_FOUND() antlr.TerminalNode
	T_NOTFOUND() antlr.TerminalNode

	// IsExpr_cursor_attributeContext differentiates from other interfaces.
	IsExpr_cursor_attributeContext()
}

type Expr_cursor_attributeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_cursor_attributeContext() *Expr_cursor_attributeContext {
	var p = new(Expr_cursor_attributeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_cursor_attribute
	return p
}

func InitEmptyExpr_cursor_attributeContext(p *Expr_cursor_attributeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_cursor_attribute
}

func (*Expr_cursor_attributeContext) IsExpr_cursor_attributeContext() {}

func NewExpr_cursor_attributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_cursor_attributeContext {
	var p = new(Expr_cursor_attributeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_cursor_attribute

	return p
}

func (s *Expr_cursor_attributeContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_cursor_attributeContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Expr_cursor_attributeContext) T_ISOPEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ISOPEN, 0)
}

func (s *Expr_cursor_attributeContext) T_FOUND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOUND, 0)
}

func (s *Expr_cursor_attributeContext) T_NOTFOUND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOTFOUND, 0)
}

func (s *Expr_cursor_attributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_cursor_attributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_cursor_attributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_cursor_attribute(s)
	}
}

func (s *Expr_cursor_attributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_cursor_attribute(s)
	}
}

func (p *HplsqlParser) Expr_cursor_attribute() (localctx IExpr_cursor_attributeContext) {
	localctx = NewExpr_cursor_attributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, HplsqlParserRULE_expr_cursor_attribute)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3006)
		p.Ident()
	}
	{
		p.SetState(3007)
		p.Match(HplsqlParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3008)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_FOUND || _la == HplsqlParserT_ISOPEN || _la == HplsqlParserT_NOTFOUND) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_agg_window_funcContext is an interface to support dynamic dispatch.
type IExpr_agg_window_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_AVG() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_CLOSE_P() antlr.TerminalNode
	Expr_func_all_distinct() IExpr_func_all_distinctContext
	Expr_func_over_clause() IExpr_func_over_clauseContext
	T_COUNT() antlr.TerminalNode
	T_MUL() antlr.TerminalNode
	T_COUNT_BIG() antlr.TerminalNode
	T_CUME_DIST() antlr.TerminalNode
	T_DENSE_RANK() antlr.TerminalNode
	T_FIRST_VALUE() antlr.TerminalNode
	T_LAG() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	T_LAST_VALUE() antlr.TerminalNode
	T_LEAD() antlr.TerminalNode
	T_MAX() antlr.TerminalNode
	T_MIN() antlr.TerminalNode
	T_RANK() antlr.TerminalNode
	T_ROW_NUMBER() antlr.TerminalNode
	T_STDEV() antlr.TerminalNode
	T_SUM() antlr.TerminalNode
	T_VAR() antlr.TerminalNode
	T_VARIANCE() antlr.TerminalNode

	// IsExpr_agg_window_funcContext differentiates from other interfaces.
	IsExpr_agg_window_funcContext()
}

type Expr_agg_window_funcContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_agg_window_funcContext() *Expr_agg_window_funcContext {
	var p = new(Expr_agg_window_funcContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_agg_window_func
	return p
}

func InitEmptyExpr_agg_window_funcContext(p *Expr_agg_window_funcContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_agg_window_func
}

func (*Expr_agg_window_funcContext) IsExpr_agg_window_funcContext() {}

func NewExpr_agg_window_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_agg_window_funcContext {
	var p = new(Expr_agg_window_funcContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_agg_window_func

	return p
}

func (s *Expr_agg_window_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_agg_window_funcContext) T_AVG() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AVG, 0)
}

func (s *Expr_agg_window_funcContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Expr_agg_window_funcContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Expr_agg_window_funcContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_agg_window_funcContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Expr_agg_window_funcContext) Expr_func_all_distinct() IExpr_func_all_distinctContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_func_all_distinctContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_func_all_distinctContext)
}

func (s *Expr_agg_window_funcContext) Expr_func_over_clause() IExpr_func_over_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_func_over_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_func_over_clauseContext)
}

func (s *Expr_agg_window_funcContext) T_COUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COUNT, 0)
}

func (s *Expr_agg_window_funcContext) T_MUL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MUL, 0)
}

func (s *Expr_agg_window_funcContext) T_COUNT_BIG() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COUNT_BIG, 0)
}

func (s *Expr_agg_window_funcContext) T_CUME_DIST() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CUME_DIST, 0)
}

func (s *Expr_agg_window_funcContext) T_DENSE_RANK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DENSE_RANK, 0)
}

func (s *Expr_agg_window_funcContext) T_FIRST_VALUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FIRST_VALUE, 0)
}

func (s *Expr_agg_window_funcContext) T_LAG() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LAG, 0)
}

func (s *Expr_agg_window_funcContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Expr_agg_window_funcContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Expr_agg_window_funcContext) T_LAST_VALUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LAST_VALUE, 0)
}

func (s *Expr_agg_window_funcContext) T_LEAD() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LEAD, 0)
}

func (s *Expr_agg_window_funcContext) T_MAX() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAX, 0)
}

func (s *Expr_agg_window_funcContext) T_MIN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MIN, 0)
}

func (s *Expr_agg_window_funcContext) T_RANK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RANK, 0)
}

func (s *Expr_agg_window_funcContext) T_ROW_NUMBER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROW_NUMBER, 0)
}

func (s *Expr_agg_window_funcContext) T_STDEV() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STDEV, 0)
}

func (s *Expr_agg_window_funcContext) T_SUM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUM, 0)
}

func (s *Expr_agg_window_funcContext) T_VAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VAR, 0)
}

func (s *Expr_agg_window_funcContext) T_VARIANCE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VARIANCE, 0)
}

func (s *Expr_agg_window_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_agg_window_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_agg_window_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_agg_window_func(s)
	}
}

func (s *Expr_agg_window_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_agg_window_func(s)
	}
}

func (p *HplsqlParser) Expr_agg_window_func() (localctx IExpr_agg_window_funcContext) {
	localctx = NewExpr_agg_window_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, HplsqlParserRULE_expr_agg_window_func)
	var _la int

	p.SetState(3162)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_AVG:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3010)
			p.Match(HplsqlParserT_AVG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3011)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3013)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 370, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3012)
				p.Expr_func_all_distinct()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3015)
			p.expr(0)
		}
		{
			p.SetState(3016)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3018)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 371, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3017)
				p.Expr_func_over_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case HplsqlParserT_COUNT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3020)
			p.Match(HplsqlParserT_COUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3021)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3027)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NULL, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_MAX_PART_STRING, HplsqlParserT_MIN_PART_STRING, HplsqlParserT_MAX_PART_INT, HplsqlParserT_MIN_PART_INT, HplsqlParserT_MAX_PART_DATE, HplsqlParserT_MIN_PART_DATE, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_ADD, HplsqlParserT_OPEN_P, HplsqlParserT_SUB, HplsqlParserL_ID, HplsqlParserL_S_STRING, HplsqlParserL_D_STRING, HplsqlParserL_INT, HplsqlParserL_DEC:
			p.SetState(3023)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 372, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(3022)
					p.Expr_func_all_distinct()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(3025)
				p.expr(0)
			}

		case HplsqlParserT_MUL:
			{
				p.SetState(3026)
				p.Match(HplsqlParserT_MUL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(3029)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3031)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 374, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3030)
				p.Expr_func_over_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case HplsqlParserT_COUNT_BIG:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3033)
			p.Match(HplsqlParserT_COUNT_BIG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3034)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3040)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NULL, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_MAX_PART_STRING, HplsqlParserT_MIN_PART_STRING, HplsqlParserT_MAX_PART_INT, HplsqlParserT_MIN_PART_INT, HplsqlParserT_MAX_PART_DATE, HplsqlParserT_MIN_PART_DATE, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_ADD, HplsqlParserT_OPEN_P, HplsqlParserT_SUB, HplsqlParserL_ID, HplsqlParserL_S_STRING, HplsqlParserL_D_STRING, HplsqlParserL_INT, HplsqlParserL_DEC:
			p.SetState(3036)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 375, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(3035)
					p.Expr_func_all_distinct()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(3038)
				p.expr(0)
			}

		case HplsqlParserT_MUL:
			{
				p.SetState(3039)
				p.Match(HplsqlParserT_MUL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(3042)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3044)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 377, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3043)
				p.Expr_func_over_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case HplsqlParserT_CUME_DIST:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3046)
			p.Match(HplsqlParserT_CUME_DIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3047)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3048)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3049)
			p.Expr_func_over_clause()
		}

	case HplsqlParserT_DENSE_RANK:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3050)
			p.Match(HplsqlParserT_DENSE_RANK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3051)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3052)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3053)
			p.Expr_func_over_clause()
		}

	case HplsqlParserT_FIRST_VALUE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3054)
			p.Match(HplsqlParserT_FIRST_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3055)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3056)
			p.expr(0)
		}
		{
			p.SetState(3057)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3058)
			p.Expr_func_over_clause()
		}

	case HplsqlParserT_LAG:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3060)
			p.Match(HplsqlParserT_LAG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3061)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3062)
			p.expr(0)
		}
		p.SetState(3069)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_COMMA {
			{
				p.SetState(3063)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3064)
				p.expr(0)
			}
			p.SetState(3067)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == HplsqlParserT_COMMA {
				{
					p.SetState(3065)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3066)
					p.expr(0)
				}

			}

		}
		{
			p.SetState(3071)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3072)
			p.Expr_func_over_clause()
		}

	case HplsqlParserT_LAST_VALUE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3074)
			p.Match(HplsqlParserT_LAST_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3075)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3076)
			p.expr(0)
		}
		{
			p.SetState(3077)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3078)
			p.Expr_func_over_clause()
		}

	case HplsqlParserT_LEAD:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3080)
			p.Match(HplsqlParserT_LEAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3081)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3082)
			p.expr(0)
		}
		p.SetState(3089)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_COMMA {
			{
				p.SetState(3083)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3084)
				p.expr(0)
			}
			p.SetState(3087)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == HplsqlParserT_COMMA {
				{
					p.SetState(3085)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3086)
					p.expr(0)
				}

			}

		}
		{
			p.SetState(3091)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3092)
			p.Expr_func_over_clause()
		}

	case HplsqlParserT_MAX:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3094)
			p.Match(HplsqlParserT_MAX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3095)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3097)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 382, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3096)
				p.Expr_func_all_distinct()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3099)
			p.expr(0)
		}
		{
			p.SetState(3100)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3102)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 383, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3101)
				p.Expr_func_over_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case HplsqlParserT_MIN:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3104)
			p.Match(HplsqlParserT_MIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3105)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3107)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 384, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3106)
				p.Expr_func_all_distinct()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3109)
			p.expr(0)
		}
		{
			p.SetState(3110)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3112)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 385, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3111)
				p.Expr_func_over_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case HplsqlParserT_RANK:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3114)
			p.Match(HplsqlParserT_RANK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3115)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3116)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3117)
			p.Expr_func_over_clause()
		}

	case HplsqlParserT_ROW_NUMBER:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(3118)
			p.Match(HplsqlParserT_ROW_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3119)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3120)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3121)
			p.Expr_func_over_clause()
		}

	case HplsqlParserT_STDEV:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(3122)
			p.Match(HplsqlParserT_STDEV)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3123)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3125)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 386, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3124)
				p.Expr_func_all_distinct()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3127)
			p.expr(0)
		}
		{
			p.SetState(3128)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3130)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 387, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3129)
				p.Expr_func_over_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case HplsqlParserT_SUM:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(3132)
			p.Match(HplsqlParserT_SUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3133)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3135)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 388, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3134)
				p.Expr_func_all_distinct()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3137)
			p.expr(0)
		}
		{
			p.SetState(3138)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3140)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 389, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3139)
				p.Expr_func_over_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case HplsqlParserT_VAR:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(3142)
			p.Match(HplsqlParserT_VAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3143)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3145)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 390, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3144)
				p.Expr_func_all_distinct()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3147)
			p.expr(0)
		}
		{
			p.SetState(3148)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3150)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 391, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3149)
				p.Expr_func_over_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case HplsqlParserT_VARIANCE:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(3152)
			p.Match(HplsqlParserT_VARIANCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3153)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3155)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 392, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3154)
				p.Expr_func_all_distinct()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3157)
			p.expr(0)
		}
		{
			p.SetState(3158)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3160)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 393, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3159)
				p.Expr_func_over_clause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_func_all_distinctContext is an interface to support dynamic dispatch.
type IExpr_func_all_distinctContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ALL() antlr.TerminalNode
	T_DISTINCT() antlr.TerminalNode

	// IsExpr_func_all_distinctContext differentiates from other interfaces.
	IsExpr_func_all_distinctContext()
}

type Expr_func_all_distinctContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_func_all_distinctContext() *Expr_func_all_distinctContext {
	var p = new(Expr_func_all_distinctContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_func_all_distinct
	return p
}

func InitEmptyExpr_func_all_distinctContext(p *Expr_func_all_distinctContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_func_all_distinct
}

func (*Expr_func_all_distinctContext) IsExpr_func_all_distinctContext() {}

func NewExpr_func_all_distinctContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_func_all_distinctContext {
	var p = new(Expr_func_all_distinctContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_func_all_distinct

	return p
}

func (s *Expr_func_all_distinctContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_func_all_distinctContext) T_ALL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALL, 0)
}

func (s *Expr_func_all_distinctContext) T_DISTINCT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DISTINCT, 0)
}

func (s *Expr_func_all_distinctContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_func_all_distinctContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_func_all_distinctContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_func_all_distinct(s)
	}
}

func (s *Expr_func_all_distinctContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_func_all_distinct(s)
	}
}

func (p *HplsqlParser) Expr_func_all_distinct() (localctx IExpr_func_all_distinctContext) {
	localctx = NewExpr_func_all_distinctContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, HplsqlParserRULE_expr_func_all_distinct)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3164)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_ALL || _la == HplsqlParserT_DISTINCT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_func_over_clauseContext is an interface to support dynamic dispatch.
type IExpr_func_over_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OVER() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode
	Expr_func_partition_by_clause() IExpr_func_partition_by_clauseContext
	Order_by_clause() IOrder_by_clauseContext

	// IsExpr_func_over_clauseContext differentiates from other interfaces.
	IsExpr_func_over_clauseContext()
}

type Expr_func_over_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_func_over_clauseContext() *Expr_func_over_clauseContext {
	var p = new(Expr_func_over_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_func_over_clause
	return p
}

func InitEmptyExpr_func_over_clauseContext(p *Expr_func_over_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_func_over_clause
}

func (*Expr_func_over_clauseContext) IsExpr_func_over_clauseContext() {}

func NewExpr_func_over_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_func_over_clauseContext {
	var p = new(Expr_func_over_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_func_over_clause

	return p
}

func (s *Expr_func_over_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_func_over_clauseContext) T_OVER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OVER, 0)
}

func (s *Expr_func_over_clauseContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Expr_func_over_clauseContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Expr_func_over_clauseContext) Expr_func_partition_by_clause() IExpr_func_partition_by_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_func_partition_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_func_partition_by_clauseContext)
}

func (s *Expr_func_over_clauseContext) Order_by_clause() IOrder_by_clauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_by_clauseContext)
}

func (s *Expr_func_over_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_func_over_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_func_over_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_func_over_clause(s)
	}
}

func (s *Expr_func_over_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_func_over_clause(s)
	}
}

func (p *HplsqlParser) Expr_func_over_clause() (localctx IExpr_func_over_clauseContext) {
	localctx = NewExpr_func_over_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, HplsqlParserRULE_expr_func_over_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3166)
		p.Match(HplsqlParserT_OVER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3167)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3169)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_PARTITION {
		{
			p.SetState(3168)
			p.Expr_func_partition_by_clause()
		}

	}
	p.SetState(3172)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_ORDER {
		{
			p.SetState(3171)
			p.Order_by_clause()
		}

	}
	{
		p.SetState(3174)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_func_partition_by_clauseContext is an interface to support dynamic dispatch.
type IExpr_func_partition_by_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_PARTITION() antlr.TerminalNode
	T_BY() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsExpr_func_partition_by_clauseContext differentiates from other interfaces.
	IsExpr_func_partition_by_clauseContext()
}

type Expr_func_partition_by_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_func_partition_by_clauseContext() *Expr_func_partition_by_clauseContext {
	var p = new(Expr_func_partition_by_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_func_partition_by_clause
	return p
}

func InitEmptyExpr_func_partition_by_clauseContext(p *Expr_func_partition_by_clauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_func_partition_by_clause
}

func (*Expr_func_partition_by_clauseContext) IsExpr_func_partition_by_clauseContext() {}

func NewExpr_func_partition_by_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_func_partition_by_clauseContext {
	var p = new(Expr_func_partition_by_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_func_partition_by_clause

	return p
}

func (s *Expr_func_partition_by_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_func_partition_by_clauseContext) T_PARTITION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PARTITION, 0)
}

func (s *Expr_func_partition_by_clauseContext) T_BY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BY, 0)
}

func (s *Expr_func_partition_by_clauseContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Expr_func_partition_by_clauseContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_func_partition_by_clauseContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Expr_func_partition_by_clauseContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Expr_func_partition_by_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_func_partition_by_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_func_partition_by_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_func_partition_by_clause(s)
	}
}

func (s *Expr_func_partition_by_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_func_partition_by_clause(s)
	}
}

func (p *HplsqlParser) Expr_func_partition_by_clause() (localctx IExpr_func_partition_by_clauseContext) {
	localctx = NewExpr_func_partition_by_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, HplsqlParserRULE_expr_func_partition_by_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3176)
		p.Match(HplsqlParserT_PARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3177)
		p.Match(HplsqlParserT_BY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3178)
		p.expr(0)
	}
	p.SetState(3183)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(3179)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3180)
			p.expr(0)
		}

		p.SetState(3185)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_spec_funcContext is an interface to support dynamic dispatch.
type IExpr_spec_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ACTIVITY_COUNT() antlr.TerminalNode
	T_CAST() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_AS() antlr.TerminalNode
	Dtype() IDtypeContext
	T_CLOSE_P() antlr.TerminalNode
	Dtype_len() IDtype_lenContext
	T_COUNT() antlr.TerminalNode
	T_MUL() antlr.TerminalNode
	T_CURRENT_DATE() antlr.TerminalNode
	T_CURRENT() antlr.TerminalNode
	T_DATE() antlr.TerminalNode
	T_CURRENT_TIMESTAMP() antlr.TerminalNode
	T_TIMESTAMP() antlr.TerminalNode
	T_CURRENT_USER() antlr.TerminalNode
	T_USER() antlr.TerminalNode
	T_MAX_PART_STRING() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	AllT_EQUAL() []antlr.TerminalNode
	T_EQUAL(i int) antlr.TerminalNode
	T_MIN_PART_STRING() antlr.TerminalNode
	T_MAX_PART_INT() antlr.TerminalNode
	T_MIN_PART_INT() antlr.TerminalNode
	T_MAX_PART_DATE() antlr.TerminalNode
	T_MIN_PART_DATE() antlr.TerminalNode
	T_PART_COUNT() antlr.TerminalNode
	T_PART_LOC() antlr.TerminalNode
	T_TRIM() antlr.TerminalNode
	T_SUBSTRING() antlr.TerminalNode
	T_FROM() antlr.TerminalNode
	T_FOR() antlr.TerminalNode
	T_SYSDATE() antlr.TerminalNode

	// IsExpr_spec_funcContext differentiates from other interfaces.
	IsExpr_spec_funcContext()
}

type Expr_spec_funcContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_spec_funcContext() *Expr_spec_funcContext {
	var p = new(Expr_spec_funcContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_spec_func
	return p
}

func InitEmptyExpr_spec_funcContext(p *Expr_spec_funcContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_spec_func
}

func (*Expr_spec_funcContext) IsExpr_spec_funcContext() {}

func NewExpr_spec_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_spec_funcContext {
	var p = new(Expr_spec_funcContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_spec_func

	return p
}

func (s *Expr_spec_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_spec_funcContext) T_ACTIVITY_COUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ACTIVITY_COUNT, 0)
}

func (s *Expr_spec_funcContext) T_CAST() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CAST, 0)
}

func (s *Expr_spec_funcContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Expr_spec_funcContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Expr_spec_funcContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_spec_funcContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Expr_spec_funcContext) Dtype() IDtypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *Expr_spec_funcContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Expr_spec_funcContext) Dtype_len() IDtype_lenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_lenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_lenContext)
}

func (s *Expr_spec_funcContext) T_COUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COUNT, 0)
}

func (s *Expr_spec_funcContext) T_MUL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MUL, 0)
}

func (s *Expr_spec_funcContext) T_CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT_DATE, 0)
}

func (s *Expr_spec_funcContext) T_CURRENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT, 0)
}

func (s *Expr_spec_funcContext) T_DATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATE, 0)
}

func (s *Expr_spec_funcContext) T_CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT_TIMESTAMP, 0)
}

func (s *Expr_spec_funcContext) T_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TIMESTAMP, 0)
}

func (s *Expr_spec_funcContext) T_CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT_USER, 0)
}

func (s *Expr_spec_funcContext) T_USER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_USER, 0)
}

func (s *Expr_spec_funcContext) T_MAX_PART_STRING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAX_PART_STRING, 0)
}

func (s *Expr_spec_funcContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Expr_spec_funcContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Expr_spec_funcContext) AllT_EQUAL() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_EQUAL)
}

func (s *Expr_spec_funcContext) T_EQUAL(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, i)
}

func (s *Expr_spec_funcContext) T_MIN_PART_STRING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MIN_PART_STRING, 0)
}

func (s *Expr_spec_funcContext) T_MAX_PART_INT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAX_PART_INT, 0)
}

func (s *Expr_spec_funcContext) T_MIN_PART_INT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MIN_PART_INT, 0)
}

func (s *Expr_spec_funcContext) T_MAX_PART_DATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAX_PART_DATE, 0)
}

func (s *Expr_spec_funcContext) T_MIN_PART_DATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MIN_PART_DATE, 0)
}

func (s *Expr_spec_funcContext) T_PART_COUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PART_COUNT, 0)
}

func (s *Expr_spec_funcContext) T_PART_LOC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PART_LOC, 0)
}

func (s *Expr_spec_funcContext) T_TRIM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TRIM, 0)
}

func (s *Expr_spec_funcContext) T_SUBSTRING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUBSTRING, 0)
}

func (s *Expr_spec_funcContext) T_FROM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FROM, 0)
}

func (s *Expr_spec_funcContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *Expr_spec_funcContext) T_SYSDATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SYSDATE, 0)
}

func (s *Expr_spec_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_spec_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_spec_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_spec_func(s)
	}
}

func (s *Expr_spec_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_spec_func(s)
	}
}

func (p *HplsqlParser) Expr_spec_func() (localctx IExpr_spec_funcContext) {
	localctx = NewExpr_spec_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, HplsqlParserRULE_expr_spec_func)
	var _la int

	var _alt int

	p.SetState(3386)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 418, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3186)
			p.Match(HplsqlParserT_ACTIVITY_COUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3187)
			p.Match(HplsqlParserT_CAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3188)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3189)
			p.expr(0)
		}
		{
			p.SetState(3190)
			p.Match(HplsqlParserT_AS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3191)
			p.Dtype()
		}
		p.SetState(3193)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_OPEN_P {
			{
				p.SetState(3192)
				p.Dtype_len()
			}

		}
		{
			p.SetState(3195)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3197)
			p.Match(HplsqlParserT_COUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3198)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3201)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NULL, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_MAX_PART_STRING, HplsqlParserT_MIN_PART_STRING, HplsqlParserT_MAX_PART_INT, HplsqlParserT_MIN_PART_INT, HplsqlParserT_MAX_PART_DATE, HplsqlParserT_MIN_PART_DATE, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_ADD, HplsqlParserT_OPEN_P, HplsqlParserT_SUB, HplsqlParserL_ID, HplsqlParserL_S_STRING, HplsqlParserL_D_STRING, HplsqlParserL_INT, HplsqlParserL_DEC:
			{
				p.SetState(3199)
				p.expr(0)
			}

		case HplsqlParserT_MUL:
			{
				p.SetState(3200)
				p.Match(HplsqlParserT_MUL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(3203)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3204)
			p.Match(HplsqlParserT_CURRENT_DATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3205)
			p.Match(HplsqlParserT_CURRENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3206)
			p.Match(HplsqlParserT_DATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(3210)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case HplsqlParserT_CURRENT_TIMESTAMP:
			{
				p.SetState(3207)
				p.Match(HplsqlParserT_CURRENT_TIMESTAMP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case HplsqlParserT_CURRENT:
			{
				p.SetState(3208)
				p.Match(HplsqlParserT_CURRENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3209)
				p.Match(HplsqlParserT_TIMESTAMP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(3216)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 401, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3212)
				p.Match(HplsqlParserT_OPEN_P)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3213)
				p.expr(0)
			}
			{
				p.SetState(3214)
				p.Match(HplsqlParserT_CLOSE_P)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3218)
			p.Match(HplsqlParserT_CURRENT_USER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3219)
			p.Match(HplsqlParserT_CURRENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3220)
			p.Match(HplsqlParserT_USER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3221)
			p.Match(HplsqlParserT_MAX_PART_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3222)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3223)
			p.expr(0)
		}
		p.SetState(3236)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_COMMA {
			{
				p.SetState(3224)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3225)
				p.expr(0)
			}
			p.SetState(3233)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == HplsqlParserT_COMMA {
				{
					p.SetState(3226)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3227)
					p.expr(0)
				}
				{
					p.SetState(3228)
					p.Match(HplsqlParserT_EQUAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3229)
					p.expr(0)
				}

				p.SetState(3235)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(3238)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3240)
			p.Match(HplsqlParserT_MIN_PART_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3241)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3242)
			p.expr(0)
		}
		p.SetState(3255)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_COMMA {
			{
				p.SetState(3243)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3244)
				p.expr(0)
			}
			p.SetState(3252)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == HplsqlParserT_COMMA {
				{
					p.SetState(3245)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3246)
					p.expr(0)
				}
				{
					p.SetState(3247)
					p.Match(HplsqlParserT_EQUAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3248)
					p.expr(0)
				}

				p.SetState(3254)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(3257)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3259)
			p.Match(HplsqlParserT_MAX_PART_INT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3260)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3261)
			p.expr(0)
		}
		p.SetState(3274)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_COMMA {
			{
				p.SetState(3262)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3263)
				p.expr(0)
			}
			p.SetState(3271)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == HplsqlParserT_COMMA {
				{
					p.SetState(3264)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3265)
					p.expr(0)
				}
				{
					p.SetState(3266)
					p.Match(HplsqlParserT_EQUAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3267)
					p.expr(0)
				}

				p.SetState(3273)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(3276)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3278)
			p.Match(HplsqlParserT_MIN_PART_INT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3279)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3280)
			p.expr(0)
		}
		p.SetState(3293)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_COMMA {
			{
				p.SetState(3281)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3282)
				p.expr(0)
			}
			p.SetState(3290)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == HplsqlParserT_COMMA {
				{
					p.SetState(3283)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3284)
					p.expr(0)
				}
				{
					p.SetState(3285)
					p.Match(HplsqlParserT_EQUAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3286)
					p.expr(0)
				}

				p.SetState(3292)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(3295)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(3297)
			p.Match(HplsqlParserT_MAX_PART_DATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3298)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3299)
			p.expr(0)
		}
		p.SetState(3312)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_COMMA {
			{
				p.SetState(3300)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3301)
				p.expr(0)
			}
			p.SetState(3309)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == HplsqlParserT_COMMA {
				{
					p.SetState(3302)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3303)
					p.expr(0)
				}
				{
					p.SetState(3304)
					p.Match(HplsqlParserT_EQUAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3305)
					p.expr(0)
				}

				p.SetState(3311)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(3314)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(3316)
			p.Match(HplsqlParserT_MIN_PART_DATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3317)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3318)
			p.expr(0)
		}
		p.SetState(3331)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_COMMA {
			{
				p.SetState(3319)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3320)
				p.expr(0)
			}
			p.SetState(3328)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == HplsqlParserT_COMMA {
				{
					p.SetState(3321)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3322)
					p.expr(0)
				}
				{
					p.SetState(3323)
					p.Match(HplsqlParserT_EQUAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3324)
					p.expr(0)
				}

				p.SetState(3330)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(3333)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(3335)
			p.Match(HplsqlParserT_PART_COUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3336)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3337)
			p.expr(0)
		}
		p.SetState(3345)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(3338)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3339)
				p.expr(0)
			}
			{
				p.SetState(3340)
				p.Match(HplsqlParserT_EQUAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3341)
				p.expr(0)
			}

			p.SetState(3347)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3348)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(3350)
			p.Match(HplsqlParserT_PART_LOC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3351)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3352)
			p.expr(0)
		}
		p.SetState(3358)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(3353)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3354)
					p.expr(0)
				}
				{
					p.SetState(3355)
					p.Match(HplsqlParserT_EQUAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3356)
					p.expr(0)
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(3360)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 415, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(3364)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_COMMA {
			{
				p.SetState(3362)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3363)
				p.expr(0)
			}

		}
		{
			p.SetState(3366)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(3368)
			p.Match(HplsqlParserT_TRIM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3369)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3370)
			p.expr(0)
		}
		{
			p.SetState(3371)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(3373)
			p.Match(HplsqlParserT_SUBSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3374)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3375)
			p.expr(0)
		}
		{
			p.SetState(3376)
			p.Match(HplsqlParserT_FROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3377)
			p.expr(0)
		}
		p.SetState(3380)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_FOR {
			{
				p.SetState(3378)
				p.Match(HplsqlParserT_FOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3379)
				p.expr(0)
			}

		}
		{
			p.SetState(3382)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(3384)
			p.Match(HplsqlParserT_SYSDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(3385)
			p.Match(HplsqlParserT_USER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_funcContext is an interface to support dynamic dispatch.
type IExpr_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ident() IIdentContext
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode
	Expr_func_params() IExpr_func_paramsContext

	// IsExpr_funcContext differentiates from other interfaces.
	IsExpr_funcContext()
}

type Expr_funcContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_funcContext() *Expr_funcContext {
	var p = new(Expr_funcContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_func
	return p
}

func InitEmptyExpr_funcContext(p *Expr_funcContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_func
}

func (*Expr_funcContext) IsExpr_funcContext() {}

func NewExpr_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_funcContext {
	var p = new(Expr_funcContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_func

	return p
}

func (s *Expr_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_funcContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Expr_funcContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Expr_funcContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Expr_funcContext) Expr_func_params() IExpr_func_paramsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_func_paramsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_func_paramsContext)
}

func (s *Expr_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_func(s)
	}
}

func (s *Expr_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_func(s)
	}
}

func (p *HplsqlParser) Expr_func() (localctx IExpr_funcContext) {
	localctx = NewExpr_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, HplsqlParserRULE_expr_func)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3388)
		p.Ident()
	}
	{
		p.SetState(3389)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3391)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 419, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3390)
			p.Expr_func_params()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3393)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_dotContext is an interface to support dynamic dispatch.
type IExpr_dotContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr_dot_method_call() IExpr_dot_method_callContext
	Expr_dot_property_access() IExpr_dot_property_accessContext

	// IsExpr_dotContext differentiates from other interfaces.
	IsExpr_dotContext()
}

type Expr_dotContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_dotContext() *Expr_dotContext {
	var p = new(Expr_dotContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_dot
	return p
}

func InitEmptyExpr_dotContext(p *Expr_dotContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_dot
}

func (*Expr_dotContext) IsExpr_dotContext() {}

func NewExpr_dotContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_dotContext {
	var p = new(Expr_dotContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_dot

	return p
}

func (s *Expr_dotContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_dotContext) Expr_dot_method_call() IExpr_dot_method_callContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_dot_method_callContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_dot_method_callContext)
}

func (s *Expr_dotContext) Expr_dot_property_access() IExpr_dot_property_accessContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_dot_property_accessContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_dot_property_accessContext)
}

func (s *Expr_dotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_dotContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_dotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_dot(s)
	}
}

func (s *Expr_dotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_dot(s)
	}
}

func (p *HplsqlParser) Expr_dot() (localctx IExpr_dotContext) {
	localctx = NewExpr_dotContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, HplsqlParserRULE_expr_dot)
	p.SetState(3397)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 420, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3395)
			p.Expr_dot_method_call()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3396)
			p.Expr_dot_property_access()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_dot_method_callContext is an interface to support dynamic dispatch.
type IExpr_dot_method_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_DOT() antlr.TerminalNode
	AllExpr_func() []IExpr_funcContext
	Expr_func(i int) IExpr_funcContext
	Ident() IIdentContext

	// IsExpr_dot_method_callContext differentiates from other interfaces.
	IsExpr_dot_method_callContext()
}

type Expr_dot_method_callContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_dot_method_callContext() *Expr_dot_method_callContext {
	var p = new(Expr_dot_method_callContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_dot_method_call
	return p
}

func InitEmptyExpr_dot_method_callContext(p *Expr_dot_method_callContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_dot_method_call
}

func (*Expr_dot_method_callContext) IsExpr_dot_method_callContext() {}

func NewExpr_dot_method_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_dot_method_callContext {
	var p = new(Expr_dot_method_callContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_dot_method_call

	return p
}

func (s *Expr_dot_method_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_dot_method_callContext) T_DOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DOT, 0)
}

func (s *Expr_dot_method_callContext) AllExpr_func() []IExpr_funcContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpr_funcContext); ok {
			len++
		}
	}

	tst := make([]IExpr_funcContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpr_funcContext); ok {
			tst[i] = t.(IExpr_funcContext)
			i++
		}
	}

	return tst
}

func (s *Expr_dot_method_callContext) Expr_func(i int) IExpr_funcContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_funcContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_funcContext)
}

func (s *Expr_dot_method_callContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Expr_dot_method_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_dot_method_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_dot_method_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_dot_method_call(s)
	}
}

func (s *Expr_dot_method_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_dot_method_call(s)
	}
}

func (p *HplsqlParser) Expr_dot_method_call() (localctx IExpr_dot_method_callContext) {
	localctx = NewExpr_dot_method_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, HplsqlParserRULE_expr_dot_method_call)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(3401)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 421, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3399)
			p.Ident()
		}

	case 2:
		{
			p.SetState(3400)
			p.Expr_func()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(3403)
		p.Match(HplsqlParserT_DOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3404)
		p.Expr_func()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_dot_property_accessContext is an interface to support dynamic dispatch.
type IExpr_dot_property_accessContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_DOT() antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	Expr_func() IExpr_funcContext

	// IsExpr_dot_property_accessContext differentiates from other interfaces.
	IsExpr_dot_property_accessContext()
}

type Expr_dot_property_accessContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_dot_property_accessContext() *Expr_dot_property_accessContext {
	var p = new(Expr_dot_property_accessContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_dot_property_access
	return p
}

func InitEmptyExpr_dot_property_accessContext(p *Expr_dot_property_accessContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_dot_property_access
}

func (*Expr_dot_property_accessContext) IsExpr_dot_property_accessContext() {}

func NewExpr_dot_property_accessContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_dot_property_accessContext {
	var p = new(Expr_dot_property_accessContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_dot_property_access

	return p
}

func (s *Expr_dot_property_accessContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_dot_property_accessContext) T_DOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DOT, 0)
}

func (s *Expr_dot_property_accessContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Expr_dot_property_accessContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Expr_dot_property_accessContext) Expr_func() IExpr_funcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_funcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_funcContext)
}

func (s *Expr_dot_property_accessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_dot_property_accessContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_dot_property_accessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_dot_property_access(s)
	}
}

func (s *Expr_dot_property_accessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_dot_property_access(s)
	}
}

func (p *HplsqlParser) Expr_dot_property_access() (localctx IExpr_dot_property_accessContext) {
	localctx = NewExpr_dot_property_accessContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, HplsqlParserRULE_expr_dot_property_access)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(3408)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 422, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3406)
			p.Ident()
		}

	case 2:
		{
			p.SetState(3407)
			p.Expr_func()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(3410)
		p.Match(HplsqlParserT_DOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3411)
		p.Ident()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_func_paramsContext is an interface to support dynamic dispatch.
type IExpr_func_paramsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFunc_param() []IFunc_paramContext
	Func_param(i int) IFunc_paramContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsExpr_func_paramsContext differentiates from other interfaces.
	IsExpr_func_paramsContext()
}

type Expr_func_paramsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_func_paramsContext() *Expr_func_paramsContext {
	var p = new(Expr_func_paramsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_func_params
	return p
}

func InitEmptyExpr_func_paramsContext(p *Expr_func_paramsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_func_params
}

func (*Expr_func_paramsContext) IsExpr_func_paramsContext() {}

func NewExpr_func_paramsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_func_paramsContext {
	var p = new(Expr_func_paramsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_func_params

	return p
}

func (s *Expr_func_paramsContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_func_paramsContext) AllFunc_param() []IFunc_paramContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunc_paramContext); ok {
			len++
		}
	}

	tst := make([]IFunc_paramContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunc_paramContext); ok {
			tst[i] = t.(IFunc_paramContext)
			i++
		}
	}

	return tst
}

func (s *Expr_func_paramsContext) Func_param(i int) IFunc_paramContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunc_paramContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunc_paramContext)
}

func (s *Expr_func_paramsContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Expr_func_paramsContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Expr_func_paramsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_func_paramsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_func_paramsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_func_params(s)
	}
}

func (s *Expr_func_paramsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_func_params(s)
	}
}

func (p *HplsqlParser) Expr_func_params() (localctx IExpr_func_paramsContext) {
	localctx = NewExpr_func_paramsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, HplsqlParserRULE_expr_func_params)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3413)
		p.Func_param()
	}
	p.SetState(3418)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 423, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3414)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3415)
				p.Func_param()
			}

		}
		p.SetState(3420)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 423, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunc_paramContext is an interface to support dynamic dispatch.
type IFunc_paramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	Ident() IIdentContext
	T_EQUAL() antlr.TerminalNode
	T_GREATER() antlr.TerminalNode

	// IsFunc_paramContext differentiates from other interfaces.
	IsFunc_paramContext()
}

type Func_paramContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunc_paramContext() *Func_paramContext {
	var p = new(Func_paramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_func_param
	return p
}

func InitEmptyFunc_paramContext(p *Func_paramContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_func_param
}

func (*Func_paramContext) IsFunc_paramContext() {}

func NewFunc_paramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Func_paramContext {
	var p = new(Func_paramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_func_param

	return p
}

func (s *Func_paramContext) GetParser() antlr.Parser { return s.parser }

func (s *Func_paramContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Func_paramContext) Ident() IIdentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Func_paramContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Func_paramContext) T_GREATER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GREATER, 0)
}

func (s *Func_paramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Func_paramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Func_paramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFunc_param(s)
	}
}

func (s *Func_paramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFunc_param(s)
	}
}

func (p *HplsqlParser) Func_param() (localctx IFunc_paramContext) {
	localctx = NewFunc_paramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, HplsqlParserRULE_func_param)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3421)

	if !(!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "INTO")) {
		p.SetError(antlr.NewFailedPredicateException(p, "!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"INTO\")", ""))
		goto errorExit
	}
	p.SetState(3427)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 425, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3422)
			p.Ident()
		}
		{
			p.SetState(3423)
			p.Match(HplsqlParserT_EQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3425)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == HplsqlParserT_GREATER {
			{
				p.SetState(3424)
				p.Match(HplsqlParserT_GREATER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3429)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_selectContext is an interface to support dynamic dispatch.
type IExpr_selectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Select_stmt() ISelect_stmtContext
	Expr() IExprContext

	// IsExpr_selectContext differentiates from other interfaces.
	IsExpr_selectContext()
}

type Expr_selectContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_selectContext() *Expr_selectContext {
	var p = new(Expr_selectContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_select
	return p
}

func InitEmptyExpr_selectContext(p *Expr_selectContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_select
}

func (*Expr_selectContext) IsExpr_selectContext() {}

func NewExpr_selectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_selectContext {
	var p = new(Expr_selectContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_select

	return p
}

func (s *Expr_selectContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_selectContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Expr_selectContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_selectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_selectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_selectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_select(s)
	}
}

func (s *Expr_selectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_select(s)
	}
}

func (p *HplsqlParser) Expr_select() (localctx IExpr_selectContext) {
	localctx = NewExpr_selectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, HplsqlParserRULE_expr_select)
	p.SetState(3433)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 426, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3431)
			p.Select_stmt()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3432)
			p.expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpr_fileContext is an interface to support dynamic dispatch.
type IExpr_fileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	File_name() IFile_nameContext
	Expr() IExprContext

	// IsExpr_fileContext differentiates from other interfaces.
	IsExpr_fileContext()
}

type Expr_fileContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_fileContext() *Expr_fileContext {
	var p = new(Expr_fileContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_file
	return p
}

func InitEmptyExpr_fileContext(p *Expr_fileContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_file
}

func (*Expr_fileContext) IsExpr_fileContext() {}

func NewExpr_fileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_fileContext {
	var p = new(Expr_fileContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_file

	return p
}

func (s *Expr_fileContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_fileContext) File_name() IFile_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFile_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFile_nameContext)
}

func (s *Expr_fileContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_fileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_fileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expr_fileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_file(s)
	}
}

func (s *Expr_fileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_file(s)
	}
}

func (p *HplsqlParser) Expr_file() (localctx IExpr_fileContext) {
	localctx = NewExpr_fileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, HplsqlParserRULE_expr_file)
	p.SetState(3437)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 427, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3435)
			p.File_name()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3436)
			p.expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHiveContext is an interface to support dynamic dispatch.
type IHiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_HIVE() antlr.TerminalNode
	AllHive_item() []IHive_itemContext
	Hive_item(i int) IHive_itemContext

	// IsHiveContext differentiates from other interfaces.
	IsHiveContext()
}

type HiveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHiveContext() *HiveContext {
	var p = new(HiveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_hive
	return p
}

func InitEmptyHiveContext(p *HiveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_hive
}

func (*HiveContext) IsHiveContext() {}

func NewHiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HiveContext {
	var p = new(HiveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_hive

	return p
}

func (s *HiveContext) GetParser() antlr.Parser { return s.parser }

func (s *HiveContext) T_HIVE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HIVE, 0)
}

func (s *HiveContext) AllHive_item() []IHive_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHive_itemContext); ok {
			len++
		}
	}

	tst := make([]IHive_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHive_itemContext); ok {
			tst[i] = t.(IHive_itemContext)
			i++
		}
	}

	return tst
}

func (s *HiveContext) Hive_item(i int) IHive_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHive_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHive_itemContext)
}

func (s *HiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterHive(s)
	}
}

func (s *HiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitHive(s)
	}
}

func (p *HplsqlParser) Hive() (localctx IHiveContext) {
	localctx = NewHiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, HplsqlParserRULE_hive)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3439)
		p.Match(HplsqlParserT_HIVE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3443)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 428, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3440)
				p.Hive_item()
			}

		}
		p.SetState(3445)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 428, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHive_itemContext is an interface to support dynamic dispatch.
type IHive_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_SUB() antlr.TerminalNode
	Qident() IQidentContext
	Expr() IExprContext
	L_ID() antlr.TerminalNode
	T_EQUAL() antlr.TerminalNode

	// IsHive_itemContext differentiates from other interfaces.
	IsHive_itemContext()
}

type Hive_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHive_itemContext() *Hive_itemContext {
	var p = new(Hive_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_hive_item
	return p
}

func InitEmptyHive_itemContext(p *Hive_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_hive_item
}

func (*Hive_itemContext) IsHive_itemContext() {}

func NewHive_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hive_itemContext {
	var p = new(Hive_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_hive_item

	return p
}

func (s *Hive_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Hive_itemContext) T_SUB() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUB, 0)
}

func (s *Hive_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Hive_itemContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Hive_itemContext) L_ID() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, 0)
}

func (s *Hive_itemContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Hive_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hive_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Hive_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterHive_item(s)
	}
}

func (s *Hive_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitHive_item(s)
	}
}

func (p *HplsqlParser) Hive_item() (localctx IHive_itemContext) {
	localctx = NewHive_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, HplsqlParserRULE_hive_item)
	p.SetState(3458)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 429, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3446)
			p.Match(HplsqlParserT_SUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3447)
			p.Qident()
		}
		{
			p.SetState(3448)
			p.expr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3450)
			p.Match(HplsqlParserT_SUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3451)
			p.Qident()
		}
		{
			p.SetState(3452)
			p.Match(HplsqlParserL_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3453)
			p.Match(HplsqlParserT_EQUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3454)
			p.expr(0)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3456)
			p.Match(HplsqlParserT_SUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3457)
			p.Qident()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHostContext is an interface to support dynamic dispatch.
type IHostContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Host_cmd() IHost_cmdContext
	T_SEMICOLON() antlr.TerminalNode
	Host_stmt() IHost_stmtContext

	// IsHostContext differentiates from other interfaces.
	IsHostContext()
}

type HostContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHostContext() *HostContext {
	var p = new(HostContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_host
	return p
}

func InitEmptyHostContext(p *HostContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_host
}

func (*HostContext) IsHostContext() {}

func NewHostContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HostContext {
	var p = new(HostContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_host

	return p
}

func (s *HostContext) GetParser() antlr.Parser { return s.parser }

func (s *HostContext) Host_cmd() IHost_cmdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHost_cmdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHost_cmdContext)
}

func (s *HostContext) T_SEMICOLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEMICOLON, 0)
}

func (s *HostContext) Host_stmt() IHost_stmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHost_stmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHost_stmtContext)
}

func (s *HostContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HostContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HostContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterHost(s)
	}
}

func (s *HostContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitHost(s)
	}
}

func (p *HplsqlParser) Host() (localctx IHostContext) {
	localctx = NewHostContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, HplsqlParserRULE_host)
	p.SetState(3465)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT__3:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3460)
			p.Match(HplsqlParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3461)
			p.Host_cmd()
		}
		{
			p.SetState(3462)
			p.Match(HplsqlParserT_SEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_HOST:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3464)
			p.Host_stmt()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHost_cmdContext is an interface to support dynamic dispatch.
type IHost_cmdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsHost_cmdContext differentiates from other interfaces.
	IsHost_cmdContext()
}

type Host_cmdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHost_cmdContext() *Host_cmdContext {
	var p = new(Host_cmdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_host_cmd
	return p
}

func InitEmptyHost_cmdContext(p *Host_cmdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_host_cmd
}

func (*Host_cmdContext) IsHost_cmdContext() {}

func NewHost_cmdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Host_cmdContext {
	var p = new(Host_cmdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_host_cmd

	return p
}

func (s *Host_cmdContext) GetParser() antlr.Parser { return s.parser }
func (s *Host_cmdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Host_cmdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Host_cmdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterHost_cmd(s)
	}
}

func (s *Host_cmdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitHost_cmd(s)
	}
}

func (p *HplsqlParser) Host_cmd() (localctx IHost_cmdContext) {
	localctx = NewHost_cmdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, HplsqlParserRULE_host_cmd)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3470)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 431, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1+1 {
			p.SetState(3467)
			p.MatchWildcard()

		}
		p.SetState(3472)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 431, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHost_stmtContext is an interface to support dynamic dispatch.
type IHost_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_HOST() antlr.TerminalNode
	Expr() IExprContext

	// IsHost_stmtContext differentiates from other interfaces.
	IsHost_stmtContext()
}

type Host_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHost_stmtContext() *Host_stmtContext {
	var p = new(Host_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_host_stmt
	return p
}

func InitEmptyHost_stmtContext(p *Host_stmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_host_stmt
}

func (*Host_stmtContext) IsHost_stmtContext() {}

func NewHost_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Host_stmtContext {
	var p = new(Host_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_host_stmt

	return p
}

func (s *Host_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Host_stmtContext) T_HOST() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HOST, 0)
}

func (s *Host_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Host_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Host_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Host_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterHost_stmt(s)
	}
}

func (s *Host_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitHost_stmt(s)
	}
}

func (p *HplsqlParser) Host_stmt() (localctx IHost_stmtContext) {
	localctx = NewHost_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, HplsqlParserRULE_host_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3473)
		p.Match(HplsqlParserT_HOST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3474)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFile_nameContext is an interface to support dynamic dispatch.
type IFile_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_FILE() antlr.TerminalNode
	AllQident() []IQidentContext
	Qident(i int) IQidentContext
	AllT_DIV() []antlr.TerminalNode
	T_DIV(i int) antlr.TerminalNode
	T_DOT() antlr.TerminalNode

	// IsFile_nameContext differentiates from other interfaces.
	IsFile_nameContext()
}

type File_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFile_nameContext() *File_nameContext {
	var p = new(File_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_file_name
	return p
}

func InitEmptyFile_nameContext(p *File_nameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_file_name
}

func (*File_nameContext) IsFile_nameContext() {}

func NewFile_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *File_nameContext {
	var p = new(File_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_file_name

	return p
}

func (s *File_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *File_nameContext) L_FILE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_FILE, 0)
}

func (s *File_nameContext) AllQident() []IQidentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQidentContext); ok {
			len++
		}
	}

	tst := make([]IQidentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQidentContext); ok {
			tst[i] = t.(IQidentContext)
			i++
		}
	}

	return tst
}

func (s *File_nameContext) Qident(i int) IQidentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *File_nameContext) AllT_DIV() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_DIV)
}

func (s *File_nameContext) T_DIV(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DIV, i)
}

func (s *File_nameContext) T_DOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DOT, 0)
}

func (s *File_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *File_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *File_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFile_name(s)
	}
}

func (s *File_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFile_name(s)
	}
}

func (p *HplsqlParser) File_name() (localctx IFile_nameContext) {
	localctx = NewFile_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, HplsqlParserRULE_file_name)
	var _alt int

	p.SetState(3490)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserL_FILE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3476)
			p.Match(HplsqlParserL_FILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_DIV, HplsqlParserT_DOT, HplsqlParserT_SUB, HplsqlParserL_ID:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3480)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case HplsqlParserT_DIV:
			{
				p.SetState(3477)
				p.Match(HplsqlParserT_DIV)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case HplsqlParserT_DOT:
			{
				p.SetState(3478)
				p.Match(HplsqlParserT_DOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3479)
				p.Match(HplsqlParserT_DIV)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_SUB, HplsqlParserL_ID:

		default:
		}
		{
			p.SetState(3482)
			p.Qident()
		}
		p.SetState(3487)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 433, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3483)
					p.Match(HplsqlParserT_DIV)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3484)
					p.Qident()
				}

			}
			p.SetState(3489)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 433, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDate_literalContext is an interface to support dynamic dispatch.
type IDate_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_DATE() antlr.TerminalNode
	String_() IStringContext

	// IsDate_literalContext differentiates from other interfaces.
	IsDate_literalContext()
}

type Date_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDate_literalContext() *Date_literalContext {
	var p = new(Date_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_date_literal
	return p
}

func InitEmptyDate_literalContext(p *Date_literalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_date_literal
}

func (*Date_literalContext) IsDate_literalContext() {}

func NewDate_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Date_literalContext {
	var p = new(Date_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_date_literal

	return p
}

func (s *Date_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Date_literalContext) T_DATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATE, 0)
}

func (s *Date_literalContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *Date_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Date_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Date_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDate_literal(s)
	}
}

func (s *Date_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDate_literal(s)
	}
}

func (p *HplsqlParser) Date_literal() (localctx IDate_literalContext) {
	localctx = NewDate_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, HplsqlParserRULE_date_literal)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3492)
		p.Match(HplsqlParserT_DATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3493)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimestamp_literalContext is an interface to support dynamic dispatch.
type ITimestamp_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_TIMESTAMP() antlr.TerminalNode
	String_() IStringContext

	// IsTimestamp_literalContext differentiates from other interfaces.
	IsTimestamp_literalContext()
}

type Timestamp_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimestamp_literalContext() *Timestamp_literalContext {
	var p = new(Timestamp_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_timestamp_literal
	return p
}

func InitEmptyTimestamp_literalContext(p *Timestamp_literalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_timestamp_literal
}

func (*Timestamp_literalContext) IsTimestamp_literalContext() {}

func NewTimestamp_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Timestamp_literalContext {
	var p = new(Timestamp_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_timestamp_literal

	return p
}

func (s *Timestamp_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Timestamp_literalContext) T_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TIMESTAMP, 0)
}

func (s *Timestamp_literalContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *Timestamp_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Timestamp_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Timestamp_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterTimestamp_literal(s)
	}
}

func (s *Timestamp_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitTimestamp_literal(s)
	}
}

func (p *HplsqlParser) Timestamp_literal() (localctx ITimestamp_literalContext) {
	localctx = NewTimestamp_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, HplsqlParserRULE_timestamp_literal)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3495)
		p.Match(HplsqlParserT_TIMESTAMP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3496)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentContext is an interface to support dynamic dispatch.
type IIdentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_ID() antlr.TerminalNode
	Non_reserved_words() INon_reserved_wordsContext
	T_SUB() antlr.TerminalNode

	// IsIdentContext differentiates from other interfaces.
	IsIdentContext()
}

type IdentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentContext() *IdentContext {
	var p = new(IdentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_ident
	return p
}

func InitEmptyIdentContext(p *IdentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_ident
}

func (*IdentContext) IsIdentContext() {}

func NewIdentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentContext {
	var p = new(IdentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_ident

	return p
}

func (s *IdentContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentContext) L_ID() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, 0)
}

func (s *IdentContext) Non_reserved_words() INon_reserved_wordsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INon_reserved_wordsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INon_reserved_wordsContext)
}

func (s *IdentContext) T_SUB() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUB, 0)
}

func (s *IdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterIdent(s)
	}
}

func (s *IdentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitIdent(s)
	}
}

func (p *HplsqlParser) Ident() (localctx IIdentContext) {
	localctx = NewIdentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, HplsqlParserRULE_ident)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3499)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_SUB {
		{
			p.SetState(3498)
			p.Match(HplsqlParserT_SUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3503)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserL_ID:
		{
			p.SetState(3501)
			p.Match(HplsqlParserL_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER:
		{
			p.SetState(3502)
			p.Non_reserved_words()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQidentContext is an interface to support dynamic dispatch.
type IQidentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	AllT_DOT() []antlr.TerminalNode
	T_DOT(i int) antlr.TerminalNode

	// IsQidentContext differentiates from other interfaces.
	IsQidentContext()
}

type QidentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQidentContext() *QidentContext {
	var p = new(QidentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_qident
	return p
}

func InitEmptyQidentContext(p *QidentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_qident
}

func (*QidentContext) IsQidentContext() {}

func NewQidentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QidentContext {
	var p = new(QidentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_qident

	return p
}

func (s *QidentContext) GetParser() antlr.Parser { return s.parser }

func (s *QidentContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *QidentContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *QidentContext) AllT_DOT() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_DOT)
}

func (s *QidentContext) T_DOT(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DOT, i)
}

func (s *QidentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QidentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QidentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterQident(s)
	}
}

func (s *QidentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitQident(s)
	}
}

func (p *HplsqlParser) Qident() (localctx IQidentContext) {
	localctx = NewQidentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, HplsqlParserRULE_qident)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3505)
		p.Ident()
	}
	p.SetState(3510)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 437, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3506)
				p.Match(HplsqlParserT_DOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3507)
				p.Ident()
			}

		}
		p.SetState(3512)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 437, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringContext is an interface to support dynamic dispatch.
type IStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStringContext differentiates from other interfaces.
	IsStringContext()
}

type StringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringContext() *StringContext {
	var p = new(StringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_string
	return p
}

func InitEmptyStringContext(p *StringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_string
}

func (*StringContext) IsStringContext() {}

func NewStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringContext {
	var p = new(StringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_string

	return p
}

func (s *StringContext) GetParser() antlr.Parser { return s.parser }

func (s *StringContext) CopyAll(ctx *StringContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type Double_quotedStringContext struct {
	StringContext
}

func NewDouble_quotedStringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Double_quotedStringContext {
	var p = new(Double_quotedStringContext)

	InitEmptyStringContext(&p.StringContext)
	p.parser = parser
	p.CopyAll(ctx.(*StringContext))

	return p
}

func (s *Double_quotedStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Double_quotedStringContext) L_D_STRING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_D_STRING, 0)
}

func (s *Double_quotedStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDouble_quotedString(s)
	}
}

func (s *Double_quotedStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDouble_quotedString(s)
	}
}

type Single_quotedStringContext struct {
	StringContext
}

func NewSingle_quotedStringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Single_quotedStringContext {
	var p = new(Single_quotedStringContext)

	InitEmptyStringContext(&p.StringContext)
	p.parser = parser
	p.CopyAll(ctx.(*StringContext))

	return p
}

func (s *Single_quotedStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Single_quotedStringContext) L_S_STRING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_S_STRING, 0)
}

func (s *Single_quotedStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSingle_quotedString(s)
	}
}

func (s *Single_quotedStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSingle_quotedString(s)
	}
}

func (p *HplsqlParser) String_() (localctx IStringContext) {
	localctx = NewStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, HplsqlParserRULE_string)
	p.SetState(3515)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserL_S_STRING:
		localctx = NewSingle_quotedStringContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3513)
			p.Match(HplsqlParserL_S_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case HplsqlParserL_D_STRING:
		localctx = NewDouble_quotedStringContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3514)
			p.Match(HplsqlParserL_D_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInt_numberContext is an interface to support dynamic dispatch.
type IInt_numberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_INT() antlr.TerminalNode
	T_SUB() antlr.TerminalNode
	T_ADD() antlr.TerminalNode

	// IsInt_numberContext differentiates from other interfaces.
	IsInt_numberContext()
}

type Int_numberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInt_numberContext() *Int_numberContext {
	var p = new(Int_numberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_int_number
	return p
}

func InitEmptyInt_numberContext(p *Int_numberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_int_number
}

func (*Int_numberContext) IsInt_numberContext() {}

func NewInt_numberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Int_numberContext {
	var p = new(Int_numberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_int_number

	return p
}

func (s *Int_numberContext) GetParser() antlr.Parser { return s.parser }

func (s *Int_numberContext) L_INT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_INT, 0)
}

func (s *Int_numberContext) T_SUB() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUB, 0)
}

func (s *Int_numberContext) T_ADD() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ADD, 0)
}

func (s *Int_numberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Int_numberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Int_numberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterInt_number(s)
	}
}

func (s *Int_numberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitInt_number(s)
	}
}

func (p *HplsqlParser) Int_number() (localctx IInt_numberContext) {
	localctx = NewInt_numberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, HplsqlParserRULE_int_number)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3518)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_ADD || _la == HplsqlParserT_SUB {
		{
			p.SetState(3517)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_ADD || _la == HplsqlParserT_SUB) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(3520)
		p.Match(HplsqlParserL_INT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDec_numberContext is an interface to support dynamic dispatch.
type IDec_numberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_DEC() antlr.TerminalNode
	T_SUB() antlr.TerminalNode
	T_ADD() antlr.TerminalNode

	// IsDec_numberContext differentiates from other interfaces.
	IsDec_numberContext()
}

type Dec_numberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDec_numberContext() *Dec_numberContext {
	var p = new(Dec_numberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_dec_number
	return p
}

func InitEmptyDec_numberContext(p *Dec_numberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_dec_number
}

func (*Dec_numberContext) IsDec_numberContext() {}

func NewDec_numberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dec_numberContext {
	var p = new(Dec_numberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_dec_number

	return p
}

func (s *Dec_numberContext) GetParser() antlr.Parser { return s.parser }

func (s *Dec_numberContext) L_DEC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_DEC, 0)
}

func (s *Dec_numberContext) T_SUB() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUB, 0)
}

func (s *Dec_numberContext) T_ADD() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ADD, 0)
}

func (s *Dec_numberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dec_numberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dec_numberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDec_number(s)
	}
}

func (s *Dec_numberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDec_number(s)
	}
}

func (p *HplsqlParser) Dec_number() (localctx IDec_numberContext) {
	localctx = NewDec_numberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, HplsqlParserRULE_dec_number)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3523)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == HplsqlParserT_ADD || _la == HplsqlParserT_SUB {
		{
			p.SetState(3522)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_ADD || _la == HplsqlParserT_SUB) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(3525)
		p.Match(HplsqlParserL_DEC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBool_literalContext is an interface to support dynamic dispatch.
type IBool_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_TRUE() antlr.TerminalNode
	T_FALSE() antlr.TerminalNode

	// IsBool_literalContext differentiates from other interfaces.
	IsBool_literalContext()
}

type Bool_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_literalContext() *Bool_literalContext {
	var p = new(Bool_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_literal
	return p
}

func InitEmptyBool_literalContext(p *Bool_literalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_literal
}

func (*Bool_literalContext) IsBool_literalContext() {}

func NewBool_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_literalContext {
	var p = new(Bool_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_bool_literal

	return p
}

func (s *Bool_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_literalContext) T_TRUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TRUE, 0)
}

func (s *Bool_literalContext) T_FALSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FALSE, 0)
}

func (s *Bool_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bool_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBool_literal(s)
	}
}

func (s *Bool_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBool_literal(s)
	}
}

func (p *HplsqlParser) Bool_literal() (localctx IBool_literalContext) {
	localctx = NewBool_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, HplsqlParserRULE_bool_literal)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3527)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_FALSE || _la == HplsqlParserT_TRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INull_constContext is an interface to support dynamic dispatch.
type INull_constContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_NULL() antlr.TerminalNode

	// IsNull_constContext differentiates from other interfaces.
	IsNull_constContext()
}

type Null_constContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNull_constContext() *Null_constContext {
	var p = new(Null_constContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_null_const
	return p
}

func InitEmptyNull_constContext(p *Null_constContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_null_const
}

func (*Null_constContext) IsNull_constContext() {}

func NewNull_constContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Null_constContext {
	var p = new(Null_constContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_null_const

	return p
}

func (s *Null_constContext) GetParser() antlr.Parser { return s.parser }

func (s *Null_constContext) T_NULL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NULL, 0)
}

func (s *Null_constContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Null_constContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Null_constContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterNull_const(s)
	}
}

func (s *Null_constContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitNull_const(s)
	}
}

func (p *HplsqlParser) Null_const() (localctx INull_constContext) {
	localctx = NewNull_constContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, HplsqlParserRULE_null_const)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3529)
		p.Match(HplsqlParserT_NULL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INon_reserved_wordsContext is an interface to support dynamic dispatch.
type INon_reserved_wordsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ACTION() antlr.TerminalNode
	T_ACTIVITY_COUNT() antlr.TerminalNode
	T_ADD2() antlr.TerminalNode
	T_ALL() antlr.TerminalNode
	T_ALLOCATE() antlr.TerminalNode
	T_ALTER() antlr.TerminalNode
	T_AND() antlr.TerminalNode
	T_ANSI_NULLS() antlr.TerminalNode
	T_ANSI_PADDING() antlr.TerminalNode
	T_AS() antlr.TerminalNode
	T_ASC() antlr.TerminalNode
	T_ASSOCIATE() antlr.TerminalNode
	T_AT() antlr.TerminalNode
	T_AUTO_INCREMENT() antlr.TerminalNode
	T_AVG() antlr.TerminalNode
	T_BATCHSIZE() antlr.TerminalNode
	T_BEGIN() antlr.TerminalNode
	T_BETWEEN() antlr.TerminalNode
	T_BIGINT() antlr.TerminalNode
	T_BINARY_DOUBLE() antlr.TerminalNode
	T_BINARY_FLOAT() antlr.TerminalNode
	T_BIT() antlr.TerminalNode
	T_BODY() antlr.TerminalNode
	T_BREAK() antlr.TerminalNode
	T_BULK() antlr.TerminalNode
	T_BY() antlr.TerminalNode
	T_BYTE() antlr.TerminalNode
	T_CALL() antlr.TerminalNode
	T_CALLER() antlr.TerminalNode
	T_CASCADE() antlr.TerminalNode
	T_CASE() antlr.TerminalNode
	T_CASESPECIFIC() antlr.TerminalNode
	T_CAST() antlr.TerminalNode
	T_CHAR() antlr.TerminalNode
	T_CHARACTER() antlr.TerminalNode
	T_CHARSET() antlr.TerminalNode
	T_CLIENT() antlr.TerminalNode
	T_CLOSE() antlr.TerminalNode
	T_CLUSTERED() antlr.TerminalNode
	T_CMP() antlr.TerminalNode
	T_COLLECT() antlr.TerminalNode
	T_COLLECTION() antlr.TerminalNode
	T_COLUMN() antlr.TerminalNode
	T_COMMENT() antlr.TerminalNode
	T_COMPRESS() antlr.TerminalNode
	T_CONSTANT() antlr.TerminalNode
	T_COPY() antlr.TerminalNode
	T_COMMIT() antlr.TerminalNode
	T_CONCAT() antlr.TerminalNode
	T_CONDITION() antlr.TerminalNode
	T_CONSTRAINT() antlr.TerminalNode
	T_CONTINUE() antlr.TerminalNode
	T_COUNT() antlr.TerminalNode
	T_COUNT_BIG() antlr.TerminalNode
	T_CREATE() antlr.TerminalNode
	T_CREATION() antlr.TerminalNode
	T_CREATOR() antlr.TerminalNode
	T_CS() antlr.TerminalNode
	T_CUME_DIST() antlr.TerminalNode
	T_CURRENT() antlr.TerminalNode
	T_CURRENT_DATE() antlr.TerminalNode
	T_CURRENT_SCHEMA() antlr.TerminalNode
	T_CURRENT_TIME_MILLIS() antlr.TerminalNode
	T_CURRENT_TIMESTAMP() antlr.TerminalNode
	T_CURRENT_USER() antlr.TerminalNode
	T_CURSOR() antlr.TerminalNode
	T_DATA() antlr.TerminalNode
	T_DATABASE() antlr.TerminalNode
	T_DATE() antlr.TerminalNode
	T_DATETIME() antlr.TerminalNode
	T_DAY() antlr.TerminalNode
	T_DAYS() antlr.TerminalNode
	T_DEC() antlr.TerminalNode
	T_DECIMAL() antlr.TerminalNode
	T_DECLARE() antlr.TerminalNode
	T_DEFAULT() antlr.TerminalNode
	T_DEFERRED() antlr.TerminalNode
	T_DEFINED() antlr.TerminalNode
	T_DEFINER() antlr.TerminalNode
	T_DEFINITION() antlr.TerminalNode
	T_DELETE() antlr.TerminalNode
	T_DELIMITED() antlr.TerminalNode
	T_DELIMITER() antlr.TerminalNode
	T_DENSE_RANK() antlr.TerminalNode
	T_DESC() antlr.TerminalNode
	T_DESCRIBE() antlr.TerminalNode
	T_DIAGNOSTICS() antlr.TerminalNode
	T_DIR() antlr.TerminalNode
	T_DIRECTORY() antlr.TerminalNode
	T_DISTINCT() antlr.TerminalNode
	T_DISTRIBUTE() antlr.TerminalNode
	T_DO() antlr.TerminalNode
	T_DOUBLE() antlr.TerminalNode
	T_DROP() antlr.TerminalNode
	T_DYNAMIC() antlr.TerminalNode
	T_ENABLE() antlr.TerminalNode
	T_ENGINE() antlr.TerminalNode
	T_ESCAPED() antlr.TerminalNode
	T_EXCEPT() antlr.TerminalNode
	T_EXEC() antlr.TerminalNode
	T_EXECUTE() antlr.TerminalNode
	T_EXCEPTION() antlr.TerminalNode
	T_EXCLUSIVE() antlr.TerminalNode
	T_EXISTS() antlr.TerminalNode
	T_EXIT() antlr.TerminalNode
	T_FALLBACK() antlr.TerminalNode
	T_FALSE() antlr.TerminalNode
	T_FETCH() antlr.TerminalNode
	T_FIELDS() antlr.TerminalNode
	T_FILE() antlr.TerminalNode
	T_FILES() antlr.TerminalNode
	T_FIRST_VALUE() antlr.TerminalNode
	T_FLOAT() antlr.TerminalNode
	T_FOR() antlr.TerminalNode
	T_FOREIGN() antlr.TerminalNode
	T_FORMAT() antlr.TerminalNode
	T_FOUND() antlr.TerminalNode
	T_FROM() antlr.TerminalNode
	T_FULL() antlr.TerminalNode
	T_FUNCTION() antlr.TerminalNode
	T_GET() antlr.TerminalNode
	T_GLOBAL() antlr.TerminalNode
	T_GO() antlr.TerminalNode
	T_GRANT() antlr.TerminalNode
	T_GROUP() antlr.TerminalNode
	T_HANDLER() antlr.TerminalNode
	T_HASH() antlr.TerminalNode
	T_HAVING() antlr.TerminalNode
	T_HDFS() antlr.TerminalNode
	T_HIVE() antlr.TerminalNode
	T_HOST() antlr.TerminalNode
	T_IDENTITY() antlr.TerminalNode
	T_IF() antlr.TerminalNode
	T_IGNORE() antlr.TerminalNode
	T_IMMEDIATE() antlr.TerminalNode
	T_IN() antlr.TerminalNode
	T_INCLUDE() antlr.TerminalNode
	T_INDEX() antlr.TerminalNode
	T_INITRANS() antlr.TerminalNode
	T_INNER() antlr.TerminalNode
	T_INOUT() antlr.TerminalNode
	T_INSERT() antlr.TerminalNode
	T_INT() antlr.TerminalNode
	T_INT2() antlr.TerminalNode
	T_INT4() antlr.TerminalNode
	T_INT8() antlr.TerminalNode
	T_INTEGER() antlr.TerminalNode
	T_INTERSECT() antlr.TerminalNode
	T_INTERVAL() antlr.TerminalNode
	T_INTO() antlr.TerminalNode
	T_INVOKER() antlr.TerminalNode
	T_ITEMS() antlr.TerminalNode
	T_IS() antlr.TerminalNode
	T_ISOPEN() antlr.TerminalNode
	T_JOIN() antlr.TerminalNode
	T_KEEP() antlr.TerminalNode
	T_KEY() antlr.TerminalNode
	T_KEYS() antlr.TerminalNode
	T_LAG() antlr.TerminalNode
	T_LANGUAGE() antlr.TerminalNode
	T_LAST_VALUE() antlr.TerminalNode
	T_LEAD() antlr.TerminalNode
	T_LEAVE() antlr.TerminalNode
	T_LEFT() antlr.TerminalNode
	T_LIKE() antlr.TerminalNode
	T_LIMIT() antlr.TerminalNode
	T_LINES() antlr.TerminalNode
	T_LOCAL() antlr.TerminalNode
	T_LOCATION() antlr.TerminalNode
	T_LOCATOR() antlr.TerminalNode
	T_LOCATORS() antlr.TerminalNode
	T_LOCKS() antlr.TerminalNode
	T_LOG() antlr.TerminalNode
	T_LOGGED() antlr.TerminalNode
	T_LOGGING() antlr.TerminalNode
	T_LOOP() antlr.TerminalNode
	T_MAP() antlr.TerminalNode
	T_MATCHED() antlr.TerminalNode
	T_MAX() antlr.TerminalNode
	T_MAXTRANS() antlr.TerminalNode
	T_MERGE() antlr.TerminalNode
	T_MESSAGE_TEXT() antlr.TerminalNode
	T_MICROSECOND() antlr.TerminalNode
	T_MICROSECONDS() antlr.TerminalNode
	T_MIN() antlr.TerminalNode
	T_MULTISET() antlr.TerminalNode
	T_NCHAR() antlr.TerminalNode
	T_NEW() antlr.TerminalNode
	T_NVARCHAR() antlr.TerminalNode
	T_NO() antlr.TerminalNode
	T_NOCOMPRESS() antlr.TerminalNode
	T_NOCOUNT() antlr.TerminalNode
	T_NOLOGGING() antlr.TerminalNode
	T_NONE() antlr.TerminalNode
	T_NOT() antlr.TerminalNode
	T_NOTFOUND() antlr.TerminalNode
	T_NUMERIC() antlr.TerminalNode
	T_NUMBER() antlr.TerminalNode
	T_OBJECT() antlr.TerminalNode
	T_OFF() antlr.TerminalNode
	T_ON() antlr.TerminalNode
	T_ONLY() antlr.TerminalNode
	T_OPEN() antlr.TerminalNode
	T_OR() antlr.TerminalNode
	T_ORDER() antlr.TerminalNode
	T_OUT() antlr.TerminalNode
	T_OUTER() antlr.TerminalNode
	T_OVER() antlr.TerminalNode
	T_OVERWRITE() antlr.TerminalNode
	T_OWNER() antlr.TerminalNode
	T_PACKAGE() antlr.TerminalNode
	T_PART_COUNT() antlr.TerminalNode
	T_PART_LOC() antlr.TerminalNode
	T_PARTITION() antlr.TerminalNode
	T_PCTFREE() antlr.TerminalNode
	T_PCTUSED() antlr.TerminalNode
	T_PRECISION() antlr.TerminalNode
	T_PRESERVE() antlr.TerminalNode
	T_PRIMARY() antlr.TerminalNode
	T_PRINT() antlr.TerminalNode
	T_PROC() antlr.TerminalNode
	T_PROCEDURE() antlr.TerminalNode
	T_PWD() antlr.TerminalNode
	T_QUALIFY() antlr.TerminalNode
	T_QUERY_BAND() antlr.TerminalNode
	T_QUIT() antlr.TerminalNode
	T_QUOTED_IDENTIFIER() antlr.TerminalNode
	T_RAISE() antlr.TerminalNode
	T_RANK() antlr.TerminalNode
	T_REAL() antlr.TerminalNode
	T_REFERENCES() antlr.TerminalNode
	T_REGEXP() antlr.TerminalNode
	T_RR() antlr.TerminalNode
	T_REPLACE() antlr.TerminalNode
	T_RESIGNAL() antlr.TerminalNode
	T_RESTRICT() antlr.TerminalNode
	T_RESULT() antlr.TerminalNode
	T_RESULT_SET_LOCATOR() antlr.TerminalNode
	T_RETURN() antlr.TerminalNode
	T_RETURNS() antlr.TerminalNode
	T_REVERSE() antlr.TerminalNode
	T_RIGHT() antlr.TerminalNode
	T_RLIKE() antlr.TerminalNode
	T_RS() antlr.TerminalNode
	T_ROLE() antlr.TerminalNode
	T_ROLLBACK() antlr.TerminalNode
	T_ROW() antlr.TerminalNode
	T_ROWS() antlr.TerminalNode
	T_ROW_COUNT() antlr.TerminalNode
	T_ROW_NUMBER() antlr.TerminalNode
	T_SCHEMA() antlr.TerminalNode
	T_SECOND() antlr.TerminalNode
	T_SECONDS() antlr.TerminalNode
	T_SECURITY() antlr.TerminalNode
	T_SEGMENT() antlr.TerminalNode
	T_SEL() antlr.TerminalNode
	T_SELECT() antlr.TerminalNode
	T_SESSION() antlr.TerminalNode
	T_SESSIONS() antlr.TerminalNode
	T_SET() antlr.TerminalNode
	T_SETS() antlr.TerminalNode
	T_SHARE() antlr.TerminalNode
	T_SIGNAL() antlr.TerminalNode
	T_SIMPLE_DOUBLE() antlr.TerminalNode
	T_SIMPLE_FLOAT() antlr.TerminalNode
	T_SMALLDATETIME() antlr.TerminalNode
	T_SMALLINT() antlr.TerminalNode
	T_SQL() antlr.TerminalNode
	T_SQLEXCEPTION() antlr.TerminalNode
	T_SQLINSERT() antlr.TerminalNode
	T_SQLSTATE() antlr.TerminalNode
	T_SQLWARNING() antlr.TerminalNode
	T_STATS() antlr.TerminalNode
	T_STATISTICS() antlr.TerminalNode
	T_STEP() antlr.TerminalNode
	T_STDEV() antlr.TerminalNode
	T_STORAGE() antlr.TerminalNode
	T_STORED() antlr.TerminalNode
	T_STRING() antlr.TerminalNode
	T_SUBDIR() antlr.TerminalNode
	T_SUBSTRING() antlr.TerminalNode
	T_SUM() antlr.TerminalNode
	T_SUMMARY() antlr.TerminalNode
	T_SYSDATE() antlr.TerminalNode
	T_SYS_REFCURSOR() antlr.TerminalNode
	T_TABLE() antlr.TerminalNode
	T_TABLESPACE() antlr.TerminalNode
	T_TEMPORARY() antlr.TerminalNode
	T_TERMINATED() antlr.TerminalNode
	T_TEXTIMAGE_ON() antlr.TerminalNode
	T_THEN() antlr.TerminalNode
	T_TIMESTAMP() antlr.TerminalNode
	T_TITLE() antlr.TerminalNode
	T_TO() antlr.TerminalNode
	T_TOP() antlr.TerminalNode
	T_TRANSACTION() antlr.TerminalNode
	T_TRIM() antlr.TerminalNode
	T_TRUE() antlr.TerminalNode
	T_TRUNCATE() antlr.TerminalNode
	T_UNIQUE() antlr.TerminalNode
	T_UPDATE() antlr.TerminalNode
	T_UR() antlr.TerminalNode
	T_USE() antlr.TerminalNode
	T_USER() antlr.TerminalNode
	T_USING() antlr.TerminalNode
	T_VALUE() antlr.TerminalNode
	T_VALUES() antlr.TerminalNode
	T_VAR() antlr.TerminalNode
	T_VARCHAR() antlr.TerminalNode
	T_VARCHAR2() antlr.TerminalNode
	T_VARYING() antlr.TerminalNode
	T_VARIANCE() antlr.TerminalNode
	T_VOLATILE() antlr.TerminalNode
	T_WHILE() antlr.TerminalNode
	T_WITH() antlr.TerminalNode
	T_WITHOUT() antlr.TerminalNode
	T_WORK() antlr.TerminalNode
	T_XACT_ABORT() antlr.TerminalNode
	T_XML() antlr.TerminalNode
	T_YES() antlr.TerminalNode

	// IsNon_reserved_wordsContext differentiates from other interfaces.
	IsNon_reserved_wordsContext()
}

type Non_reserved_wordsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNon_reserved_wordsContext() *Non_reserved_wordsContext {
	var p = new(Non_reserved_wordsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_non_reserved_words
	return p
}

func InitEmptyNon_reserved_wordsContext(p *Non_reserved_wordsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_non_reserved_words
}

func (*Non_reserved_wordsContext) IsNon_reserved_wordsContext() {}

func NewNon_reserved_wordsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Non_reserved_wordsContext {
	var p = new(Non_reserved_wordsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_non_reserved_words

	return p
}

func (s *Non_reserved_wordsContext) GetParser() antlr.Parser { return s.parser }

func (s *Non_reserved_wordsContext) T_ACTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ACTION, 0)
}

func (s *Non_reserved_wordsContext) T_ACTIVITY_COUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ACTIVITY_COUNT, 0)
}

func (s *Non_reserved_wordsContext) T_ADD2() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ADD2, 0)
}

func (s *Non_reserved_wordsContext) T_ALL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALL, 0)
}

func (s *Non_reserved_wordsContext) T_ALLOCATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALLOCATE, 0)
}

func (s *Non_reserved_wordsContext) T_ALTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALTER, 0)
}

func (s *Non_reserved_wordsContext) T_AND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AND, 0)
}

func (s *Non_reserved_wordsContext) T_ANSI_NULLS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ANSI_NULLS, 0)
}

func (s *Non_reserved_wordsContext) T_ANSI_PADDING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ANSI_PADDING, 0)
}

func (s *Non_reserved_wordsContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Non_reserved_wordsContext) T_ASC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ASC, 0)
}

func (s *Non_reserved_wordsContext) T_ASSOCIATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ASSOCIATE, 0)
}

func (s *Non_reserved_wordsContext) T_AT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AT, 0)
}

func (s *Non_reserved_wordsContext) T_AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AUTO_INCREMENT, 0)
}

func (s *Non_reserved_wordsContext) T_AVG() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AVG, 0)
}

func (s *Non_reserved_wordsContext) T_BATCHSIZE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BATCHSIZE, 0)
}

func (s *Non_reserved_wordsContext) T_BEGIN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BEGIN, 0)
}

func (s *Non_reserved_wordsContext) T_BETWEEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BETWEEN, 0)
}

func (s *Non_reserved_wordsContext) T_BIGINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BIGINT, 0)
}

func (s *Non_reserved_wordsContext) T_BINARY_DOUBLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BINARY_DOUBLE, 0)
}

func (s *Non_reserved_wordsContext) T_BINARY_FLOAT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BINARY_FLOAT, 0)
}

func (s *Non_reserved_wordsContext) T_BIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BIT, 0)
}

func (s *Non_reserved_wordsContext) T_BODY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BODY, 0)
}

func (s *Non_reserved_wordsContext) T_BREAK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BREAK, 0)
}

func (s *Non_reserved_wordsContext) T_BULK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BULK, 0)
}

func (s *Non_reserved_wordsContext) T_BY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BY, 0)
}

func (s *Non_reserved_wordsContext) T_BYTE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BYTE, 0)
}

func (s *Non_reserved_wordsContext) T_CALL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CALL, 0)
}

func (s *Non_reserved_wordsContext) T_CALLER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CALLER, 0)
}

func (s *Non_reserved_wordsContext) T_CASCADE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CASCADE, 0)
}

func (s *Non_reserved_wordsContext) T_CASE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CASE, 0)
}

func (s *Non_reserved_wordsContext) T_CASESPECIFIC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CASESPECIFIC, 0)
}

func (s *Non_reserved_wordsContext) T_CAST() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CAST, 0)
}

func (s *Non_reserved_wordsContext) T_CHAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CHAR, 0)
}

func (s *Non_reserved_wordsContext) T_CHARACTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CHARACTER, 0)
}

func (s *Non_reserved_wordsContext) T_CHARSET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CHARSET, 0)
}

func (s *Non_reserved_wordsContext) T_CLIENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLIENT, 0)
}

func (s *Non_reserved_wordsContext) T_CLOSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE, 0)
}

func (s *Non_reserved_wordsContext) T_CLUSTERED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLUSTERED, 0)
}

func (s *Non_reserved_wordsContext) T_CMP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CMP, 0)
}

func (s *Non_reserved_wordsContext) T_COLLECT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLLECT, 0)
}

func (s *Non_reserved_wordsContext) T_COLLECTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLLECTION, 0)
}

func (s *Non_reserved_wordsContext) T_COLUMN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLUMN, 0)
}

func (s *Non_reserved_wordsContext) T_COMMENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMENT, 0)
}

func (s *Non_reserved_wordsContext) T_COMPRESS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMPRESS, 0)
}

func (s *Non_reserved_wordsContext) T_CONSTANT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONSTANT, 0)
}

func (s *Non_reserved_wordsContext) T_COPY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COPY, 0)
}

func (s *Non_reserved_wordsContext) T_COMMIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMIT, 0)
}

func (s *Non_reserved_wordsContext) T_CONCAT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONCAT, 0)
}

func (s *Non_reserved_wordsContext) T_CONDITION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONDITION, 0)
}

func (s *Non_reserved_wordsContext) T_CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONSTRAINT, 0)
}

func (s *Non_reserved_wordsContext) T_CONTINUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONTINUE, 0)
}

func (s *Non_reserved_wordsContext) T_COUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COUNT, 0)
}

func (s *Non_reserved_wordsContext) T_COUNT_BIG() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COUNT_BIG, 0)
}

func (s *Non_reserved_wordsContext) T_CREATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATE, 0)
}

func (s *Non_reserved_wordsContext) T_CREATION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATION, 0)
}

func (s *Non_reserved_wordsContext) T_CREATOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATOR, 0)
}

func (s *Non_reserved_wordsContext) T_CS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CS, 0)
}

func (s *Non_reserved_wordsContext) T_CUME_DIST() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CUME_DIST, 0)
}

func (s *Non_reserved_wordsContext) T_CURRENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT, 0)
}

func (s *Non_reserved_wordsContext) T_CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT_DATE, 0)
}

func (s *Non_reserved_wordsContext) T_CURRENT_SCHEMA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT_SCHEMA, 0)
}

func (s *Non_reserved_wordsContext) T_CURRENT_TIME_MILLIS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT_TIME_MILLIS, 0)
}

func (s *Non_reserved_wordsContext) T_CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT_TIMESTAMP, 0)
}

func (s *Non_reserved_wordsContext) T_CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT_USER, 0)
}

func (s *Non_reserved_wordsContext) T_CURSOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURSOR, 0)
}

func (s *Non_reserved_wordsContext) T_DATA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATA, 0)
}

func (s *Non_reserved_wordsContext) T_DATABASE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATABASE, 0)
}

func (s *Non_reserved_wordsContext) T_DATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATE, 0)
}

func (s *Non_reserved_wordsContext) T_DATETIME() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATETIME, 0)
}

func (s *Non_reserved_wordsContext) T_DAY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DAY, 0)
}

func (s *Non_reserved_wordsContext) T_DAYS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DAYS, 0)
}

func (s *Non_reserved_wordsContext) T_DEC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEC, 0)
}

func (s *Non_reserved_wordsContext) T_DECIMAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DECIMAL, 0)
}

func (s *Non_reserved_wordsContext) T_DECLARE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DECLARE, 0)
}

func (s *Non_reserved_wordsContext) T_DEFAULT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFAULT, 0)
}

func (s *Non_reserved_wordsContext) T_DEFERRED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFERRED, 0)
}

func (s *Non_reserved_wordsContext) T_DEFINED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFINED, 0)
}

func (s *Non_reserved_wordsContext) T_DEFINER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFINER, 0)
}

func (s *Non_reserved_wordsContext) T_DEFINITION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFINITION, 0)
}

func (s *Non_reserved_wordsContext) T_DELETE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DELETE, 0)
}

func (s *Non_reserved_wordsContext) T_DELIMITED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DELIMITED, 0)
}

func (s *Non_reserved_wordsContext) T_DELIMITER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DELIMITER, 0)
}

func (s *Non_reserved_wordsContext) T_DENSE_RANK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DENSE_RANK, 0)
}

func (s *Non_reserved_wordsContext) T_DESC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DESC, 0)
}

func (s *Non_reserved_wordsContext) T_DESCRIBE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DESCRIBE, 0)
}

func (s *Non_reserved_wordsContext) T_DIAGNOSTICS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DIAGNOSTICS, 0)
}

func (s *Non_reserved_wordsContext) T_DIR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DIR, 0)
}

func (s *Non_reserved_wordsContext) T_DIRECTORY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DIRECTORY, 0)
}

func (s *Non_reserved_wordsContext) T_DISTINCT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DISTINCT, 0)
}

func (s *Non_reserved_wordsContext) T_DISTRIBUTE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DISTRIBUTE, 0)
}

func (s *Non_reserved_wordsContext) T_DO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DO, 0)
}

func (s *Non_reserved_wordsContext) T_DOUBLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DOUBLE, 0)
}

func (s *Non_reserved_wordsContext) T_DROP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DROP, 0)
}

func (s *Non_reserved_wordsContext) T_DYNAMIC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DYNAMIC, 0)
}

func (s *Non_reserved_wordsContext) T_ENABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ENABLE, 0)
}

func (s *Non_reserved_wordsContext) T_ENGINE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ENGINE, 0)
}

func (s *Non_reserved_wordsContext) T_ESCAPED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ESCAPED, 0)
}

func (s *Non_reserved_wordsContext) T_EXCEPT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXCEPT, 0)
}

func (s *Non_reserved_wordsContext) T_EXEC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXEC, 0)
}

func (s *Non_reserved_wordsContext) T_EXECUTE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXECUTE, 0)
}

func (s *Non_reserved_wordsContext) T_EXCEPTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXCEPTION, 0)
}

func (s *Non_reserved_wordsContext) T_EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXCLUSIVE, 0)
}

func (s *Non_reserved_wordsContext) T_EXISTS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXISTS, 0)
}

func (s *Non_reserved_wordsContext) T_EXIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXIT, 0)
}

func (s *Non_reserved_wordsContext) T_FALLBACK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FALLBACK, 0)
}

func (s *Non_reserved_wordsContext) T_FALSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FALSE, 0)
}

func (s *Non_reserved_wordsContext) T_FETCH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FETCH, 0)
}

func (s *Non_reserved_wordsContext) T_FIELDS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FIELDS, 0)
}

func (s *Non_reserved_wordsContext) T_FILE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FILE, 0)
}

func (s *Non_reserved_wordsContext) T_FILES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FILES, 0)
}

func (s *Non_reserved_wordsContext) T_FIRST_VALUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FIRST_VALUE, 0)
}

func (s *Non_reserved_wordsContext) T_FLOAT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FLOAT, 0)
}

func (s *Non_reserved_wordsContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *Non_reserved_wordsContext) T_FOREIGN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOREIGN, 0)
}

func (s *Non_reserved_wordsContext) T_FORMAT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FORMAT, 0)
}

func (s *Non_reserved_wordsContext) T_FOUND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOUND, 0)
}

func (s *Non_reserved_wordsContext) T_FROM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FROM, 0)
}

func (s *Non_reserved_wordsContext) T_FULL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FULL, 0)
}

func (s *Non_reserved_wordsContext) T_FUNCTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FUNCTION, 0)
}

func (s *Non_reserved_wordsContext) T_GET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GET, 0)
}

func (s *Non_reserved_wordsContext) T_GLOBAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GLOBAL, 0)
}

func (s *Non_reserved_wordsContext) T_GO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GO, 0)
}

func (s *Non_reserved_wordsContext) T_GRANT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GRANT, 0)
}

func (s *Non_reserved_wordsContext) T_GROUP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GROUP, 0)
}

func (s *Non_reserved_wordsContext) T_HANDLER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HANDLER, 0)
}

func (s *Non_reserved_wordsContext) T_HASH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HASH, 0)
}

func (s *Non_reserved_wordsContext) T_HAVING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HAVING, 0)
}

func (s *Non_reserved_wordsContext) T_HDFS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HDFS, 0)
}

func (s *Non_reserved_wordsContext) T_HIVE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HIVE, 0)
}

func (s *Non_reserved_wordsContext) T_HOST() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HOST, 0)
}

func (s *Non_reserved_wordsContext) T_IDENTITY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IDENTITY, 0)
}

func (s *Non_reserved_wordsContext) T_IF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IF, 0)
}

func (s *Non_reserved_wordsContext) T_IGNORE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IGNORE, 0)
}

func (s *Non_reserved_wordsContext) T_IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IMMEDIATE, 0)
}

func (s *Non_reserved_wordsContext) T_IN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IN, 0)
}

func (s *Non_reserved_wordsContext) T_INCLUDE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INCLUDE, 0)
}

func (s *Non_reserved_wordsContext) T_INDEX() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INDEX, 0)
}

func (s *Non_reserved_wordsContext) T_INITRANS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INITRANS, 0)
}

func (s *Non_reserved_wordsContext) T_INNER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INNER, 0)
}

func (s *Non_reserved_wordsContext) T_INOUT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INOUT, 0)
}

func (s *Non_reserved_wordsContext) T_INSERT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INSERT, 0)
}

func (s *Non_reserved_wordsContext) T_INT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INT, 0)
}

func (s *Non_reserved_wordsContext) T_INT2() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INT2, 0)
}

func (s *Non_reserved_wordsContext) T_INT4() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INT4, 0)
}

func (s *Non_reserved_wordsContext) T_INT8() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INT8, 0)
}

func (s *Non_reserved_wordsContext) T_INTEGER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTEGER, 0)
}

func (s *Non_reserved_wordsContext) T_INTERSECT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTERSECT, 0)
}

func (s *Non_reserved_wordsContext) T_INTERVAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTERVAL, 0)
}

func (s *Non_reserved_wordsContext) T_INTO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTO, 0)
}

func (s *Non_reserved_wordsContext) T_INVOKER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INVOKER, 0)
}

func (s *Non_reserved_wordsContext) T_ITEMS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ITEMS, 0)
}

func (s *Non_reserved_wordsContext) T_IS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IS, 0)
}

func (s *Non_reserved_wordsContext) T_ISOPEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ISOPEN, 0)
}

func (s *Non_reserved_wordsContext) T_JOIN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_JOIN, 0)
}

func (s *Non_reserved_wordsContext) T_KEEP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_KEEP, 0)
}

func (s *Non_reserved_wordsContext) T_KEY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_KEY, 0)
}

func (s *Non_reserved_wordsContext) T_KEYS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_KEYS, 0)
}

func (s *Non_reserved_wordsContext) T_LAG() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LAG, 0)
}

func (s *Non_reserved_wordsContext) T_LANGUAGE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LANGUAGE, 0)
}

func (s *Non_reserved_wordsContext) T_LAST_VALUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LAST_VALUE, 0)
}

func (s *Non_reserved_wordsContext) T_LEAD() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LEAD, 0)
}

func (s *Non_reserved_wordsContext) T_LEAVE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LEAVE, 0)
}

func (s *Non_reserved_wordsContext) T_LEFT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LEFT, 0)
}

func (s *Non_reserved_wordsContext) T_LIKE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LIKE, 0)
}

func (s *Non_reserved_wordsContext) T_LIMIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LIMIT, 0)
}

func (s *Non_reserved_wordsContext) T_LINES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LINES, 0)
}

func (s *Non_reserved_wordsContext) T_LOCAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCAL, 0)
}

func (s *Non_reserved_wordsContext) T_LOCATION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCATION, 0)
}

func (s *Non_reserved_wordsContext) T_LOCATOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCATOR, 0)
}

func (s *Non_reserved_wordsContext) T_LOCATORS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCATORS, 0)
}

func (s *Non_reserved_wordsContext) T_LOCKS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCKS, 0)
}

func (s *Non_reserved_wordsContext) T_LOG() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOG, 0)
}

func (s *Non_reserved_wordsContext) T_LOGGED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOGGED, 0)
}

func (s *Non_reserved_wordsContext) T_LOGGING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOGGING, 0)
}

func (s *Non_reserved_wordsContext) T_LOOP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOOP, 0)
}

func (s *Non_reserved_wordsContext) T_MAP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAP, 0)
}

func (s *Non_reserved_wordsContext) T_MATCHED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MATCHED, 0)
}

func (s *Non_reserved_wordsContext) T_MAX() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAX, 0)
}

func (s *Non_reserved_wordsContext) T_MAXTRANS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAXTRANS, 0)
}

func (s *Non_reserved_wordsContext) T_MERGE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MERGE, 0)
}

func (s *Non_reserved_wordsContext) T_MESSAGE_TEXT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MESSAGE_TEXT, 0)
}

func (s *Non_reserved_wordsContext) T_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MICROSECOND, 0)
}

func (s *Non_reserved_wordsContext) T_MICROSECONDS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MICROSECONDS, 0)
}

func (s *Non_reserved_wordsContext) T_MIN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MIN, 0)
}

func (s *Non_reserved_wordsContext) T_MULTISET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MULTISET, 0)
}

func (s *Non_reserved_wordsContext) T_NCHAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NCHAR, 0)
}

func (s *Non_reserved_wordsContext) T_NEW() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NEW, 0)
}

func (s *Non_reserved_wordsContext) T_NVARCHAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NVARCHAR, 0)
}

func (s *Non_reserved_wordsContext) T_NO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NO, 0)
}

func (s *Non_reserved_wordsContext) T_NOCOMPRESS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOCOMPRESS, 0)
}

func (s *Non_reserved_wordsContext) T_NOCOUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOCOUNT, 0)
}

func (s *Non_reserved_wordsContext) T_NOLOGGING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOLOGGING, 0)
}

func (s *Non_reserved_wordsContext) T_NONE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NONE, 0)
}

func (s *Non_reserved_wordsContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Non_reserved_wordsContext) T_NOTFOUND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOTFOUND, 0)
}

func (s *Non_reserved_wordsContext) T_NUMERIC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NUMERIC, 0)
}

func (s *Non_reserved_wordsContext) T_NUMBER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NUMBER, 0)
}

func (s *Non_reserved_wordsContext) T_OBJECT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OBJECT, 0)
}

func (s *Non_reserved_wordsContext) T_OFF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OFF, 0)
}

func (s *Non_reserved_wordsContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *Non_reserved_wordsContext) T_ONLY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ONLY, 0)
}

func (s *Non_reserved_wordsContext) T_OPEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN, 0)
}

func (s *Non_reserved_wordsContext) T_OR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OR, 0)
}

func (s *Non_reserved_wordsContext) T_ORDER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ORDER, 0)
}

func (s *Non_reserved_wordsContext) T_OUT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OUT, 0)
}

func (s *Non_reserved_wordsContext) T_OUTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OUTER, 0)
}

func (s *Non_reserved_wordsContext) T_OVER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OVER, 0)
}

func (s *Non_reserved_wordsContext) T_OVERWRITE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OVERWRITE, 0)
}

func (s *Non_reserved_wordsContext) T_OWNER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OWNER, 0)
}

func (s *Non_reserved_wordsContext) T_PACKAGE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PACKAGE, 0)
}

func (s *Non_reserved_wordsContext) T_PART_COUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PART_COUNT, 0)
}

func (s *Non_reserved_wordsContext) T_PART_LOC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PART_LOC, 0)
}

func (s *Non_reserved_wordsContext) T_PARTITION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PARTITION, 0)
}

func (s *Non_reserved_wordsContext) T_PCTFREE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PCTFREE, 0)
}

func (s *Non_reserved_wordsContext) T_PCTUSED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PCTUSED, 0)
}

func (s *Non_reserved_wordsContext) T_PRECISION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRECISION, 0)
}

func (s *Non_reserved_wordsContext) T_PRESERVE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRESERVE, 0)
}

func (s *Non_reserved_wordsContext) T_PRIMARY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRIMARY, 0)
}

func (s *Non_reserved_wordsContext) T_PRINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRINT, 0)
}

func (s *Non_reserved_wordsContext) T_PROC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PROC, 0)
}

func (s *Non_reserved_wordsContext) T_PROCEDURE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PROCEDURE, 0)
}

func (s *Non_reserved_wordsContext) T_PWD() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PWD, 0)
}

func (s *Non_reserved_wordsContext) T_QUALIFY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_QUALIFY, 0)
}

func (s *Non_reserved_wordsContext) T_QUERY_BAND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_QUERY_BAND, 0)
}

func (s *Non_reserved_wordsContext) T_QUIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_QUIT, 0)
}

func (s *Non_reserved_wordsContext) T_QUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_QUOTED_IDENTIFIER, 0)
}

func (s *Non_reserved_wordsContext) T_RAISE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RAISE, 0)
}

func (s *Non_reserved_wordsContext) T_RANK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RANK, 0)
}

func (s *Non_reserved_wordsContext) T_REAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REAL, 0)
}

func (s *Non_reserved_wordsContext) T_REFERENCES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REFERENCES, 0)
}

func (s *Non_reserved_wordsContext) T_REGEXP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REGEXP, 0)
}

func (s *Non_reserved_wordsContext) T_RR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RR, 0)
}

func (s *Non_reserved_wordsContext) T_REPLACE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REPLACE, 0)
}

func (s *Non_reserved_wordsContext) T_RESIGNAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESIGNAL, 0)
}

func (s *Non_reserved_wordsContext) T_RESTRICT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESTRICT, 0)
}

func (s *Non_reserved_wordsContext) T_RESULT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESULT, 0)
}

func (s *Non_reserved_wordsContext) T_RESULT_SET_LOCATOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESULT_SET_LOCATOR, 0)
}

func (s *Non_reserved_wordsContext) T_RETURN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RETURN, 0)
}

func (s *Non_reserved_wordsContext) T_RETURNS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RETURNS, 0)
}

func (s *Non_reserved_wordsContext) T_REVERSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REVERSE, 0)
}

func (s *Non_reserved_wordsContext) T_RIGHT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RIGHT, 0)
}

func (s *Non_reserved_wordsContext) T_RLIKE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RLIKE, 0)
}

func (s *Non_reserved_wordsContext) T_RS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RS, 0)
}

func (s *Non_reserved_wordsContext) T_ROLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROLE, 0)
}

func (s *Non_reserved_wordsContext) T_ROLLBACK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROLLBACK, 0)
}

func (s *Non_reserved_wordsContext) T_ROW() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROW, 0)
}

func (s *Non_reserved_wordsContext) T_ROWS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROWS, 0)
}

func (s *Non_reserved_wordsContext) T_ROW_COUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROW_COUNT, 0)
}

func (s *Non_reserved_wordsContext) T_ROW_NUMBER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROW_NUMBER, 0)
}

func (s *Non_reserved_wordsContext) T_SCHEMA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SCHEMA, 0)
}

func (s *Non_reserved_wordsContext) T_SECOND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SECOND, 0)
}

func (s *Non_reserved_wordsContext) T_SECONDS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SECONDS, 0)
}

func (s *Non_reserved_wordsContext) T_SECURITY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SECURITY, 0)
}

func (s *Non_reserved_wordsContext) T_SEGMENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEGMENT, 0)
}

func (s *Non_reserved_wordsContext) T_SEL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEL, 0)
}

func (s *Non_reserved_wordsContext) T_SELECT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SELECT, 0)
}

func (s *Non_reserved_wordsContext) T_SESSION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SESSION, 0)
}

func (s *Non_reserved_wordsContext) T_SESSIONS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SESSIONS, 0)
}

func (s *Non_reserved_wordsContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Non_reserved_wordsContext) T_SETS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SETS, 0)
}

func (s *Non_reserved_wordsContext) T_SHARE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SHARE, 0)
}

func (s *Non_reserved_wordsContext) T_SIGNAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SIGNAL, 0)
}

func (s *Non_reserved_wordsContext) T_SIMPLE_DOUBLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SIMPLE_DOUBLE, 0)
}

func (s *Non_reserved_wordsContext) T_SIMPLE_FLOAT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SIMPLE_FLOAT, 0)
}

func (s *Non_reserved_wordsContext) T_SMALLDATETIME() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SMALLDATETIME, 0)
}

func (s *Non_reserved_wordsContext) T_SMALLINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SMALLINT, 0)
}

func (s *Non_reserved_wordsContext) T_SQL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SQL, 0)
}

func (s *Non_reserved_wordsContext) T_SQLEXCEPTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SQLEXCEPTION, 0)
}

func (s *Non_reserved_wordsContext) T_SQLINSERT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SQLINSERT, 0)
}

func (s *Non_reserved_wordsContext) T_SQLSTATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SQLSTATE, 0)
}

func (s *Non_reserved_wordsContext) T_SQLWARNING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SQLWARNING, 0)
}

func (s *Non_reserved_wordsContext) T_STATS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STATS, 0)
}

func (s *Non_reserved_wordsContext) T_STATISTICS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STATISTICS, 0)
}

func (s *Non_reserved_wordsContext) T_STEP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STEP, 0)
}

func (s *Non_reserved_wordsContext) T_STDEV() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STDEV, 0)
}

func (s *Non_reserved_wordsContext) T_STORAGE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STORAGE, 0)
}

func (s *Non_reserved_wordsContext) T_STORED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STORED, 0)
}

func (s *Non_reserved_wordsContext) T_STRING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STRING, 0)
}

func (s *Non_reserved_wordsContext) T_SUBDIR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUBDIR, 0)
}

func (s *Non_reserved_wordsContext) T_SUBSTRING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUBSTRING, 0)
}

func (s *Non_reserved_wordsContext) T_SUM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUM, 0)
}

func (s *Non_reserved_wordsContext) T_SUMMARY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUMMARY, 0)
}

func (s *Non_reserved_wordsContext) T_SYSDATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SYSDATE, 0)
}

func (s *Non_reserved_wordsContext) T_SYS_REFCURSOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SYS_REFCURSOR, 0)
}

func (s *Non_reserved_wordsContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLE, 0)
}

func (s *Non_reserved_wordsContext) T_TABLESPACE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLESPACE, 0)
}

func (s *Non_reserved_wordsContext) T_TEMPORARY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TEMPORARY, 0)
}

func (s *Non_reserved_wordsContext) T_TERMINATED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TERMINATED, 0)
}

func (s *Non_reserved_wordsContext) T_TEXTIMAGE_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TEXTIMAGE_ON, 0)
}

func (s *Non_reserved_wordsContext) T_THEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_THEN, 0)
}

func (s *Non_reserved_wordsContext) T_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TIMESTAMP, 0)
}

func (s *Non_reserved_wordsContext) T_TITLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TITLE, 0)
}

func (s *Non_reserved_wordsContext) T_TO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TO, 0)
}

func (s *Non_reserved_wordsContext) T_TOP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TOP, 0)
}

func (s *Non_reserved_wordsContext) T_TRANSACTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TRANSACTION, 0)
}

func (s *Non_reserved_wordsContext) T_TRIM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TRIM, 0)
}

func (s *Non_reserved_wordsContext) T_TRUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TRUE, 0)
}

func (s *Non_reserved_wordsContext) T_TRUNCATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TRUNCATE, 0)
}

func (s *Non_reserved_wordsContext) T_UNIQUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UNIQUE, 0)
}

func (s *Non_reserved_wordsContext) T_UPDATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UPDATE, 0)
}

func (s *Non_reserved_wordsContext) T_UR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UR, 0)
}

func (s *Non_reserved_wordsContext) T_USE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_USE, 0)
}

func (s *Non_reserved_wordsContext) T_USER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_USER, 0)
}

func (s *Non_reserved_wordsContext) T_USING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_USING, 0)
}

func (s *Non_reserved_wordsContext) T_VALUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VALUE, 0)
}

func (s *Non_reserved_wordsContext) T_VALUES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VALUES, 0)
}

func (s *Non_reserved_wordsContext) T_VAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VAR, 0)
}

func (s *Non_reserved_wordsContext) T_VARCHAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VARCHAR, 0)
}

func (s *Non_reserved_wordsContext) T_VARCHAR2() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VARCHAR2, 0)
}

func (s *Non_reserved_wordsContext) T_VARYING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VARYING, 0)
}

func (s *Non_reserved_wordsContext) T_VARIANCE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VARIANCE, 0)
}

func (s *Non_reserved_wordsContext) T_VOLATILE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VOLATILE, 0)
}

func (s *Non_reserved_wordsContext) T_WHILE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WHILE, 0)
}

func (s *Non_reserved_wordsContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITH, 0)
}

func (s *Non_reserved_wordsContext) T_WITHOUT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITHOUT, 0)
}

func (s *Non_reserved_wordsContext) T_WORK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WORK, 0)
}

func (s *Non_reserved_wordsContext) T_XACT_ABORT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_XACT_ABORT, 0)
}

func (s *Non_reserved_wordsContext) T_XML() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_XML, 0)
}

func (s *Non_reserved_wordsContext) T_YES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_YES, 0)
}

func (s *Non_reserved_wordsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Non_reserved_wordsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Non_reserved_wordsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterNon_reserved_words(s)
	}
}

func (s *Non_reserved_wordsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitNon_reserved_words(s)
	}
}

func (p *HplsqlParser) Non_reserved_words() (localctx INon_reserved_wordsContext) {
	localctx = NewNon_reserved_wordsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, HplsqlParserRULE_non_reserved_words)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3531)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4328521760) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-49392123905) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-72057594037927937) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-36028797094462497) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-1729453312849219585) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&534806527) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *HplsqlParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 4:
		var t *Block_endContext = nil
		if localctx != nil {
			t = localctx.(*Block_endContext)
		}
		return p.Block_end_Sempred(t, predIndex)

	case 11:
		var t *Expr_stmtContext = nil
		if localctx != nil {
			t = localctx.(*Expr_stmtContext)
		}
		return p.Expr_stmt_Sempred(t, predIndex)

	case 84:
		var t *Create_routine_paramsContext = nil
		if localctx != nil {
			t = localctx.(*Create_routine_paramsContext)
		}
		return p.Create_routine_params_Sempred(t, predIndex)

	case 164:
		var t *Select_list_aliasContext = nil
		if localctx != nil {
			t = localctx.(*Select_list_aliasContext)
		}
		return p.Select_list_alias_Sempred(t, predIndex)

	case 177:
		var t *From_alias_clauseContext = nil
		if localctx != nil {
			t = localctx.(*From_alias_clauseContext)
		}
		return p.From_alias_clause_Sempred(t, predIndex)

	case 195:
		var t *Delete_aliasContext = nil
		if localctx != nil {
			t = localctx.(*Delete_aliasContext)
		}
		return p.Delete_alias_Sempred(t, predIndex)

	case 197:
		var t *Bool_exprContext = nil
		if localctx != nil {
			t = localctx.(*Bool_exprContext)
		}
		return p.Bool_expr_Sempred(t, predIndex)

	case 205:
		var t *ExprContext = nil
		if localctx != nil {
			t = localctx.(*ExprContext)
		}
		return p.Expr_Sempred(t, predIndex)

	case 225:
		var t *Func_paramContext = nil
		if localctx != nil {
			t = localctx.(*Func_paramContext)
		}
		return p.Func_param_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *HplsqlParser) Block_end_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return !strings.EqualFold(p.GetTokenStream().LT(2).GetText(), "TRANSACTION")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *HplsqlParser) Expr_stmt_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "GO")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *HplsqlParser) Create_routine_params_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "IS") &&
			!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "AS") &&
			!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "DYNAMIC") && strings.EqualFold(p.GetTokenStream().LT(2).GetText(), "RESULT")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *HplsqlParser) Select_list_alias_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "INTO") && !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "FROM")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *HplsqlParser) From_alias_clause_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 4:
		return !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "EXEC") &&
			!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "EXECUTE") &&
			!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "INNER") &&
			!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "LEFT") &&
			!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "GROUP") &&
			!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "ORDER") &&
			!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "LIMIT") &&
			!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "WITH")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *HplsqlParser) Delete_alias_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
		return !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "ALL")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *HplsqlParser) Bool_expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 6:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *HplsqlParser) Expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 14)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *HplsqlParser) Func_param_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 10:
		return !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "INTO")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
