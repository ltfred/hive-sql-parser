// Code generated from Hplsql.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser // Hplsql

import (
	"fmt"
	"strconv"
	"strings"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}


type HplsqlParser struct {
	*antlr.BaseParser
}

var HplsqlParserStaticData struct {
  once                   sync.Once
  serializedATN          []int32
  LiteralNames           []string
  SymbolicNames          []string
  RuleNames              []string
  PredictionContextCache *antlr.PredictionContextCache
  atn                    *antlr.ATN
  decisionToDFA          []*antlr.DFA
}

func hplsqlParserInit() {
  staticData := &HplsqlParserStaticData
  staticData.LiteralNames = []string{
    "", "'@'", "'#'", "'%'", "'!'", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "", "", "", "'+'", "':'", "','", "'||'", 
    "'/'", "'.'", "'..'", "'='", "'=='", "'<>'", "'!='", "'>'", "'>='", 
    "'<'", "'<='", "'*'", "'{'", "'('", "'['", "'}'", "')'", "']'", "';'", 
    "'-'",
  }
  staticData.SymbolicNames = []string{
    "", "", "", "", "", "T_ACTION", "T_ADD2", "T_ALL", "T_ALLOCATE", "T_ALTER", 
    "T_AND", "T_ANSI_NULLS", "T_ANSI_PADDING", "T_AS", "T_ASC", "T_ASSOCIATE", 
    "T_AT", "T_AUTO_INCREMENT", "T_AVG", "T_BATCHSIZE", "T_BEGIN", "T_BETWEEN", 
    "T_BIGINT", "T_BINARY_DOUBLE", "T_BINARY_FLOAT", "T_BINARY_INTEGER", 
    "T_BIT", "T_BODY", "T_BREAK", "T_BULK", "T_BY", "T_BYTE", "T_CALL", 
    "T_CALLER", "T_CASCADE", "T_CASE", "T_CASESPECIFIC", "T_CAST", "T_CHAR", 
    "T_CHARACTER", "T_CHARSET", "T_CLIENT", "T_CLOSE", "T_CLUSTERED", "T_CMP", 
    "T_COLLECT", "T_COLLECTION", "T_COLUMN", "T_COMMENT", "T_CONSTANT", 
    "T_COMMIT", "T_COMPRESS", "T_CONCAT", "T_CONDITION", "T_CONSTRAINT", 
    "T_CONTINUE", "T_COPY", "T_COUNT", "T_COUNT_BIG", "T_CREATE", "T_CREATION", 
    "T_CREATOR", "T_CS", "T_CURRENT", "T_CURRENT_SCHEMA", "T_CURSOR", "T_DATABASE", 
    "T_DATA", "T_DATE", "T_DATETIME", "T_DAY", "T_DAYS", "T_DEC", "T_DECIMAL", 
    "T_DECLARE", "T_DEFAULT", "T_DEFERRED", "T_DEFINED", "T_DEFINER", "T_DEFINITION", 
    "T_DELETE", "T_DELIMITED", "T_DELIMITER", "T_DESC", "T_DESCRIBE", "T_DIAGNOSTICS", 
    "T_DIR", "T_DIRECTORY", "T_DISTINCT", "T_DISTRIBUTE", "T_DO", "T_DOUBLE", 
    "T_DROP", "T_DYNAMIC", "T_ELSE", "T_ELSEIF", "T_ELSIF", "T_ENABLE", 
    "T_END", "T_ENGINE", "T_ESCAPED", "T_EXCEPT", "T_EXEC", "T_EXECUTE", 
    "T_EXCEPTION", "T_EXCLUSIVE", "T_EXISTS", "T_EXIT", "T_FALLBACK", "T_FALSE", 
    "T_FETCH", "T_FIELDS", "T_FILE", "T_FILES", "T_FLOAT", "T_FOR", "T_FOREIGN", 
    "T_FORMAT", "T_FOUND", "T_FROM", "T_FULL", "T_FUNCTION", "T_GET", "T_GLOBAL", 
    "T_GO", "T_GRANT", "T_GROUP", "T_HANDLER", "T_HASH", "T_HAVING", "T_HDFS", 
    "T_HIVE", "T_HOST", "T_IDENTITY", "T_IF", "T_IGNORE", "T_IMMEDIATE", 
    "T_IN", "T_INCLUDE", "T_INDEX", "T_INITRANS", "T_INNER", "T_INOUT", 
    "T_INSERT", "T_INT", "T_INT2", "T_INT4", "T_INT8", "T_INTEGER", "T_INTERSECT", 
    "T_INTERVAL", "T_INTO", "T_INVOKER", "T_IS", "T_ISOPEN", "T_ITEMS", 
    "T_JOIN", "T_KEEP", "T_KEY", "T_KEYS", "T_LANGUAGE", "T_LEAVE", "T_LEFT", 
    "T_LIKE", "T_LIMIT", "T_LINES", "T_LOCAL", "T_LOCATION", "T_LOCATOR", 
    "T_LOCATORS", "T_LOCKS", "T_LOG", "T_LOGGED", "T_LOGGING", "T_LOOP", 
    "T_MAP", "T_MATCHED", "T_MAX", "T_MAXTRANS", "T_MERGE", "T_MESSAGE_TEXT", 
    "T_MICROSECOND", "T_MICROSECONDS", "T_MILLIS", "T_MIN", "T_MULTISET", 
    "T_NCHAR", "T_NEW", "T_NVARCHAR", "T_NO", "T_NOCOUNT", "T_NOCOMPRESS", 
    "T_NOLOGGING", "T_NONE", "T_NOT", "T_NOTFOUND", "T_NULL", "T_NUMERIC", 
    "T_NUMBER", "T_OBJECT", "T_OFF", "T_OF", "T_ON", "T_ONLY", "T_OPEN", 
    "T_OR", "T_ORDER", "T_OUT", "T_OUTER", "T_OVER", "T_OVERWRITE", "T_OWNER", 
    "T_PACKAGE", "T_PARTITION", "T_PCTFREE", "T_PCTUSED", "T_PLS_INTEGER", 
    "T_PRECISION", "T_PRESERVE", "T_PRIMARY", "T_PRINT", "T_PROC", "T_PROCEDURE", 
    "T_QUALIFY", "T_QUERY_BAND", "T_QUIT", "T_QUOTED_IDENTIFIER", "T_RAISE", 
    "T_REAL", "T_REFERENCES", "T_REGEXP", "T_REPLACE", "T_RESIGNAL", "T_RESTRICT", 
    "T_RESULT", "T_RESULT_SET_LOCATOR", "T_RETURN", "T_RETURNS", "T_REVERSE", 
    "T_RIGHT", "T_RLIKE", "T_ROLE", "T_ROLLBACK", "T_ROW", "T_ROWS", "T_ROWTYPE", 
    "T_ROW_COUNT", "T_RR", "T_RS", "T_PWD", "T_TRIM", "T_SCHEMA", "T_SECOND", 
    "T_SECONDS", "T_SECURITY", "T_SEGMENT", "T_SEL", "T_SELECT", "T_SET", 
    "T_SESSION", "T_SESSIONS", "T_SETS", "T_SHARE", "T_SIGNAL", "T_SIMPLE_DOUBLE", 
    "T_SIMPLE_FLOAT", "T_SIMPLE_INTEGER", "T_SMALLDATETIME", "T_SMALLINT", 
    "T_SQL", "T_SQLEXCEPTION", "T_SQLINSERT", "T_SQLSTATE", "T_SQLWARNING", 
    "T_STATS", "T_STATISTICS", "T_STEP", "T_STORAGE", "T_STORED", "T_STRING", 
    "T_SUBDIR", "T_SUBSTRING", "T_SUM", "T_SUMMARY", "T_SYS_REFCURSOR", 
    "T_TABLE", "T_TABLESPACE", "T_TEMPORARY", "T_TERMINATED", "T_TEXTIMAGE_ON", 
    "T_THEN", "T_TIME", "T_TIMESTAMP", "T_TINYINT", "T_TITLE", "T_TO", "T_TOP", 
    "T_TRANSACTION", "T_TRUE", "T_TRUNCATE", "T_TYPE", "T_UNION", "T_UNIQUE", 
    "T_UPDATE", "T_UR", "T_USE", "T_USING", "T_VALUE", "T_VALUES", "T_VAR", 
    "T_VARCHAR", "T_VARCHAR2", "T_VARYING", "T_VOLATILE", "T_WHEN", "T_WHERE", 
    "T_WHILE", "T_WITH", "T_WITHOUT", "T_WORK", "T_XACT_ABORT", "T_XML", 
    "T_YES", "T_ACTIVITY_COUNT", "T_CUME_DIST", "T_CURRENT_DATE", "T_CURRENT_TIME_MILLIS", 
    "T_CURRENT_TIMESTAMP", "T_CURRENT_USER", "T_DENSE_RANK", "T_FIRST_VALUE", 
    "T_LAG", "T_LAST_VALUE", "T_LEAD", "T_MAX_PART_STRING", "T_MIN_PART_STRING", 
    "T_MAX_PART_INT", "T_MIN_PART_INT", "T_MAX_PART_DATE", "T_MIN_PART_DATE", 
    "T_PART_COUNT", "T_PART_LOC", "T_RANK", "T_ROW_NUMBER", "T_STDEV", "T_SYSDATE", 
    "T_VARIANCE", "T_USER", "T_ADD", "T_COLON", "T_COMMA", "T_PIPE", "T_DIV", 
    "T_DOT", "T_DOT2", "T_EQUAL", "T_EQUAL2", "T_NOTEQUAL", "T_NOTEQUAL2", 
    "T_GREATER", "T_GREATEREQUAL", "T_LESS", "T_LESSEQUAL", "T_MUL", "T_OPEN_B", 
    "T_OPEN_P", "T_OPEN_SB", "T_CLOSE_B", "T_CLOSE_P", "T_CLOSE_SB", "T_SEMICOLON", 
    "T_SUB", "L_ID", "L_S_STRING", "L_D_STRING", "L_INT", "L_DEC", "L_WS", 
    "L_M_COMMENT", "L_S_COMMENT", "L_FILE", "L_LABEL",
  }
  staticData.RuleNames = []string{
    "program", "block", "begin_end_block", "single_block_stmt", "block_end", 
    "proc_block", "stmt", "semicolon_stmt", "exception_block", "exception_block_item", 
    "null_stmt", "expr_stmt", "assignment_stmt", "assignment_stmt_item", 
    "assignment_stmt_single_item", "assignment_stmt_collection_item", "assignment_stmt_multiple_item", 
    "assignment_stmt_select_item", "allocate_cursor_stmt", "associate_locator_stmt", 
    "begin_transaction_stmt", "break_stmt", "call_stmt", "declare_stmt", 
    "declare_block", "declare_block_inplace", "declare_stmt_item", "declare_var_item", 
    "declare_condition_item", "declare_cursor_item", "cursor_with_return", 
    "cursor_without_return", "declare_handler_item", "declare_temporary_table_item", 
    "create_table_stmt", "create_local_temp_table_stmt", "create_table_definition", 
    "create_table_column_comment", "create_table_columns", "create_table_columns_item", 
    "create_table_type_stmt", "tbl_type", "sql_type", "column_name", "create_table_column_inline_cons", 
    "create_table_column_cons", "create_table_fk_action", "create_table_preoptions", 
    "create_table_preoptions_item", "create_table_preoptions_td_item", "create_table_options", 
    "create_table_options_item", "create_table_options_ora_item", "create_table_options_db2_item", 
    "create_table_options_td_item", "create_table_options_hive_item", "create_table_hive_row_format", 
    "create_table_hive_row_format_fields", "create_table_options_mssql_item", 
    "create_table_options_mysql_item", "alter_table_stmt", "alter_table_item", 
    "alter_table_add_constraint", "alter_table_add_constraint_item", "dtype", 
    "dtype_len", "dtype_attr", "dtype_default", "create_database_stmt", 
    "create_database_option", "create_function_stmt", "create_function_return", 
    "create_package_stmt", "package_spec", "package_spec_item", "create_package_body_stmt", 
    "package_body", "package_body_item", "create_procedure_stmt", "create_routine_params", 
    "create_routine_param_item", "create_routine_options", "create_routine_option", 
    "drop_stmt", "end_transaction_stmt", "exec_stmt", "if_stmt", "if_plsql_stmt", 
    "if_tsql_stmt", "if_bteq_stmt", "elseif_block", "else_block", "include_stmt", 
    "insert_stmt", "insert_stmt_cols", "insert_stmt_rows", "insert_stmt_row", 
    "insert_directory_stmt", "exit_stmt", "get_diag_stmt", "get_diag_stmt_item", 
    "get_diag_stmt_exception_item", "get_diag_stmt_rowcount_item", "grant_stmt", 
    "grant_stmt_item", "leave_stmt", "map_object_stmt", "open_stmt", "fetch_stmt", 
    "fetch_limit", "collect_stats_stmt", "collect_stats_clause", "close_stmt", 
    "cmp_stmt", "cmp_source", "copy_from_local_stmt", "copy_stmt", "copy_source", 
    "copy_target", "copy_option", "copy_file_option", "commit_stmt", "create_index_stmt", 
    "create_index_col", "index_storage_clause", "index_mssql_storage_clause", 
    "print_stmt", "quit_stmt", "raise_stmt", "resignal_stmt", "return_stmt", 
    "rollback_stmt", "set_session_option", "set_current_schema_option", 
    "set_mssql_session_option", "set_teradata_session_option", "signal_stmt", 
    "summary_stmt", "truncate_stmt", "use_stmt", "values_into_stmt", "while_stmt", 
    "unconditional_loop_stmt", "for_cursor_stmt", "for_range_stmt", "label", 
    "using_clause", "select_stmt", "cte_select_stmt", "cte_select_stmt_item", 
    "cte_select_cols", "fullselect_stmt", "fullselect_stmt_item", "fullselect_set_clause", 
    "subselect_stmt", "select_list", "select_list_set", "select_list_limit", 
    "select_list_item", "select_list_alias", "select_list_asterisk", "table_row", 
    "into_clause", "bulk_collect_clause", "from_clause", "from_table_clause", 
    "from_table_name_clause", "from_subselect_clause", "from_join_clause", 
    "from_join_type_clause", "from_table_values_clause", "from_table_values_row", 
    "from_alias_clause", "table_name", "where_clause", "group_by_clause", 
    "having_clause", "qualify_clause", "order_by_clause", "select_options", 
    "select_options_item", "update_stmt", "update_assignment", "update_table", 
    "update_upsert", "merge_stmt", "merge_table", "merge_condition", "merge_action", 
    "delete_stmt", "delete_alias", "describe_stmt", "bool_expr", "bool_expr_atom", 
    "bool_expr_unary", "bool_expr_single_in", "bool_expr_multi_in", "bool_expr_binary", 
    "bool_expr_logical_operator", "bool_expr_binary_operator", "expr", "expr_atom", 
    "expr_interval", "interval_item", "expr_concat", "expr_concat_item", 
    "expr_case", "expr_case_simple", "expr_case_searched", "expr_cursor_attribute", 
    "expr_agg_window_func", "expr_func_all_distinct", "expr_func_over_clause", 
    "expr_func_partition_by_clause", "expr_spec_func", "expr_func", "expr_dot", 
    "expr_dot_method_call", "expr_dot_property_access", "expr_func_params", 
    "func_param", "expr_select", "expr_file", "hive", "hive_item", "host", 
    "host_cmd", "host_stmt", "file_name", "date_literal", "timestamp_literal", 
    "ident", "qident", "string", "int_number", "dec_number", "bool_literal", 
    "null_const", "non_reserved_words",
  }
  staticData.PredictionContextCache = antlr.NewPredictionContextCache()
  staticData.serializedATN = []int32{
	4, 1, 381, 3461, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 
	7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 
	7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 
	15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 
	2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 
	26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 
	7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 
	36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 
	2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 
	47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 
	7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 
	57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 
	2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 
	68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 
	7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 
	78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83, 
	2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2, 
	89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94, 
	7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7, 
	99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2, 
	104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7, 
	108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2, 
	113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7, 
	117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2, 
	122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7, 
	126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2, 
	131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7, 
	135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2, 
	140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7, 
	144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2, 
	149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7, 
	153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2, 
	158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7, 
	162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2, 
	167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7, 
	171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2, 
	176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7, 
	180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2, 
	185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7, 
	189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2, 
	194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7, 
	198, 2, 199, 7, 199, 2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2, 
	203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206, 7, 206, 2, 207, 7, 
	207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2, 
	212, 7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7, 
	216, 2, 217, 7, 217, 2, 218, 7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2, 
	221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 2, 224, 7, 224, 2, 225, 7, 
	225, 2, 226, 7, 226, 2, 227, 7, 227, 2, 228, 7, 228, 2, 229, 7, 229, 2, 
	230, 7, 230, 2, 231, 7, 231, 2, 232, 7, 232, 2, 233, 7, 233, 2, 234, 7, 
	234, 2, 235, 7, 235, 2, 236, 7, 236, 2, 237, 7, 237, 2, 238, 7, 238, 1, 
	0, 1, 0, 1, 0, 1, 1, 1, 1, 3, 1, 484, 8, 1, 1, 1, 3, 1, 487, 8, 1, 4, 1, 
	489, 8, 1, 11, 1, 12, 1, 490, 1, 2, 3, 2, 494, 8, 2, 1, 2, 1, 2, 1, 2, 
	3, 2, 499, 8, 2, 1, 2, 1, 2, 1, 3, 1, 3, 1, 3, 3, 3, 506, 8, 3, 1, 3, 1, 
	3, 1, 3, 1, 3, 3, 3, 512, 8, 3, 3, 3, 514, 8, 3, 1, 4, 1, 4, 1, 4, 1, 5, 
	1, 5, 4, 5, 521, 8, 5, 11, 5, 12, 5, 522, 1, 5, 3, 5, 526, 8, 5, 3, 5, 
	528, 8, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 
	1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 
	1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 
	1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 
	1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 
	1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 3, 6, 593, 8, 6, 1, 7, 1, 7, 1, 8, 1, 8, 
	4, 8, 599, 8, 8, 11, 8, 12, 8, 600, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 
	1, 10, 1, 10, 1, 11, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 3, 12, 617, 8, 
	12, 1, 12, 1, 12, 1, 12, 5, 12, 622, 8, 12, 10, 12, 12, 12, 625, 9, 12, 
	3, 12, 627, 8, 12, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 633, 8, 13, 1, 14, 
	1, 14, 3, 14, 637, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 
	14, 3, 14, 646, 8, 14, 1, 14, 1, 14, 1, 14, 3, 14, 651, 8, 14, 1, 15, 1, 
	15, 1, 15, 1, 15, 1, 15, 1, 16, 1, 16, 1, 16, 1, 16, 5, 16, 662, 8, 16, 
	10, 16, 12, 16, 665, 9, 16, 1, 16, 1, 16, 3, 16, 669, 8, 16, 1, 16, 1, 
	16, 1, 16, 1, 16, 1, 16, 5, 16, 676, 8, 16, 10, 16, 12, 16, 679, 9, 16, 
	1, 16, 1, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 5, 17, 688, 8, 17, 10, 
	17, 12, 17, 691, 9, 17, 1, 17, 1, 17, 3, 17, 695, 8, 17, 1, 17, 3, 17, 
	698, 8, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 18, 1, 18, 1, 18, 1, 
	18, 1, 18, 1, 18, 1, 18, 3, 18, 712, 8, 18, 1, 18, 1, 18, 1, 19, 1, 19, 
	1, 19, 3, 19, 719, 8, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 5, 19, 726, 
	8, 19, 10, 19, 12, 19, 729, 9, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 
	20, 1, 20, 1, 20, 1, 21, 1, 21, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 745, 
	8, 22, 1, 23, 1, 23, 1, 23, 1, 23, 5, 23, 751, 8, 23, 10, 23, 12, 23, 754, 
	9, 23, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 5, 24, 762, 8, 24, 10, 
	24, 12, 24, 765, 9, 24, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 5, 25, 772, 
	8, 25, 10, 25, 12, 25, 775, 9, 25, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 3, 
	26, 782, 8, 26, 1, 27, 1, 27, 1, 27, 5, 27, 787, 8, 27, 10, 27, 12, 27, 
	790, 9, 27, 1, 27, 3, 27, 793, 8, 27, 1, 27, 1, 27, 3, 27, 797, 8, 27, 
	1, 27, 5, 27, 800, 8, 27, 10, 27, 12, 27, 803, 9, 27, 1, 27, 3, 27, 806, 
	8, 27, 1, 27, 1, 27, 1, 27, 3, 27, 811, 8, 27, 1, 27, 1, 27, 3, 27, 815, 
	8, 27, 1, 27, 1, 27, 3, 27, 819, 8, 27, 1, 28, 1, 28, 1, 28, 1, 29, 1, 
	29, 1, 29, 1, 29, 1, 29, 3, 29, 829, 8, 29, 1, 29, 1, 29, 3, 29, 833, 8, 
	29, 1, 29, 1, 29, 1, 29, 3, 29, 838, 8, 29, 1, 30, 1, 30, 1, 30, 3, 30, 
	843, 8, 30, 1, 30, 1, 30, 3, 30, 847, 8, 30, 1, 31, 1, 31, 1, 31, 1, 32, 
	1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 3, 32, 860, 8, 32, 1, 
	32, 1, 32, 1, 33, 3, 33, 865, 8, 33, 1, 33, 1, 33, 1, 33, 1, 33, 3, 33, 
	871, 8, 33, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 3, 34, 880, 
	8, 34, 1, 34, 1, 34, 3, 34, 884, 8, 34, 1, 34, 1, 34, 1, 35, 1, 35, 1, 
	35, 1, 35, 3, 35, 892, 8, 35, 1, 35, 3, 35, 895, 8, 35, 1, 35, 1, 35, 1, 
	35, 3, 35, 900, 8, 35, 1, 35, 1, 35, 1, 36, 3, 36, 905, 8, 36, 1, 36, 1, 
	36, 1, 36, 1, 36, 1, 36, 3, 36, 912, 8, 36, 1, 36, 1, 36, 1, 36, 1, 36, 
	1, 36, 1, 36, 1, 36, 3, 36, 921, 8, 36, 1, 36, 3, 36, 924, 8, 36, 1, 37, 
	1, 37, 1, 37, 1, 38, 1, 38, 3, 38, 931, 8, 38, 1, 38, 1, 38, 1, 38, 3, 
	38, 936, 8, 38, 5, 38, 938, 8, 38, 10, 38, 12, 38, 941, 9, 38, 1, 39, 1, 
	39, 1, 39, 3, 39, 946, 8, 39, 1, 39, 5, 39, 949, 8, 39, 10, 39, 12, 39, 
	952, 9, 39, 1, 39, 5, 39, 955, 8, 39, 10, 39, 12, 39, 958, 9, 39, 1, 39, 
	1, 39, 3, 39, 962, 8, 39, 1, 39, 3, 39, 965, 8, 39, 1, 40, 1, 40, 1, 40, 
	1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 3, 40, 975, 8, 40, 1, 40, 1, 40, 1, 
	40, 1, 40, 1, 41, 1, 41, 3, 41, 983, 8, 41, 1, 42, 1, 42, 1, 42, 1, 42, 
	1, 43, 1, 43, 1, 44, 1, 44, 3, 44, 993, 8, 44, 1, 44, 1, 44, 1, 44, 1, 
	44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 5, 44, 1005, 8, 44, 10, 44, 
	12, 44, 1008, 9, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 5, 44, 1015, 8, 
	44, 10, 44, 12, 44, 1018, 9, 44, 1, 44, 1, 44, 1, 44, 3, 44, 1023, 8, 44, 
	1, 45, 1, 45, 1, 45, 3, 45, 1028, 8, 45, 1, 45, 1, 45, 1, 45, 3, 45, 1033, 
	8, 45, 1, 45, 1, 45, 1, 45, 3, 45, 1038, 8, 45, 5, 45, 1040, 8, 45, 10, 
	45, 12, 45, 1043, 9, 45, 1, 45, 1, 45, 3, 45, 1047, 8, 45, 1, 45, 3, 45, 
	1050, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 5, 45, 1058, 8, 
	45, 10, 45, 12, 45, 1061, 9, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 
	45, 1, 45, 5, 45, 1070, 8, 45, 10, 45, 12, 45, 1073, 9, 45, 1, 45, 1, 45, 
	5, 45, 1077, 8, 45, 10, 45, 12, 45, 1080, 9, 45, 3, 45, 1082, 8, 45, 1, 
	46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46, 
	1094, 8, 46, 1, 47, 4, 47, 1097, 8, 47, 11, 47, 12, 47, 1098, 1, 48, 1, 
	48, 1, 48, 3, 48, 1104, 8, 48, 1, 49, 3, 49, 1107, 8, 49, 1, 49, 1, 49, 
	1, 50, 4, 50, 1112, 8, 50, 11, 50, 12, 50, 1113, 1, 51, 1, 51, 1, 51, 1, 
	51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 3, 51, 1126, 8, 51, 1, 52, 
	1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 4, 
	52, 1139, 8, 52, 11, 52, 12, 52, 1140, 1, 52, 1, 52, 1, 52, 3, 52, 1146, 
	8, 52, 1, 53, 3, 53, 1149, 8, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 
	53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 5, 53, 1162, 8, 53, 10, 53, 12, 
	53, 1165, 9, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1170, 8, 53, 1, 53, 1, 53, 
	1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1181, 8, 53, 1, 
	54, 3, 54, 1184, 8, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 5, 54, 
	1192, 8, 54, 10, 54, 12, 54, 1195, 9, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 
	54, 1201, 8, 54, 1, 55, 1, 55, 1, 55, 1, 55, 3, 55, 1207, 8, 55, 1, 56, 
	1, 56, 1, 56, 1, 56, 5, 56, 1213, 8, 56, 10, 56, 12, 56, 1216, 9, 56, 1, 
	57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 1225, 8, 57, 1, 57, 
	1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 
	57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 1245, 8, 57, 1, 58, 
	1, 58, 1, 58, 1, 58, 3, 58, 1251, 8, 58, 1, 59, 1, 59, 3, 59, 1255, 8, 
	59, 1, 59, 1, 59, 1, 59, 3, 59, 1260, 8, 59, 1, 59, 1, 59, 3, 59, 1264, 
	8, 59, 1, 59, 1, 59, 1, 59, 3, 59, 1269, 8, 59, 1, 59, 3, 59, 1272, 8, 
	59, 1, 59, 1, 59, 1, 59, 3, 59, 1277, 8, 59, 1, 59, 3, 59, 1280, 8, 59, 
	1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 61, 1, 61, 1, 62, 1, 62, 1, 62, 3, 
	62, 1292, 8, 62, 1, 62, 1, 62, 1, 63, 1, 63, 1, 63, 3, 63, 1299, 8, 63, 
	1, 63, 1, 63, 1, 63, 3, 63, 1304, 8, 63, 1, 63, 1, 63, 1, 63, 3, 63, 1309, 
	8, 63, 5, 63, 1311, 8, 63, 10, 63, 12, 63, 1314, 9, 63, 1, 63, 1, 63, 3, 
	63, 1318, 8, 63, 1, 63, 3, 63, 1321, 8, 63, 1, 63, 1, 63, 1, 63, 1, 63, 
	1, 63, 1, 63, 5, 63, 1329, 8, 63, 10, 63, 12, 63, 1332, 9, 63, 1, 63, 1, 
	63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 5, 63, 1341, 8, 63, 10, 63, 12, 
	63, 1344, 9, 63, 1, 63, 1, 63, 5, 63, 1348, 8, 63, 10, 63, 12, 63, 1351, 
	9, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 3, 63, 1358, 8, 63, 1, 64, 1, 
	64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 
	1, 64, 3, 64, 1373, 8, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 
	64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 
	1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 
	64, 1, 64, 3, 64, 1404, 8, 64, 3, 64, 1406, 8, 64, 1, 65, 1, 65, 1, 65, 
	3, 65, 1411, 8, 65, 1, 65, 1, 65, 3, 65, 1415, 8, 65, 1, 65, 1, 65, 1, 
	66, 3, 66, 1420, 8, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 3, 66, 1427, 
	8, 66, 1, 66, 3, 66, 1430, 8, 66, 1, 67, 3, 67, 1433, 8, 67, 1, 67, 1, 
	67, 1, 67, 3, 67, 1438, 8, 67, 1, 67, 1, 67, 3, 67, 1442, 8, 67, 3, 67, 
	1444, 8, 67, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 3, 68, 1451, 8, 68, 1, 
	68, 1, 68, 5, 68, 1455, 8, 68, 10, 68, 12, 68, 1458, 9, 68, 1, 69, 1, 69, 
	1, 69, 1, 69, 3, 69, 1464, 8, 69, 1, 70, 1, 70, 1, 70, 1, 70, 3, 70, 1470, 
	8, 70, 1, 70, 3, 70, 1473, 8, 70, 1, 70, 1, 70, 1, 70, 3, 70, 1478, 8, 
	70, 1, 70, 1, 70, 3, 70, 1482, 8, 70, 1, 70, 3, 70, 1485, 8, 70, 1, 70, 
	1, 70, 1, 71, 1, 71, 1, 71, 3, 71, 1492, 8, 71, 1, 72, 1, 72, 1, 72, 1, 
	72, 3, 72, 1498, 8, 72, 1, 72, 3, 72, 1501, 8, 72, 1, 72, 1, 72, 1, 72, 
	1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 1511, 8, 72, 1, 73, 1, 73, 1, 
	73, 1, 73, 1, 73, 5, 73, 1518, 8, 73, 10, 73, 12, 73, 1521, 9, 73, 1, 74, 
	1, 74, 1, 74, 1, 74, 3, 74, 1527, 8, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 
	74, 3, 74, 1534, 8, 74, 3, 74, 1536, 8, 74, 1, 75, 1, 75, 1, 75, 1, 75, 
	3, 75, 1542, 8, 75, 1, 75, 3, 75, 1545, 8, 75, 1, 75, 1, 75, 1, 75, 1, 
	75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 3, 75, 1556, 8, 75, 1, 76, 1, 76, 
	1, 76, 1, 76, 1, 76, 5, 76, 1563, 8, 76, 10, 76, 12, 76, 1566, 9, 76, 1, 
	77, 1, 77, 1, 77, 3, 77, 1571, 8, 77, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 
	1577, 8, 78, 1, 78, 3, 78, 1580, 8, 78, 1, 78, 1, 78, 1, 78, 3, 78, 1585, 
	8, 78, 1, 78, 3, 78, 1588, 8, 78, 1, 78, 3, 78, 1591, 8, 78, 1, 78, 3, 
	78, 1594, 8, 78, 1, 78, 3, 78, 1597, 8, 78, 1, 78, 1, 78, 1, 78, 1, 78, 
	3, 78, 1603, 8, 78, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 5, 79, 1611, 
	8, 79, 10, 79, 12, 79, 1614, 9, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 
	1, 79, 5, 79, 1622, 8, 79, 10, 79, 12, 79, 1625, 9, 79, 3, 79, 1627, 8, 
	79, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 3, 80, 1634, 8, 80, 1, 80, 1, 80, 
	1, 80, 3, 80, 1639, 8, 80, 1, 80, 5, 80, 1642, 8, 80, 10, 80, 12, 80, 1645, 
	9, 80, 1, 80, 3, 80, 1648, 8, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 
	80, 3, 80, 1656, 8, 80, 1, 80, 1, 80, 3, 80, 1660, 8, 80, 1, 80, 5, 80, 
	1663, 8, 80, 10, 80, 12, 80, 1666, 9, 80, 1, 80, 3, 80, 1669, 8, 80, 3, 
	80, 1671, 8, 80, 1, 81, 4, 81, 1674, 8, 81, 11, 81, 12, 81, 1675, 1, 82, 
	1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 3, 82, 1684, 8, 82, 1, 82, 1, 82, 1, 
	82, 3, 82, 1689, 8, 82, 1, 83, 1, 83, 1, 83, 1, 83, 3, 83, 1695, 8, 83, 
	1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 3, 83, 1702, 8, 83, 1, 83, 1, 83, 1, 
	83, 1, 83, 1, 83, 3, 83, 1709, 8, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 
	3, 83, 1716, 8, 83, 1, 83, 3, 83, 1719, 8, 83, 1, 84, 1, 84, 1, 84, 1, 
	85, 1, 85, 3, 85, 1726, 8, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 
	3, 85, 1734, 8, 85, 1, 85, 1, 85, 1, 85, 1, 85, 5, 85, 1740, 8, 85, 10, 
	85, 12, 85, 1743, 9, 85, 3, 85, 1745, 8, 85, 1, 85, 3, 85, 1748, 8, 85, 
	1, 86, 1, 86, 1, 86, 3, 86, 1753, 8, 86, 1, 87, 1, 87, 1, 87, 1, 87, 1, 
	87, 5, 87, 1760, 8, 87, 10, 87, 12, 87, 1763, 9, 87, 1, 87, 3, 87, 1766, 
	8, 87, 1, 87, 1, 87, 1, 87, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 3, 88, 1776, 
	8, 88, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 90, 1, 90, 1, 90, 1, 
	90, 1, 90, 1, 91, 1, 91, 1, 91, 1, 92, 1, 92, 1, 92, 3, 92, 1795, 8, 92, 
	1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 3, 93, 1802, 8, 93, 3, 93, 1804, 8, 
	93, 1, 93, 1, 93, 3, 93, 1808, 8, 93, 1, 93, 1, 93, 3, 93, 1812, 8, 93, 
	1, 94, 1, 94, 1, 94, 1, 94, 5, 94, 1818, 8, 94, 10, 94, 12, 94, 1821, 9, 
	94, 1, 94, 1, 94, 1, 95, 1, 95, 1, 95, 1, 95, 5, 95, 1829, 8, 95, 10, 95, 
	12, 95, 1832, 9, 95, 1, 96, 1, 96, 1, 96, 1, 96, 5, 96, 1838, 8, 96, 10, 
	96, 12, 96, 1841, 9, 96, 1, 96, 1, 96, 1, 97, 1, 97, 1, 97, 3, 97, 1848, 
	8, 97, 1, 97, 1, 97, 1, 97, 1, 97, 1, 98, 1, 98, 3, 98, 1856, 8, 98, 1, 
	98, 1, 98, 3, 98, 1860, 8, 98, 1, 99, 1, 99, 1, 99, 1, 99, 1, 100, 1, 100, 
	3, 100, 1868, 8, 100, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 
	102, 1, 102, 1, 102, 1, 102, 1, 103, 1, 103, 1, 103, 1, 103, 5, 103, 1884, 
	8, 103, 10, 103, 12, 103, 1887, 9, 103, 1, 103, 1, 103, 1, 103, 1, 103, 
	1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 105, 1, 105, 3, 105, 1900, 8, 
	105, 1, 106, 1, 106, 1, 106, 1, 106, 1, 106, 3, 106, 1907, 8, 106, 1, 106, 
	1, 106, 3, 106, 1911, 8, 106, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 3, 
	107, 1918, 8, 107, 3, 107, 1920, 8, 107, 1, 108, 1, 108, 3, 108, 1924, 
	8, 108, 1, 108, 1, 108, 3, 108, 1928, 8, 108, 1, 108, 1, 108, 1, 108, 1, 
	108, 5, 108, 1934, 8, 108, 10, 108, 12, 108, 1937, 9, 108, 1, 108, 3, 108, 
	1940, 8, 108, 1, 109, 1, 109, 1, 109, 1, 110, 1, 110, 1, 110, 1, 110, 1, 
	110, 3, 110, 1950, 8, 110, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 5, 111, 
	1957, 8, 111, 10, 111, 12, 111, 1960, 9, 111, 1, 111, 1, 111, 1, 112, 1, 
	112, 1, 112, 1, 113, 1, 113, 1, 113, 1, 113, 1, 113, 1, 113, 1, 114, 1, 
	114, 3, 114, 1975, 8, 114, 1, 114, 1, 114, 1, 114, 1, 114, 3, 114, 1981, 
	8, 114, 1, 114, 1, 114, 3, 114, 1985, 8, 114, 1, 115, 1, 115, 1, 115, 1, 
	115, 1, 115, 1, 115, 5, 115, 1993, 8, 115, 10, 115, 12, 115, 1996, 9, 115, 
	1, 115, 1, 115, 1, 115, 5, 115, 2001, 8, 115, 10, 115, 12, 115, 2004, 9, 
	115, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 3, 116, 2012, 8, 116, 
	1, 116, 1, 116, 3, 116, 2016, 8, 116, 1, 116, 1, 116, 5, 116, 2020, 8, 
	116, 10, 116, 12, 116, 2023, 9, 116, 1, 117, 1, 117, 3, 117, 2027, 8, 117, 
	1, 118, 1, 118, 3, 118, 2031, 8, 118, 1, 119, 1, 119, 1, 119, 1, 119, 1, 
	119, 1, 119, 1, 119, 1, 119, 3, 119, 2041, 8, 119, 1, 120, 1, 120, 1, 121, 
	1, 121, 3, 121, 2047, 8, 121, 1, 122, 1, 122, 3, 122, 2051, 8, 122, 1, 
	122, 1, 122, 1, 122, 1, 122, 1, 122, 1, 122, 1, 122, 1, 122, 5, 122, 2061, 
	8, 122, 10, 122, 12, 122, 2064, 9, 122, 1, 122, 1, 122, 1, 123, 1, 123, 
	3, 123, 2070, 8, 123, 1, 124, 1, 124, 1, 125, 1, 125, 1, 125, 1, 125, 1, 
	125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 5, 125, 2084, 8, 125, 10, 
	125, 12, 125, 2087, 9, 125, 1, 125, 1, 125, 5, 125, 2091, 8, 125, 10, 125, 
	12, 125, 2094, 9, 125, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 
	1, 126, 3, 126, 2103, 8, 126, 1, 127, 3, 127, 2106, 8, 127, 1, 127, 1, 
	127, 3, 127, 2110, 8, 127, 1, 128, 1, 128, 1, 129, 1, 129, 1, 129, 3, 129, 
	2117, 8, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 3, 129, 2124, 8, 
	129, 3, 129, 2126, 8, 129, 1, 130, 1, 130, 3, 130, 2130, 8, 130, 1, 131, 
	1, 131, 3, 131, 2134, 8, 131, 1, 132, 1, 132, 1, 132, 3, 132, 2139, 8, 
	132, 1, 133, 3, 133, 2142, 8, 133, 1, 133, 1, 133, 3, 133, 2146, 8, 133, 
	1, 133, 3, 133, 2149, 8, 133, 1, 133, 1, 133, 1, 134, 1, 134, 1, 134, 1, 
	135, 1, 135, 1, 135, 1, 135, 3, 135, 2160, 8, 135, 1, 135, 3, 135, 2163, 
	8, 135, 1, 135, 1, 135, 1, 135, 1, 136, 1, 136, 1, 136, 1, 137, 1, 137, 
	1, 137, 3, 137, 2174, 8, 137, 1, 137, 1, 137, 1, 137, 1, 137, 3, 137, 2180, 
	8, 137, 1, 137, 1, 137, 3, 137, 2184, 8, 137, 3, 137, 2186, 8, 137, 1, 
	138, 1, 138, 3, 138, 2190, 8, 138, 1, 138, 1, 138, 1, 139, 1, 139, 1, 139, 
	1, 140, 1, 140, 3, 140, 2199, 8, 140, 1, 140, 1, 140, 1, 140, 5, 140, 2204, 
	8, 140, 10, 140, 12, 140, 2207, 9, 140, 1, 140, 3, 140, 2210, 8, 140, 1, 
	140, 1, 140, 3, 140, 2214, 8, 140, 1, 140, 1, 140, 1, 140, 5, 140, 2219, 
	8, 140, 10, 140, 12, 140, 2222, 9, 140, 1, 140, 3, 140, 2225, 8, 140, 1, 
	141, 1, 141, 1, 141, 1, 141, 1, 141, 1, 141, 3, 141, 2233, 8, 141, 1, 142, 
	1, 142, 1, 142, 1, 142, 1, 142, 1, 143, 1, 143, 1, 143, 1, 143, 3, 143, 
	2244, 8, 143, 1, 143, 1, 143, 3, 143, 2248, 8, 143, 1, 143, 1, 143, 1, 
	143, 1, 143, 1, 143, 1, 144, 1, 144, 1, 144, 1, 144, 3, 144, 2259, 8, 144, 
	1, 144, 1, 144, 1, 144, 1, 144, 1, 144, 3, 144, 2266, 8, 144, 1, 144, 1, 
	144, 1, 144, 1, 144, 1, 144, 1, 145, 1, 145, 1, 145, 1, 145, 1, 145, 1, 
	145, 3, 145, 2279, 8, 145, 1, 146, 1, 146, 1, 146, 1, 146, 5, 146, 2285, 
	8, 146, 10, 146, 12, 146, 2288, 9, 146, 1, 147, 3, 147, 2291, 8, 147, 1, 
	147, 1, 147, 1, 148, 1, 148, 1, 148, 1, 148, 5, 148, 2299, 8, 148, 10, 
	148, 12, 148, 2302, 9, 148, 1, 149, 1, 149, 3, 149, 2306, 8, 149, 1, 149, 
	1, 149, 1, 149, 1, 149, 1, 149, 1, 150, 1, 150, 1, 150, 1, 150, 5, 150, 
	2317, 8, 150, 10, 150, 12, 150, 2320, 9, 150, 1, 150, 1, 150, 1, 151, 1, 
	151, 1, 151, 1, 151, 5, 151, 2328, 8, 151, 10, 151, 12, 151, 2331, 9, 151, 
	1, 152, 1, 152, 1, 152, 1, 152, 1, 152, 3, 152, 2338, 8, 152, 1, 153, 1, 
	153, 3, 153, 2342, 8, 153, 1, 153, 1, 153, 3, 153, 2346, 8, 153, 1, 153, 
	1, 153, 3, 153, 2350, 8, 153, 3, 153, 2352, 8, 153, 1, 154, 1, 154, 1, 
	154, 3, 154, 2357, 8, 154, 1, 154, 3, 154, 2360, 8, 154, 1, 154, 3, 154, 
	2363, 8, 154, 1, 154, 3, 154, 2366, 8, 154, 1, 154, 1, 154, 3, 154, 2370, 
	8, 154, 1, 154, 3, 154, 2373, 8, 154, 1, 154, 3, 154, 2376, 8, 154, 1, 
	155, 3, 155, 2379, 8, 155, 1, 155, 3, 155, 2382, 8, 155, 1, 155, 1, 155, 
	1, 155, 5, 155, 2387, 8, 155, 10, 155, 12, 155, 2390, 9, 155, 1, 156, 1, 
	156, 1, 157, 1, 157, 1, 157, 1, 158, 1, 158, 1, 158, 3, 158, 2400, 8, 158, 
	1, 158, 1, 158, 3, 158, 2404, 8, 158, 1, 158, 3, 158, 2407, 8, 158, 1, 
	159, 1, 159, 3, 159, 2411, 8, 159, 1, 159, 1, 159, 1, 159, 1, 159, 1, 159, 
	3, 159, 2418, 8, 159, 1, 160, 1, 160, 3, 160, 2422, 8, 160, 1, 160, 1, 
	160, 1, 161, 1, 161, 1, 161, 1, 161, 1, 161, 1, 162, 3, 162, 2432, 8, 162, 
	1, 162, 1, 162, 1, 162, 3, 162, 2437, 8, 162, 1, 162, 1, 162, 1, 162, 3, 
	162, 2442, 8, 162, 5, 162, 2444, 8, 162, 10, 162, 12, 162, 2447, 9, 162, 
	1, 163, 1, 163, 1, 163, 1, 164, 1, 164, 1, 164, 5, 164, 2455, 8, 164, 10, 
	164, 12, 164, 2458, 9, 164, 1, 165, 1, 165, 1, 165, 3, 165, 2463, 8, 165, 
	1, 166, 1, 166, 3, 166, 2467, 8, 166, 1, 167, 1, 167, 1, 167, 1, 167, 3, 
	167, 2473, 8, 167, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 
	3, 168, 2482, 8, 168, 1, 169, 3, 169, 2485, 8, 169, 1, 169, 1, 169, 1, 
	169, 3, 169, 2490, 8, 169, 1, 169, 3, 169, 2493, 8, 169, 1, 170, 1, 170, 
	1, 170, 1, 170, 1, 170, 1, 170, 5, 170, 2501, 8, 170, 10, 170, 12, 170, 
	2504, 9, 170, 1, 170, 1, 170, 3, 170, 2508, 8, 170, 1, 171, 1, 171, 1, 
	171, 1, 171, 1, 171, 5, 171, 2515, 8, 171, 10, 171, 12, 171, 2518, 9, 171, 
	1, 171, 1, 171, 3, 171, 2522, 8, 171, 1, 172, 1, 172, 3, 172, 2526, 8, 
	172, 1, 172, 1, 172, 1, 172, 1, 172, 1, 172, 5, 172, 2533, 8, 172, 10, 
	172, 12, 172, 2536, 9, 172, 1, 172, 3, 172, 2539, 8, 172, 1, 173, 1, 173, 
	1, 174, 1, 174, 1, 174, 1, 175, 1, 175, 1, 175, 1, 175, 1, 175, 5, 175, 
	2551, 8, 175, 10, 175, 12, 175, 2554, 9, 175, 1, 176, 1, 176, 1, 176, 1, 
	177, 1, 177, 1, 177, 1, 178, 1, 178, 1, 178, 1, 178, 3, 178, 2566, 8, 178, 
	1, 178, 1, 178, 1, 178, 3, 178, 2571, 8, 178, 5, 178, 2573, 8, 178, 10, 
	178, 12, 178, 2576, 9, 178, 1, 179, 4, 179, 2579, 8, 179, 11, 179, 12, 
	179, 2580, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 
	1, 180, 3, 180, 2592, 8, 180, 3, 180, 2594, 8, 180, 1, 181, 1, 181, 1, 
	181, 1, 181, 1, 181, 3, 181, 2601, 8, 181, 1, 181, 3, 181, 2604, 8, 181, 
	1, 182, 1, 182, 1, 182, 5, 182, 2609, 8, 182, 10, 182, 12, 182, 2612, 9, 
	182, 1, 183, 1, 183, 3, 183, 2616, 8, 183, 1, 183, 1, 183, 1, 183, 1, 183, 
	3, 183, 2622, 8, 183, 1, 183, 3, 183, 2625, 8, 183, 1, 183, 3, 183, 2628, 
	8, 183, 1, 184, 1, 184, 1, 184, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 
	1, 185, 1, 185, 1, 185, 4, 185, 2641, 8, 185, 11, 185, 12, 185, 2642, 1, 
	186, 1, 186, 1, 186, 1, 186, 1, 186, 3, 186, 2650, 8, 186, 1, 186, 3, 186, 
	2653, 8, 186, 1, 186, 3, 186, 2656, 8, 186, 1, 187, 1, 187, 3, 187, 2660, 
	8, 187, 1, 187, 1, 187, 1, 187, 3, 187, 2665, 8, 187, 1, 187, 1, 187, 1, 
	187, 1, 187, 3, 187, 2671, 8, 187, 1, 188, 1, 188, 3, 188, 2675, 8, 188, 
	1, 188, 1, 188, 1, 188, 1, 188, 1, 188, 1, 188, 1, 188, 5, 188, 2684, 8, 
	188, 10, 188, 12, 188, 2687, 9, 188, 1, 188, 3, 188, 2690, 8, 188, 1, 188, 
	3, 188, 2693, 8, 188, 1, 189, 1, 189, 3, 189, 2697, 8, 189, 1, 189, 1, 
	189, 3, 189, 2701, 8, 189, 1, 189, 1, 189, 3, 189, 2705, 8, 189, 1, 190, 
	1, 190, 3, 190, 2709, 8, 190, 1, 190, 1, 190, 1, 191, 1, 191, 3, 191, 2715, 
	8, 191, 1, 191, 1, 191, 1, 192, 1, 192, 3, 192, 2721, 8, 192, 1, 192, 1, 
	192, 1, 192, 1, 192, 1, 192, 3, 192, 2728, 8, 192, 1, 192, 1, 192, 1, 192, 
	1, 192, 5, 192, 2734, 8, 192, 10, 192, 12, 192, 2737, 9, 192, 1, 193, 1, 
	193, 1, 193, 3, 193, 2742, 8, 193, 1, 194, 1, 194, 1, 194, 3, 194, 2747, 
	8, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 
	1, 194, 3, 194, 2758, 8, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 
	194, 1, 194, 3, 194, 2767, 8, 194, 1, 195, 1, 195, 3, 195, 2771, 8, 195, 
	1, 195, 1, 195, 1, 195, 1, 195, 1, 195, 5, 195, 2778, 8, 195, 10, 195, 
	12, 195, 2781, 9, 195, 1, 195, 3, 195, 2784, 8, 195, 1, 195, 1, 195, 1, 
	196, 1, 196, 1, 196, 1, 196, 5, 196, 2792, 8, 196, 10, 196, 12, 196, 2795, 
	9, 196, 1, 196, 1, 196, 3, 196, 2799, 8, 196, 1, 196, 1, 196, 1, 196, 1, 
	196, 1, 196, 1, 197, 1, 197, 1, 197, 1, 197, 1, 198, 1, 198, 1, 199, 1, 
	199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 3, 199, 2821, 
	8, 199, 1, 199, 3, 199, 2824, 8, 199, 1, 200, 1, 200, 1, 200, 1, 200, 1, 
	200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 
	200, 1, 200, 1, 200, 1, 200, 1, 200, 3, 200, 2844, 8, 200, 1, 200, 1, 200, 
	1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 5, 200, 2854, 8, 200, 10, 
	200, 12, 200, 2857, 9, 200, 1, 201, 1, 201, 1, 201, 1, 201, 1, 201, 1, 
	201, 1, 201, 1, 201, 3, 201, 2867, 8, 201, 1, 202, 1, 202, 1, 202, 1, 202, 
	1, 203, 1, 203, 1, 204, 1, 204, 1, 204, 1, 204, 1, 204, 5, 204, 2880, 8, 
	204, 10, 204, 12, 204, 2883, 9, 204, 1, 205, 1, 205, 1, 205, 1, 205, 1, 
	205, 1, 205, 1, 205, 1, 205, 1, 205, 1, 205, 3, 205, 2895, 8, 205, 1, 206, 
	1, 206, 3, 206, 2899, 8, 206, 1, 207, 1, 207, 1, 207, 1, 207, 1, 207, 1, 
	207, 1, 207, 4, 207, 2908, 8, 207, 11, 207, 12, 207, 2909, 1, 207, 1, 207, 
	3, 207, 2914, 8, 207, 1, 207, 1, 207, 1, 208, 1, 208, 1, 208, 1, 208, 1, 
	208, 1, 208, 4, 208, 2924, 8, 208, 11, 208, 12, 208, 2925, 1, 208, 1, 208, 
	3, 208, 2930, 8, 208, 1, 208, 1, 208, 1, 209, 1, 209, 1, 209, 1, 209, 1, 
	210, 1, 210, 1, 210, 3, 210, 2941, 8, 210, 1, 210, 1, 210, 1, 210, 3, 210, 
	2946, 8, 210, 1, 210, 1, 210, 1, 210, 3, 210, 2951, 8, 210, 1, 210, 1, 
	210, 3, 210, 2955, 8, 210, 1, 210, 1, 210, 3, 210, 2959, 8, 210, 1, 210, 
	1, 210, 1, 210, 3, 210, 2964, 8, 210, 1, 210, 1, 210, 3, 210, 2968, 8, 
	210, 1, 210, 1, 210, 3, 210, 2972, 8, 210, 1, 210, 1, 210, 1, 210, 1, 210, 
	1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 
	1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 3, 210, 
	2995, 8, 210, 3, 210, 2997, 8, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 
	210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 
	210, 1, 210, 1, 210, 3, 210, 3015, 8, 210, 3, 210, 3017, 8, 210, 1, 210, 
	1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 3, 210, 3025, 8, 210, 1, 210, 1, 
	210, 1, 210, 3, 210, 3030, 8, 210, 1, 210, 1, 210, 1, 210, 3, 210, 3035, 
	8, 210, 1, 210, 1, 210, 1, 210, 3, 210, 3040, 8, 210, 1, 210, 1, 210, 1, 
	210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 3, 
	210, 3053, 8, 210, 1, 210, 1, 210, 1, 210, 3, 210, 3058, 8, 210, 1, 210, 
	1, 210, 1, 210, 3, 210, 3063, 8, 210, 1, 210, 1, 210, 1, 210, 3, 210, 3068, 
	8, 210, 1, 210, 1, 210, 1, 210, 3, 210, 3073, 8, 210, 1, 210, 1, 210, 1, 
	210, 3, 210, 3078, 8, 210, 1, 210, 1, 210, 1, 210, 3, 210, 3083, 8, 210, 
	1, 210, 1, 210, 1, 210, 3, 210, 3088, 8, 210, 3, 210, 3090, 8, 210, 1, 
	211, 1, 211, 1, 212, 1, 212, 1, 212, 3, 212, 3097, 8, 212, 1, 212, 3, 212, 
	3100, 8, 212, 1, 212, 1, 212, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 5, 
	213, 3109, 8, 213, 10, 213, 12, 213, 3112, 9, 213, 1, 214, 1, 214, 1, 214, 
	1, 214, 1, 214, 1, 214, 1, 214, 3, 214, 3121, 8, 214, 1, 214, 1, 214, 1, 
	214, 1, 214, 1, 214, 1, 214, 3, 214, 3129, 8, 214, 1, 214, 1, 214, 1, 214, 
	1, 214, 1, 214, 1, 214, 1, 214, 3, 214, 3138, 8, 214, 1, 214, 1, 214, 1, 
	214, 1, 214, 3, 214, 3144, 8, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 
	1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 5, 214, 
	3159, 8, 214, 10, 214, 12, 214, 3162, 9, 214, 3, 214, 3164, 8, 214, 1, 
	214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 
	214, 1, 214, 1, 214, 5, 214, 3178, 8, 214, 10, 214, 12, 214, 3181, 9, 214, 
	3, 214, 3183, 8, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 
	214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 5, 214, 3197, 8, 214, 10, 
	214, 12, 214, 3200, 9, 214, 3, 214, 3202, 8, 214, 1, 214, 1, 214, 1, 214, 
	1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 
	5, 214, 3216, 8, 214, 10, 214, 12, 214, 3219, 9, 214, 3, 214, 3221, 8, 
	214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 
	214, 1, 214, 1, 214, 1, 214, 5, 214, 3235, 8, 214, 10, 214, 12, 214, 3238, 
	9, 214, 3, 214, 3240, 8, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 
	214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 5, 214, 3254, 8, 214, 
	10, 214, 12, 214, 3257, 9, 214, 3, 214, 3259, 8, 214, 1, 214, 1, 214, 1, 
	214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 5, 214, 3271, 
	8, 214, 10, 214, 12, 214, 3274, 9, 214, 1, 214, 1, 214, 1, 214, 1, 214, 
	1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 4, 214, 3286, 8, 214, 11, 
	214, 12, 214, 3287, 1, 214, 1, 214, 3, 214, 3292, 8, 214, 1, 214, 1, 214, 
	1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 
	1, 214, 1, 214, 1, 214, 3, 214, 3308, 8, 214, 1, 214, 1, 214, 1, 214, 1, 
	214, 3, 214, 3314, 8, 214, 1, 215, 1, 215, 1, 215, 3, 215, 3319, 8, 215, 
	1, 215, 1, 215, 1, 216, 1, 216, 3, 216, 3325, 8, 216, 1, 217, 1, 217, 3, 
	217, 3329, 8, 217, 1, 217, 1, 217, 1, 217, 1, 218, 1, 218, 3, 218, 3336, 
	8, 218, 1, 218, 1, 218, 1, 218, 1, 219, 1, 219, 1, 219, 5, 219, 3344, 8, 
	219, 10, 219, 12, 219, 3347, 9, 219, 1, 220, 1, 220, 1, 220, 1, 220, 3, 
	220, 3353, 8, 220, 3, 220, 3355, 8, 220, 1, 220, 1, 220, 1, 221, 1, 221, 
	3, 221, 3361, 8, 221, 1, 222, 1, 222, 3, 222, 3365, 8, 222, 1, 223, 1, 
	223, 5, 223, 3369, 8, 223, 10, 223, 12, 223, 3372, 9, 223, 1, 224, 1, 224, 
	1, 224, 1, 224, 1, 224, 1, 224, 1, 224, 1, 224, 1, 224, 1, 224, 1, 224, 
	1, 224, 3, 224, 3386, 8, 224, 1, 225, 1, 225, 1, 225, 1, 225, 1, 225, 3, 
	225, 3393, 8, 225, 1, 226, 5, 226, 3396, 8, 226, 10, 226, 12, 226, 3399, 
	9, 226, 1, 227, 1, 227, 1, 227, 1, 228, 1, 228, 1, 228, 1, 228, 3, 228, 
	3408, 8, 228, 1, 228, 1, 228, 1, 228, 5, 228, 3413, 8, 228, 10, 228, 12, 
	228, 3416, 9, 228, 3, 228, 3418, 8, 228, 1, 229, 1, 229, 1, 229, 1, 230, 
	1, 230, 1, 230, 1, 231, 3, 231, 3427, 8, 231, 1, 231, 1, 231, 3, 231, 3431, 
	8, 231, 1, 232, 1, 232, 1, 232, 5, 232, 3436, 8, 232, 10, 232, 12, 232, 
	3439, 9, 232, 1, 233, 1, 233, 3, 233, 3443, 8, 233, 1, 234, 3, 234, 3446, 
	8, 234, 1, 234, 1, 234, 1, 235, 3, 235, 3451, 8, 235, 1, 235, 1, 235, 1, 
	236, 1, 236, 1, 237, 1, 237, 1, 238, 1, 238, 1, 238, 1, 3397, 2, 384, 400, 
	239, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 
	36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 
	72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 
	106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 
	136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 
	166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 
	196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 
	226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 
	256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 
	286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 
	316, 318, 320, 322, 324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 
	346, 348, 350, 352, 354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, 
	376, 378, 380, 382, 384, 386, 388, 390, 392, 394, 396, 398, 400, 402, 404, 
	406, 408, 410, 412, 414, 416, 418, 420, 422, 424, 426, 428, 430, 432, 434, 
	436, 438, 440, 442, 444, 446, 448, 450, 452, 454, 456, 458, 460, 462, 464, 
	466, 468, 470, 472, 474, 476, 0, 51, 3, 0, 1, 2, 352, 352, 370, 370, 2, 
	0, 98, 98, 314, 314, 1, 0, 168, 169, 3, 0, 13, 13, 115, 115, 153, 153, 
	2, 0, 33, 33, 41, 41, 2, 0, 55, 55, 107, 107, 2, 0, 185, 185, 258, 258, 
	2, 0, 245, 245, 300, 300, 2, 0, 14, 14, 83, 83, 2, 0, 80, 80, 303, 303, 
	2, 0, 108, 108, 171, 171, 2, 0, 80, 80, 218, 218, 2, 0, 76, 76, 136, 136, 
	3, 0, 140, 140, 178, 178, 214, 215, 2, 0, 173, 173, 192, 192, 2, 0, 189, 
	189, 322, 322, 2, 0, 177, 177, 375, 375, 2, 0, 31, 31, 38, 38, 2, 0, 36, 
	36, 62, 62, 2, 0, 66, 66, 251, 251, 2, 0, 13, 13, 153, 153, 1, 0, 236, 
	237, 1, 0, 221, 222, 4, 0, 61, 61, 78, 78, 152, 152, 211, 211, 2, 0, 121, 
	121, 222, 222, 1, 0, 102, 103, 1, 0, 95, 96, 1, 0, 274, 275, 2, 0, 246, 
	246, 282, 282, 3, 0, 80, 80, 135, 135, 210, 210, 4, 0, 11, 12, 190, 190, 
	226, 226, 320, 320, 2, 0, 200, 200, 202, 202, 2, 0, 259, 259, 297, 297, 
	4, 0, 20, 20, 90, 90, 174, 174, 290, 290, 2, 0, 174, 174, 316, 316, 2, 
	0, 30, 30, 276, 276, 1, 0, 256, 257, 2, 0, 7, 7, 88, 88, 3, 0, 120, 120, 
	162, 162, 239, 239, 3, 0, 62, 62, 247, 248, 304, 304, 3, 0, 105, 105, 262, 
	262, 303, 303, 1, 0, 83, 84, 2, 0, 10, 10, 205, 205, 3, 0, 163, 163, 230, 
	230, 240, 240, 2, 0, 352, 352, 363, 363, 2, 0, 348, 348, 371, 371, 3, 0, 
	70, 71, 181, 182, 252, 253, 2, 0, 52, 52, 351, 351, 3, 0, 118, 118, 154, 
	154, 195, 195, 2, 0, 109, 109, 298, 298, 15, 0, 5, 24, 26, 93, 97, 97, 
	99, 182, 184, 195, 197, 200, 202, 215, 217, 244, 246, 265, 267, 290, 292, 
	292, 294, 299, 302, 313, 316, 333, 340, 347, 3892, 0, 478, 1, 0, 0, 0, 
	2, 488, 1, 0, 0, 0, 4, 493, 1, 0, 0, 0, 6, 513, 1, 0, 0, 0, 8, 515, 1, 
	0, 0, 0, 10, 527, 1, 0, 0, 0, 12, 592, 1, 0, 0, 0, 14, 594, 1, 0, 0, 0, 
	16, 596, 1, 0, 0, 0, 18, 602, 1, 0, 0, 0, 20, 608, 1, 0, 0, 0, 22, 610, 
	1, 0, 0, 0, 24, 626, 1, 0, 0, 0, 26, 632, 1, 0, 0, 0, 28, 650, 1, 0, 0, 
	0, 30, 652, 1, 0, 0, 0, 32, 657, 1, 0, 0, 0, 34, 694, 1, 0, 0, 0, 36, 704, 
	1, 0, 0, 0, 38, 715, 1, 0, 0, 0, 40, 735, 1, 0, 0, 0, 42, 738, 1, 0, 0, 
	0, 44, 740, 1, 0, 0, 0, 46, 746, 1, 0, 0, 0, 48, 755, 1, 0, 0, 0, 50, 766, 
	1, 0, 0, 0, 52, 781, 1, 0, 0, 0, 54, 818, 1, 0, 0, 0, 56, 820, 1, 0, 0, 
	0, 58, 828, 1, 0, 0, 0, 60, 839, 1, 0, 0, 0, 62, 848, 1, 0, 0, 0, 64, 851, 
	1, 0, 0, 0, 66, 864, 1, 0, 0, 0, 68, 874, 1, 0, 0, 0, 70, 887, 1, 0, 0, 
	0, 72, 920, 1, 0, 0, 0, 74, 925, 1, 0, 0, 0, 76, 928, 1, 0, 0, 0, 78, 964, 
	1, 0, 0, 0, 80, 966, 1, 0, 0, 0, 82, 982, 1, 0, 0, 0, 84, 984, 1, 0, 0, 
	0, 86, 988, 1, 0, 0, 0, 88, 1022, 1, 0, 0, 0, 90, 1081, 1, 0, 0, 0, 92, 
	1083, 1, 0, 0, 0, 94, 1096, 1, 0, 0, 0, 96, 1103, 1, 0, 0, 0, 98, 1106, 
	1, 0, 0, 0, 100, 1111, 1, 0, 0, 0, 102, 1125, 1, 0, 0, 0, 104, 1145, 1, 
	0, 0, 0, 106, 1180, 1, 0, 0, 0, 108, 1200, 1, 0, 0, 0, 110, 1206, 1, 0, 
	0, 0, 112, 1208, 1, 0, 0, 0, 114, 1244, 1, 0, 0, 0, 116, 1250, 1, 0, 0, 
	0, 118, 1279, 1, 0, 0, 0, 120, 1281, 1, 0, 0, 0, 122, 1286, 1, 0, 0, 0, 
	124, 1288, 1, 0, 0, 0, 126, 1357, 1, 0, 0, 0, 128, 1405, 1, 0, 0, 0, 130, 
	1407, 1, 0, 0, 0, 132, 1429, 1, 0, 0, 0, 134, 1443, 1, 0, 0, 0, 136, 1445, 
	1, 0, 0, 0, 138, 1463, 1, 0, 0, 0, 140, 1472, 1, 0, 0, 0, 142, 1488, 1, 
	0, 0, 0, 144, 1500, 1, 0, 0, 0, 146, 1512, 1, 0, 0, 0, 148, 1535, 1, 0, 
	0, 0, 150, 1544, 1, 0, 0, 0, 152, 1557, 1, 0, 0, 0, 154, 1570, 1, 0, 0, 
	0, 156, 1579, 1, 0, 0, 0, 158, 1626, 1, 0, 0, 0, 160, 1670, 1, 0, 0, 0, 
	162, 1673, 1, 0, 0, 0, 164, 1688, 1, 0, 0, 0, 166, 1718, 1, 0, 0, 0, 168, 
	1720, 1, 0, 0, 0, 170, 1723, 1, 0, 0, 0, 172, 1752, 1, 0, 0, 0, 174, 1754, 
	1, 0, 0, 0, 176, 1770, 1, 0, 0, 0, 178, 1777, 1, 0, 0, 0, 180, 1783, 1, 
	0, 0, 0, 182, 1788, 1, 0, 0, 0, 184, 1791, 1, 0, 0, 0, 186, 1796, 1, 0, 
	0, 0, 188, 1813, 1, 0, 0, 0, 190, 1824, 1, 0, 0, 0, 192, 1833, 1, 0, 0, 
	0, 194, 1844, 1, 0, 0, 0, 196, 1853, 1, 0, 0, 0, 198, 1861, 1, 0, 0, 0, 
	200, 1867, 1, 0, 0, 0, 202, 1869, 1, 0, 0, 0, 204, 1875, 1, 0, 0, 0, 206, 
	1879, 1, 0, 0, 0, 208, 1892, 1, 0, 0, 0, 210, 1897, 1, 0, 0, 0, 212, 1901, 
	1, 0, 0, 0, 214, 1912, 1, 0, 0, 0, 216, 1921, 1, 0, 0, 0, 218, 1941, 1, 
	0, 0, 0, 220, 1944, 1, 0, 0, 0, 222, 1951, 1, 0, 0, 0, 224, 1963, 1, 0, 
	0, 0, 226, 1966, 1, 0, 0, 0, 228, 1980, 1, 0, 0, 0, 230, 1986, 1, 0, 0, 
	0, 232, 2005, 1, 0, 0, 0, 234, 2026, 1, 0, 0, 0, 236, 2030, 1, 0, 0, 0, 
	238, 2040, 1, 0, 0, 0, 240, 2042, 1, 0, 0, 0, 242, 2044, 1, 0, 0, 0, 244, 
	2048, 1, 0, 0, 0, 246, 2067, 1, 0, 0, 0, 248, 2071, 1, 0, 0, 0, 250, 2073, 
	1, 0, 0, 0, 252, 2102, 1, 0, 0, 0, 254, 2105, 1, 0, 0, 0, 256, 2111, 1, 
	0, 0, 0, 258, 2113, 1, 0, 0, 0, 260, 2127, 1, 0, 0, 0, 262, 2131, 1, 0, 
	0, 0, 264, 2138, 1, 0, 0, 0, 266, 2145, 1, 0, 0, 0, 268, 2152, 1, 0, 0, 
	0, 270, 2155, 1, 0, 0, 0, 272, 2167, 1, 0, 0, 0, 274, 2170, 1, 0, 0, 0, 
	276, 2187, 1, 0, 0, 0, 278, 2193, 1, 0, 0, 0, 280, 2196, 1, 0, 0, 0, 282, 
	2226, 1, 0, 0, 0, 284, 2234, 1, 0, 0, 0, 286, 2239, 1, 0, 0, 0, 288, 2254, 
	1, 0, 0, 0, 290, 2278, 1, 0, 0, 0, 292, 2280, 1, 0, 0, 0, 294, 2290, 1, 
	0, 0, 0, 296, 2294, 1, 0, 0, 0, 298, 2303, 1, 0, 0, 0, 300, 2312, 1, 0, 
	0, 0, 302, 2323, 1, 0, 0, 0, 304, 2337, 1, 0, 0, 0, 306, 2351, 1, 0, 0, 
	0, 308, 2353, 1, 0, 0, 0, 310, 2378, 1, 0, 0, 0, 312, 2391, 1, 0, 0, 0, 
	314, 2393, 1, 0, 0, 0, 316, 2406, 1, 0, 0, 0, 318, 2417, 1, 0, 0, 0, 320, 
	2421, 1, 0, 0, 0, 322, 2425, 1, 0, 0, 0, 324, 2431, 1, 0, 0, 0, 326, 2448, 
	1, 0, 0, 0, 328, 2451, 1, 0, 0, 0, 330, 2462, 1, 0, 0, 0, 332, 2464, 1, 
	0, 0, 0, 334, 2468, 1, 0, 0, 0, 336, 2481, 1, 0, 0, 0, 338, 2492, 1, 0, 
	0, 0, 340, 2494, 1, 0, 0, 0, 342, 2521, 1, 0, 0, 0, 344, 2523, 1, 0, 0, 
	0, 346, 2540, 1, 0, 0, 0, 348, 2542, 1, 0, 0, 0, 350, 2545, 1, 0, 0, 0, 
	352, 2555, 1, 0, 0, 0, 354, 2558, 1, 0, 0, 0, 356, 2561, 1, 0, 0, 0, 358, 
	2578, 1, 0, 0, 0, 360, 2593, 1, 0, 0, 0, 362, 2595, 1, 0, 0, 0, 364, 2605, 
	1, 0, 0, 0, 366, 2621, 1, 0, 0, 0, 368, 2629, 1, 0, 0, 0, 370, 2632, 1, 
	0, 0, 0, 372, 2649, 1, 0, 0, 0, 374, 2670, 1, 0, 0, 0, 376, 2692, 1, 0, 
	0, 0, 378, 2694, 1, 0, 0, 0, 380, 2706, 1, 0, 0, 0, 382, 2712, 1, 0, 0, 
	0, 384, 2727, 1, 0, 0, 0, 386, 2741, 1, 0, 0, 0, 388, 2766, 1, 0, 0, 0, 
	390, 2768, 1, 0, 0, 0, 392, 2787, 1, 0, 0, 0, 394, 2805, 1, 0, 0, 0, 396, 
	2809, 1, 0, 0, 0, 398, 2823, 1, 0, 0, 0, 400, 2843, 1, 0, 0, 0, 402, 2866, 
	1, 0, 0, 0, 404, 2868, 1, 0, 0, 0, 406, 2872, 1, 0, 0, 0, 408, 2874, 1, 
	0, 0, 0, 410, 2894, 1, 0, 0, 0, 412, 2898, 1, 0, 0, 0, 414, 2900, 1, 0, 
	0, 0, 416, 2917, 1, 0, 0, 0, 418, 2933, 1, 0, 0, 0, 420, 3089, 1, 0, 0, 
	0, 422, 3091, 1, 0, 0, 0, 424, 3093, 1, 0, 0, 0, 426, 3103, 1, 0, 0, 0, 
	428, 3313, 1, 0, 0, 0, 430, 3315, 1, 0, 0, 0, 432, 3324, 1, 0, 0, 0, 434, 
	3328, 1, 0, 0, 0, 436, 3335, 1, 0, 0, 0, 438, 3340, 1, 0, 0, 0, 440, 3348, 
	1, 0, 0, 0, 442, 3360, 1, 0, 0, 0, 444, 3364, 1, 0, 0, 0, 446, 3366, 1, 
	0, 0, 0, 448, 3385, 1, 0, 0, 0, 450, 3392, 1, 0, 0, 0, 452, 3397, 1, 0, 
	0, 0, 454, 3400, 1, 0, 0, 0, 456, 3417, 1, 0, 0, 0, 458, 3419, 1, 0, 0, 
	0, 460, 3422, 1, 0, 0, 0, 462, 3426, 1, 0, 0, 0, 464, 3432, 1, 0, 0, 0, 
	466, 3442, 1, 0, 0, 0, 468, 3445, 1, 0, 0, 0, 470, 3450, 1, 0, 0, 0, 472, 
	3454, 1, 0, 0, 0, 474, 3456, 1, 0, 0, 0, 476, 3458, 1, 0, 0, 0, 478, 479, 
	3, 2, 1, 0, 479, 480, 5, 0, 0, 1, 480, 1, 1, 0, 0, 0, 481, 484, 3, 4, 2, 
	0, 482, 484, 3, 12, 6, 0, 483, 481, 1, 0, 0, 0, 483, 482, 1, 0, 0, 0, 484, 
	486, 1, 0, 0, 0, 485, 487, 5, 124, 0, 0, 486, 485, 1, 0, 0, 0, 486, 487, 
	1, 0, 0, 0, 487, 489, 1, 0, 0, 0, 488, 483, 1, 0, 0, 0, 489, 490, 1, 0, 
	0, 0, 490, 488, 1, 0, 0, 0, 490, 491, 1, 0, 0, 0, 491, 3, 1, 0, 0, 0, 492, 
	494, 3, 48, 24, 0, 493, 492, 1, 0, 0, 0, 493, 494, 1, 0, 0, 0, 494, 495, 
	1, 0, 0, 0, 495, 496, 5, 20, 0, 0, 496, 498, 3, 2, 1, 0, 497, 499, 3, 16, 
	8, 0, 498, 497, 1, 0, 0, 0, 498, 499, 1, 0, 0, 0, 499, 500, 1, 0, 0, 0, 
	500, 501, 3, 8, 4, 0, 501, 5, 1, 0, 0, 0, 502, 503, 5, 20, 0, 0, 503, 505, 
	3, 2, 1, 0, 504, 506, 3, 16, 8, 0, 505, 504, 1, 0, 0, 0, 505, 506, 1, 0, 
	0, 0, 506, 507, 1, 0, 0, 0, 507, 508, 3, 8, 4, 0, 508, 514, 1, 0, 0, 0, 
	509, 511, 3, 12, 6, 0, 510, 512, 5, 370, 0, 0, 511, 510, 1, 0, 0, 0, 511, 
	512, 1, 0, 0, 0, 512, 514, 1, 0, 0, 0, 513, 502, 1, 0, 0, 0, 513, 509, 
	1, 0, 0, 0, 514, 7, 1, 0, 0, 0, 515, 516, 4, 4, 0, 0, 516, 517, 5, 98, 
	0, 0, 517, 9, 1, 0, 0, 0, 518, 528, 3, 4, 2, 0, 519, 521, 3, 12, 6, 0, 
	520, 519, 1, 0, 0, 0, 521, 522, 1, 0, 0, 0, 522, 520, 1, 0, 0, 0, 522, 
	523, 1, 0, 0, 0, 523, 525, 1, 0, 0, 0, 524, 526, 5, 124, 0, 0, 525, 524, 
	1, 0, 0, 0, 525, 526, 1, 0, 0, 0, 526, 528, 1, 0, 0, 0, 527, 518, 1, 0, 
	0, 0, 527, 520, 1, 0, 0, 0, 528, 11, 1, 0, 0, 0, 529, 593, 3, 24, 12, 0, 
	530, 593, 3, 36, 18, 0, 531, 593, 3, 120, 60, 0, 532, 593, 3, 38, 19, 0, 
	533, 593, 3, 40, 20, 0, 534, 593, 3, 42, 21, 0, 535, 593, 3, 44, 22, 0, 
	536, 593, 3, 220, 110, 0, 537, 593, 3, 224, 112, 0, 538, 593, 3, 226, 113, 
	0, 539, 593, 3, 230, 115, 0, 540, 593, 3, 232, 116, 0, 541, 593, 3, 242, 
	121, 0, 542, 593, 3, 136, 68, 0, 543, 593, 3, 140, 70, 0, 544, 593, 3, 
	244, 122, 0, 545, 593, 3, 70, 35, 0, 546, 593, 3, 144, 72, 0, 547, 593, 
	3, 150, 75, 0, 548, 593, 3, 156, 78, 0, 549, 593, 3, 68, 34, 0, 550, 593, 
	3, 80, 40, 0, 551, 593, 3, 46, 23, 0, 552, 593, 3, 378, 189, 0, 553, 593, 
	3, 382, 191, 0, 554, 593, 3, 166, 83, 0, 555, 593, 3, 168, 84, 0, 556, 
	593, 3, 170, 85, 0, 557, 593, 3, 196, 98, 0, 558, 593, 3, 216, 108, 0, 
	559, 593, 3, 286, 143, 0, 560, 593, 3, 288, 144, 0, 561, 593, 3, 172, 86, 
	0, 562, 593, 3, 184, 92, 0, 563, 593, 3, 186, 93, 0, 564, 593, 3, 194, 
	97, 0, 565, 593, 3, 198, 99, 0, 566, 593, 3, 206, 103, 0, 567, 593, 3, 
	210, 105, 0, 568, 593, 3, 212, 106, 0, 569, 593, 3, 370, 185, 0, 570, 593, 
	3, 214, 107, 0, 571, 593, 3, 252, 126, 0, 572, 593, 3, 254, 127, 0, 573, 
	593, 3, 256, 128, 0, 574, 593, 3, 258, 129, 0, 575, 593, 3, 260, 130, 0, 
	576, 593, 3, 262, 131, 0, 577, 593, 3, 294, 147, 0, 578, 593, 3, 272, 136, 
	0, 579, 593, 3, 274, 137, 0, 580, 593, 3, 362, 181, 0, 581, 593, 3, 278, 
	139, 0, 582, 593, 3, 276, 138, 0, 583, 593, 3, 280, 140, 0, 584, 593, 3, 
	282, 141, 0, 585, 593, 3, 284, 142, 0, 586, 593, 3, 290, 145, 0, 587, 593, 
	3, 446, 223, 0, 588, 593, 3, 450, 225, 0, 589, 593, 3, 20, 10, 0, 590, 
	593, 3, 22, 11, 0, 591, 593, 3, 14, 7, 0, 592, 529, 1, 0, 0, 0, 592, 530, 
	1, 0, 0, 0, 592, 531, 1, 0, 0, 0, 592, 532, 1, 0, 0, 0, 592, 533, 1, 0, 
	0, 0, 592, 534, 1, 0, 0, 0, 592, 535, 1, 0, 0, 0, 592, 536, 1, 0, 0, 0, 
	592, 537, 1, 0, 0, 0, 592, 538, 1, 0, 0, 0, 592, 539, 1, 0, 0, 0, 592, 
	540, 1, 0, 0, 0, 592, 541, 1, 0, 0, 0, 592, 542, 1, 0, 0, 0, 592, 543, 
	1, 0, 0, 0, 592, 544, 1, 0, 0, 0, 592, 545, 1, 0, 0, 0, 592, 546, 1, 0, 
	0, 0, 592, 547, 1, 0, 0, 0, 592, 548, 1, 0, 0, 0, 592, 549, 1, 0, 0, 0, 
	592, 550, 1, 0, 0, 0, 592, 551, 1, 0, 0, 0, 592, 552, 1, 0, 0, 0, 592, 
	553, 1, 0, 0, 0, 592, 554, 1, 0, 0, 0, 592, 555, 1, 0, 0, 0, 592, 556, 
	1, 0, 0, 0, 592, 557, 1, 0, 0, 0, 592, 558, 1, 0, 0, 0, 592, 559, 1, 0, 
	0, 0, 592, 560, 1, 0, 0, 0, 592, 561, 1, 0, 0, 0, 592, 562, 1, 0, 0, 0, 
	592, 563, 1, 0, 0, 0, 592, 564, 1, 0, 0, 0, 592, 565, 1, 0, 0, 0, 592, 
	566, 1, 0, 0, 0, 592, 567, 1, 0, 0, 0, 592, 568, 1, 0, 0, 0, 592, 569, 
	1, 0, 0, 0, 592, 570, 1, 0, 0, 0, 592, 571, 1, 0, 0, 0, 592, 572, 1, 0, 
	0, 0, 592, 573, 1, 0, 0, 0, 592, 574, 1, 0, 0, 0, 592, 575, 1, 0, 0, 0, 
	592, 576, 1, 0, 0, 0, 592, 577, 1, 0, 0, 0, 592, 578, 1, 0, 0, 0, 592, 
	579, 1, 0, 0, 0, 592, 580, 1, 0, 0, 0, 592, 581, 1, 0, 0, 0, 592, 582, 
	1, 0, 0, 0, 592, 583, 1, 0, 0, 0, 592, 584, 1, 0, 0, 0, 592, 585, 1, 0, 
	0, 0, 592, 586, 1, 0, 0, 0, 592, 587, 1, 0, 0, 0, 592, 588, 1, 0, 0, 0, 
	592, 589, 1, 0, 0, 0, 592, 590, 1, 0, 0, 0, 592, 591, 1, 0, 0, 0, 593, 
	13, 1, 0, 0, 0, 594, 595, 7, 0, 0, 0, 595, 15, 1, 0, 0, 0, 596, 598, 5, 
	104, 0, 0, 597, 599, 3, 18, 9, 0, 598, 597, 1, 0, 0, 0, 599, 600, 1, 0, 
	0, 0, 600, 598, 1, 0, 0, 0, 600, 601, 1, 0, 0, 0, 601, 17, 1, 0, 0, 0, 
	602, 603, 5, 314, 0, 0, 603, 604, 5, 372, 0, 0, 604, 605, 5, 290, 0, 0, 
	605, 606, 3, 2, 1, 0, 606, 607, 8, 1, 0, 0, 607, 19, 1, 0, 0, 0, 608, 609, 
	5, 196, 0, 0, 609, 21, 1, 0, 0, 0, 610, 611, 4, 11, 1, 0, 611, 612, 3, 
	400, 200, 0, 612, 23, 1, 0, 0, 0, 613, 614, 5, 258, 0, 0, 614, 627, 3, 
	264, 132, 0, 615, 617, 5, 258, 0, 0, 616, 615, 1, 0, 0, 0, 616, 617, 1, 
	0, 0, 0, 617, 618, 1, 0, 0, 0, 618, 623, 3, 26, 13, 0, 619, 620, 5, 350, 
	0, 0, 620, 622, 3, 26, 13, 0, 621, 619, 1, 0, 0, 0, 622, 625, 1, 0, 0, 
	0, 623, 621, 1, 0, 0, 0, 623, 624, 1, 0, 0, 0, 624, 627, 1, 0, 0, 0, 625, 
	623, 1, 0, 0, 0, 626, 613, 1, 0, 0, 0, 626, 616, 1, 0, 0, 0, 627, 25, 1, 
	0, 0, 0, 628, 633, 3, 28, 14, 0, 629, 633, 3, 32, 16, 0, 630, 633, 3, 34, 
	17, 0, 631, 633, 3, 30, 15, 0, 632, 628, 1, 0, 0, 0, 632, 629, 1, 0, 0, 
	0, 632, 630, 1, 0, 0, 0, 632, 631, 1, 0, 0, 0, 633, 27, 1, 0, 0, 0, 634, 
	636, 3, 464, 232, 0, 635, 637, 5, 349, 0, 0, 636, 635, 1, 0, 0, 0, 636, 
	637, 1, 0, 0, 0, 637, 638, 1, 0, 0, 0, 638, 639, 5, 355, 0, 0, 639, 640, 
	3, 400, 200, 0, 640, 651, 1, 0, 0, 0, 641, 642, 5, 365, 0, 0, 642, 643, 
	3, 464, 232, 0, 643, 645, 5, 368, 0, 0, 644, 646, 5, 349, 0, 0, 645, 644, 
	1, 0, 0, 0, 645, 646, 1, 0, 0, 0, 646, 647, 1, 0, 0, 0, 647, 648, 5, 355, 
	0, 0, 648, 649, 3, 400, 200, 0, 649, 651, 1, 0, 0, 0, 650, 634, 1, 0, 0, 
	0, 650, 641, 1, 0, 0, 0, 651, 29, 1, 0, 0, 0, 652, 653, 3, 430, 215, 0, 
	653, 654, 5, 349, 0, 0, 654, 655, 5, 355, 0, 0, 655, 656, 3, 400, 200, 
	0, 656, 31, 1, 0, 0, 0, 657, 658, 5, 365, 0, 0, 658, 663, 3, 462, 231, 
	0, 659, 660, 5, 350, 0, 0, 660, 662, 3, 462, 231, 0, 661, 659, 1, 0, 0, 
	0, 662, 665, 1, 0, 0, 0, 663, 661, 1, 0, 0, 0, 663, 664, 1, 0, 0, 0, 664, 
	666, 1, 0, 0, 0, 665, 663, 1, 0, 0, 0, 666, 668, 5, 368, 0, 0, 667, 669, 
	5, 349, 0, 0, 668, 667, 1, 0, 0, 0, 668, 669, 1, 0, 0, 0, 669, 670, 1, 
	0, 0, 0, 670, 671, 5, 355, 0, 0, 671, 672, 5, 365, 0, 0, 672, 677, 3, 400, 
	200, 0, 673, 674, 5, 350, 0, 0, 674, 676, 3, 400, 200, 0, 675, 673, 1, 
	0, 0, 0, 676, 679, 1, 0, 0, 0, 677, 675, 1, 0, 0, 0, 677, 678, 1, 0, 0, 
	0, 678, 680, 1, 0, 0, 0, 679, 677, 1, 0, 0, 0, 680, 681, 5, 368, 0, 0, 
	681, 33, 1, 0, 0, 0, 682, 695, 3, 462, 231, 0, 683, 684, 5, 365, 0, 0, 
	684, 689, 3, 462, 231, 0, 685, 686, 5, 350, 0, 0, 686, 688, 3, 462, 231, 
	0, 687, 685, 1, 0, 0, 0, 688, 691, 1, 0, 0, 0, 689, 687, 1, 0, 0, 0, 689, 
	690, 1, 0, 0, 0, 690, 692, 1, 0, 0, 0, 691, 689, 1, 0, 0, 0, 692, 693, 
	5, 368, 0, 0, 693, 695, 1, 0, 0, 0, 694, 682, 1, 0, 0, 0, 694, 683, 1, 
	0, 0, 0, 695, 697, 1, 0, 0, 0, 696, 698, 5, 349, 0, 0, 697, 696, 1, 0, 
	0, 0, 697, 698, 1, 0, 0, 0, 698, 699, 1, 0, 0, 0, 699, 700, 5, 355, 0, 
	0, 700, 701, 5, 365, 0, 0, 701, 702, 3, 294, 147, 0, 702, 703, 5, 368, 
	0, 0, 703, 35, 1, 0, 0, 0, 704, 705, 5, 8, 0, 0, 705, 706, 3, 462, 231, 
	0, 706, 707, 5, 65, 0, 0, 707, 711, 5, 115, 0, 0, 708, 709, 5, 234, 0, 
	0, 709, 712, 5, 258, 0, 0, 710, 712, 5, 222, 0, 0, 711, 708, 1, 0, 0, 0, 
	711, 710, 1, 0, 0, 0, 712, 713, 1, 0, 0, 0, 713, 714, 3, 462, 231, 0, 714, 
	37, 1, 0, 0, 0, 715, 718, 5, 15, 0, 0, 716, 717, 5, 234, 0, 0, 717, 719, 
	5, 258, 0, 0, 718, 716, 1, 0, 0, 0, 718, 719, 1, 0, 0, 0, 719, 720, 1, 
	0, 0, 0, 720, 721, 7, 2, 0, 0, 721, 722, 5, 365, 0, 0, 722, 727, 3, 462, 
	231, 0, 723, 724, 5, 350, 0, 0, 724, 726, 3, 462, 231, 0, 725, 723, 1, 
	0, 0, 0, 726, 729, 1, 0, 0, 0, 727, 725, 1, 0, 0, 0, 727, 728, 1, 0, 0, 
	0, 728, 730, 1, 0, 0, 0, 729, 727, 1, 0, 0, 0, 730, 731, 5, 368, 0, 0, 
	731, 732, 5, 317, 0, 0, 732, 733, 5, 222, 0, 0, 733, 734, 3, 462, 231, 
	0, 734, 39, 1, 0, 0, 0, 735, 736, 5, 20, 0, 0, 736, 737, 5, 297, 0, 0, 
	737, 41, 1, 0, 0, 0, 738, 739, 5, 28, 0, 0, 739, 43, 1, 0, 0, 0, 740, 744, 
	5, 32, 0, 0, 741, 745, 3, 432, 216, 0, 742, 745, 3, 430, 215, 0, 743, 745, 
	3, 462, 231, 0, 744, 741, 1, 0, 0, 0, 744, 742, 1, 0, 0, 0, 744, 743, 1, 
	0, 0, 0, 745, 45, 1, 0, 0, 0, 746, 747, 5, 74, 0, 0, 747, 752, 3, 52, 26, 
	0, 748, 749, 5, 350, 0, 0, 749, 751, 3, 52, 26, 0, 750, 748, 1, 0, 0, 0, 
	751, 754, 1, 0, 0, 0, 752, 750, 1, 0, 0, 0, 752, 753, 1, 0, 0, 0, 753, 
	47, 1, 0, 0, 0, 754, 752, 1, 0, 0, 0, 755, 756, 5, 74, 0, 0, 756, 757, 
	3, 52, 26, 0, 757, 763, 5, 370, 0, 0, 758, 759, 3, 52, 26, 0, 759, 760, 
	5, 370, 0, 0, 760, 762, 1, 0, 0, 0, 761, 758, 1, 0, 0, 0, 762, 765, 1, 
	0, 0, 0, 763, 761, 1, 0, 0, 0, 763, 764, 1, 0, 0, 0, 764, 49, 1, 0, 0, 
	0, 765, 763, 1, 0, 0, 0, 766, 767, 3, 52, 26, 0, 767, 773, 5, 370, 0, 0, 
	768, 769, 3, 52, 26, 0, 769, 770, 5, 370, 0, 0, 770, 772, 1, 0, 0, 0, 771, 
	768, 1, 0, 0, 0, 772, 775, 1, 0, 0, 0, 773, 771, 1, 0, 0, 0, 773, 774, 
	1, 0, 0, 0, 774, 51, 1, 0, 0, 0, 775, 773, 1, 0, 0, 0, 776, 782, 3, 58, 
	29, 0, 777, 782, 3, 56, 28, 0, 778, 782, 3, 64, 32, 0, 779, 782, 3, 54, 
	27, 0, 780, 782, 3, 66, 33, 0, 781, 776, 1, 0, 0, 0, 781, 777, 1, 0, 0, 
	0, 781, 778, 1, 0, 0, 0, 781, 779, 1, 0, 0, 0, 781, 780, 1, 0, 0, 0, 782, 
	53, 1, 0, 0, 0, 783, 788, 3, 462, 231, 0, 784, 785, 5, 350, 0, 0, 785, 
	787, 3, 462, 231, 0, 786, 784, 1, 0, 0, 0, 787, 790, 1, 0, 0, 0, 788, 786, 
	1, 0, 0, 0, 788, 789, 1, 0, 0, 0, 789, 792, 1, 0, 0, 0, 790, 788, 1, 0, 
	0, 0, 791, 793, 5, 13, 0, 0, 792, 791, 1, 0, 0, 0, 792, 793, 1, 0, 0, 0, 
	793, 794, 1, 0, 0, 0, 794, 796, 3, 128, 64, 0, 795, 797, 3, 130, 65, 0, 
	796, 795, 1, 0, 0, 0, 796, 797, 1, 0, 0, 0, 797, 801, 1, 0, 0, 0, 798, 
	800, 3, 132, 66, 0, 799, 798, 1, 0, 0, 0, 800, 803, 1, 0, 0, 0, 801, 799, 
	1, 0, 0, 0, 801, 802, 1, 0, 0, 0, 802, 805, 1, 0, 0, 0, 803, 801, 1, 0, 
	0, 0, 804, 806, 3, 134, 67, 0, 805, 804, 1, 0, 0, 0, 805, 806, 1, 0, 0, 
	0, 806, 819, 1, 0, 0, 0, 807, 808, 3, 462, 231, 0, 808, 810, 5, 49, 0, 
	0, 809, 811, 5, 13, 0, 0, 810, 809, 1, 0, 0, 0, 810, 811, 1, 0, 0, 0, 811, 
	812, 1, 0, 0, 0, 812, 814, 3, 128, 64, 0, 813, 815, 3, 130, 65, 0, 814, 
	813, 1, 0, 0, 0, 814, 815, 1, 0, 0, 0, 815, 816, 1, 0, 0, 0, 816, 817, 
	3, 134, 67, 0, 817, 819, 1, 0, 0, 0, 818, 783, 1, 0, 0, 0, 818, 807, 1, 
	0, 0, 0, 819, 55, 1, 0, 0, 0, 820, 821, 3, 462, 231, 0, 821, 822, 5, 53, 
	0, 0, 822, 57, 1, 0, 0, 0, 823, 824, 5, 65, 0, 0, 824, 829, 3, 462, 231, 
	0, 825, 826, 3, 462, 231, 0, 826, 827, 5, 65, 0, 0, 827, 829, 1, 0, 0, 
	0, 828, 823, 1, 0, 0, 0, 828, 825, 1, 0, 0, 0, 829, 832, 1, 0, 0, 0, 830, 
	833, 3, 60, 30, 0, 831, 833, 3, 62, 31, 0, 832, 830, 1, 0, 0, 0, 832, 831, 
	1, 0, 0, 0, 832, 833, 1, 0, 0, 0, 833, 834, 1, 0, 0, 0, 834, 837, 7, 3, 
	0, 0, 835, 838, 3, 294, 147, 0, 836, 838, 3, 400, 200, 0, 837, 835, 1, 
	0, 0, 0, 837, 836, 1, 0, 0, 0, 838, 59, 1, 0, 0, 0, 839, 840, 5, 317, 0, 
	0, 840, 842, 5, 236, 0, 0, 841, 843, 5, 203, 0, 0, 842, 841, 1, 0, 0, 0, 
	842, 843, 1, 0, 0, 0, 843, 846, 1, 0, 0, 0, 844, 845, 5, 295, 0, 0, 845, 
	847, 7, 4, 0, 0, 846, 844, 1, 0, 0, 0, 846, 847, 1, 0, 0, 0, 847, 61, 1, 
	0, 0, 0, 848, 849, 5, 318, 0, 0, 849, 850, 5, 236, 0, 0, 850, 63, 1, 0, 
	0, 0, 851, 852, 7, 5, 0, 0, 852, 853, 5, 127, 0, 0, 853, 859, 5, 115, 0, 
	0, 854, 860, 5, 270, 0, 0, 855, 860, 5, 273, 0, 0, 856, 857, 5, 194, 0, 
	0, 857, 860, 5, 118, 0, 0, 858, 860, 3, 462, 231, 0, 859, 854, 1, 0, 0, 
	0, 859, 855, 1, 0, 0, 0, 859, 856, 1, 0, 0, 0, 859, 858, 1, 0, 0, 0, 860, 
	861, 1, 0, 0, 0, 861, 862, 3, 6, 3, 0, 862, 65, 1, 0, 0, 0, 863, 865, 5, 
	123, 0, 0, 864, 863, 1, 0, 0, 0, 864, 865, 1, 0, 0, 0, 865, 866, 1, 0, 
	0, 0, 866, 867, 5, 287, 0, 0, 867, 868, 5, 285, 0, 0, 868, 870, 3, 464, 
	232, 0, 869, 871, 3, 94, 47, 0, 870, 869, 1, 0, 0, 0, 870, 871, 1, 0, 0, 
	0, 871, 872, 1, 0, 0, 0, 872, 873, 3, 72, 36, 0, 873, 67, 1, 0, 0, 0, 874, 
	875, 5, 59, 0, 0, 875, 879, 5, 285, 0, 0, 876, 877, 5, 134, 0, 0, 877, 
	878, 5, 194, 0, 0, 878, 880, 5, 106, 0, 0, 879, 876, 1, 0, 0, 0, 879, 880, 
	1, 0, 0, 0, 880, 881, 1, 0, 0, 0, 881, 883, 3, 346, 173, 0, 882, 884, 3, 
	94, 47, 0, 883, 882, 1, 0, 0, 0, 883, 884, 1, 0, 0, 0, 884, 885, 1, 0, 
	0, 0, 885, 886, 3, 72, 36, 0, 886, 69, 1, 0, 0, 0, 887, 894, 5, 59, 0, 
	0, 888, 889, 5, 166, 0, 0, 889, 895, 5, 287, 0, 0, 890, 892, 7, 6, 0, 0, 
	891, 890, 1, 0, 0, 0, 891, 892, 1, 0, 0, 0, 892, 893, 1, 0, 0, 0, 893, 
	895, 5, 313, 0, 0, 894, 888, 1, 0, 0, 0, 894, 891, 1, 0, 0, 0, 895, 896, 
	1, 0, 0, 0, 896, 897, 5, 285, 0, 0, 897, 899, 3, 464, 232, 0, 898, 900, 
	3, 94, 47, 0, 899, 898, 1, 0, 0, 0, 899, 900, 1, 0, 0, 0, 900, 901, 1, 
	0, 0, 0, 901, 902, 3, 72, 36, 0, 902, 71, 1, 0, 0, 0, 903, 905, 5, 13, 
	0, 0, 904, 903, 1, 0, 0, 0, 904, 905, 1, 0, 0, 0, 905, 906, 1, 0, 0, 0, 
	906, 907, 5, 365, 0, 0, 907, 908, 3, 294, 147, 0, 908, 909, 5, 368, 0, 
	0, 909, 921, 1, 0, 0, 0, 910, 912, 5, 13, 0, 0, 911, 910, 1, 0, 0, 0, 911, 
	912, 1, 0, 0, 0, 912, 913, 1, 0, 0, 0, 913, 921, 3, 294, 147, 0, 914, 915, 
	5, 365, 0, 0, 915, 916, 3, 76, 38, 0, 916, 917, 5, 368, 0, 0, 917, 921, 
	1, 0, 0, 0, 918, 919, 5, 163, 0, 0, 919, 921, 3, 346, 173, 0, 920, 904, 
	1, 0, 0, 0, 920, 911, 1, 0, 0, 0, 920, 914, 1, 0, 0, 0, 920, 918, 1, 0, 
	0, 0, 921, 923, 1, 0, 0, 0, 922, 924, 3, 100, 50, 0, 923, 922, 1, 0, 0, 
	0, 923, 924, 1, 0, 0, 0, 924, 73, 1, 0, 0, 0, 925, 926, 5, 48, 0, 0, 926, 
	927, 3, 400, 200, 0, 927, 75, 1, 0, 0, 0, 928, 930, 3, 78, 39, 0, 929, 
	931, 3, 74, 37, 0, 930, 929, 1, 0, 0, 0, 930, 931, 1, 0, 0, 0, 931, 939, 
	1, 0, 0, 0, 932, 933, 5, 350, 0, 0, 933, 935, 3, 78, 39, 0, 934, 936, 3, 
	74, 37, 0, 935, 934, 1, 0, 0, 0, 935, 936, 1, 0, 0, 0, 936, 938, 1, 0, 
	0, 0, 937, 932, 1, 0, 0, 0, 938, 941, 1, 0, 0, 0, 939, 937, 1, 0, 0, 0, 
	939, 940, 1, 0, 0, 0, 940, 77, 1, 0, 0, 0, 941, 939, 1, 0, 0, 0, 942, 943, 
	3, 86, 43, 0, 943, 945, 3, 128, 64, 0, 944, 946, 3, 130, 65, 0, 945, 944, 
	1, 0, 0, 0, 945, 946, 1, 0, 0, 0, 946, 950, 1, 0, 0, 0, 947, 949, 3, 132, 
	66, 0, 948, 947, 1, 0, 0, 0, 949, 952, 1, 0, 0, 0, 950, 948, 1, 0, 0, 0, 
	950, 951, 1, 0, 0, 0, 951, 956, 1, 0, 0, 0, 952, 950, 1, 0, 0, 0, 953, 
	955, 3, 88, 44, 0, 954, 953, 1, 0, 0, 0, 955, 958, 1, 0, 0, 0, 956, 954, 
	1, 0, 0, 0, 956, 957, 1, 0, 0, 0, 957, 965, 1, 0, 0, 0, 958, 956, 1, 0, 
	0, 0, 959, 960, 5, 54, 0, 0, 960, 962, 3, 464, 232, 0, 961, 959, 1, 0, 
	0, 0, 961, 962, 1, 0, 0, 0, 962, 963, 1, 0, 0, 0, 963, 965, 3, 90, 45, 
	0, 964, 942, 1, 0, 0, 0, 964, 961, 1, 0, 0, 0, 965, 79, 1, 0, 0, 0, 966, 
	967, 5, 300, 0, 0, 967, 968, 3, 462, 231, 0, 968, 969, 5, 153, 0, 0, 969, 
	970, 5, 285, 0, 0, 970, 971, 5, 201, 0, 0, 971, 974, 3, 82, 41, 0, 972, 
	973, 5, 194, 0, 0, 973, 975, 5, 196, 0, 0, 974, 972, 1, 0, 0, 0, 974, 975, 
	1, 0, 0, 0, 975, 976, 1, 0, 0, 0, 976, 977, 5, 139, 0, 0, 977, 978, 5, 
	30, 0, 0, 978, 979, 3, 128, 64, 0, 979, 81, 1, 0, 0, 0, 980, 983, 3, 84, 
	42, 0, 981, 983, 3, 128, 64, 0, 982, 980, 1, 0, 0, 0, 982, 981, 1, 0, 0, 
	0, 983, 83, 1, 0, 0, 0, 984, 985, 3, 464, 232, 0, 985, 986, 5, 3, 0, 0, 
	986, 987, 7, 7, 0, 0, 987, 85, 1, 0, 0, 0, 988, 989, 3, 464, 232, 0, 989, 
	87, 1, 0, 0, 0, 990, 1023, 3, 134, 67, 0, 991, 993, 5, 194, 0, 0, 992, 
	991, 1, 0, 0, 0, 992, 993, 1, 0, 0, 0, 993, 994, 1, 0, 0, 0, 994, 1023, 
	5, 196, 0, 0, 995, 996, 5, 219, 0, 0, 996, 1023, 5, 158, 0, 0, 997, 1023, 
	5, 302, 0, 0, 998, 999, 5, 229, 0, 0, 999, 1000, 3, 346, 173, 0, 1000, 
	1001, 5, 365, 0, 0, 1001, 1002, 3, 464, 232, 0, 1002, 1006, 5, 368, 0, 
	0, 1003, 1005, 3, 92, 46, 0, 1004, 1003, 1, 0, 0, 0, 1005, 1008, 1, 0, 
	0, 0, 1006, 1004, 1, 0, 0, 0, 1006, 1007, 1, 0, 0, 0, 1007, 1023, 1, 0, 
	0, 0, 1008, 1006, 1, 0, 0, 0, 1009, 1010, 5, 133, 0, 0, 1010, 1011, 5, 
	365, 0, 0, 1011, 1016, 5, 375, 0, 0, 1012, 1013, 5, 350, 0, 0, 1013, 1015, 
	5, 375, 0, 0, 1014, 1012, 1, 0, 0, 0, 1015, 1018, 1, 0, 0, 0, 1016, 1014, 
	1, 0, 0, 0, 1016, 1017, 1, 0, 0, 0, 1017, 1019, 1, 0, 0, 0, 1018, 1016, 
	1, 0, 0, 0, 1019, 1023, 5, 368, 0, 0, 1020, 1023, 5, 17, 0, 0, 1021, 1023, 
	5, 97, 0, 0, 1022, 990, 1, 0, 0, 0, 1022, 992, 1, 0, 0, 0, 1022, 995, 1, 
	0, 0, 0, 1022, 997, 1, 0, 0, 0, 1022, 998, 1, 0, 0, 0, 1022, 1009, 1, 0, 
	0, 0, 1022, 1020, 1, 0, 0, 0, 1022, 1021, 1, 0, 0, 0, 1023, 89, 1, 0, 0, 
	0, 1024, 1025, 5, 219, 0, 0, 1025, 1027, 5, 158, 0, 0, 1026, 1028, 5, 43, 
	0, 0, 1027, 1026, 1, 0, 0, 0, 1027, 1028, 1, 0, 0, 0, 1028, 1029, 1, 0, 
	0, 0, 1029, 1030, 5, 365, 0, 0, 1030, 1032, 3, 464, 232, 0, 1031, 1033, 
	7, 8, 0, 0, 1032, 1031, 1, 0, 0, 0, 1032, 1033, 1, 0, 0, 0, 1033, 1041, 
	1, 0, 0, 0, 1034, 1035, 5, 350, 0, 0, 1035, 1037, 3, 464, 232, 0, 1036, 
	1038, 7, 8, 0, 0, 1037, 1036, 1, 0, 0, 0, 1037, 1038, 1, 0, 0, 0, 1038, 
	1040, 1, 0, 0, 0, 1039, 1034, 1, 0, 0, 0, 1040, 1043, 1, 0, 0, 0, 1041, 
	1039, 1, 0, 0, 0, 1041, 1042, 1, 0, 0, 0, 1042, 1044, 1, 0, 0, 0, 1043, 
	1041, 1, 0, 0, 0, 1044, 1046, 5, 368, 0, 0, 1045, 1047, 5, 97, 0, 0, 1046, 
	1045, 1, 0, 0, 0, 1046, 1047, 1, 0, 0, 0, 1047, 1049, 1, 0, 0, 0, 1048, 
	1050, 3, 248, 124, 0, 1049, 1048, 1, 0, 0, 0, 1049, 1050, 1, 0, 0, 0, 1050, 
	1082, 1, 0, 0, 0, 1051, 1052, 5, 116, 0, 0, 1052, 1053, 5, 158, 0, 0, 1053, 
	1054, 5, 365, 0, 0, 1054, 1059, 3, 464, 232, 0, 1055, 1056, 5, 350, 0, 
	0, 1056, 1058, 3, 464, 232, 0, 1057, 1055, 1, 0, 0, 0, 1058, 1061, 1, 0, 
	0, 0, 1059, 1057, 1, 0, 0, 0, 1059, 1060, 1, 0, 0, 0, 1060, 1062, 1, 0, 
	0, 0, 1061, 1059, 1, 0, 0, 0, 1062, 1063, 5, 368, 0, 0, 1063, 1064, 5, 
	229, 0, 0, 1064, 1065, 3, 346, 173, 0, 1065, 1066, 5, 365, 0, 0, 1066, 
	1071, 3, 464, 232, 0, 1067, 1068, 5, 350, 0, 0, 1068, 1070, 3, 464, 232, 
	0, 1069, 1067, 1, 0, 0, 0, 1070, 1073, 1, 0, 0, 0, 1071, 1069, 1, 0, 0, 
	0, 1071, 1072, 1, 0, 0, 0, 1072, 1074, 1, 0, 0, 0, 1073, 1071, 1, 0, 0, 
	0, 1074, 1078, 5, 368, 0, 0, 1075, 1077, 3, 92, 46, 0, 1076, 1075, 1, 0, 
	0, 0, 1077, 1080, 1, 0, 0, 0, 1078, 1076, 1, 0, 0, 0, 1078, 1079, 1, 0, 
	0, 0, 1079, 1082, 1, 0, 0, 0, 1080, 1078, 1, 0, 0, 0, 1081, 1024, 1, 0, 
	0, 0, 1081, 1051, 1, 0, 0, 0, 1082, 91, 1, 0, 0, 0, 1083, 1084, 5, 202, 
	0, 0, 1084, 1093, 7, 9, 0, 0, 1085, 1086, 5, 189, 0, 0, 1086, 1094, 5, 
	5, 0, 0, 1087, 1094, 5, 233, 0, 0, 1088, 1089, 5, 258, 0, 0, 1089, 1094, 
	5, 196, 0, 0, 1090, 1091, 5, 258, 0, 0, 1091, 1094, 5, 75, 0, 0, 1092, 
	1094, 5, 34, 0, 0, 1093, 1085, 1, 0, 0, 0, 1093, 1087, 1, 0, 0, 0, 1093, 
	1088, 1, 0, 0, 0, 1093, 1090, 1, 0, 0, 0, 1093, 1092, 1, 0, 0, 0, 1094, 
	93, 1, 0, 0, 0, 1095, 1097, 3, 96, 48, 0, 1096, 1095, 1, 0, 0, 0, 1097, 
	1098, 1, 0, 0, 0, 1098, 1096, 1, 0, 0, 0, 1098, 1099, 1, 0, 0, 0, 1099, 
	95, 1, 0, 0, 0, 1100, 1101, 5, 350, 0, 0, 1101, 1104, 3, 98, 49, 0, 1102, 
	1104, 3, 110, 55, 0, 1103, 1100, 1, 0, 0, 0, 1103, 1102, 1, 0, 0, 0, 1104, 
	97, 1, 0, 0, 0, 1105, 1107, 5, 189, 0, 0, 1106, 1105, 1, 0, 0, 0, 1106, 
	1107, 1, 0, 0, 0, 1107, 1108, 1, 0, 0, 0, 1108, 1109, 7, 10, 0, 0, 1109, 
	99, 1, 0, 0, 0, 1110, 1112, 3, 102, 51, 0, 1111, 1110, 1, 0, 0, 0, 1112, 
	1113, 1, 0, 0, 0, 1113, 1111, 1, 0, 0, 0, 1113, 1114, 1, 0, 0, 0, 1114, 
	101, 1, 0, 0, 0, 1115, 1116, 5, 202, 0, 0, 1116, 1117, 5, 50, 0, 0, 1117, 
	1118, 7, 11, 0, 0, 1118, 1126, 5, 244, 0, 0, 1119, 1126, 3, 104, 52, 0, 
	1120, 1126, 3, 106, 53, 0, 1121, 1126, 3, 108, 54, 0, 1122, 1126, 3, 110, 
	55, 0, 1123, 1126, 3, 116, 58, 0, 1124, 1126, 3, 118, 59, 0, 1125, 1115, 
	1, 0, 0, 0, 1125, 1119, 1, 0, 0, 0, 1125, 1120, 1, 0, 0, 0, 1125, 1121, 
	1, 0, 0, 0, 1125, 1122, 1, 0, 0, 0, 1125, 1123, 1, 0, 0, 0, 1125, 1124, 
	1, 0, 0, 0, 1126, 103, 1, 0, 0, 0, 1127, 1128, 5, 255, 0, 0, 1128, 1129, 
	5, 60, 0, 0, 1129, 1146, 7, 12, 0, 0, 1130, 1131, 7, 13, 0, 0, 1131, 1146, 
	5, 375, 0, 0, 1132, 1146, 5, 191, 0, 0, 1133, 1146, 7, 14, 0, 0, 1134, 
	1135, 5, 277, 0, 0, 1135, 1138, 5, 365, 0, 0, 1136, 1139, 3, 464, 232, 
	0, 1137, 1139, 5, 375, 0, 0, 1138, 1136, 1, 0, 0, 0, 1138, 1137, 1, 0, 
	0, 0, 1139, 1140, 1, 0, 0, 0, 1140, 1138, 1, 0, 0, 0, 1140, 1141, 1, 0, 
	0, 0, 1141, 1142, 1, 0, 0, 0, 1142, 1146, 5, 368, 0, 0, 1143, 1144, 5, 
	286, 0, 0, 1144, 1146, 3, 464, 232, 0, 1145, 1127, 1, 0, 0, 0, 1145, 1130, 
	1, 0, 0, 0, 1145, 1132, 1, 0, 0, 0, 1145, 1133, 1, 0, 0, 0, 1145, 1134, 
	1, 0, 0, 0, 1145, 1143, 1, 0, 0, 0, 1146, 105, 1, 0, 0, 0, 1147, 1149, 
	5, 139, 0, 0, 1148, 1147, 1, 0, 0, 0, 1148, 1149, 1, 0, 0, 0, 1149, 1150, 
	1, 0, 0, 0, 1150, 1151, 5, 137, 0, 0, 1151, 1181, 3, 464, 232, 0, 1152, 
	1153, 5, 317, 0, 0, 1153, 1181, 5, 231, 0, 0, 1154, 1155, 5, 89, 0, 0, 
	1155, 1156, 5, 30, 0, 0, 1156, 1157, 5, 128, 0, 0, 1157, 1158, 5, 365, 
	0, 0, 1158, 1163, 3, 464, 232, 0, 1159, 1160, 5, 350, 0, 0, 1160, 1162, 
	3, 464, 232, 0, 1161, 1159, 1, 0, 0, 0, 1162, 1165, 1, 0, 0, 0, 1163, 1161, 
	1, 0, 0, 0, 1163, 1164, 1, 0, 0, 0, 1164, 1166, 1, 0, 0, 0, 1165, 1163, 
	1, 0, 0, 0, 1166, 1167, 5, 368, 0, 0, 1167, 1181, 1, 0, 0, 0, 1168, 1170, 
	5, 194, 0, 0, 1169, 1168, 1, 0, 0, 0, 1169, 1170, 1, 0, 0, 0, 1170, 1171, 
	1, 0, 0, 0, 1171, 1181, 5, 172, 0, 0, 1172, 1173, 5, 51, 0, 0, 1173, 1181, 
	7, 15, 0, 0, 1174, 1175, 5, 79, 0, 0, 1175, 1181, 5, 203, 0, 0, 1176, 1177, 
	5, 317, 0, 0, 1177, 1178, 5, 233, 0, 0, 1178, 1179, 5, 202, 0, 0, 1179, 
	1181, 5, 92, 0, 0, 1180, 1148, 1, 0, 0, 0, 1180, 1152, 1, 0, 0, 0, 1180, 
	1154, 1, 0, 0, 0, 1180, 1169, 1, 0, 0, 0, 1180, 1172, 1, 0, 0, 0, 1180, 
	1174, 1, 0, 0, 0, 1180, 1176, 1, 0, 0, 0, 1181, 107, 1, 0, 0, 0, 1182, 
	1184, 5, 302, 0, 0, 1183, 1182, 1, 0, 0, 0, 1183, 1184, 1, 0, 0, 0, 1184, 
	1185, 1, 0, 0, 0, 1185, 1186, 5, 219, 0, 0, 1186, 1187, 5, 139, 0, 0, 1187, 
	1188, 5, 365, 0, 0, 1188, 1193, 3, 464, 232, 0, 1189, 1190, 5, 350, 0, 
	0, 1190, 1192, 3, 464, 232, 0, 1191, 1189, 1, 0, 0, 0, 1192, 1195, 1, 0, 
	0, 0, 1193, 1191, 1, 0, 0, 0, 1193, 1194, 1, 0, 0, 0, 1194, 1196, 1, 0, 
	0, 0, 1195, 1193, 1, 0, 0, 0, 1196, 1197, 5, 368, 0, 0, 1197, 1201, 1, 
	0, 0, 0, 1198, 1199, 5, 317, 0, 0, 1199, 1201, 5, 67, 0, 0, 1200, 1183, 
	1, 0, 0, 0, 1200, 1198, 1, 0, 0, 0, 1201, 109, 1, 0, 0, 0, 1202, 1207, 
	3, 112, 56, 0, 1203, 1204, 5, 278, 0, 0, 1204, 1205, 5, 13, 0, 0, 1205, 
	1207, 3, 464, 232, 0, 1206, 1202, 1, 0, 0, 0, 1206, 1203, 1, 0, 0, 0, 1207, 
	111, 1, 0, 0, 0, 1208, 1209, 5, 243, 0, 0, 1209, 1210, 5, 117, 0, 0, 1210, 
	1214, 5, 81, 0, 0, 1211, 1213, 3, 114, 57, 0, 1212, 1211, 1, 0, 0, 0, 1213, 
	1216, 1, 0, 0, 0, 1214, 1212, 1, 0, 0, 0, 1214, 1215, 1, 0, 0, 0, 1215, 
	113, 1, 0, 0, 0, 1216, 1214, 1, 0, 0, 0, 1217, 1218, 5, 111, 0, 0, 1218, 
	1219, 5, 288, 0, 0, 1219, 1220, 5, 30, 0, 0, 1220, 1224, 3, 400, 200, 0, 
	1221, 1222, 5, 100, 0, 0, 1222, 1223, 5, 30, 0, 0, 1223, 1225, 3, 400, 
	200, 0, 1224, 1221, 1, 0, 0, 0, 1224, 1225, 1, 0, 0, 0, 1225, 1245, 1, 
	0, 0, 0, 1226, 1227, 5, 46, 0, 0, 1227, 1228, 5, 155, 0, 0, 1228, 1229, 
	5, 288, 0, 0, 1229, 1230, 5, 30, 0, 0, 1230, 1245, 3, 400, 200, 0, 1231, 
	1232, 5, 175, 0, 0, 1232, 1233, 5, 159, 0, 0, 1233, 1234, 5, 288, 0, 0, 
	1234, 1235, 5, 30, 0, 0, 1235, 1245, 3, 400, 200, 0, 1236, 1237, 5, 165, 
	0, 0, 1237, 1238, 5, 288, 0, 0, 1238, 1239, 5, 30, 0, 0, 1239, 1245, 3, 
	400, 200, 0, 1240, 1241, 5, 196, 0, 0, 1241, 1242, 5, 77, 0, 0, 1242, 1243, 
	5, 13, 0, 0, 1243, 1245, 3, 400, 200, 0, 1244, 1217, 1, 0, 0, 0, 1244, 
	1226, 1, 0, 0, 0, 1244, 1231, 1, 0, 0, 0, 1244, 1236, 1, 0, 0, 0, 1244, 
	1240, 1, 0, 0, 0, 1245, 115, 1, 0, 0, 0, 1246, 1247, 5, 202, 0, 0, 1247, 
	1251, 3, 464, 232, 0, 1248, 1249, 5, 289, 0, 0, 1249, 1251, 3, 464, 232, 
	0, 1250, 1246, 1, 0, 0, 0, 1250, 1248, 1, 0, 0, 0, 1251, 117, 1, 0, 0, 
	0, 1252, 1254, 5, 17, 0, 0, 1253, 1255, 5, 355, 0, 0, 1254, 1253, 1, 0, 
	0, 0, 1254, 1255, 1, 0, 0, 0, 1255, 1256, 1, 0, 0, 0, 1256, 1280, 3, 400, 
	200, 0, 1257, 1259, 5, 48, 0, 0, 1258, 1260, 5, 355, 0, 0, 1259, 1258, 
	1, 0, 0, 0, 1259, 1260, 1, 0, 0, 0, 1260, 1261, 1, 0, 0, 0, 1261, 1280, 
	3, 400, 200, 0, 1262, 1264, 5, 75, 0, 0, 1263, 1262, 1, 0, 0, 0, 1263, 
	1264, 1, 0, 0, 0, 1264, 1268, 1, 0, 0, 0, 1265, 1266, 5, 39, 0, 0, 1266, 
	1269, 5, 258, 0, 0, 1267, 1269, 5, 40, 0, 0, 1268, 1265, 1, 0, 0, 0, 1268, 
	1267, 1, 0, 0, 0, 1269, 1271, 1, 0, 0, 0, 1270, 1272, 5, 355, 0, 0, 1271, 
	1270, 1, 0, 0, 0, 1271, 1272, 1, 0, 0, 0, 1272, 1273, 1, 0, 0, 0, 1273, 
	1280, 3, 400, 200, 0, 1274, 1276, 5, 99, 0, 0, 1275, 1277, 5, 355, 0, 0, 
	1276, 1275, 1, 0, 0, 0, 1276, 1277, 1, 0, 0, 0, 1277, 1278, 1, 0, 0, 0, 
	1278, 1280, 3, 400, 200, 0, 1279, 1252, 1, 0, 0, 0, 1279, 1257, 1, 0, 0, 
	0, 1279, 1263, 1, 0, 0, 0, 1279, 1274, 1, 0, 0, 0, 1280, 119, 1, 0, 0, 
	0, 1281, 1282, 5, 9, 0, 0, 1282, 1283, 5, 285, 0, 0, 1283, 1284, 3, 346, 
	173, 0, 1284, 1285, 3, 122, 61, 0, 1285, 121, 1, 0, 0, 0, 1286, 1287, 3, 
	124, 62, 0, 1287, 123, 1, 0, 0, 0, 1288, 1291, 5, 6, 0, 0, 1289, 1290, 
	5, 54, 0, 0, 1290, 1292, 3, 464, 232, 0, 1291, 1289, 1, 0, 0, 0, 1291, 
	1292, 1, 0, 0, 0, 1292, 1293, 1, 0, 0, 0, 1293, 1294, 3, 126, 63, 0, 1294, 
	125, 1, 0, 0, 0, 1295, 1296, 5, 219, 0, 0, 1296, 1298, 5, 158, 0, 0, 1297, 
	1299, 5, 43, 0, 0, 1298, 1297, 1, 0, 0, 0, 1298, 1299, 1, 0, 0, 0, 1299, 
	1300, 1, 0, 0, 0, 1300, 1301, 5, 365, 0, 0, 1301, 1303, 3, 464, 232, 0, 
	1302, 1304, 7, 8, 0, 0, 1303, 1302, 1, 0, 0, 0, 1303, 1304, 1, 0, 0, 0, 
	1304, 1312, 1, 0, 0, 0, 1305, 1306, 5, 350, 0, 0, 1306, 1308, 3, 464, 232, 
	0, 1307, 1309, 7, 8, 0, 0, 1308, 1307, 1, 0, 0, 0, 1308, 1309, 1, 0, 0, 
	0, 1309, 1311, 1, 0, 0, 0, 1310, 1305, 1, 0, 0, 0, 1311, 1314, 1, 0, 0, 
	0, 1312, 1310, 1, 0, 0, 0, 1312, 1313, 1, 0, 0, 0, 1313, 1315, 1, 0, 0, 
	0, 1314, 1312, 1, 0, 0, 0, 1315, 1317, 5, 368, 0, 0, 1316, 1318, 5, 97, 
	0, 0, 1317, 1316, 1, 0, 0, 0, 1317, 1318, 1, 0, 0, 0, 1318, 1320, 1, 0, 
	0, 0, 1319, 1321, 3, 248, 124, 0, 1320, 1319, 1, 0, 0, 0, 1320, 1321, 1, 
	0, 0, 0, 1321, 1358, 1, 0, 0, 0, 1322, 1323, 5, 116, 0, 0, 1323, 1324, 
	5, 158, 0, 0, 1324, 1325, 5, 365, 0, 0, 1325, 1330, 3, 464, 232, 0, 1326, 
	1327, 5, 350, 0, 0, 1327, 1329, 3, 464, 232, 0, 1328, 1326, 1, 0, 0, 0, 
	1329, 1332, 1, 0, 0, 0, 1330, 1328, 1, 0, 0, 0, 1330, 1331, 1, 0, 0, 0, 
	1331, 1333, 1, 0, 0, 0, 1332, 1330, 1, 0, 0, 0, 1333, 1334, 5, 368, 0, 
	0, 1334, 1335, 5, 229, 0, 0, 1335, 1336, 3, 346, 173, 0, 1336, 1337, 5, 
	365, 0, 0, 1337, 1342, 3, 464, 232, 0, 1338, 1339, 5, 350, 0, 0, 1339, 
	1341, 3, 464, 232, 0, 1340, 1338, 1, 0, 0, 0, 1341, 1344, 1, 0, 0, 0, 1342, 
	1340, 1, 0, 0, 0, 1342, 1343, 1, 0, 0, 0, 1343, 1345, 1, 0, 0, 0, 1344, 
	1342, 1, 0, 0, 0, 1345, 1349, 5, 368, 0, 0, 1346, 1348, 3, 92, 46, 0, 1347, 
	1346, 1, 0, 0, 0, 1348, 1351, 1, 0, 0, 0, 1349, 1347, 1, 0, 0, 0, 1349, 
	1350, 1, 0, 0, 0, 1350, 1358, 1, 0, 0, 0, 1351, 1349, 1, 0, 0, 0, 1352, 
	1353, 5, 75, 0, 0, 1353, 1354, 3, 400, 200, 0, 1354, 1355, 5, 115, 0, 0, 
	1355, 1356, 3, 464, 232, 0, 1356, 1358, 1, 0, 0, 0, 1357, 1295, 1, 0, 0, 
	0, 1357, 1322, 1, 0, 0, 0, 1357, 1352, 1, 0, 0, 0, 1358, 127, 1, 0, 0, 
	0, 1359, 1406, 5, 38, 0, 0, 1360, 1406, 5, 39, 0, 0, 1361, 1406, 5, 22, 
	0, 0, 1362, 1406, 5, 23, 0, 0, 1363, 1406, 5, 24, 0, 0, 1364, 1406, 5, 
	25, 0, 0, 1365, 1406, 5, 26, 0, 0, 1366, 1406, 5, 68, 0, 0, 1367, 1406, 
	5, 69, 0, 0, 1368, 1406, 5, 72, 0, 0, 1369, 1406, 5, 73, 0, 0, 1370, 1372, 
	5, 91, 0, 0, 1371, 1373, 5, 217, 0, 0, 1372, 1371, 1, 0, 0, 0, 1372, 1373, 
	1, 0, 0, 0, 1373, 1406, 1, 0, 0, 0, 1374, 1406, 5, 114, 0, 0, 1375, 1406, 
	5, 144, 0, 0, 1376, 1406, 5, 145, 0, 0, 1377, 1406, 5, 146, 0, 0, 1378, 
	1406, 5, 147, 0, 0, 1379, 1406, 5, 148, 0, 0, 1380, 1406, 5, 186, 0, 0, 
	1381, 1406, 5, 188, 0, 0, 1382, 1406, 5, 198, 0, 0, 1383, 1406, 5, 197, 
	0, 0, 1384, 1406, 5, 216, 0, 0, 1385, 1406, 5, 228, 0, 0, 1386, 1387, 5, 
	235, 0, 0, 1387, 1406, 5, 312, 0, 0, 1388, 1406, 5, 265, 0, 0, 1389, 1406, 
	5, 264, 0, 0, 1390, 1406, 5, 266, 0, 0, 1391, 1406, 5, 268, 0, 0, 1392, 
	1406, 5, 267, 0, 0, 1393, 1406, 5, 279, 0, 0, 1394, 1406, 5, 284, 0, 0, 
	1395, 1406, 5, 292, 0, 0, 1396, 1406, 5, 293, 0, 0, 1397, 1406, 5, 310, 
	0, 0, 1398, 1406, 5, 311, 0, 0, 1399, 1406, 5, 321, 0, 0, 1400, 1403, 3, 
	464, 232, 0, 1401, 1402, 5, 3, 0, 0, 1402, 1404, 7, 7, 0, 0, 1403, 1401, 
	1, 0, 0, 0, 1403, 1404, 1, 0, 0, 0, 1404, 1406, 1, 0, 0, 0, 1405, 1359, 
	1, 0, 0, 0, 1405, 1360, 1, 0, 0, 0, 1405, 1361, 1, 0, 0, 0, 1405, 1362, 
	1, 0, 0, 0, 1405, 1363, 1, 0, 0, 0, 1405, 1364, 1, 0, 0, 0, 1405, 1365, 
	1, 0, 0, 0, 1405, 1366, 1, 0, 0, 0, 1405, 1367, 1, 0, 0, 0, 1405, 1368, 
	1, 0, 0, 0, 1405, 1369, 1, 0, 0, 0, 1405, 1370, 1, 0, 0, 0, 1405, 1374, 
	1, 0, 0, 0, 1405, 1375, 1, 0, 0, 0, 1405, 1376, 1, 0, 0, 0, 1405, 1377, 
	1, 0, 0, 0, 1405, 1378, 1, 0, 0, 0, 1405, 1379, 1, 0, 0, 0, 1405, 1380, 
	1, 0, 0, 0, 1405, 1381, 1, 0, 0, 0, 1405, 1382, 1, 0, 0, 0, 1405, 1383, 
	1, 0, 0, 0, 1405, 1384, 1, 0, 0, 0, 1405, 1385, 1, 0, 0, 0, 1405, 1386, 
	1, 0, 0, 0, 1405, 1388, 1, 0, 0, 0, 1405, 1389, 1, 0, 0, 0, 1405, 1390, 
	1, 0, 0, 0, 1405, 1391, 1, 0, 0, 0, 1405, 1392, 1, 0, 0, 0, 1405, 1393, 
	1, 0, 0, 0, 1405, 1394, 1, 0, 0, 0, 1405, 1395, 1, 0, 0, 0, 1405, 1396, 
	1, 0, 0, 0, 1405, 1397, 1, 0, 0, 0, 1405, 1398, 1, 0, 0, 0, 1405, 1399, 
	1, 0, 0, 0, 1405, 1400, 1, 0, 0, 0, 1406, 129, 1, 0, 0, 0, 1407, 1408, 
	5, 365, 0, 0, 1408, 1410, 7, 16, 0, 0, 1409, 1411, 7, 17, 0, 0, 1410, 1409, 
	1, 0, 0, 0, 1410, 1411, 1, 0, 0, 0, 1411, 1414, 1, 0, 0, 0, 1412, 1413, 
	5, 350, 0, 0, 1413, 1415, 5, 375, 0, 0, 1414, 1412, 1, 0, 0, 0, 1414, 1415, 
	1, 0, 0, 0, 1415, 1416, 1, 0, 0, 0, 1416, 1417, 5, 368, 0, 0, 1417, 131, 
	1, 0, 0, 0, 1418, 1420, 5, 194, 0, 0, 1419, 1418, 1, 0, 0, 0, 1419, 1420, 
	1, 0, 0, 0, 1420, 1421, 1, 0, 0, 0, 1421, 1430, 5, 196, 0, 0, 1422, 1423, 
	5, 39, 0, 0, 1423, 1424, 5, 258, 0, 0, 1424, 1430, 3, 462, 231, 0, 1425, 
	1427, 5, 194, 0, 0, 1426, 1425, 1, 0, 0, 0, 1426, 1427, 1, 0, 0, 0, 1427, 
	1428, 1, 0, 0, 0, 1428, 1430, 7, 18, 0, 0, 1429, 1419, 1, 0, 0, 0, 1429, 
	1422, 1, 0, 0, 0, 1429, 1426, 1, 0, 0, 0, 1430, 133, 1, 0, 0, 0, 1431, 
	1433, 5, 349, 0, 0, 1432, 1431, 1, 0, 0, 0, 1432, 1433, 1, 0, 0, 0, 1433, 
	1434, 1, 0, 0, 0, 1434, 1435, 5, 355, 0, 0, 1435, 1444, 3, 400, 200, 0, 
	1436, 1438, 5, 317, 0, 0, 1437, 1436, 1, 0, 0, 0, 1437, 1438, 1, 0, 0, 
	0, 1438, 1439, 1, 0, 0, 0, 1439, 1441, 5, 75, 0, 0, 1440, 1442, 3, 400, 
	200, 0, 1441, 1440, 1, 0, 0, 0, 1441, 1442, 1, 0, 0, 0, 1442, 1444, 1, 
	0, 0, 0, 1443, 1432, 1, 0, 0, 0, 1443, 1437, 1, 0, 0, 0, 1444, 135, 1, 
	0, 0, 0, 1445, 1446, 5, 59, 0, 0, 1446, 1450, 7, 19, 0, 0, 1447, 1448, 
	5, 134, 0, 0, 1448, 1449, 5, 194, 0, 0, 1449, 1451, 5, 106, 0, 0, 1450, 
	1447, 1, 0, 0, 0, 1450, 1451, 1, 0, 0, 0, 1451, 1452, 1, 0, 0, 0, 1452, 
	1456, 3, 400, 200, 0, 1453, 1455, 3, 138, 69, 0, 1454, 1453, 1, 0, 0, 0, 
	1455, 1458, 1, 0, 0, 0, 1456, 1454, 1, 0, 0, 0, 1456, 1457, 1, 0, 0, 0, 
	1457, 137, 1, 0, 0, 0, 1458, 1456, 1, 0, 0, 0, 1459, 1460, 5, 48, 0, 0, 
	1460, 1464, 3, 400, 200, 0, 1461, 1462, 5, 167, 0, 0, 1462, 1464, 3, 400, 
	200, 0, 1463, 1459, 1, 0, 0, 0, 1463, 1461, 1, 0, 0, 0, 1464, 139, 1, 0, 
	0, 0, 1465, 1473, 5, 9, 0, 0, 1466, 1469, 5, 59, 0, 0, 1467, 1468, 5, 205, 
	0, 0, 1468, 1470, 5, 231, 0, 0, 1469, 1467, 1, 0, 0, 0, 1469, 1470, 1, 
	0, 0, 0, 1470, 1473, 1, 0, 0, 0, 1471, 1473, 5, 231, 0, 0, 1472, 1465, 
	1, 0, 0, 0, 1472, 1466, 1, 0, 0, 0, 1472, 1471, 1, 0, 0, 0, 1472, 1473, 
	1, 0, 0, 0, 1473, 1474, 1, 0, 0, 0, 1474, 1475, 5, 121, 0, 0, 1475, 1477, 
	3, 462, 231, 0, 1476, 1478, 3, 158, 79, 0, 1477, 1476, 1, 0, 0, 0, 1477, 
	1478, 1, 0, 0, 0, 1478, 1479, 1, 0, 0, 0, 1479, 1481, 3, 142, 71, 0, 1480, 
	1482, 7, 20, 0, 0, 1481, 1480, 1, 0, 0, 0, 1481, 1482, 1, 0, 0, 0, 1482, 
	1484, 1, 0, 0, 0, 1483, 1485, 3, 50, 25, 0, 1484, 1483, 1, 0, 0, 0, 1484, 
	1485, 1, 0, 0, 0, 1485, 1486, 1, 0, 0, 0, 1486, 1487, 3, 6, 3, 0, 1487, 
	141, 1, 0, 0, 0, 1488, 1489, 7, 21, 0, 0, 1489, 1491, 3, 128, 64, 0, 1490, 
	1492, 3, 130, 65, 0, 1491, 1490, 1, 0, 0, 0, 1491, 1492, 1, 0, 0, 0, 1492, 
	143, 1, 0, 0, 0, 1493, 1501, 5, 9, 0, 0, 1494, 1497, 5, 59, 0, 0, 1495, 
	1496, 5, 205, 0, 0, 1496, 1498, 5, 231, 0, 0, 1497, 1495, 1, 0, 0, 0, 1497, 
	1498, 1, 0, 0, 0, 1498, 1501, 1, 0, 0, 0, 1499, 1501, 5, 231, 0, 0, 1500, 
	1493, 1, 0, 0, 0, 1500, 1494, 1, 0, 0, 0, 1500, 1499, 1, 0, 0, 0, 1500, 
	1501, 1, 0, 0, 0, 1501, 1502, 1, 0, 0, 0, 1502, 1503, 5, 212, 0, 0, 1503, 
	1504, 3, 462, 231, 0, 1504, 1505, 7, 20, 0, 0, 1505, 1506, 3, 146, 73, 
	0, 1506, 1510, 5, 98, 0, 0, 1507, 1508, 3, 462, 231, 0, 1508, 1509, 5, 
	370, 0, 0, 1509, 1511, 1, 0, 0, 0, 1510, 1507, 1, 0, 0, 0, 1510, 1511, 
	1, 0, 0, 0, 1511, 145, 1, 0, 0, 0, 1512, 1513, 3, 148, 74, 0, 1513, 1519, 
	5, 370, 0, 0, 1514, 1515, 3, 148, 74, 0, 1515, 1516, 5, 370, 0, 0, 1516, 
	1518, 1, 0, 0, 0, 1517, 1514, 1, 0, 0, 0, 1518, 1521, 1, 0, 0, 0, 1519, 
	1517, 1, 0, 0, 0, 1519, 1520, 1, 0, 0, 0, 1520, 147, 1, 0, 0, 0, 1521, 
	1519, 1, 0, 0, 0, 1522, 1536, 3, 52, 26, 0, 1523, 1524, 5, 121, 0, 0, 1524, 
	1526, 3, 462, 231, 0, 1525, 1527, 3, 158, 79, 0, 1526, 1525, 1, 0, 0, 0, 
	1526, 1527, 1, 0, 0, 0, 1527, 1528, 1, 0, 0, 0, 1528, 1529, 3, 142, 71, 
	0, 1529, 1536, 1, 0, 0, 0, 1530, 1531, 7, 22, 0, 0, 1531, 1533, 3, 462, 
	231, 0, 1532, 1534, 3, 158, 79, 0, 1533, 1532, 1, 0, 0, 0, 1533, 1534, 
	1, 0, 0, 0, 1534, 1536, 1, 0, 0, 0, 1535, 1522, 1, 0, 0, 0, 1535, 1523, 
	1, 0, 0, 0, 1535, 1530, 1, 0, 0, 0, 1536, 149, 1, 0, 0, 0, 1537, 1545, 
	5, 9, 0, 0, 1538, 1541, 5, 59, 0, 0, 1539, 1540, 5, 205, 0, 0, 1540, 1542, 
	5, 231, 0, 0, 1541, 1539, 1, 0, 0, 0, 1541, 1542, 1, 0, 0, 0, 1542, 1545, 
	1, 0, 0, 0, 1543, 1545, 5, 231, 0, 0, 1544, 1537, 1, 0, 0, 0, 1544, 1538, 
	1, 0, 0, 0, 1544, 1543, 1, 0, 0, 0, 1544, 1545, 1, 0, 0, 0, 1545, 1546, 
	1, 0, 0, 0, 1546, 1547, 5, 212, 0, 0, 1547, 1548, 5, 27, 0, 0, 1548, 1549, 
	3, 462, 231, 0, 1549, 1550, 7, 20, 0, 0, 1550, 1551, 3, 152, 76, 0, 1551, 
	1555, 5, 98, 0, 0, 1552, 1553, 3, 462, 231, 0, 1553, 1554, 5, 370, 0, 0, 
	1554, 1556, 1, 0, 0, 0, 1555, 1552, 1, 0, 0, 0, 1555, 1556, 1, 0, 0, 0, 
	1556, 151, 1, 0, 0, 0, 1557, 1558, 3, 154, 77, 0, 1558, 1564, 5, 370, 0, 
	0, 1559, 1560, 3, 154, 77, 0, 1560, 1561, 5, 370, 0, 0, 1561, 1563, 1, 
	0, 0, 0, 1562, 1559, 1, 0, 0, 0, 1563, 1566, 1, 0, 0, 0, 1564, 1562, 1, 
	0, 0, 0, 1564, 1565, 1, 0, 0, 0, 1565, 153, 1, 0, 0, 0, 1566, 1564, 1, 
	0, 0, 0, 1567, 1571, 3, 52, 26, 0, 1568, 1571, 3, 140, 70, 0, 1569, 1571, 
	3, 156, 78, 0, 1570, 1567, 1, 0, 0, 0, 1570, 1568, 1, 0, 0, 0, 1570, 1569, 
	1, 0, 0, 0, 1571, 155, 1, 0, 0, 0, 1572, 1580, 5, 9, 0, 0, 1573, 1576, 
	5, 59, 0, 0, 1574, 1575, 5, 205, 0, 0, 1575, 1577, 5, 231, 0, 0, 1576, 
	1574, 1, 0, 0, 0, 1576, 1577, 1, 0, 0, 0, 1577, 1580, 1, 0, 0, 0, 1578, 
	1580, 5, 231, 0, 0, 1579, 1572, 1, 0, 0, 0, 1579, 1573, 1, 0, 0, 0, 1579, 
	1578, 1, 0, 0, 0, 1579, 1580, 1, 0, 0, 0, 1580, 1581, 1, 0, 0, 0, 1581, 
	1582, 7, 22, 0, 0, 1582, 1584, 3, 462, 231, 0, 1583, 1585, 3, 158, 79, 
	0, 1584, 1583, 1, 0, 0, 0, 1584, 1585, 1, 0, 0, 0, 1585, 1587, 1, 0, 0, 
	0, 1586, 1588, 3, 162, 81, 0, 1587, 1586, 1, 0, 0, 0, 1587, 1588, 1, 0, 
	0, 0, 1588, 1590, 1, 0, 0, 0, 1589, 1591, 7, 20, 0, 0, 1590, 1589, 1, 0, 
	0, 0, 1590, 1591, 1, 0, 0, 0, 1591, 1593, 1, 0, 0, 0, 1592, 1594, 3, 50, 
	25, 0, 1593, 1592, 1, 0, 0, 0, 1593, 1594, 1, 0, 0, 0, 1594, 1596, 1, 0, 
	0, 0, 1595, 1597, 3, 290, 145, 0, 1596, 1595, 1, 0, 0, 0, 1596, 1597, 1, 
	0, 0, 0, 1597, 1598, 1, 0, 0, 0, 1598, 1602, 3, 10, 5, 0, 1599, 1600, 3, 
	462, 231, 0, 1600, 1601, 5, 370, 0, 0, 1601, 1603, 1, 0, 0, 0, 1602, 1599, 
	1, 0, 0, 0, 1602, 1603, 1, 0, 0, 0, 1603, 157, 1, 0, 0, 0, 1604, 1605, 
	5, 365, 0, 0, 1605, 1627, 5, 368, 0, 0, 1606, 1607, 5, 365, 0, 0, 1607, 
	1612, 3, 160, 80, 0, 1608, 1609, 5, 350, 0, 0, 1609, 1611, 3, 160, 80, 
	0, 1610, 1608, 1, 0, 0, 0, 1611, 1614, 1, 0, 0, 0, 1612, 1610, 1, 0, 0, 
	0, 1612, 1613, 1, 0, 0, 0, 1613, 1615, 1, 0, 0, 0, 1614, 1612, 1, 0, 0, 
	0, 1615, 1616, 5, 368, 0, 0, 1616, 1627, 1, 0, 0, 0, 1617, 1618, 4, 79, 
	2, 0, 1618, 1623, 3, 160, 80, 0, 1619, 1620, 5, 350, 0, 0, 1620, 1622, 
	3, 160, 80, 0, 1621, 1619, 1, 0, 0, 0, 1622, 1625, 1, 0, 0, 0, 1623, 1621, 
	1, 0, 0, 0, 1623, 1624, 1, 0, 0, 0, 1624, 1627, 1, 0, 0, 0, 1625, 1623, 
	1, 0, 0, 0, 1626, 1604, 1, 0, 0, 0, 1626, 1606, 1, 0, 0, 0, 1626, 1617, 
	1, 0, 0, 0, 1627, 159, 1, 0, 0, 0, 1628, 1634, 5, 137, 0, 0, 1629, 1634, 
	5, 207, 0, 0, 1630, 1634, 5, 142, 0, 0, 1631, 1632, 5, 137, 0, 0, 1632, 
	1634, 5, 207, 0, 0, 1633, 1628, 1, 0, 0, 0, 1633, 1629, 1, 0, 0, 0, 1633, 
	1630, 1, 0, 0, 0, 1633, 1631, 1, 0, 0, 0, 1633, 1634, 1, 0, 0, 0, 1634, 
	1635, 1, 0, 0, 0, 1635, 1636, 3, 462, 231, 0, 1636, 1638, 3, 128, 64, 0, 
	1637, 1639, 3, 130, 65, 0, 1638, 1637, 1, 0, 0, 0, 1638, 1639, 1, 0, 0, 
	0, 1639, 1643, 1, 0, 0, 0, 1640, 1642, 3, 132, 66, 0, 1641, 1640, 1, 0, 
	0, 0, 1642, 1645, 1, 0, 0, 0, 1643, 1641, 1, 0, 0, 0, 1643, 1644, 1, 0, 
	0, 0, 1644, 1647, 1, 0, 0, 0, 1645, 1643, 1, 0, 0, 0, 1646, 1648, 3, 134, 
	67, 0, 1647, 1646, 1, 0, 0, 0, 1647, 1648, 1, 0, 0, 0, 1648, 1671, 1, 0, 
	0, 0, 1649, 1655, 3, 462, 231, 0, 1650, 1656, 5, 137, 0, 0, 1651, 1656, 
	5, 207, 0, 0, 1652, 1656, 5, 142, 0, 0, 1653, 1654, 5, 137, 0, 0, 1654, 
	1656, 5, 207, 0, 0, 1655, 1650, 1, 0, 0, 0, 1655, 1651, 1, 0, 0, 0, 1655, 
	1652, 1, 0, 0, 0, 1655, 1653, 1, 0, 0, 0, 1655, 1656, 1, 0, 0, 0, 1656, 
	1657, 1, 0, 0, 0, 1657, 1659, 3, 128, 64, 0, 1658, 1660, 3, 130, 65, 0, 
	1659, 1658, 1, 0, 0, 0, 1659, 1660, 1, 0, 0, 0, 1660, 1664, 1, 0, 0, 0, 
	1661, 1663, 3, 132, 66, 0, 1662, 1661, 1, 0, 0, 0, 1663, 1666, 1, 0, 0, 
	0, 1664, 1662, 1, 0, 0, 0, 1664, 1665, 1, 0, 0, 0, 1665, 1668, 1, 0, 0, 
	0, 1666, 1664, 1, 0, 0, 0, 1667, 1669, 3, 134, 67, 0, 1668, 1667, 1, 0, 
	0, 0, 1668, 1669, 1, 0, 0, 0, 1669, 1671, 1, 0, 0, 0, 1670, 1633, 1, 0, 
	0, 0, 1670, 1649, 1, 0, 0, 0, 1671, 161, 1, 0, 0, 0, 1672, 1674, 3, 164, 
	82, 0, 1673, 1672, 1, 0, 0, 0, 1674, 1675, 1, 0, 0, 0, 1675, 1673, 1, 0, 
	0, 0, 1675, 1676, 1, 0, 0, 0, 1676, 163, 1, 0, 0, 0, 1677, 1678, 5, 160, 
	0, 0, 1678, 1689, 5, 269, 0, 0, 1679, 1680, 5, 269, 0, 0, 1680, 1681, 5, 
	254, 0, 0, 1681, 1689, 7, 23, 0, 0, 1682, 1684, 5, 93, 0, 0, 1683, 1682, 
	1, 0, 0, 0, 1683, 1684, 1, 0, 0, 0, 1684, 1685, 1, 0, 0, 0, 1685, 1686, 
	5, 234, 0, 0, 1686, 1687, 5, 261, 0, 0, 1687, 1689, 5, 375, 0, 0, 1688, 
	1677, 1, 0, 0, 0, 1688, 1679, 1, 0, 0, 0, 1688, 1683, 1, 0, 0, 0, 1689, 
	165, 1, 0, 0, 0, 1690, 1691, 5, 92, 0, 0, 1691, 1694, 5, 285, 0, 0, 1692, 
	1693, 5, 134, 0, 0, 1693, 1695, 5, 106, 0, 0, 1694, 1692, 1, 0, 0, 0, 1694, 
	1695, 1, 0, 0, 0, 1695, 1696, 1, 0, 0, 0, 1696, 1719, 3, 346, 173, 0, 1697, 
	1698, 5, 92, 0, 0, 1698, 1701, 5, 212, 0, 0, 1699, 1700, 5, 134, 0, 0, 
	1700, 1702, 5, 106, 0, 0, 1701, 1699, 1, 0, 0, 0, 1701, 1702, 1, 0, 0, 
	0, 1702, 1703, 1, 0, 0, 0, 1703, 1719, 3, 462, 231, 0, 1704, 1705, 5, 92, 
	0, 0, 1705, 1708, 7, 24, 0, 0, 1706, 1707, 5, 134, 0, 0, 1707, 1709, 5, 
	106, 0, 0, 1708, 1706, 1, 0, 0, 0, 1708, 1709, 1, 0, 0, 0, 1709, 1710, 
	1, 0, 0, 0, 1710, 1719, 3, 462, 231, 0, 1711, 1712, 5, 92, 0, 0, 1712, 
	1715, 7, 19, 0, 0, 1713, 1714, 5, 134, 0, 0, 1714, 1716, 5, 106, 0, 0, 
	1715, 1713, 1, 0, 0, 0, 1715, 1716, 1, 0, 0, 0, 1716, 1717, 1, 0, 0, 0, 
	1717, 1719, 3, 400, 200, 0, 1718, 1690, 1, 0, 0, 0, 1718, 1697, 1, 0, 0, 
	0, 1718, 1704, 1, 0, 0, 0, 1718, 1711, 1, 0, 0, 0, 1719, 167, 1, 0, 0, 
	0, 1720, 1721, 5, 98, 0, 0, 1721, 1722, 5, 297, 0, 0, 1722, 169, 1, 0, 
	0, 0, 1723, 1725, 7, 25, 0, 0, 1724, 1726, 5, 136, 0, 0, 1725, 1724, 1, 
	0, 0, 0, 1725, 1726, 1, 0, 0, 0, 1726, 1727, 1, 0, 0, 0, 1727, 1733, 3, 
	400, 200, 0, 1728, 1729, 5, 365, 0, 0, 1729, 1730, 3, 438, 219, 0, 1730, 
	1731, 5, 368, 0, 0, 1731, 1734, 1, 0, 0, 0, 1732, 1734, 3, 438, 219, 0, 
	1733, 1728, 1, 0, 0, 0, 1733, 1732, 1, 0, 0, 0, 1733, 1734, 1, 0, 0, 0, 
	1734, 1744, 1, 0, 0, 0, 1735, 1736, 5, 151, 0, 0, 1736, 1741, 5, 372, 0, 
	0, 1737, 1738, 5, 350, 0, 0, 1738, 1740, 5, 372, 0, 0, 1739, 1737, 1, 0, 
	0, 0, 1740, 1743, 1, 0, 0, 0, 1741, 1739, 1, 0, 0, 0, 1741, 1742, 1, 0, 
	0, 0, 1742, 1745, 1, 0, 0, 0, 1743, 1741, 1, 0, 0, 0, 1744, 1735, 1, 0, 
	0, 0, 1744, 1745, 1, 0, 0, 0, 1745, 1747, 1, 0, 0, 0, 1746, 1748, 3, 292, 
	146, 0, 1747, 1746, 1, 0, 0, 0, 1747, 1748, 1, 0, 0, 0, 1748, 171, 1, 0, 
	0, 0, 1749, 1753, 3, 174, 87, 0, 1750, 1753, 3, 176, 88, 0, 1751, 1753, 
	3, 178, 89, 0, 1752, 1749, 1, 0, 0, 0, 1752, 1750, 1, 0, 0, 0, 1752, 1751, 
	1, 0, 0, 0, 1753, 173, 1, 0, 0, 0, 1754, 1755, 5, 134, 0, 0, 1755, 1756, 
	3, 384, 192, 0, 1756, 1757, 5, 290, 0, 0, 1757, 1761, 3, 2, 1, 0, 1758, 
	1760, 3, 180, 90, 0, 1759, 1758, 1, 0, 0, 0, 1760, 1763, 1, 0, 0, 0, 1761, 
	1759, 1, 0, 0, 0, 1761, 1762, 1, 0, 0, 0, 1762, 1765, 1, 0, 0, 0, 1763, 
	1761, 1, 0, 0, 0, 1764, 1766, 3, 182, 91, 0, 1765, 1764, 1, 0, 0, 0, 1765, 
	1766, 1, 0, 0, 0, 1766, 1767, 1, 0, 0, 0, 1767, 1768, 5, 98, 0, 0, 1768, 
	1769, 5, 134, 0, 0, 1769, 175, 1, 0, 0, 0, 1770, 1771, 5, 134, 0, 0, 1771, 
	1772, 3, 384, 192, 0, 1772, 1775, 3, 6, 3, 0, 1773, 1774, 5, 94, 0, 0, 
	1774, 1776, 3, 6, 3, 0, 1775, 1773, 1, 0, 0, 0, 1775, 1776, 1, 0, 0, 0, 
	1776, 177, 1, 0, 0, 0, 1777, 1778, 5, 353, 0, 0, 1778, 1779, 5, 134, 0, 
	0, 1779, 1780, 3, 384, 192, 0, 1780, 1781, 5, 290, 0, 0, 1781, 1782, 3, 
	6, 3, 0, 1782, 179, 1, 0, 0, 0, 1783, 1784, 7, 26, 0, 0, 1784, 1785, 3, 
	384, 192, 0, 1785, 1786, 5, 290, 0, 0, 1786, 1787, 3, 2, 1, 0, 1787, 181, 
	1, 0, 0, 0, 1788, 1789, 5, 94, 0, 0, 1789, 1790, 3, 2, 1, 0, 1790, 183, 
	1, 0, 0, 0, 1791, 1794, 5, 138, 0, 0, 1792, 1795, 3, 456, 228, 0, 1793, 
	1795, 3, 400, 200, 0, 1794, 1792, 1, 0, 0, 0, 1794, 1793, 1, 0, 0, 0, 1795, 
	185, 1, 0, 0, 0, 1796, 1803, 5, 143, 0, 0, 1797, 1798, 5, 210, 0, 0, 1798, 
	1804, 5, 285, 0, 0, 1799, 1801, 5, 151, 0, 0, 1800, 1802, 5, 285, 0, 0, 
	1801, 1800, 1, 0, 0, 0, 1801, 1802, 1, 0, 0, 0, 1802, 1804, 1, 0, 0, 0, 
	1803, 1797, 1, 0, 0, 0, 1803, 1799, 1, 0, 0, 0, 1804, 1805, 1, 0, 0, 0, 
	1805, 1807, 3, 346, 173, 0, 1806, 1808, 3, 188, 94, 0, 1807, 1806, 1, 0, 
	0, 0, 1807, 1808, 1, 0, 0, 0, 1808, 1811, 1, 0, 0, 0, 1809, 1812, 3, 294, 
	147, 0, 1810, 1812, 3, 190, 95, 0, 1811, 1809, 1, 0, 0, 0, 1811, 1810, 
	1, 0, 0, 0, 1812, 187, 1, 0, 0, 0, 1813, 1814, 5, 365, 0, 0, 1814, 1819, 
	3, 464, 232, 0, 1815, 1816, 5, 350, 0, 0, 1816, 1818, 3, 464, 232, 0, 1817, 
	1815, 1, 0, 0, 0, 1818, 1821, 1, 0, 0, 0, 1819, 1817, 1, 0, 0, 0, 1819, 
	1820, 1, 0, 0, 0, 1820, 1822, 1, 0, 0, 0, 1821, 1819, 1, 0, 0, 0, 1822, 
	1823, 5, 368, 0, 0, 1823, 189, 1, 0, 0, 0, 1824, 1825, 5, 308, 0, 0, 1825, 
	1830, 3, 192, 96, 0, 1826, 1827, 5, 350, 0, 0, 1827, 1829, 3, 192, 96, 
	0, 1828, 1826, 1, 0, 0, 0, 1829, 1832, 1, 0, 0, 0, 1830, 1828, 1, 0, 0, 
	0, 1830, 1831, 1, 0, 0, 0, 1831, 191, 1, 0, 0, 0, 1832, 1830, 1, 0, 0, 
	0, 1833, 1834, 5, 365, 0, 0, 1834, 1839, 3, 400, 200, 0, 1835, 1836, 5, 
	350, 0, 0, 1836, 1838, 3, 400, 200, 0, 1837, 1835, 1, 0, 0, 0, 1838, 1841, 
	1, 0, 0, 0, 1839, 1837, 1, 0, 0, 0, 1839, 1840, 1, 0, 0, 0, 1840, 1842, 
	1, 0, 0, 0, 1841, 1839, 1, 0, 0, 0, 1842, 1843, 5, 368, 0, 0, 1843, 193, 
	1, 0, 0, 0, 1844, 1845, 5, 143, 0, 0, 1845, 1847, 5, 210, 0, 0, 1846, 1848, 
	5, 166, 0, 0, 1847, 1846, 1, 0, 0, 0, 1847, 1848, 1, 0, 0, 0, 1848, 1849, 
	1, 0, 0, 0, 1849, 1850, 5, 87, 0, 0, 1850, 1851, 3, 444, 222, 0, 1851, 
	1852, 3, 442, 221, 0, 1852, 195, 1, 0, 0, 0, 1853, 1855, 5, 107, 0, 0, 
	1854, 1856, 5, 372, 0, 0, 1855, 1854, 1, 0, 0, 0, 1855, 1856, 1, 0, 0, 
	0, 1856, 1859, 1, 0, 0, 0, 1857, 1858, 5, 314, 0, 0, 1858, 1860, 3, 384, 
	192, 0, 1859, 1857, 1, 0, 0, 0, 1859, 1860, 1, 0, 0, 0, 1860, 197, 1, 0, 
	0, 0, 1861, 1862, 5, 122, 0, 0, 1862, 1863, 5, 85, 0, 0, 1863, 1864, 3, 
	200, 100, 0, 1864, 199, 1, 0, 0, 0, 1865, 1868, 3, 202, 101, 0, 1866, 1868, 
	3, 204, 102, 0, 1867, 1865, 1, 0, 0, 0, 1867, 1866, 1, 0, 0, 0, 1868, 201, 
	1, 0, 0, 0, 1869, 1870, 5, 104, 0, 0, 1870, 1871, 5, 375, 0, 0, 1871, 1872, 
	3, 464, 232, 0, 1872, 1873, 5, 355, 0, 0, 1873, 1874, 5, 180, 0, 0, 1874, 
	203, 1, 0, 0, 0, 1875, 1876, 3, 464, 232, 0, 1876, 1877, 5, 355, 0, 0, 
	1877, 1878, 5, 246, 0, 0, 1878, 205, 1, 0, 0, 0, 1879, 1880, 5, 125, 0, 
	0, 1880, 1885, 3, 208, 104, 0, 1881, 1882, 5, 350, 0, 0, 1882, 1884, 3, 
	208, 104, 0, 1883, 1881, 1, 0, 0, 0, 1884, 1887, 1, 0, 0, 0, 1885, 1883, 
	1, 0, 0, 0, 1885, 1886, 1, 0, 0, 0, 1886, 1888, 1, 0, 0, 0, 1887, 1885, 
	1, 0, 0, 0, 1888, 1889, 5, 295, 0, 0, 1889, 1890, 5, 241, 0, 0, 1890, 1891, 
	3, 464, 232, 0, 1891, 207, 1, 0, 0, 0, 1892, 1893, 5, 103, 0, 0, 1893, 
	1894, 5, 202, 0, 0, 1894, 1895, 5, 222, 0, 0, 1895, 1896, 3, 464, 232, 
	0, 1896, 209, 1, 0, 0, 0, 1897, 1899, 5, 161, 0, 0, 1898, 1900, 5, 372, 
	0, 0, 1899, 1898, 1, 0, 0, 0, 1899, 1900, 1, 0, 0, 0, 1900, 211, 1, 0, 
	0, 0, 1901, 1902, 5, 175, 0, 0, 1902, 1903, 5, 199, 0, 0, 1903, 1906, 3, 
	462, 231, 0, 1904, 1905, 5, 295, 0, 0, 1905, 1907, 3, 462, 231, 0, 1906, 
	1904, 1, 0, 0, 0, 1906, 1907, 1, 0, 0, 0, 1907, 1910, 1, 0, 0, 0, 1908, 
	1909, 5, 16, 0, 0, 1909, 1911, 3, 462, 231, 0, 1910, 1908, 1, 0, 0, 0, 
	1910, 1911, 1, 0, 0, 0, 1911, 213, 1, 0, 0, 0, 1912, 1913, 5, 204, 0, 0, 
	1913, 1919, 3, 462, 231, 0, 1914, 1917, 5, 115, 0, 0, 1915, 1918, 3, 294, 
	147, 0, 1916, 1918, 3, 400, 200, 0, 1917, 1915, 1, 0, 0, 0, 1917, 1916, 
	1, 0, 0, 0, 1918, 1920, 1, 0, 0, 0, 1919, 1914, 1, 0, 0, 0, 1919, 1920, 
	1, 0, 0, 0, 1920, 215, 1, 0, 0, 0, 1921, 1923, 5, 110, 0, 0, 1922, 1924, 
	5, 119, 0, 0, 1923, 1922, 1, 0, 0, 0, 1923, 1924, 1, 0, 0, 0, 1924, 1925, 
	1, 0, 0, 0, 1925, 1927, 3, 462, 231, 0, 1926, 1928, 3, 326, 163, 0, 1927, 
	1926, 1, 0, 0, 0, 1927, 1928, 1, 0, 0, 0, 1928, 1929, 1, 0, 0, 0, 1929, 
	1930, 5, 151, 0, 0, 1930, 1935, 3, 462, 231, 0, 1931, 1932, 5, 350, 0, 
	0, 1932, 1934, 3, 462, 231, 0, 1933, 1931, 1, 0, 0, 0, 1934, 1937, 1, 0, 
	0, 0, 1935, 1933, 1, 0, 0, 0, 1935, 1936, 1, 0, 0, 0, 1936, 1939, 1, 0, 
	0, 0, 1937, 1935, 1, 0, 0, 0, 1938, 1940, 3, 218, 109, 0, 1939, 1938, 1, 
	0, 0, 0, 1939, 1940, 1, 0, 0, 0, 1940, 217, 1, 0, 0, 0, 1941, 1942, 5, 
	164, 0, 0, 1942, 1943, 3, 400, 200, 0, 1943, 219, 1, 0, 0, 0, 1944, 1945, 
	5, 45, 0, 0, 1945, 1946, 7, 27, 0, 0, 1946, 1947, 5, 202, 0, 0, 1947, 1949, 
	3, 346, 173, 0, 1948, 1950, 3, 222, 111, 0, 1949, 1948, 1, 0, 0, 0, 1949, 
	1950, 1, 0, 0, 0, 1950, 221, 1, 0, 0, 0, 1951, 1952, 5, 47, 0, 0, 1952, 
	1953, 5, 365, 0, 0, 1953, 1958, 3, 464, 232, 0, 1954, 1955, 5, 350, 0, 
	0, 1955, 1957, 3, 464, 232, 0, 1956, 1954, 1, 0, 0, 0, 1957, 1960, 1, 0, 
	0, 0, 1958, 1956, 1, 0, 0, 0, 1958, 1959, 1, 0, 0, 0, 1959, 1961, 1, 0, 
	0, 0, 1960, 1958, 1, 0, 0, 0, 1961, 1962, 5, 368, 0, 0, 1962, 223, 1, 0, 
	0, 0, 1963, 1964, 5, 42, 0, 0, 1964, 1965, 5, 372, 0, 0, 1965, 225, 1, 
	0, 0, 0, 1966, 1967, 5, 44, 0, 0, 1967, 1968, 7, 28, 0, 0, 1968, 1969, 
	3, 228, 114, 0, 1969, 1970, 5, 350, 0, 0, 1970, 1971, 3, 228, 114, 0, 1971, 
	227, 1, 0, 0, 0, 1972, 1974, 3, 346, 173, 0, 1973, 1975, 3, 348, 174, 0, 
	1974, 1973, 1, 0, 0, 0, 1974, 1975, 1, 0, 0, 0, 1975, 1981, 1, 0, 0, 0, 
	1976, 1977, 5, 365, 0, 0, 1977, 1978, 3, 294, 147, 0, 1978, 1979, 5, 368, 
	0, 0, 1979, 1981, 1, 0, 0, 0, 1980, 1972, 1, 0, 0, 0, 1980, 1976, 1, 0, 
	0, 0, 1981, 1984, 1, 0, 0, 0, 1982, 1983, 5, 16, 0, 0, 1983, 1985, 3, 464, 
	232, 0, 1984, 1982, 1, 0, 0, 0, 1984, 1985, 1, 0, 0, 0, 1985, 229, 1, 0, 
	0, 0, 1986, 1987, 5, 56, 0, 0, 1987, 1988, 5, 119, 0, 0, 1988, 1989, 5, 
	166, 0, 0, 1989, 1994, 3, 234, 117, 0, 1990, 1991, 5, 350, 0, 0, 1991, 
	1993, 3, 234, 117, 0, 1992, 1990, 1, 0, 0, 0, 1993, 1996, 1, 0, 0, 0, 1994, 
	1992, 1, 0, 0, 0, 1994, 1995, 1, 0, 0, 0, 1995, 1997, 1, 0, 0, 0, 1996, 
	1994, 1, 0, 0, 0, 1997, 1998, 5, 295, 0, 0, 1998, 2002, 3, 236, 118, 0, 
	1999, 2001, 3, 240, 120, 0, 2000, 1999, 1, 0, 0, 0, 2001, 2004, 1, 0, 0, 
	0, 2002, 2000, 1, 0, 0, 0, 2002, 2003, 1, 0, 0, 0, 2003, 231, 1, 0, 0, 
	0, 2004, 2002, 1, 0, 0, 0, 2005, 2011, 5, 56, 0, 0, 2006, 2012, 3, 346, 
	173, 0, 2007, 2008, 5, 365, 0, 0, 2008, 2009, 3, 294, 147, 0, 2009, 2010, 
	5, 368, 0, 0, 2010, 2012, 1, 0, 0, 0, 2011, 2006, 1, 0, 0, 0, 2011, 2007, 
	1, 0, 0, 0, 2012, 2013, 1, 0, 0, 0, 2013, 2015, 5, 295, 0, 0, 2014, 2016, 
	5, 130, 0, 0, 2015, 2014, 1, 0, 0, 0, 2015, 2016, 1, 0, 0, 0, 2016, 2017, 
	1, 0, 0, 0, 2017, 2021, 3, 236, 118, 0, 2018, 2020, 3, 238, 119, 0, 2019, 
	2018, 1, 0, 0, 0, 2020, 2023, 1, 0, 0, 0, 2021, 2019, 1, 0, 0, 0, 2021, 
	2022, 1, 0, 0, 0, 2022, 233, 1, 0, 0, 0, 2023, 2021, 1, 0, 0, 0, 2024, 
	2027, 3, 456, 228, 0, 2025, 2027, 3, 400, 200, 0, 2026, 2024, 1, 0, 0, 
	0, 2026, 2025, 1, 0, 0, 0, 2027, 235, 1, 0, 0, 0, 2028, 2031, 3, 456, 228, 
	0, 2029, 2031, 3, 400, 200, 0, 2030, 2028, 1, 0, 0, 0, 2030, 2029, 1, 0, 
	0, 0, 2031, 237, 1, 0, 0, 0, 2032, 2033, 5, 16, 0, 0, 2033, 2041, 3, 464, 
	232, 0, 2034, 2035, 5, 19, 0, 0, 2035, 2041, 3, 400, 200, 0, 2036, 2037, 
	5, 82, 0, 0, 2037, 2041, 3, 400, 200, 0, 2038, 2039, 5, 271, 0, 0, 2039, 
	2041, 3, 464, 232, 0, 2040, 2032, 1, 0, 0, 0, 2040, 2034, 1, 0, 0, 0, 2040, 
	2036, 1, 0, 0, 0, 2040, 2038, 1, 0, 0, 0, 2041, 239, 1, 0, 0, 0, 2042, 
	2043, 7, 29, 0, 0, 2043, 241, 1, 0, 0, 0, 2044, 2046, 5, 50, 0, 0, 2045, 
	2047, 5, 319, 0, 0, 2046, 2045, 1, 0, 0, 0, 2046, 2047, 1, 0, 0, 0, 2047, 
	243, 1, 0, 0, 0, 2048, 2050, 5, 59, 0, 0, 2049, 2051, 5, 302, 0, 0, 2050, 
	2049, 1, 0, 0, 0, 2050, 2051, 1, 0, 0, 0, 2051, 2052, 1, 0, 0, 0, 2052, 
	2053, 5, 139, 0, 0, 2053, 2054, 3, 464, 232, 0, 2054, 2055, 5, 202, 0, 
	0, 2055, 2056, 3, 346, 173, 0, 2056, 2057, 5, 365, 0, 0, 2057, 2062, 3, 
	246, 123, 0, 2058, 2059, 5, 350, 0, 0, 2059, 2061, 3, 246, 123, 0, 2060, 
	2058, 1, 0, 0, 0, 2061, 2064, 1, 0, 0, 0, 2062, 2060, 1, 0, 0, 0, 2062, 
	2063, 1, 0, 0, 0, 2063, 2065, 1, 0, 0, 0, 2064, 2062, 1, 0, 0, 0, 2065, 
	2066, 5, 368, 0, 0, 2066, 245, 1, 0, 0, 0, 2067, 2069, 3, 464, 232, 0, 
	2068, 2070, 7, 8, 0, 0, 2069, 2068, 1, 0, 0, 0, 2069, 2070, 1, 0, 0, 0, 
	2070, 247, 1, 0, 0, 0, 2071, 2072, 3, 250, 125, 0, 2072, 249, 1, 0, 0, 
	0, 2073, 2074, 5, 317, 0, 0, 2074, 2075, 5, 365, 0, 0, 2075, 2076, 3, 464, 
	232, 0, 2076, 2077, 5, 355, 0, 0, 2077, 2085, 3, 464, 232, 0, 2078, 2079, 
	5, 350, 0, 0, 2079, 2080, 3, 464, 232, 0, 2080, 2081, 5, 355, 0, 0, 2081, 
	2082, 3, 464, 232, 0, 2082, 2084, 1, 0, 0, 0, 2083, 2078, 1, 0, 0, 0, 2084, 
	2087, 1, 0, 0, 0, 2085, 2083, 1, 0, 0, 0, 2085, 2086, 1, 0, 0, 0, 2086, 
	2088, 1, 0, 0, 0, 2087, 2085, 1, 0, 0, 0, 2088, 2092, 5, 368, 0, 0, 2089, 
	2091, 3, 116, 58, 0, 2090, 2089, 1, 0, 0, 0, 2091, 2094, 1, 0, 0, 0, 2092, 
	2090, 1, 0, 0, 0, 2092, 2093, 1, 0, 0, 0, 2093, 251, 1, 0, 0, 0, 2094, 
	2092, 1, 0, 0, 0, 2095, 2096, 5, 220, 0, 0, 2096, 2103, 3, 400, 200, 0, 
	2097, 2098, 5, 220, 0, 0, 2098, 2099, 5, 365, 0, 0, 2099, 2100, 3, 400, 
	200, 0, 2100, 2101, 5, 368, 0, 0, 2101, 2103, 1, 0, 0, 0, 2102, 2095, 1, 
	0, 0, 0, 2102, 2097, 1, 0, 0, 0, 2103, 253, 1, 0, 0, 0, 2104, 2106, 5, 
	353, 0, 0, 2105, 2104, 1, 0, 0, 0, 2105, 2106, 1, 0, 0, 0, 2106, 2107, 
	1, 0, 0, 0, 2107, 2109, 5, 225, 0, 0, 2108, 2110, 3, 400, 200, 0, 2109, 
	2108, 1, 0, 0, 0, 2109, 2110, 1, 0, 0, 0, 2110, 255, 1, 0, 0, 0, 2111, 
	2112, 5, 227, 0, 0, 2112, 257, 1, 0, 0, 0, 2113, 2125, 5, 232, 0, 0, 2114, 
	2116, 5, 272, 0, 0, 2115, 2117, 5, 307, 0, 0, 2116, 2115, 1, 0, 0, 0, 2116, 
	2117, 1, 0, 0, 0, 2117, 2118, 1, 0, 0, 0, 2118, 2123, 3, 400, 200, 0, 2119, 
	2120, 5, 258, 0, 0, 2120, 2121, 5, 180, 0, 0, 2121, 2122, 5, 355, 0, 0, 
	2122, 2124, 3, 400, 200, 0, 2123, 2119, 1, 0, 0, 0, 2123, 2124, 1, 0, 0, 
	0, 2124, 2126, 1, 0, 0, 0, 2125, 2114, 1, 0, 0, 0, 2125, 2126, 1, 0, 0, 
	0, 2126, 259, 1, 0, 0, 0, 2127, 2129, 5, 236, 0, 0, 2128, 2130, 3, 400, 
	200, 0, 2129, 2128, 1, 0, 0, 0, 2129, 2130, 1, 0, 0, 0, 2130, 261, 1, 0, 
	0, 0, 2131, 2133, 5, 242, 0, 0, 2132, 2134, 5, 319, 0, 0, 2133, 2132, 1, 
	0, 0, 0, 2133, 2134, 1, 0, 0, 0, 2134, 263, 1, 0, 0, 0, 2135, 2139, 3, 
	266, 133, 0, 2136, 2139, 3, 268, 134, 0, 2137, 2139, 3, 270, 135, 0, 2138, 
	2135, 1, 0, 0, 0, 2138, 2136, 1, 0, 0, 0, 2138, 2137, 1, 0, 0, 0, 2139, 
	265, 1, 0, 0, 0, 2140, 2142, 5, 63, 0, 0, 2141, 2140, 1, 0, 0, 0, 2141, 
	2142, 1, 0, 0, 0, 2142, 2143, 1, 0, 0, 0, 2143, 2146, 5, 251, 0, 0, 2144, 
	2146, 5, 64, 0, 0, 2145, 2141, 1, 0, 0, 0, 2145, 2144, 1, 0, 0, 0, 2146, 
	2148, 1, 0, 0, 0, 2147, 2149, 5, 355, 0, 0, 2148, 2147, 1, 0, 0, 0, 2148, 
	2149, 1, 0, 0, 0, 2149, 2150, 1, 0, 0, 0, 2150, 2151, 3, 400, 200, 0, 2151, 
	267, 1, 0, 0, 0, 2152, 2153, 7, 30, 0, 0, 2153, 2154, 7, 31, 0, 0, 2154, 
	269, 1, 0, 0, 0, 2155, 2156, 5, 224, 0, 0, 2156, 2159, 5, 355, 0, 0, 2157, 
	2160, 3, 400, 200, 0, 2158, 2160, 5, 193, 0, 0, 2159, 2157, 1, 0, 0, 0, 
	2159, 2158, 1, 0, 0, 0, 2160, 2162, 1, 0, 0, 0, 2161, 2163, 5, 303, 0, 
	0, 2162, 2161, 1, 0, 0, 0, 2162, 2163, 1, 0, 0, 0, 2163, 2164, 1, 0, 0, 
	0, 2164, 2165, 5, 115, 0, 0, 2165, 2166, 7, 32, 0, 0, 2166, 271, 1, 0, 
	0, 0, 2167, 2168, 5, 263, 0, 0, 2168, 2169, 3, 462, 231, 0, 2169, 273, 
	1, 0, 0, 0, 2170, 2173, 5, 283, 0, 0, 2171, 2172, 5, 296, 0, 0, 2172, 2174, 
	3, 400, 200, 0, 2173, 2171, 1, 0, 0, 0, 2173, 2174, 1, 0, 0, 0, 2174, 2175, 
	1, 0, 0, 0, 2175, 2185, 5, 115, 0, 0, 2176, 2186, 3, 294, 147, 0, 2177, 
	2179, 3, 346, 173, 0, 2178, 2180, 3, 348, 174, 0, 2179, 2178, 1, 0, 0, 
	0, 2179, 2180, 1, 0, 0, 0, 2180, 2183, 1, 0, 0, 0, 2181, 2182, 5, 164, 
	0, 0, 2182, 2184, 3, 400, 200, 0, 2183, 2181, 1, 0, 0, 0, 2183, 2184, 1, 
	0, 0, 0, 2184, 2186, 1, 0, 0, 0, 2185, 2176, 1, 0, 0, 0, 2185, 2177, 1, 
	0, 0, 0, 2186, 275, 1, 0, 0, 0, 2187, 2189, 5, 299, 0, 0, 2188, 2190, 5, 
	285, 0, 0, 2189, 2188, 1, 0, 0, 0, 2189, 2190, 1, 0, 0, 0, 2190, 2191, 
	1, 0, 0, 0, 2191, 2192, 3, 346, 173, 0, 2192, 277, 1, 0, 0, 0, 2193, 2194, 
	5, 305, 0, 0, 2194, 2195, 3, 400, 200, 0, 2195, 279, 1, 0, 0, 0, 2196, 
	2198, 5, 308, 0, 0, 2197, 2199, 5, 365, 0, 0, 2198, 2197, 1, 0, 0, 0, 2198, 
	2199, 1, 0, 0, 0, 2199, 2200, 1, 0, 0, 0, 2200, 2205, 3, 400, 200, 0, 2201, 
	2202, 5, 350, 0, 0, 2202, 2204, 3, 400, 200, 0, 2203, 2201, 1, 0, 0, 0, 
	2204, 2207, 1, 0, 0, 0, 2205, 2203, 1, 0, 0, 0, 2205, 2206, 1, 0, 0, 0, 
	2206, 2209, 1, 0, 0, 0, 2207, 2205, 1, 0, 0, 0, 2208, 2210, 5, 368, 0, 
	0, 2209, 2208, 1, 0, 0, 0, 2209, 2210, 1, 0, 0, 0, 2210, 2211, 1, 0, 0, 
	0, 2211, 2213, 5, 151, 0, 0, 2212, 2214, 5, 365, 0, 0, 2213, 2212, 1, 0, 
	0, 0, 2213, 2214, 1, 0, 0, 0, 2214, 2215, 1, 0, 0, 0, 2215, 2220, 3, 462, 
	231, 0, 2216, 2217, 5, 350, 0, 0, 2217, 2219, 3, 462, 231, 0, 2218, 2216, 
	1, 0, 0, 0, 2219, 2222, 1, 0, 0, 0, 2220, 2218, 1, 0, 0, 0, 2220, 2221, 
	1, 0, 0, 0, 2221, 2224, 1, 0, 0, 0, 2222, 2220, 1, 0, 0, 0, 2223, 2225, 
	5, 368, 0, 0, 2224, 2223, 1, 0, 0, 0, 2224, 2225, 1, 0, 0, 0, 2225, 281, 
	1, 0, 0, 0, 2226, 2227, 5, 316, 0, 0, 2227, 2228, 3, 384, 192, 0, 2228, 
	2229, 7, 33, 0, 0, 2229, 2230, 3, 2, 1, 0, 2230, 2232, 5, 98, 0, 0, 2231, 
	2233, 7, 34, 0, 0, 2232, 2231, 1, 0, 0, 0, 2232, 2233, 1, 0, 0, 0, 2233, 
	283, 1, 0, 0, 0, 2234, 2235, 5, 174, 0, 0, 2235, 2236, 3, 2, 1, 0, 2236, 
	2237, 5, 98, 0, 0, 2237, 2238, 5, 174, 0, 0, 2238, 285, 1, 0, 0, 0, 2239, 
	2240, 5, 115, 0, 0, 2240, 2241, 5, 372, 0, 0, 2241, 2243, 5, 137, 0, 0, 
	2242, 2244, 5, 365, 0, 0, 2243, 2242, 1, 0, 0, 0, 2243, 2244, 1, 0, 0, 
	0, 2244, 2245, 1, 0, 0, 0, 2245, 2247, 3, 294, 147, 0, 2246, 2248, 5, 368, 
	0, 0, 2247, 2246, 1, 0, 0, 0, 2247, 2248, 1, 0, 0, 0, 2248, 2249, 1, 0, 
	0, 0, 2249, 2250, 5, 174, 0, 0, 2250, 2251, 3, 2, 1, 0, 2251, 2252, 5, 
	98, 0, 0, 2252, 2253, 5, 174, 0, 0, 2253, 287, 1, 0, 0, 0, 2254, 2255, 
	5, 115, 0, 0, 2255, 2256, 5, 372, 0, 0, 2256, 2258, 5, 137, 0, 0, 2257, 
	2259, 5, 238, 0, 0, 2258, 2257, 1, 0, 0, 0, 2258, 2259, 1, 0, 0, 0, 2259, 
	2260, 1, 0, 0, 0, 2260, 2261, 3, 400, 200, 0, 2261, 2262, 5, 354, 0, 0, 
	2262, 2265, 3, 400, 200, 0, 2263, 2264, 7, 35, 0, 0, 2264, 2266, 3, 400, 
	200, 0, 2265, 2263, 1, 0, 0, 0, 2265, 2266, 1, 0, 0, 0, 2266, 2267, 1, 
	0, 0, 0, 2267, 2268, 5, 174, 0, 0, 2268, 2269, 3, 2, 1, 0, 2269, 2270, 
	5, 98, 0, 0, 2270, 2271, 5, 174, 0, 0, 2271, 289, 1, 0, 0, 0, 2272, 2279, 
	5, 381, 0, 0, 2273, 2274, 5, 361, 0, 0, 2274, 2275, 5, 361, 0, 0, 2275, 
	2276, 5, 372, 0, 0, 2276, 2277, 5, 359, 0, 0, 2277, 2279, 5, 359, 0, 0, 
	2278, 2272, 1, 0, 0, 0, 2278, 2273, 1, 0, 0, 0, 2279, 291, 1, 0, 0, 0, 
	2280, 2281, 5, 306, 0, 0, 2281, 2286, 3, 400, 200, 0, 2282, 2283, 5, 350, 
	0, 0, 2283, 2285, 3, 400, 200, 0, 2284, 2282, 1, 0, 0, 0, 2285, 2288, 1, 
	0, 0, 0, 2286, 2284, 1, 0, 0, 0, 2286, 2287, 1, 0, 0, 0, 2287, 293, 1, 
	0, 0, 0, 2288, 2286, 1, 0, 0, 0, 2289, 2291, 3, 296, 148, 0, 2290, 2289, 
	1, 0, 0, 0, 2290, 2291, 1, 0, 0, 0, 2291, 2292, 1, 0, 0, 0, 2292, 2293, 
	3, 302, 151, 0, 2293, 295, 1, 0, 0, 0, 2294, 2295, 5, 317, 0, 0, 2295, 
	2300, 3, 298, 149, 0, 2296, 2297, 5, 350, 0, 0, 2297, 2299, 3, 298, 149, 
	0, 2298, 2296, 1, 0, 0, 0, 2299, 2302, 1, 0, 0, 0, 2300, 2298, 1, 0, 0, 
	0, 2300, 2301, 1, 0, 0, 0, 2301, 297, 1, 0, 0, 0, 2302, 2300, 1, 0, 0, 
	0, 2303, 2305, 3, 464, 232, 0, 2304, 2306, 3, 300, 150, 0, 2305, 2304, 
	1, 0, 0, 0, 2305, 2306, 1, 0, 0, 0, 2306, 2307, 1, 0, 0, 0, 2307, 2308, 
	5, 13, 0, 0, 2308, 2309, 5, 365, 0, 0, 2309, 2310, 3, 302, 151, 0, 2310, 
	2311, 5, 368, 0, 0, 2311, 299, 1, 0, 0, 0, 2312, 2313, 5, 365, 0, 0, 2313, 
	2318, 3, 464, 232, 0, 2314, 2315, 5, 350, 0, 0, 2315, 2317, 3, 464, 232, 
	0, 2316, 2314, 1, 0, 0, 0, 2317, 2320, 1, 0, 0, 0, 2318, 2316, 1, 0, 0, 
	0, 2318, 2319, 1, 0, 0, 0, 2319, 2321, 1, 0, 0, 0, 2320, 2318, 1, 0, 0, 
	0, 2321, 2322, 5, 368, 0, 0, 2322, 301, 1, 0, 0, 0, 2323, 2329, 3, 304, 
	152, 0, 2324, 2325, 3, 306, 153, 0, 2325, 2326, 3, 304, 152, 0, 2326, 2328, 
	1, 0, 0, 0, 2327, 2324, 1, 0, 0, 0, 2328, 2331, 1, 0, 0, 0, 2329, 2327, 
	1, 0, 0, 0, 2329, 2330, 1, 0, 0, 0, 2330, 303, 1, 0, 0, 0, 2331, 2329, 
	1, 0, 0, 0, 2332, 2338, 3, 308, 154, 0, 2333, 2334, 5, 365, 0, 0, 2334, 
	2335, 3, 302, 151, 0, 2335, 2336, 5, 368, 0, 0, 2336, 2338, 1, 0, 0, 0, 
	2337, 2332, 1, 0, 0, 0, 2337, 2333, 1, 0, 0, 0, 2338, 305, 1, 0, 0, 0, 
	2339, 2341, 5, 301, 0, 0, 2340, 2342, 5, 7, 0, 0, 2341, 2340, 1, 0, 0, 
	0, 2341, 2342, 1, 0, 0, 0, 2342, 2352, 1, 0, 0, 0, 2343, 2345, 5, 101, 
	0, 0, 2344, 2346, 5, 7, 0, 0, 2345, 2344, 1, 0, 0, 0, 2345, 2346, 1, 0, 
	0, 0, 2346, 2352, 1, 0, 0, 0, 2347, 2349, 5, 149, 0, 0, 2348, 2350, 5, 
	7, 0, 0, 2349, 2348, 1, 0, 0, 0, 2349, 2350, 1, 0, 0, 0, 2350, 2352, 1, 
	0, 0, 0, 2351, 2339, 1, 0, 0, 0, 2351, 2343, 1, 0, 0, 0, 2351, 2347, 1, 
	0, 0, 0, 2352, 307, 1, 0, 0, 0, 2353, 2354, 7, 36, 0, 0, 2354, 2356, 3, 
	310, 155, 0, 2355, 2357, 3, 324, 162, 0, 2356, 2355, 1, 0, 0, 0, 2356, 
	2357, 1, 0, 0, 0, 2357, 2359, 1, 0, 0, 0, 2358, 2360, 3, 328, 164, 0, 2359, 
	2358, 1, 0, 0, 0, 2359, 2360, 1, 0, 0, 0, 2360, 2362, 1, 0, 0, 0, 2361, 
	2363, 3, 348, 174, 0, 2362, 2361, 1, 0, 0, 0, 2362, 2363, 1, 0, 0, 0, 2363, 
	2365, 1, 0, 0, 0, 2364, 2366, 3, 350, 175, 0, 2365, 2364, 1, 0, 0, 0, 2365, 
	2366, 1, 0, 0, 0, 2366, 2369, 1, 0, 0, 0, 2367, 2370, 3, 352, 176, 0, 2368, 
	2370, 3, 354, 177, 0, 2369, 2367, 1, 0, 0, 0, 2369, 2368, 1, 0, 0, 0, 2369, 
	2370, 1, 0, 0, 0, 2370, 2372, 1, 0, 0, 0, 2371, 2373, 3, 356, 178, 0, 2372, 
	2371, 1, 0, 0, 0, 2372, 2373, 1, 0, 0, 0, 2373, 2375, 1, 0, 0, 0, 2374, 
	2376, 3, 358, 179, 0, 2375, 2374, 1, 0, 0, 0, 2375, 2376, 1, 0, 0, 0, 2376, 
	309, 1, 0, 0, 0, 2377, 2379, 3, 312, 156, 0, 2378, 2377, 1, 0, 0, 0, 2378, 
	2379, 1, 0, 0, 0, 2379, 2381, 1, 0, 0, 0, 2380, 2382, 3, 314, 157, 0, 2381, 
	2380, 1, 0, 0, 0, 2381, 2382, 1, 0, 0, 0, 2382, 2383, 1, 0, 0, 0, 2383, 
	2388, 3, 316, 158, 0, 2384, 2385, 5, 350, 0, 0, 2385, 2387, 3, 316, 158, 
	0, 2386, 2384, 1, 0, 0, 0, 2387, 2390, 1, 0, 0, 0, 2388, 2386, 1, 0, 0, 
	0, 2388, 2389, 1, 0, 0, 0, 2389, 311, 1, 0, 0, 0, 2390, 2388, 1, 0, 0, 
	0, 2391, 2392, 7, 37, 0, 0, 2392, 313, 1, 0, 0, 0, 2393, 2394, 5, 296, 
	0, 0, 2394, 2395, 3, 400, 200, 0, 2395, 315, 1, 0, 0, 0, 2396, 2397, 3, 
	464, 232, 0, 2397, 2398, 5, 355, 0, 0, 2398, 2400, 1, 0, 0, 0, 2399, 2396, 
	1, 0, 0, 0, 2399, 2400, 1, 0, 0, 0, 2400, 2401, 1, 0, 0, 0, 2401, 2403, 
	3, 400, 200, 0, 2402, 2404, 3, 318, 159, 0, 2403, 2402, 1, 0, 0, 0, 2403, 
	2404, 1, 0, 0, 0, 2404, 2407, 1, 0, 0, 0, 2405, 2407, 3, 320, 160, 0, 2406, 
	2399, 1, 0, 0, 0, 2406, 2405, 1, 0, 0, 0, 2407, 317, 1, 0, 0, 0, 2408, 
	2410, 4, 159, 3, 0, 2409, 2411, 5, 13, 0, 0, 2410, 2409, 1, 0, 0, 0, 2410, 
	2411, 1, 0, 0, 0, 2411, 2412, 1, 0, 0, 0, 2412, 2418, 3, 464, 232, 0, 2413, 
	2414, 5, 365, 0, 0, 2414, 2415, 5, 294, 0, 0, 2415, 2416, 5, 373, 0, 0, 
	2416, 2418, 5, 368, 0, 0, 2417, 2408, 1, 0, 0, 0, 2417, 2413, 1, 0, 0, 
	0, 2418, 319, 1, 0, 0, 0, 2419, 2420, 5, 372, 0, 0, 2420, 2422, 5, 353, 
	0, 0, 2421, 2419, 1, 0, 0, 0, 2421, 2422, 1, 0, 0, 0, 2422, 2423, 1, 0, 
	0, 0, 2423, 2424, 5, 363, 0, 0, 2424, 321, 1, 0, 0, 0, 2425, 2426, 3, 462, 
	231, 0, 2426, 2427, 5, 365, 0, 0, 2427, 2428, 5, 375, 0, 0, 2428, 2429, 
	5, 368, 0, 0, 2429, 323, 1, 0, 0, 0, 2430, 2432, 3, 326, 163, 0, 2431, 
	2430, 1, 0, 0, 0, 2431, 2432, 1, 0, 0, 0, 2432, 2433, 1, 0, 0, 0, 2433, 
	2436, 5, 151, 0, 0, 2434, 2437, 3, 322, 161, 0, 2435, 2437, 3, 462, 231, 
	0, 2436, 2434, 1, 0, 0, 0, 2436, 2435, 1, 0, 0, 0, 2437, 2445, 1, 0, 0, 
	0, 2438, 2441, 5, 350, 0, 0, 2439, 2442, 3, 322, 161, 0, 2440, 2442, 3, 
	462, 231, 0, 2441, 2439, 1, 0, 0, 0, 2441, 2440, 1, 0, 0, 0, 2442, 2444, 
	1, 0, 0, 0, 2443, 2438, 1, 0, 0, 0, 2444, 2447, 1, 0, 0, 0, 2445, 2443, 
	1, 0, 0, 0, 2445, 2446, 1, 0, 0, 0, 2446, 325, 1, 0, 0, 0, 2447, 2445, 
	1, 0, 0, 0, 2448, 2449, 5, 29, 0, 0, 2449, 2450, 5, 45, 0, 0, 2450, 327, 
	1, 0, 0, 0, 2451, 2452, 5, 119, 0, 0, 2452, 2456, 3, 330, 165, 0, 2453, 
	2455, 3, 336, 168, 0, 2454, 2453, 1, 0, 0, 0, 2455, 2458, 1, 0, 0, 0, 2456, 
	2454, 1, 0, 0, 0, 2456, 2457, 1, 0, 0, 0, 2457, 329, 1, 0, 0, 0, 2458, 
	2456, 1, 0, 0, 0, 2459, 2463, 3, 332, 166, 0, 2460, 2463, 3, 334, 167, 
	0, 2461, 2463, 3, 340, 170, 0, 2462, 2459, 1, 0, 0, 0, 2462, 2460, 1, 0, 
	0, 0, 2462, 2461, 1, 0, 0, 0, 2463, 331, 1, 0, 0, 0, 2464, 2466, 3, 346, 
	173, 0, 2465, 2467, 3, 344, 172, 0, 2466, 2465, 1, 0, 0, 0, 2466, 2467, 
	1, 0, 0, 0, 2467, 333, 1, 0, 0, 0, 2468, 2469, 5, 365, 0, 0, 2469, 2470, 
	3, 294, 147, 0, 2470, 2472, 5, 368, 0, 0, 2471, 2473, 3, 344, 172, 0, 2472, 
	2471, 1, 0, 0, 0, 2472, 2473, 1, 0, 0, 0, 2473, 335, 1, 0, 0, 0, 2474, 
	2475, 5, 350, 0, 0, 2475, 2482, 3, 330, 165, 0, 2476, 2477, 3, 338, 169, 
	0, 2477, 2478, 3, 330, 165, 0, 2478, 2479, 5, 202, 0, 0, 2479, 2480, 3, 
	384, 192, 0, 2480, 2482, 1, 0, 0, 0, 2481, 2474, 1, 0, 0, 0, 2481, 2476, 
	1, 0, 0, 0, 2482, 337, 1, 0, 0, 0, 2483, 2485, 5, 141, 0, 0, 2484, 2483, 
	1, 0, 0, 0, 2484, 2485, 1, 0, 0, 0, 2485, 2486, 1, 0, 0, 0, 2486, 2493, 
	5, 156, 0, 0, 2487, 2489, 7, 38, 0, 0, 2488, 2490, 5, 208, 0, 0, 2489, 
	2488, 1, 0, 0, 0, 2489, 2490, 1, 0, 0, 0, 2490, 2491, 1, 0, 0, 0, 2491, 
	2493, 5, 156, 0, 0, 2492, 2484, 1, 0, 0, 0, 2492, 2487, 1, 0, 0, 0, 2493, 
	339, 1, 0, 0, 0, 2494, 2495, 5, 285, 0, 0, 2495, 2496, 5, 365, 0, 0, 2496, 
	2497, 5, 308, 0, 0, 2497, 2502, 3, 342, 171, 0, 2498, 2499, 5, 350, 0, 
	0, 2499, 2501, 3, 342, 171, 0, 2500, 2498, 1, 0, 0, 0, 2501, 2504, 1, 0, 
	0, 0, 2502, 2500, 1, 0, 0, 0, 2502, 2503, 1, 0, 0, 0, 2503, 2505, 1, 0, 
	0, 0, 2504, 2502, 1, 0, 0, 0, 2505, 2507, 5, 368, 0, 0, 2506, 2508, 3, 
	344, 172, 0, 2507, 2506, 1, 0, 0, 0, 2507, 2508, 1, 0, 0, 0, 2508, 341, 
	1, 0, 0, 0, 2509, 2522, 3, 400, 200, 0, 2510, 2511, 5, 365, 0, 0, 2511, 
	2516, 3, 400, 200, 0, 2512, 2513, 5, 350, 0, 0, 2513, 2515, 3, 400, 200, 
	0, 2514, 2512, 1, 0, 0, 0, 2515, 2518, 1, 0, 0, 0, 2516, 2514, 1, 0, 0, 
	0, 2516, 2517, 1, 0, 0, 0, 2517, 2519, 1, 0, 0, 0, 2518, 2516, 1, 0, 0, 
	0, 2519, 2520, 5, 368, 0, 0, 2520, 2522, 1, 0, 0, 0, 2521, 2509, 1, 0, 
	0, 0, 2521, 2510, 1, 0, 0, 0, 2522, 343, 1, 0, 0, 0, 2523, 2525, 4, 172, 
	4, 0, 2524, 2526, 5, 13, 0, 0, 2525, 2524, 1, 0, 0, 0, 2525, 2526, 1, 0, 
	0, 0, 2526, 2527, 1, 0, 0, 0, 2527, 2538, 3, 464, 232, 0, 2528, 2529, 5, 
	365, 0, 0, 2529, 2534, 5, 372, 0, 0, 2530, 2531, 5, 350, 0, 0, 2531, 2533, 
	5, 372, 0, 0, 2532, 2530, 1, 0, 0, 0, 2533, 2536, 1, 0, 0, 0, 2534, 2532, 
	1, 0, 0, 0, 2534, 2535, 1, 0, 0, 0, 2535, 2537, 1, 0, 0, 0, 2536, 2534, 
	1, 0, 0, 0, 2537, 2539, 5, 368, 0, 0, 2538, 2528, 1, 0, 0, 0, 2538, 2539, 
	1, 0, 0, 0, 2539, 345, 1, 0, 0, 0, 2540, 2541, 3, 464, 232, 0, 2541, 347, 
	1, 0, 0, 0, 2542, 2543, 5, 315, 0, 0, 2543, 2544, 3, 384, 192, 0, 2544, 
	349, 1, 0, 0, 0, 2545, 2546, 5, 126, 0, 0, 2546, 2547, 5, 30, 0, 0, 2547, 
	2552, 3, 400, 200, 0, 2548, 2549, 5, 350, 0, 0, 2549, 2551, 3, 400, 200, 
	0, 2550, 2548, 1, 0, 0, 0, 2551, 2554, 1, 0, 0, 0, 2552, 2550, 1, 0, 0, 
	0, 2552, 2553, 1, 0, 0, 0, 2553, 351, 1, 0, 0, 0, 2554, 2552, 1, 0, 0, 
	0, 2555, 2556, 5, 129, 0, 0, 2556, 2557, 3, 384, 192, 0, 2557, 353, 1, 
	0, 0, 0, 2558, 2559, 5, 223, 0, 0, 2559, 2560, 3, 384, 192, 0, 2560, 355, 
	1, 0, 0, 0, 2561, 2562, 5, 206, 0, 0, 2562, 2563, 5, 30, 0, 0, 2563, 2565, 
	3, 400, 200, 0, 2564, 2566, 7, 8, 0, 0, 2565, 2564, 1, 0, 0, 0, 2565, 2566, 
	1, 0, 0, 0, 2566, 2574, 1, 0, 0, 0, 2567, 2568, 5, 350, 0, 0, 2568, 2570, 
	3, 400, 200, 0, 2569, 2571, 7, 8, 0, 0, 2570, 2569, 1, 0, 0, 0, 2570, 2571, 
	1, 0, 0, 0, 2571, 2573, 1, 0, 0, 0, 2572, 2567, 1, 0, 0, 0, 2573, 2576, 
	1, 0, 0, 0, 2574, 2572, 1, 0, 0, 0, 2574, 2575, 1, 0, 0, 0, 2575, 357, 
	1, 0, 0, 0, 2576, 2574, 1, 0, 0, 0, 2577, 2579, 3, 360, 180, 0, 2578, 2577, 
	1, 0, 0, 0, 2579, 2580, 1, 0, 0, 0, 2580, 2578, 1, 0, 0, 0, 2580, 2581, 
	1, 0, 0, 0, 2581, 359, 1, 0, 0, 0, 2582, 2583, 5, 164, 0, 0, 2583, 2594, 
	3, 400, 200, 0, 2584, 2585, 5, 317, 0, 0, 2585, 2591, 7, 39, 0, 0, 2586, 
	2587, 5, 305, 0, 0, 2587, 2588, 5, 10, 0, 0, 2588, 2589, 5, 157, 0, 0, 
	2589, 2590, 7, 40, 0, 0, 2590, 2592, 5, 170, 0, 0, 2591, 2586, 1, 0, 0, 
	0, 2591, 2592, 1, 0, 0, 0, 2592, 2594, 1, 0, 0, 0, 2593, 2582, 1, 0, 0, 
	0, 2593, 2584, 1, 0, 0, 0, 2594, 361, 1, 0, 0, 0, 2595, 2596, 5, 303, 0, 
	0, 2596, 2597, 3, 366, 183, 0, 2597, 2598, 5, 258, 0, 0, 2598, 2600, 3, 
	364, 182, 0, 2599, 2601, 3, 348, 174, 0, 2600, 2599, 1, 0, 0, 0, 2600, 
	2601, 1, 0, 0, 0, 2601, 2603, 1, 0, 0, 0, 2602, 2604, 3, 368, 184, 0, 2603, 
	2602, 1, 0, 0, 0, 2603, 2604, 1, 0, 0, 0, 2604, 363, 1, 0, 0, 0, 2605, 
	2610, 3, 26, 13, 0, 2606, 2607, 5, 350, 0, 0, 2607, 2609, 3, 26, 13, 0, 
	2608, 2606, 1, 0, 0, 0, 2609, 2612, 1, 0, 0, 0, 2610, 2608, 1, 0, 0, 0, 
	2610, 2611, 1, 0, 0, 0, 2611, 365, 1, 0, 0, 0, 2612, 2610, 1, 0, 0, 0, 
	2613, 2615, 3, 346, 173, 0, 2614, 2616, 3, 328, 164, 0, 2615, 2614, 1, 
	0, 0, 0, 2615, 2616, 1, 0, 0, 0, 2616, 2622, 1, 0, 0, 0, 2617, 2618, 5, 
	365, 0, 0, 2618, 2619, 3, 294, 147, 0, 2619, 2620, 5, 368, 0, 0, 2620, 
	2622, 1, 0, 0, 0, 2621, 2613, 1, 0, 0, 0, 2621, 2617, 1, 0, 0, 0, 2622, 
	2627, 1, 0, 0, 0, 2623, 2625, 5, 13, 0, 0, 2624, 2623, 1, 0, 0, 0, 2624, 
	2625, 1, 0, 0, 0, 2625, 2626, 1, 0, 0, 0, 2626, 2628, 3, 464, 232, 0, 2627, 
	2624, 1, 0, 0, 0, 2627, 2628, 1, 0, 0, 0, 2628, 367, 1, 0, 0, 0, 2629, 
	2630, 5, 94, 0, 0, 2630, 2631, 3, 186, 93, 0, 2631, 369, 1, 0, 0, 0, 2632, 
	2633, 5, 179, 0, 0, 2633, 2634, 5, 151, 0, 0, 2634, 2635, 3, 372, 186, 
	0, 2635, 2636, 5, 306, 0, 0, 2636, 2637, 3, 372, 186, 0, 2637, 2638, 5, 
	202, 0, 0, 2638, 2640, 3, 384, 192, 0, 2639, 2641, 3, 374, 187, 0, 2640, 
	2639, 1, 0, 0, 0, 2641, 2642, 1, 0, 0, 0, 2642, 2640, 1, 0, 0, 0, 2642, 
	2643, 1, 0, 0, 0, 2643, 371, 1, 0, 0, 0, 2644, 2650, 3, 346, 173, 0, 2645, 
	2646, 5, 365, 0, 0, 2646, 2647, 3, 294, 147, 0, 2647, 2648, 5, 368, 0, 
	0, 2648, 2650, 1, 0, 0, 0, 2649, 2644, 1, 0, 0, 0, 2649, 2645, 1, 0, 0, 
	0, 2650, 2655, 1, 0, 0, 0, 2651, 2653, 5, 13, 0, 0, 2652, 2651, 1, 0, 0, 
	0, 2652, 2653, 1, 0, 0, 0, 2653, 2654, 1, 0, 0, 0, 2654, 2656, 3, 464, 
	232, 0, 2655, 2652, 1, 0, 0, 0, 2655, 2656, 1, 0, 0, 0, 2656, 373, 1, 0, 
	0, 0, 2657, 2659, 5, 314, 0, 0, 2658, 2660, 5, 194, 0, 0, 2659, 2658, 1, 
	0, 0, 0, 2659, 2660, 1, 0, 0, 0, 2660, 2661, 1, 0, 0, 0, 2661, 2664, 5, 
	176, 0, 0, 2662, 2663, 5, 10, 0, 0, 2663, 2665, 3, 384, 192, 0, 2664, 2662, 
	1, 0, 0, 0, 2664, 2665, 1, 0, 0, 0, 2665, 2666, 1, 0, 0, 0, 2666, 2667, 
	5, 290, 0, 0, 2667, 2671, 3, 376, 188, 0, 2668, 2669, 5, 94, 0, 0, 2669, 
	2671, 5, 135, 0, 0, 2670, 2657, 1, 0, 0, 0, 2670, 2668, 1, 0, 0, 0, 2671, 
	375, 1, 0, 0, 0, 2672, 2674, 5, 143, 0, 0, 2673, 2675, 3, 188, 94, 0, 2674, 
	2673, 1, 0, 0, 0, 2674, 2675, 1, 0, 0, 0, 2675, 2676, 1, 0, 0, 0, 2676, 
	2677, 5, 308, 0, 0, 2677, 2693, 3, 192, 96, 0, 2678, 2679, 5, 303, 0, 0, 
	2679, 2680, 5, 258, 0, 0, 2680, 2685, 3, 26, 13, 0, 2681, 2682, 5, 350, 
	0, 0, 2682, 2684, 3, 26, 13, 0, 2683, 2681, 1, 0, 0, 0, 2684, 2687, 1, 
	0, 0, 0, 2685, 2683, 1, 0, 0, 0, 2685, 2686, 1, 0, 0, 0, 2686, 2689, 1, 
	0, 0, 0, 2687, 2685, 1, 0, 0, 0, 2688, 2690, 3, 348, 174, 0, 2689, 2688, 
	1, 0, 0, 0, 2689, 2690, 1, 0, 0, 0, 2690, 2693, 1, 0, 0, 0, 2691, 2693, 
	5, 80, 0, 0, 2692, 2672, 1, 0, 0, 0, 2692, 2678, 1, 0, 0, 0, 2692, 2691, 
	1, 0, 0, 0, 2693, 377, 1, 0, 0, 0, 2694, 2696, 5, 80, 0, 0, 2695, 2697, 
	5, 119, 0, 0, 2696, 2695, 1, 0, 0, 0, 2696, 2697, 1, 0, 0, 0, 2697, 2698, 
	1, 0, 0, 0, 2698, 2700, 3, 346, 173, 0, 2699, 2701, 3, 380, 190, 0, 2700, 
	2699, 1, 0, 0, 0, 2700, 2701, 1, 0, 0, 0, 2701, 2704, 1, 0, 0, 0, 2702, 
	2705, 3, 348, 174, 0, 2703, 2705, 5, 7, 0, 0, 2704, 2702, 1, 0, 0, 0, 2704, 
	2703, 1, 0, 0, 0, 2704, 2705, 1, 0, 0, 0, 2705, 379, 1, 0, 0, 0, 2706, 
	2708, 4, 190, 5, 0, 2707, 2709, 5, 13, 0, 0, 2708, 2707, 1, 0, 0, 0, 2708, 
	2709, 1, 0, 0, 0, 2709, 2710, 1, 0, 0, 0, 2710, 2711, 3, 464, 232, 0, 2711, 
	381, 1, 0, 0, 0, 2712, 2714, 7, 41, 0, 0, 2713, 2715, 5, 285, 0, 0, 2714, 
	2713, 1, 0, 0, 0, 2714, 2715, 1, 0, 0, 0, 2715, 2716, 1, 0, 0, 0, 2716, 
	2717, 3, 346, 173, 0, 2717, 383, 1, 0, 0, 0, 2718, 2720, 6, 192, -1, 0, 
	2719, 2721, 5, 194, 0, 0, 2720, 2719, 1, 0, 0, 0, 2720, 2721, 1, 0, 0, 
	0, 2721, 2722, 1, 0, 0, 0, 2722, 2723, 5, 365, 0, 0, 2723, 2724, 3, 384, 
	192, 0, 2724, 2725, 5, 368, 0, 0, 2725, 2728, 1, 0, 0, 0, 2726, 2728, 3, 
	386, 193, 0, 2727, 2718, 1, 0, 0, 0, 2727, 2726, 1, 0, 0, 0, 2728, 2735, 
	1, 0, 0, 0, 2729, 2730, 10, 2, 0, 0, 2730, 2731, 3, 396, 198, 0, 2731, 
	2732, 3, 384, 192, 3, 2732, 2734, 1, 0, 0, 0, 2733, 2729, 1, 0, 0, 0, 2734, 
	2737, 1, 0, 0, 0, 2735, 2733, 1, 0, 0, 0, 2735, 2736, 1, 0, 0, 0, 2736, 
	385, 1, 0, 0, 0, 2737, 2735, 1, 0, 0, 0, 2738, 2742, 3, 388, 194, 0, 2739, 
	2742, 3, 394, 197, 0, 2740, 2742, 3, 400, 200, 0, 2741, 2738, 1, 0, 0, 
	0, 2741, 2739, 1, 0, 0, 0, 2741, 2740, 1, 0, 0, 0, 2742, 387, 1, 0, 0, 
	0, 2743, 2744, 3, 400, 200, 0, 2744, 2746, 5, 153, 0, 0, 2745, 2747, 5, 
	194, 0, 0, 2746, 2745, 1, 0, 0, 0, 2746, 2747, 1, 0, 0, 0, 2747, 2748, 
	1, 0, 0, 0, 2748, 2749, 5, 196, 0, 0, 2749, 2767, 1, 0, 0, 0, 2750, 2751, 
	3, 400, 200, 0, 2751, 2752, 5, 21, 0, 0, 2752, 2753, 3, 400, 200, 0, 2753, 
	2754, 5, 10, 0, 0, 2754, 2755, 3, 400, 200, 0, 2755, 2767, 1, 0, 0, 0, 
	2756, 2758, 5, 194, 0, 0, 2757, 2756, 1, 0, 0, 0, 2757, 2758, 1, 0, 0, 
	0, 2758, 2759, 1, 0, 0, 0, 2759, 2760, 5, 106, 0, 0, 2760, 2761, 5, 365, 
	0, 0, 2761, 2762, 3, 294, 147, 0, 2762, 2763, 5, 368, 0, 0, 2763, 2767, 
	1, 0, 0, 0, 2764, 2767, 3, 390, 195, 0, 2765, 2767, 3, 392, 196, 0, 2766, 
	2743, 1, 0, 0, 0, 2766, 2750, 1, 0, 0, 0, 2766, 2757, 1, 0, 0, 0, 2766, 
	2764, 1, 0, 0, 0, 2766, 2765, 1, 0, 0, 0, 2767, 389, 1, 0, 0, 0, 2768, 
	2770, 3, 400, 200, 0, 2769, 2771, 5, 194, 0, 0, 2770, 2769, 1, 0, 0, 0, 
	2770, 2771, 1, 0, 0, 0, 2771, 2772, 1, 0, 0, 0, 2772, 2773, 5, 137, 0, 
	0, 2773, 2783, 5, 365, 0, 0, 2774, 2779, 3, 400, 200, 0, 2775, 2776, 5, 
	350, 0, 0, 2776, 2778, 3, 400, 200, 0, 2777, 2775, 1, 0, 0, 0, 2778, 2781, 
	1, 0, 0, 0, 2779, 2777, 1, 0, 0, 0, 2779, 2780, 1, 0, 0, 0, 2780, 2784, 
	1, 0, 0, 0, 2781, 2779, 1, 0, 0, 0, 2782, 2784, 3, 294, 147, 0, 2783, 2774, 
	1, 0, 0, 0, 2783, 2782, 1, 0, 0, 0, 2784, 2785, 1, 0, 0, 0, 2785, 2786, 
	5, 368, 0, 0, 2786, 391, 1, 0, 0, 0, 2787, 2788, 5, 365, 0, 0, 2788, 2793, 
	3, 400, 200, 0, 2789, 2790, 5, 350, 0, 0, 2790, 2792, 3, 400, 200, 0, 2791, 
	2789, 1, 0, 0, 0, 2792, 2795, 1, 0, 0, 0, 2793, 2791, 1, 0, 0, 0, 2793, 
	2794, 1, 0, 0, 0, 2794, 2796, 1, 0, 0, 0, 2795, 2793, 1, 0, 0, 0, 2796, 
	2798, 5, 368, 0, 0, 2797, 2799, 5, 194, 0, 0, 2798, 2797, 1, 0, 0, 0, 2798, 
	2799, 1, 0, 0, 0, 2799, 2800, 1, 0, 0, 0, 2800, 2801, 5, 137, 0, 0, 2801, 
	2802, 5, 365, 0, 0, 2802, 2803, 3, 294, 147, 0, 2803, 2804, 5, 368, 0, 
	0, 2804, 393, 1, 0, 0, 0, 2805, 2806, 3, 400, 200, 0, 2806, 2807, 3, 398, 
	199, 0, 2807, 2808, 3, 400, 200, 0, 2808, 395, 1, 0, 0, 0, 2809, 2810, 
	7, 42, 0, 0, 2810, 397, 1, 0, 0, 0, 2811, 2824, 5, 355, 0, 0, 2812, 2824, 
	5, 356, 0, 0, 2813, 2824, 5, 357, 0, 0, 2814, 2824, 5, 358, 0, 0, 2815, 
	2824, 5, 361, 0, 0, 2816, 2824, 5, 362, 0, 0, 2817, 2824, 5, 359, 0, 0, 
	2818, 2824, 5, 360, 0, 0, 2819, 2821, 5, 194, 0, 0, 2820, 2819, 1, 0, 0, 
	0, 2820, 2821, 1, 0, 0, 0, 2821, 2822, 1, 0, 0, 0, 2822, 2824, 7, 43, 0, 
	0, 2823, 2811, 1, 0, 0, 0, 2823, 2812, 1, 0, 0, 0, 2823, 2813, 1, 0, 0, 
	0, 2823, 2814, 1, 0, 0, 0, 2823, 2815, 1, 0, 0, 0, 2823, 2816, 1, 0, 0, 
	0, 2823, 2817, 1, 0, 0, 0, 2823, 2818, 1, 0, 0, 0, 2823, 2820, 1, 0, 0, 
	0, 2824, 399, 1, 0, 0, 0, 2825, 2826, 6, 200, -1, 0, 2826, 2827, 5, 365, 
	0, 0, 2827, 2828, 3, 294, 147, 0, 2828, 2829, 5, 368, 0, 0, 2829, 2844, 
	1, 0, 0, 0, 2830, 2831, 5, 365, 0, 0, 2831, 2832, 3, 400, 200, 0, 2832, 
	2833, 5, 368, 0, 0, 2833, 2844, 1, 0, 0, 0, 2834, 2844, 3, 404, 202, 0, 
	2835, 2844, 3, 408, 204, 0, 2836, 2844, 3, 432, 216, 0, 2837, 2844, 3, 
	412, 206, 0, 2838, 2844, 3, 418, 209, 0, 2839, 2844, 3, 420, 210, 0, 2840, 
	2844, 3, 428, 214, 0, 2841, 2844, 3, 430, 215, 0, 2842, 2844, 3, 402, 201, 
	0, 2843, 2825, 1, 0, 0, 0, 2843, 2830, 1, 0, 0, 0, 2843, 2834, 1, 0, 0, 
	0, 2843, 2835, 1, 0, 0, 0, 2843, 2836, 1, 0, 0, 0, 2843, 2837, 1, 0, 0, 
	0, 2843, 2838, 1, 0, 0, 0, 2843, 2839, 1, 0, 0, 0, 2843, 2840, 1, 0, 0, 
	0, 2843, 2841, 1, 0, 0, 0, 2843, 2842, 1, 0, 0, 0, 2844, 2855, 1, 0, 0, 
	0, 2845, 2846, 10, 13, 0, 0, 2846, 2847, 7, 44, 0, 0, 2847, 2854, 3, 400, 
	200, 14, 2848, 2849, 10, 12, 0, 0, 2849, 2850, 7, 45, 0, 0, 2850, 2854, 
	3, 400, 200, 13, 2851, 2852, 10, 14, 0, 0, 2852, 2854, 3, 406, 203, 0, 
	2853, 2845, 1, 0, 0, 0, 2853, 2848, 1, 0, 0, 0, 2853, 2851, 1, 0, 0, 0, 
	2854, 2857, 1, 0, 0, 0, 2855, 2853, 1, 0, 0, 0, 2855, 2856, 1, 0, 0, 0, 
	2856, 401, 1, 0, 0, 0, 2857, 2855, 1, 0, 0, 0, 2858, 2867, 3, 458, 229, 
	0, 2859, 2867, 3, 460, 230, 0, 2860, 2867, 3, 472, 236, 0, 2861, 2867, 
	3, 464, 232, 0, 2862, 2867, 3, 466, 233, 0, 2863, 2867, 3, 470, 235, 0, 
	2864, 2867, 3, 468, 234, 0, 2865, 2867, 3, 474, 237, 0, 2866, 2858, 1, 
	0, 0, 0, 2866, 2859, 1, 0, 0, 0, 2866, 2860, 1, 0, 0, 0, 2866, 2861, 1, 
	0, 0, 0, 2866, 2862, 1, 0, 0, 0, 2866, 2863, 1, 0, 0, 0, 2866, 2864, 1, 
	0, 0, 0, 2866, 2865, 1, 0, 0, 0, 2867, 403, 1, 0, 0, 0, 2868, 2869, 5, 
	150, 0, 0, 2869, 2870, 3, 400, 200, 0, 2870, 2871, 3, 406, 203, 0, 2871, 
	405, 1, 0, 0, 0, 2872, 2873, 7, 46, 0, 0, 2873, 407, 1, 0, 0, 0, 2874, 
	2875, 3, 410, 205, 0, 2875, 2876, 7, 47, 0, 0, 2876, 2881, 3, 410, 205, 
	0, 2877, 2878, 7, 47, 0, 0, 2878, 2880, 3, 410, 205, 0, 2879, 2877, 1, 
	0, 0, 0, 2880, 2883, 1, 0, 0, 0, 2881, 2879, 1, 0, 0, 0, 2881, 2882, 1, 
	0, 0, 0, 2882, 409, 1, 0, 0, 0, 2883, 2881, 1, 0, 0, 0, 2884, 2885, 5, 
	365, 0, 0, 2885, 2886, 3, 400, 200, 0, 2886, 2887, 5, 368, 0, 0, 2887, 
	2895, 1, 0, 0, 0, 2888, 2895, 3, 412, 206, 0, 2889, 2895, 3, 420, 210, 
	0, 2890, 2895, 3, 428, 214, 0, 2891, 2895, 3, 432, 216, 0, 2892, 2895, 
	3, 430, 215, 0, 2893, 2895, 3, 402, 201, 0, 2894, 2884, 1, 0, 0, 0, 2894, 
	2888, 1, 0, 0, 0, 2894, 2889, 1, 0, 0, 0, 2894, 2890, 1, 0, 0, 0, 2894, 
	2891, 1, 0, 0, 0, 2894, 2892, 1, 0, 0, 0, 2894, 2893, 1, 0, 0, 0, 2895, 
	411, 1, 0, 0, 0, 2896, 2899, 3, 414, 207, 0, 2897, 2899, 3, 416, 208, 0, 
	2898, 2896, 1, 0, 0, 0, 2898, 2897, 1, 0, 0, 0, 2899, 413, 1, 0, 0, 0, 
	2900, 2901, 5, 35, 0, 0, 2901, 2907, 3, 400, 200, 0, 2902, 2903, 5, 314, 
	0, 0, 2903, 2904, 3, 400, 200, 0, 2904, 2905, 5, 290, 0, 0, 2905, 2906, 
	3, 400, 200, 0, 2906, 2908, 1, 0, 0, 0, 2907, 2902, 1, 0, 0, 0, 2908, 2909, 
	1, 0, 0, 0, 2909, 2907, 1, 0, 0, 0, 2909, 2910, 1, 0, 0, 0, 2910, 2913, 
	1, 0, 0, 0, 2911, 2912, 5, 94, 0, 0, 2912, 2914, 3, 400, 200, 0, 2913, 
	2911, 1, 0, 0, 0, 2913, 2914, 1, 0, 0, 0, 2914, 2915, 1, 0, 0, 0, 2915, 
	2916, 5, 98, 0, 0, 2916, 415, 1, 0, 0, 0, 2917, 2923, 5, 35, 0, 0, 2918, 
	2919, 5, 314, 0, 0, 2919, 2920, 3, 384, 192, 0, 2920, 2921, 5, 290, 0, 
	0, 2921, 2922, 3, 400, 200, 0, 2922, 2924, 1, 0, 0, 0, 2923, 2918, 1, 0, 
	0, 0, 2924, 2925, 1, 0, 0, 0, 2925, 2923, 1, 0, 0, 0, 2925, 2926, 1, 0, 
	0, 0, 2926, 2929, 1, 0, 0, 0, 2927, 2928, 5, 94, 0, 0, 2928, 2930, 3, 400, 
	200, 0, 2929, 2927, 1, 0, 0, 0, 2929, 2930, 1, 0, 0, 0, 2930, 2931, 1, 
	0, 0, 0, 2931, 2932, 5, 98, 0, 0, 2932, 417, 1, 0, 0, 0, 2933, 2934, 3, 
	462, 231, 0, 2934, 2935, 5, 3, 0, 0, 2935, 2936, 7, 48, 0, 0, 2936, 419, 
	1, 0, 0, 0, 2937, 2938, 5, 18, 0, 0, 2938, 2940, 5, 365, 0, 0, 2939, 2941, 
	3, 422, 211, 0, 2940, 2939, 1, 0, 0, 0, 2940, 2941, 1, 0, 0, 0, 2941, 2942, 
	1, 0, 0, 0, 2942, 2943, 3, 400, 200, 0, 2943, 2945, 5, 368, 0, 0, 2944, 
	2946, 3, 424, 212, 0, 2945, 2944, 1, 0, 0, 0, 2945, 2946, 1, 0, 0, 0, 2946, 
	3090, 1, 0, 0, 0, 2947, 2948, 5, 57, 0, 0, 2948, 2954, 5, 365, 0, 0, 2949, 
	2951, 3, 422, 211, 0, 2950, 2949, 1, 0, 0, 0, 2950, 2951, 1, 0, 0, 0, 2951, 
	2952, 1, 0, 0, 0, 2952, 2955, 3, 400, 200, 0, 2953, 2955, 5, 363, 0, 0, 
	2954, 2950, 1, 0, 0, 0, 2954, 2953, 1, 0, 0, 0, 2955, 2956, 1, 0, 0, 0, 
	2956, 2958, 5, 368, 0, 0, 2957, 2959, 3, 424, 212, 0, 2958, 2957, 1, 0, 
	0, 0, 2958, 2959, 1, 0, 0, 0, 2959, 3090, 1, 0, 0, 0, 2960, 2961, 5, 58, 
	0, 0, 2961, 2967, 5, 365, 0, 0, 2962, 2964, 3, 422, 211, 0, 2963, 2962, 
	1, 0, 0, 0, 2963, 2964, 1, 0, 0, 0, 2964, 2965, 1, 0, 0, 0, 2965, 2968, 
	3, 400, 200, 0, 2966, 2968, 5, 363, 0, 0, 2967, 2963, 1, 0, 0, 0, 2967, 
	2966, 1, 0, 0, 0, 2968, 2969, 1, 0, 0, 0, 2969, 2971, 5, 368, 0, 0, 2970, 
	2972, 3, 424, 212, 0, 2971, 2970, 1, 0, 0, 0, 2971, 2972, 1, 0, 0, 0, 2972, 
	3090, 1, 0, 0, 0, 2973, 2974, 5, 324, 0, 0, 2974, 2975, 5, 365, 0, 0, 2975, 
	2976, 5, 368, 0, 0, 2976, 3090, 3, 424, 212, 0, 2977, 2978, 5, 329, 0, 
	0, 2978, 2979, 5, 365, 0, 0, 2979, 2980, 5, 368, 0, 0, 2980, 3090, 3, 424, 
	212, 0, 2981, 2982, 5, 330, 0, 0, 2982, 2983, 5, 365, 0, 0, 2983, 2984, 
	3, 400, 200, 0, 2984, 2985, 5, 368, 0, 0, 2985, 2986, 3, 424, 212, 0, 2986, 
	3090, 1, 0, 0, 0, 2987, 2988, 5, 331, 0, 0, 2988, 2989, 5, 365, 0, 0, 2989, 
	2996, 3, 400, 200, 0, 2990, 2991, 5, 350, 0, 0, 2991, 2994, 3, 400, 200, 
	0, 2992, 2993, 5, 350, 0, 0, 2993, 2995, 3, 400, 200, 0, 2994, 2992, 1, 
	0, 0, 0, 2994, 2995, 1, 0, 0, 0, 2995, 2997, 1, 0, 0, 0, 2996, 2990, 1, 
	0, 0, 0, 2996, 2997, 1, 0, 0, 0, 2997, 2998, 1, 0, 0, 0, 2998, 2999, 5, 
	368, 0, 0, 2999, 3000, 3, 424, 212, 0, 3000, 3090, 1, 0, 0, 0, 3001, 3002, 
	5, 332, 0, 0, 3002, 3003, 5, 365, 0, 0, 3003, 3004, 3, 400, 200, 0, 3004, 
	3005, 5, 368, 0, 0, 3005, 3006, 3, 424, 212, 0, 3006, 3090, 1, 0, 0, 0, 
	3007, 3008, 5, 333, 0, 0, 3008, 3009, 5, 365, 0, 0, 3009, 3016, 3, 400, 
	200, 0, 3010, 3011, 5, 350, 0, 0, 3011, 3014, 3, 400, 200, 0, 3012, 3013, 
	5, 350, 0, 0, 3013, 3015, 3, 400, 200, 0, 3014, 3012, 1, 0, 0, 0, 3014, 
	3015, 1, 0, 0, 0, 3015, 3017, 1, 0, 0, 0, 3016, 3010, 1, 0, 0, 0, 3016, 
	3017, 1, 0, 0, 0, 3017, 3018, 1, 0, 0, 0, 3018, 3019, 5, 368, 0, 0, 3019, 
	3020, 3, 424, 212, 0, 3020, 3090, 1, 0, 0, 0, 3021, 3022, 5, 177, 0, 0, 
	3022, 3024, 5, 365, 0, 0, 3023, 3025, 3, 422, 211, 0, 3024, 3023, 1, 0, 
	0, 0, 3024, 3025, 1, 0, 0, 0, 3025, 3026, 1, 0, 0, 0, 3026, 3027, 3, 400, 
	200, 0, 3027, 3029, 5, 368, 0, 0, 3028, 3030, 3, 424, 212, 0, 3029, 3028, 
	1, 0, 0, 0, 3029, 3030, 1, 0, 0, 0, 3030, 3090, 1, 0, 0, 0, 3031, 3032, 
	5, 184, 0, 0, 3032, 3034, 5, 365, 0, 0, 3033, 3035, 3, 422, 211, 0, 3034, 
	3033, 1, 0, 0, 0, 3034, 3035, 1, 0, 0, 0, 3035, 3036, 1, 0, 0, 0, 3036, 
	3037, 3, 400, 200, 0, 3037, 3039, 5, 368, 0, 0, 3038, 3040, 3, 424, 212, 
	0, 3039, 3038, 1, 0, 0, 0, 3039, 3040, 1, 0, 0, 0, 3040, 3090, 1, 0, 0, 
	0, 3041, 3042, 5, 342, 0, 0, 3042, 3043, 5, 365, 0, 0, 3043, 3044, 5, 368, 
	0, 0, 3044, 3090, 3, 424, 212, 0, 3045, 3046, 5, 343, 0, 0, 3046, 3047, 
	5, 365, 0, 0, 3047, 3048, 5, 368, 0, 0, 3048, 3090, 3, 424, 212, 0, 3049, 
	3050, 5, 344, 0, 0, 3050, 3052, 5, 365, 0, 0, 3051, 3053, 3, 422, 211, 
	0, 3052, 3051, 1, 0, 0, 0, 3052, 3053, 1, 0, 0, 0, 3053, 3054, 1, 0, 0, 
	0, 3054, 3055, 3, 400, 200, 0, 3055, 3057, 5, 368, 0, 0, 3056, 3058, 3, 
	424, 212, 0, 3057, 3056, 1, 0, 0, 0, 3057, 3058, 1, 0, 0, 0, 3058, 3090, 
	1, 0, 0, 0, 3059, 3060, 5, 282, 0, 0, 3060, 3062, 5, 365, 0, 0, 3061, 3063, 
	3, 422, 211, 0, 3062, 3061, 1, 0, 0, 0, 3062, 3063, 1, 0, 0, 0, 3063, 3064, 
	1, 0, 0, 0, 3064, 3065, 3, 400, 200, 0, 3065, 3067, 5, 368, 0, 0, 3066, 
	3068, 3, 424, 212, 0, 3067, 3066, 1, 0, 0, 0, 3067, 3068, 1, 0, 0, 0, 3068, 
	3090, 1, 0, 0, 0, 3069, 3070, 5, 309, 0, 0, 3070, 3072, 5, 365, 0, 0, 3071, 
	3073, 3, 422, 211, 0, 3072, 3071, 1, 0, 0, 0, 3072, 3073, 1, 0, 0, 0, 3073, 
	3074, 1, 0, 0, 0, 3074, 3075, 3, 400, 200, 0, 3075, 3077, 5, 368, 0, 0, 
	3076, 3078, 3, 424, 212, 0, 3077, 3076, 1, 0, 0, 0, 3077, 3078, 1, 0, 0, 
	0, 3078, 3090, 1, 0, 0, 0, 3079, 3080, 5, 346, 0, 0, 3080, 3082, 5, 365, 
	0, 0, 3081, 3083, 3, 422, 211, 0, 3082, 3081, 1, 0, 0, 0, 3082, 3083, 1, 
	0, 0, 0, 3083, 3084, 1, 0, 0, 0, 3084, 3085, 3, 400, 200, 0, 3085, 3087, 
	5, 368, 0, 0, 3086, 3088, 3, 424, 212, 0, 3087, 3086, 1, 0, 0, 0, 3087, 
	3088, 1, 0, 0, 0, 3088, 3090, 1, 0, 0, 0, 3089, 2937, 1, 0, 0, 0, 3089, 
	2947, 1, 0, 0, 0, 3089, 2960, 1, 0, 0, 0, 3089, 2973, 1, 0, 0, 0, 3089, 
	2977, 1, 0, 0, 0, 3089, 2981, 1, 0, 0, 0, 3089, 2987, 1, 0, 0, 0, 3089, 
	3001, 1, 0, 0, 0, 3089, 3007, 1, 0, 0, 0, 3089, 3021, 1, 0, 0, 0, 3089, 
	3031, 1, 0, 0, 0, 3089, 3041, 1, 0, 0, 0, 3089, 3045, 1, 0, 0, 0, 3089, 
	3049, 1, 0, 0, 0, 3089, 3059, 1, 0, 0, 0, 3089, 3069, 1, 0, 0, 0, 3089, 
	3079, 1, 0, 0, 0, 3090, 421, 1, 0, 0, 0, 3091, 3092, 7, 37, 0, 0, 3092, 
	423, 1, 0, 0, 0, 3093, 3094, 5, 209, 0, 0, 3094, 3096, 5, 365, 0, 0, 3095, 
	3097, 3, 426, 213, 0, 3096, 3095, 1, 0, 0, 0, 3096, 3097, 1, 0, 0, 0, 3097, 
	3099, 1, 0, 0, 0, 3098, 3100, 3, 356, 178, 0, 3099, 3098, 1, 0, 0, 0, 3099, 
	3100, 1, 0, 0, 0, 3100, 3101, 1, 0, 0, 0, 3101, 3102, 5, 368, 0, 0, 3102, 
	425, 1, 0, 0, 0, 3103, 3104, 5, 213, 0, 0, 3104, 3105, 5, 30, 0, 0, 3105, 
	3110, 3, 400, 200, 0, 3106, 3107, 5, 350, 0, 0, 3107, 3109, 3, 400, 200, 
	0, 3108, 3106, 1, 0, 0, 0, 3109, 3112, 1, 0, 0, 0, 3110, 3108, 1, 0, 0, 
	0, 3110, 3111, 1, 0, 0, 0, 3111, 427, 1, 0, 0, 0, 3112, 3110, 1, 0, 0, 
	0, 3113, 3314, 5, 323, 0, 0, 3114, 3115, 5, 37, 0, 0, 3115, 3116, 5, 365, 
	0, 0, 3116, 3117, 3, 400, 200, 0, 3117, 3118, 5, 13, 0, 0, 3118, 3120, 
	3, 128, 64, 0, 3119, 3121, 3, 130, 65, 0, 3120, 3119, 1, 0, 0, 0, 3120, 
	3121, 1, 0, 0, 0, 3121, 3122, 1, 0, 0, 0, 3122, 3123, 5, 368, 0, 0, 3123, 
	3314, 1, 0, 0, 0, 3124, 3125, 5, 57, 0, 0, 3125, 3128, 5, 365, 0, 0, 3126, 
	3129, 3, 400, 200, 0, 3127, 3129, 5, 363, 0, 0, 3128, 3126, 1, 0, 0, 0, 
	3128, 3127, 1, 0, 0, 0, 3129, 3130, 1, 0, 0, 0, 3130, 3314, 5, 368, 0, 
	0, 3131, 3314, 5, 325, 0, 0, 3132, 3133, 5, 63, 0, 0, 3133, 3314, 5, 68, 
	0, 0, 3134, 3138, 5, 327, 0, 0, 3135, 3136, 5, 63, 0, 0, 3136, 3138, 5, 
	292, 0, 0, 3137, 3134, 1, 0, 0, 0, 3137, 3135, 1, 0, 0, 0, 3138, 3143, 
	1, 0, 0, 0, 3139, 3140, 5, 365, 0, 0, 3140, 3141, 3, 400, 200, 0, 3141, 
	3142, 5, 368, 0, 0, 3142, 3144, 1, 0, 0, 0, 3143, 3139, 1, 0, 0, 0, 3143, 
	3144, 1, 0, 0, 0, 3144, 3314, 1, 0, 0, 0, 3145, 3314, 5, 328, 0, 0, 3146, 
	3147, 5, 63, 0, 0, 3147, 3314, 5, 347, 0, 0, 3148, 3149, 5, 334, 0, 0, 
	3149, 3150, 5, 365, 0, 0, 3150, 3163, 3, 400, 200, 0, 3151, 3152, 5, 350, 
	0, 0, 3152, 3160, 3, 400, 200, 0, 3153, 3154, 5, 350, 0, 0, 3154, 3155, 
	3, 400, 200, 0, 3155, 3156, 5, 355, 0, 0, 3156, 3157, 3, 400, 200, 0, 3157, 
	3159, 1, 0, 0, 0, 3158, 3153, 1, 0, 0, 0, 3159, 3162, 1, 0, 0, 0, 3160, 
	3158, 1, 0, 0, 0, 3160, 3161, 1, 0, 0, 0, 3161, 3164, 1, 0, 0, 0, 3162, 
	3160, 1, 0, 0, 0, 3163, 3151, 1, 0, 0, 0, 3163, 3164, 1, 0, 0, 0, 3164, 
	3165, 1, 0, 0, 0, 3165, 3166, 5, 368, 0, 0, 3166, 3314, 1, 0, 0, 0, 3167, 
	3168, 5, 335, 0, 0, 3168, 3169, 5, 365, 0, 0, 3169, 3182, 3, 400, 200, 
	0, 3170, 3171, 5, 350, 0, 0, 3171, 3179, 3, 400, 200, 0, 3172, 3173, 5, 
	350, 0, 0, 3173, 3174, 3, 400, 200, 0, 3174, 3175, 5, 355, 0, 0, 3175, 
	3176, 3, 400, 200, 0, 3176, 3178, 1, 0, 0, 0, 3177, 3172, 1, 0, 0, 0, 3178, 
	3181, 1, 0, 0, 0, 3179, 3177, 1, 0, 0, 0, 3179, 3180, 1, 0, 0, 0, 3180, 
	3183, 1, 0, 0, 0, 3181, 3179, 1, 0, 0, 0, 3182, 3170, 1, 0, 0, 0, 3182, 
	3183, 1, 0, 0, 0, 3183, 3184, 1, 0, 0, 0, 3184, 3185, 5, 368, 0, 0, 3185, 
	3314, 1, 0, 0, 0, 3186, 3187, 5, 336, 0, 0, 3187, 3188, 5, 365, 0, 0, 3188, 
	3201, 3, 400, 200, 0, 3189, 3190, 5, 350, 0, 0, 3190, 3198, 3, 400, 200, 
	0, 3191, 3192, 5, 350, 0, 0, 3192, 3193, 3, 400, 200, 0, 3193, 3194, 5, 
	355, 0, 0, 3194, 3195, 3, 400, 200, 0, 3195, 3197, 1, 0, 0, 0, 3196, 3191, 
	1, 0, 0, 0, 3197, 3200, 1, 0, 0, 0, 3198, 3196, 1, 0, 0, 0, 3198, 3199, 
	1, 0, 0, 0, 3199, 3202, 1, 0, 0, 0, 3200, 3198, 1, 0, 0, 0, 3201, 3189, 
	1, 0, 0, 0, 3201, 3202, 1, 0, 0, 0, 3202, 3203, 1, 0, 0, 0, 3203, 3204, 
	5, 368, 0, 0, 3204, 3314, 1, 0, 0, 0, 3205, 3206, 5, 337, 0, 0, 3206, 3207, 
	5, 365, 0, 0, 3207, 3220, 3, 400, 200, 0, 3208, 3209, 5, 350, 0, 0, 3209, 
	3217, 3, 400, 200, 0, 3210, 3211, 5, 350, 0, 0, 3211, 3212, 3, 400, 200, 
	0, 3212, 3213, 5, 355, 0, 0, 3213, 3214, 3, 400, 200, 0, 3214, 3216, 1, 
	0, 0, 0, 3215, 3210, 1, 0, 0, 0, 3216, 3219, 1, 0, 0, 0, 3217, 3215, 1, 
	0, 0, 0, 3217, 3218, 1, 0, 0, 0, 3218, 3221, 1, 0, 0, 0, 3219, 3217, 1, 
	0, 0, 0, 3220, 3208, 1, 0, 0, 0, 3220, 3221, 1, 0, 0, 0, 3221, 3222, 1, 
	0, 0, 0, 3222, 3223, 5, 368, 0, 0, 3223, 3314, 1, 0, 0, 0, 3224, 3225, 
	5, 338, 0, 0, 3225, 3226, 5, 365, 0, 0, 3226, 3239, 3, 400, 200, 0, 3227, 
	3228, 5, 350, 0, 0, 3228, 3236, 3, 400, 200, 0, 3229, 3230, 5, 350, 0, 
	0, 3230, 3231, 3, 400, 200, 0, 3231, 3232, 5, 355, 0, 0, 3232, 3233, 3, 
	400, 200, 0, 3233, 3235, 1, 0, 0, 0, 3234, 3229, 1, 0, 0, 0, 3235, 3238, 
	1, 0, 0, 0, 3236, 3234, 1, 0, 0, 0, 3236, 3237, 1, 0, 0, 0, 3237, 3240, 
	1, 0, 0, 0, 3238, 3236, 1, 0, 0, 0, 3239, 3227, 1, 0, 0, 0, 3239, 3240, 
	1, 0, 0, 0, 3240, 3241, 1, 0, 0, 0, 3241, 3242, 5, 368, 0, 0, 3242, 3314, 
	1, 0, 0, 0, 3243, 3244, 5, 339, 0, 0, 3244, 3245, 5, 365, 0, 0, 3245, 3258, 
	3, 400, 200, 0, 3246, 3247, 5, 350, 0, 0, 3247, 3255, 3, 400, 200, 0, 3248, 
	3249, 5, 350, 0, 0, 3249, 3250, 3, 400, 200, 0, 3250, 3251, 5, 355, 0, 
	0, 3251, 3252, 3, 400, 200, 0, 3252, 3254, 1, 0, 0, 0, 3253, 3248, 1, 0, 
	0, 0, 3254, 3257, 1, 0, 0, 0, 3255, 3253, 1, 0, 0, 0, 3255, 3256, 1, 0, 
	0, 0, 3256, 3259, 1, 0, 0, 0, 3257, 3255, 1, 0, 0, 0, 3258, 3246, 1, 0, 
	0, 0, 3258, 3259, 1, 0, 0, 0, 3259, 3260, 1, 0, 0, 0, 3260, 3261, 5, 368, 
	0, 0, 3261, 3314, 1, 0, 0, 0, 3262, 3263, 5, 340, 0, 0, 3263, 3264, 5, 
	365, 0, 0, 3264, 3272, 3, 400, 200, 0, 3265, 3266, 5, 350, 0, 0, 3266, 
	3267, 3, 400, 200, 0, 3267, 3268, 5, 355, 0, 0, 3268, 3269, 3, 400, 200, 
	0, 3269, 3271, 1, 0, 0, 0, 3270, 3265, 1, 0, 0, 0, 3271, 3274, 1, 0, 0, 
	0, 3272, 3270, 1, 0, 0, 0, 3272, 3273, 1, 0, 0, 0, 3273, 3275, 1, 0, 0, 
	0, 3274, 3272, 1, 0, 0, 0, 3275, 3276, 5, 368, 0, 0, 3276, 3314, 1, 0, 
	0, 0, 3277, 3278, 5, 341, 0, 0, 3278, 3279, 5, 365, 0, 0, 3279, 3285, 3, 
	400, 200, 0, 3280, 3281, 5, 350, 0, 0, 3281, 3282, 3, 400, 200, 0, 3282, 
	3283, 5, 355, 0, 0, 3283, 3284, 3, 400, 200, 0, 3284, 3286, 1, 0, 0, 0, 
	3285, 3280, 1, 0, 0, 0, 3286, 3287, 1, 0, 0, 0, 3287, 3285, 1, 0, 0, 0, 
	3287, 3288, 1, 0, 0, 0, 3288, 3291, 1, 0, 0, 0, 3289, 3290, 5, 350, 0, 
	0, 3290, 3292, 3, 400, 200, 0, 3291, 3289, 1, 0, 0, 0, 3291, 3292, 1, 0, 
	0, 0, 3292, 3293, 1, 0, 0, 0, 3293, 3294, 5, 368, 0, 0, 3294, 3314, 1, 
	0, 0, 0, 3295, 3296, 5, 250, 0, 0, 3296, 3297, 5, 365, 0, 0, 3297, 3298, 
	3, 400, 200, 0, 3298, 3299, 5, 368, 0, 0, 3299, 3314, 1, 0, 0, 0, 3300, 
	3301, 5, 281, 0, 0, 3301, 3302, 5, 365, 0, 0, 3302, 3303, 3, 400, 200, 
	0, 3303, 3304, 5, 119, 0, 0, 3304, 3307, 3, 400, 200, 0, 3305, 3306, 5, 
	115, 0, 0, 3306, 3308, 3, 400, 200, 0, 3307, 3305, 1, 0, 0, 0, 3307, 3308, 
	1, 0, 0, 0, 3308, 3309, 1, 0, 0, 0, 3309, 3310, 5, 368, 0, 0, 3310, 3314, 
	1, 0, 0, 0, 3311, 3314, 5, 345, 0, 0, 3312, 3314, 5, 347, 0, 0, 3313, 3113, 
	1, 0, 0, 0, 3313, 3114, 1, 0, 0, 0, 3313, 3124, 1, 0, 0, 0, 3313, 3131, 
	1, 0, 0, 0, 3313, 3132, 1, 0, 0, 0, 3313, 3137, 1, 0, 0, 0, 3313, 3145, 
	1, 0, 0, 0, 3313, 3146, 1, 0, 0, 0, 3313, 3148, 1, 0, 0, 0, 3313, 3167, 
	1, 0, 0, 0, 3313, 3186, 1, 0, 0, 0, 3313, 3205, 1, 0, 0, 0, 3313, 3224, 
	1, 0, 0, 0, 3313, 3243, 1, 0, 0, 0, 3313, 3262, 1, 0, 0, 0, 3313, 3277, 
	1, 0, 0, 0, 3313, 3295, 1, 0, 0, 0, 3313, 3300, 1, 0, 0, 0, 3313, 3311, 
	1, 0, 0, 0, 3313, 3312, 1, 0, 0, 0, 3314, 429, 1, 0, 0, 0, 3315, 3316, 
	3, 462, 231, 0, 3316, 3318, 5, 365, 0, 0, 3317, 3319, 3, 438, 219, 0, 3318, 
	3317, 1, 0, 0, 0, 3318, 3319, 1, 0, 0, 0, 3319, 3320, 1, 0, 0, 0, 3320, 
	3321, 5, 368, 0, 0, 3321, 431, 1, 0, 0, 0, 3322, 3325, 3, 434, 217, 0, 
	3323, 3325, 3, 436, 218, 0, 3324, 3322, 1, 0, 0, 0, 3324, 3323, 1, 0, 0, 
	0, 3325, 433, 1, 0, 0, 0, 3326, 3329, 3, 462, 231, 0, 3327, 3329, 3, 430, 
	215, 0, 3328, 3326, 1, 0, 0, 0, 3328, 3327, 1, 0, 0, 0, 3329, 3330, 1, 
	0, 0, 0, 3330, 3331, 5, 353, 0, 0, 3331, 3332, 3, 430, 215, 0, 3332, 435, 
	1, 0, 0, 0, 3333, 3336, 3, 462, 231, 0, 3334, 3336, 3, 430, 215, 0, 3335, 
	3333, 1, 0, 0, 0, 3335, 3334, 1, 0, 0, 0, 3336, 3337, 1, 0, 0, 0, 3337, 
	3338, 5, 353, 0, 0, 3338, 3339, 3, 462, 231, 0, 3339, 437, 1, 0, 0, 0, 
	3340, 3345, 3, 440, 220, 0, 3341, 3342, 5, 350, 0, 0, 3342, 3344, 3, 440, 
	220, 0, 3343, 3341, 1, 0, 0, 0, 3344, 3347, 1, 0, 0, 0, 3345, 3343, 1, 
	0, 0, 0, 3345, 3346, 1, 0, 0, 0, 3346, 439, 1, 0, 0, 0, 3347, 3345, 1, 
	0, 0, 0, 3348, 3354, 4, 220, 10, 0, 3349, 3350, 3, 462, 231, 0, 3350, 3352, 
	5, 355, 0, 0, 3351, 3353, 5, 359, 0, 0, 3352, 3351, 1, 0, 0, 0, 3352, 3353, 
	1, 0, 0, 0, 3353, 3355, 1, 0, 0, 0, 3354, 3349, 1, 0, 0, 0, 3354, 3355, 
	1, 0, 0, 0, 3355, 3356, 1, 0, 0, 0, 3356, 3357, 3, 400, 200, 0, 3357, 441, 
	1, 0, 0, 0, 3358, 3361, 3, 294, 147, 0, 3359, 3361, 3, 400, 200, 0, 3360, 
	3358, 1, 0, 0, 0, 3360, 3359, 1, 0, 0, 0, 3361, 443, 1, 0, 0, 0, 3362, 
	3365, 3, 456, 228, 0, 3363, 3365, 3, 400, 200, 0, 3364, 3362, 1, 0, 0, 
	0, 3364, 3363, 1, 0, 0, 0, 3365, 445, 1, 0, 0, 0, 3366, 3370, 5, 131, 0, 
	0, 3367, 3369, 3, 448, 224, 0, 3368, 3367, 1, 0, 0, 0, 3369, 3372, 1, 0, 
	0, 0, 3370, 3368, 1, 0, 0, 0, 3370, 3371, 1, 0, 0, 0, 3371, 447, 1, 0, 
	0, 0, 3372, 3370, 1, 0, 0, 0, 3373, 3374, 5, 371, 0, 0, 3374, 3375, 3, 
	464, 232, 0, 3375, 3376, 3, 400, 200, 0, 3376, 3386, 1, 0, 0, 0, 3377, 
	3378, 5, 371, 0, 0, 3378, 3379, 3, 464, 232, 0, 3379, 3380, 5, 372, 0, 
	0, 3380, 3381, 5, 355, 0, 0, 3381, 3382, 3, 400, 200, 0, 3382, 3386, 1, 
	0, 0, 0, 3383, 3384, 5, 371, 0, 0, 3384, 3386, 3, 464, 232, 0, 3385, 3373, 
	1, 0, 0, 0, 3385, 3377, 1, 0, 0, 0, 3385, 3383, 1, 0, 0, 0, 3386, 449, 
	1, 0, 0, 0, 3387, 3388, 5, 4, 0, 0, 3388, 3389, 3, 452, 226, 0, 3389, 3390, 
	5, 370, 0, 0, 3390, 3393, 1, 0, 0, 0, 3391, 3393, 3, 454, 227, 0, 3392, 
	3387, 1, 0, 0, 0, 3392, 3391, 1, 0, 0, 0, 3393, 451, 1, 0, 0, 0, 3394, 
	3396, 9, 0, 0, 0, 3395, 3394, 1, 0, 0, 0, 3396, 3399, 1, 0, 0, 0, 3397, 
	3398, 1, 0, 0, 0, 3397, 3395, 1, 0, 0, 0, 3398, 453, 1, 0, 0, 0, 3399, 
	3397, 1, 0, 0, 0, 3400, 3401, 5, 132, 0, 0, 3401, 3402, 3, 400, 200, 0, 
	3402, 455, 1, 0, 0, 0, 3403, 3418, 5, 380, 0, 0, 3404, 3408, 5, 352, 0, 
	0, 3405, 3406, 5, 353, 0, 0, 3406, 3408, 5, 352, 0, 0, 3407, 3404, 1, 0, 
	0, 0, 3407, 3405, 1, 0, 0, 0, 3407, 3408, 1, 0, 0, 0, 3408, 3409, 1, 0, 
	0, 0, 3409, 3414, 3, 464, 232, 0, 3410, 3411, 5, 352, 0, 0, 3411, 3413, 
	3, 464, 232, 0, 3412, 3410, 1, 0, 0, 0, 3413, 3416, 1, 0, 0, 0, 3414, 3412, 
	1, 0, 0, 0, 3414, 3415, 1, 0, 0, 0, 3415, 3418, 1, 0, 0, 0, 3416, 3414, 
	1, 0, 0, 0, 3417, 3403, 1, 0, 0, 0, 3417, 3407, 1, 0, 0, 0, 3418, 457, 
	1, 0, 0, 0, 3419, 3420, 5, 68, 0, 0, 3420, 3421, 3, 466, 233, 0, 3421, 
	459, 1, 0, 0, 0, 3422, 3423, 5, 292, 0, 0, 3423, 3424, 3, 466, 233, 0, 
	3424, 461, 1, 0, 0, 0, 3425, 3427, 5, 371, 0, 0, 3426, 3425, 1, 0, 0, 0, 
	3426, 3427, 1, 0, 0, 0, 3427, 3430, 1, 0, 0, 0, 3428, 3431, 5, 372, 0, 
	0, 3429, 3431, 3, 476, 238, 0, 3430, 3428, 1, 0, 0, 0, 3430, 3429, 1, 0, 
	0, 0, 3431, 463, 1, 0, 0, 0, 3432, 3437, 3, 462, 231, 0, 3433, 3434, 5, 
	353, 0, 0, 3434, 3436, 3, 462, 231, 0, 3435, 3433, 1, 0, 0, 0, 3436, 3439, 
	1, 0, 0, 0, 3437, 3435, 1, 0, 0, 0, 3437, 3438, 1, 0, 0, 0, 3438, 465, 
	1, 0, 0, 0, 3439, 3437, 1, 0, 0, 0, 3440, 3443, 5, 373, 0, 0, 3441, 3443, 
	5, 374, 0, 0, 3442, 3440, 1, 0, 0, 0, 3442, 3441, 1, 0, 0, 0, 3443, 467, 
	1, 0, 0, 0, 3444, 3446, 7, 45, 0, 0, 3445, 3444, 1, 0, 0, 0, 3445, 3446, 
	1, 0, 0, 0, 3446, 3447, 1, 0, 0, 0, 3447, 3448, 5, 375, 0, 0, 3448, 469, 
	1, 0, 0, 0, 3449, 3451, 7, 45, 0, 0, 3450, 3449, 1, 0, 0, 0, 3450, 3451, 
	1, 0, 0, 0, 3451, 3452, 1, 0, 0, 0, 3452, 3453, 5, 376, 0, 0, 3453, 471, 
	1, 0, 0, 0, 3454, 3455, 7, 49, 0, 0, 3455, 473, 1, 0, 0, 0, 3456, 3457, 
	5, 196, 0, 0, 3457, 475, 1, 0, 0, 0, 3458, 3459, 7, 50, 0, 0, 3459, 477, 
	1, 0, 0, 0, 436, 483, 486, 490, 493, 498, 505, 511, 513, 522, 525, 527, 
	592, 600, 616, 623, 626, 632, 636, 645, 650, 663, 668, 677, 689, 694, 697, 
	711, 718, 727, 744, 752, 763, 773, 781, 788, 792, 796, 801, 805, 810, 814, 
	818, 828, 832, 837, 842, 846, 859, 864, 870, 879, 883, 891, 894, 899, 904, 
	911, 920, 923, 930, 935, 939, 945, 950, 956, 961, 964, 974, 982, 992, 1006, 
	1016, 1022, 1027, 1032, 1037, 1041, 1046, 1049, 1059, 1071, 1078, 1081, 
	1093, 1098, 1103, 1106, 1113, 1125, 1138, 1140, 1145, 1148, 1163, 1169, 
	1180, 1183, 1193, 1200, 1206, 1214, 1224, 1244, 1250, 1254, 1259, 1263, 
	1268, 1271, 1276, 1279, 1291, 1298, 1303, 1308, 1312, 1317, 1320, 1330, 
	1342, 1349, 1357, 1372, 1403, 1405, 1410, 1414, 1419, 1426, 1429, 1432, 
	1437, 1441, 1443, 1450, 1456, 1463, 1469, 1472, 1477, 1481, 1484, 1491, 
	1497, 1500, 1510, 1519, 1526, 1533, 1535, 1541, 1544, 1555, 1564, 1570, 
	1576, 1579, 1584, 1587, 1590, 1593, 1596, 1602, 1612, 1623, 1626, 1633, 
	1638, 1643, 1647, 1655, 1659, 1664, 1668, 1670, 1675, 1683, 1688, 1694, 
	1701, 1708, 1715, 1718, 1725, 1733, 1741, 1744, 1747, 1752, 1761, 1765, 
	1775, 1794, 1801, 1803, 1807, 1811, 1819, 1830, 1839, 1847, 1855, 1859, 
	1867, 1885, 1899, 1906, 1910, 1917, 1919, 1923, 1927, 1935, 1939, 1949, 
	1958, 1974, 1980, 1984, 1994, 2002, 2011, 2015, 2021, 2026, 2030, 2040, 
	2046, 2050, 2062, 2069, 2085, 2092, 2102, 2105, 2109, 2116, 2123, 2125, 
	2129, 2133, 2138, 2141, 2145, 2148, 2159, 2162, 2173, 2179, 2183, 2185, 
	2189, 2198, 2205, 2209, 2213, 2220, 2224, 2232, 2243, 2247, 2258, 2265, 
	2278, 2286, 2290, 2300, 2305, 2318, 2329, 2337, 2341, 2345, 2349, 2351, 
	2356, 2359, 2362, 2365, 2369, 2372, 2375, 2378, 2381, 2388, 2399, 2403, 
	2406, 2410, 2417, 2421, 2431, 2436, 2441, 2445, 2456, 2462, 2466, 2472, 
	2481, 2484, 2489, 2492, 2502, 2507, 2516, 2521, 2525, 2534, 2538, 2552, 
	2565, 2570, 2574, 2580, 2591, 2593, 2600, 2603, 2610, 2615, 2621, 2624, 
	2627, 2642, 2649, 2652, 2655, 2659, 2664, 2670, 2674, 2685, 2689, 2692, 
	2696, 2700, 2704, 2708, 2714, 2720, 2727, 2735, 2741, 2746, 2757, 2766, 
	2770, 2779, 2783, 2793, 2798, 2820, 2823, 2843, 2853, 2855, 2866, 2881, 
	2894, 2898, 2909, 2913, 2925, 2929, 2940, 2945, 2950, 2954, 2958, 2963, 
	2967, 2971, 2994, 2996, 3014, 3016, 3024, 3029, 3034, 3039, 3052, 3057, 
	3062, 3067, 3072, 3077, 3082, 3087, 3089, 3096, 3099, 3110, 3120, 3128, 
	3137, 3143, 3160, 3163, 3179, 3182, 3198, 3201, 3217, 3220, 3236, 3239, 
	3255, 3258, 3272, 3287, 3291, 3307, 3313, 3318, 3324, 3328, 3335, 3345, 
	3352, 3354, 3360, 3364, 3370, 3385, 3392, 3397, 3407, 3414, 3417, 3426, 
	3430, 3437, 3442, 3445, 3450,
}
  deserializer := antlr.NewATNDeserializer(nil)
  staticData.atn = deserializer.Deserialize(staticData.serializedATN)
  atn := staticData.atn
  staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
  decisionToDFA := staticData.decisionToDFA
  for index, state := range atn.DecisionToState {
    decisionToDFA[index] = antlr.NewDFA(state, index)
  }
}

// HplsqlParserInit initializes any static state used to implement HplsqlParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewHplsqlParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func HplsqlParserInit() {
  staticData := &HplsqlParserStaticData
  staticData.once.Do(hplsqlParserInit)
}

// NewHplsqlParser produces a new parser instance for the optional input antlr.TokenStream.
func NewHplsqlParser(input antlr.TokenStream) *HplsqlParser {
	HplsqlParserInit()
	this := new(HplsqlParser)
	this.BaseParser = antlr.NewBaseParser(input)
  staticData := &HplsqlParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "Hplsql.g4"

	return this
}


// HplsqlParser tokens.
const (
	HplsqlParserEOF = antlr.TokenEOF
	HplsqlParserT__0 = 1
	HplsqlParserT__1 = 2
	HplsqlParserT__2 = 3
	HplsqlParserT__3 = 4
	HplsqlParserT_ACTION = 5
	HplsqlParserT_ADD2 = 6
	HplsqlParserT_ALL = 7
	HplsqlParserT_ALLOCATE = 8
	HplsqlParserT_ALTER = 9
	HplsqlParserT_AND = 10
	HplsqlParserT_ANSI_NULLS = 11
	HplsqlParserT_ANSI_PADDING = 12
	HplsqlParserT_AS = 13
	HplsqlParserT_ASC = 14
	HplsqlParserT_ASSOCIATE = 15
	HplsqlParserT_AT = 16
	HplsqlParserT_AUTO_INCREMENT = 17
	HplsqlParserT_AVG = 18
	HplsqlParserT_BATCHSIZE = 19
	HplsqlParserT_BEGIN = 20
	HplsqlParserT_BETWEEN = 21
	HplsqlParserT_BIGINT = 22
	HplsqlParserT_BINARY_DOUBLE = 23
	HplsqlParserT_BINARY_FLOAT = 24
	HplsqlParserT_BINARY_INTEGER = 25
	HplsqlParserT_BIT = 26
	HplsqlParserT_BODY = 27
	HplsqlParserT_BREAK = 28
	HplsqlParserT_BULK = 29
	HplsqlParserT_BY = 30
	HplsqlParserT_BYTE = 31
	HplsqlParserT_CALL = 32
	HplsqlParserT_CALLER = 33
	HplsqlParserT_CASCADE = 34
	HplsqlParserT_CASE = 35
	HplsqlParserT_CASESPECIFIC = 36
	HplsqlParserT_CAST = 37
	HplsqlParserT_CHAR = 38
	HplsqlParserT_CHARACTER = 39
	HplsqlParserT_CHARSET = 40
	HplsqlParserT_CLIENT = 41
	HplsqlParserT_CLOSE = 42
	HplsqlParserT_CLUSTERED = 43
	HplsqlParserT_CMP = 44
	HplsqlParserT_COLLECT = 45
	HplsqlParserT_COLLECTION = 46
	HplsqlParserT_COLUMN = 47
	HplsqlParserT_COMMENT = 48
	HplsqlParserT_CONSTANT = 49
	HplsqlParserT_COMMIT = 50
	HplsqlParserT_COMPRESS = 51
	HplsqlParserT_CONCAT = 52
	HplsqlParserT_CONDITION = 53
	HplsqlParserT_CONSTRAINT = 54
	HplsqlParserT_CONTINUE = 55
	HplsqlParserT_COPY = 56
	HplsqlParserT_COUNT = 57
	HplsqlParserT_COUNT_BIG = 58
	HplsqlParserT_CREATE = 59
	HplsqlParserT_CREATION = 60
	HplsqlParserT_CREATOR = 61
	HplsqlParserT_CS = 62
	HplsqlParserT_CURRENT = 63
	HplsqlParserT_CURRENT_SCHEMA = 64
	HplsqlParserT_CURSOR = 65
	HplsqlParserT_DATABASE = 66
	HplsqlParserT_DATA = 67
	HplsqlParserT_DATE = 68
	HplsqlParserT_DATETIME = 69
	HplsqlParserT_DAY = 70
	HplsqlParserT_DAYS = 71
	HplsqlParserT_DEC = 72
	HplsqlParserT_DECIMAL = 73
	HplsqlParserT_DECLARE = 74
	HplsqlParserT_DEFAULT = 75
	HplsqlParserT_DEFERRED = 76
	HplsqlParserT_DEFINED = 77
	HplsqlParserT_DEFINER = 78
	HplsqlParserT_DEFINITION = 79
	HplsqlParserT_DELETE = 80
	HplsqlParserT_DELIMITED = 81
	HplsqlParserT_DELIMITER = 82
	HplsqlParserT_DESC = 83
	HplsqlParserT_DESCRIBE = 84
	HplsqlParserT_DIAGNOSTICS = 85
	HplsqlParserT_DIR = 86
	HplsqlParserT_DIRECTORY = 87
	HplsqlParserT_DISTINCT = 88
	HplsqlParserT_DISTRIBUTE = 89
	HplsqlParserT_DO = 90
	HplsqlParserT_DOUBLE = 91
	HplsqlParserT_DROP = 92
	HplsqlParserT_DYNAMIC = 93
	HplsqlParserT_ELSE = 94
	HplsqlParserT_ELSEIF = 95
	HplsqlParserT_ELSIF = 96
	HplsqlParserT_ENABLE = 97
	HplsqlParserT_END = 98
	HplsqlParserT_ENGINE = 99
	HplsqlParserT_ESCAPED = 100
	HplsqlParserT_EXCEPT = 101
	HplsqlParserT_EXEC = 102
	HplsqlParserT_EXECUTE = 103
	HplsqlParserT_EXCEPTION = 104
	HplsqlParserT_EXCLUSIVE = 105
	HplsqlParserT_EXISTS = 106
	HplsqlParserT_EXIT = 107
	HplsqlParserT_FALLBACK = 108
	HplsqlParserT_FALSE = 109
	HplsqlParserT_FETCH = 110
	HplsqlParserT_FIELDS = 111
	HplsqlParserT_FILE = 112
	HplsqlParserT_FILES = 113
	HplsqlParserT_FLOAT = 114
	HplsqlParserT_FOR = 115
	HplsqlParserT_FOREIGN = 116
	HplsqlParserT_FORMAT = 117
	HplsqlParserT_FOUND = 118
	HplsqlParserT_FROM = 119
	HplsqlParserT_FULL = 120
	HplsqlParserT_FUNCTION = 121
	HplsqlParserT_GET = 122
	HplsqlParserT_GLOBAL = 123
	HplsqlParserT_GO = 124
	HplsqlParserT_GRANT = 125
	HplsqlParserT_GROUP = 126
	HplsqlParserT_HANDLER = 127
	HplsqlParserT_HASH = 128
	HplsqlParserT_HAVING = 129
	HplsqlParserT_HDFS = 130
	HplsqlParserT_HIVE = 131
	HplsqlParserT_HOST = 132
	HplsqlParserT_IDENTITY = 133
	HplsqlParserT_IF = 134
	HplsqlParserT_IGNORE = 135
	HplsqlParserT_IMMEDIATE = 136
	HplsqlParserT_IN = 137
	HplsqlParserT_INCLUDE = 138
	HplsqlParserT_INDEX = 139
	HplsqlParserT_INITRANS = 140
	HplsqlParserT_INNER = 141
	HplsqlParserT_INOUT = 142
	HplsqlParserT_INSERT = 143
	HplsqlParserT_INT = 144
	HplsqlParserT_INT2 = 145
	HplsqlParserT_INT4 = 146
	HplsqlParserT_INT8 = 147
	HplsqlParserT_INTEGER = 148
	HplsqlParserT_INTERSECT = 149
	HplsqlParserT_INTERVAL = 150
	HplsqlParserT_INTO = 151
	HplsqlParserT_INVOKER = 152
	HplsqlParserT_IS = 153
	HplsqlParserT_ISOPEN = 154
	HplsqlParserT_ITEMS = 155
	HplsqlParserT_JOIN = 156
	HplsqlParserT_KEEP = 157
	HplsqlParserT_KEY = 158
	HplsqlParserT_KEYS = 159
	HplsqlParserT_LANGUAGE = 160
	HplsqlParserT_LEAVE = 161
	HplsqlParserT_LEFT = 162
	HplsqlParserT_LIKE = 163
	HplsqlParserT_LIMIT = 164
	HplsqlParserT_LINES = 165
	HplsqlParserT_LOCAL = 166
	HplsqlParserT_LOCATION = 167
	HplsqlParserT_LOCATOR = 168
	HplsqlParserT_LOCATORS = 169
	HplsqlParserT_LOCKS = 170
	HplsqlParserT_LOG = 171
	HplsqlParserT_LOGGED = 172
	HplsqlParserT_LOGGING = 173
	HplsqlParserT_LOOP = 174
	HplsqlParserT_MAP = 175
	HplsqlParserT_MATCHED = 176
	HplsqlParserT_MAX = 177
	HplsqlParserT_MAXTRANS = 178
	HplsqlParserT_MERGE = 179
	HplsqlParserT_MESSAGE_TEXT = 180
	HplsqlParserT_MICROSECOND = 181
	HplsqlParserT_MICROSECONDS = 182
	HplsqlParserT_MILLIS = 183
	HplsqlParserT_MIN = 184
	HplsqlParserT_MULTISET = 185
	HplsqlParserT_NCHAR = 186
	HplsqlParserT_NEW = 187
	HplsqlParserT_NVARCHAR = 188
	HplsqlParserT_NO = 189
	HplsqlParserT_NOCOUNT = 190
	HplsqlParserT_NOCOMPRESS = 191
	HplsqlParserT_NOLOGGING = 192
	HplsqlParserT_NONE = 193
	HplsqlParserT_NOT = 194
	HplsqlParserT_NOTFOUND = 195
	HplsqlParserT_NULL = 196
	HplsqlParserT_NUMERIC = 197
	HplsqlParserT_NUMBER = 198
	HplsqlParserT_OBJECT = 199
	HplsqlParserT_OFF = 200
	HplsqlParserT_OF = 201
	HplsqlParserT_ON = 202
	HplsqlParserT_ONLY = 203
	HplsqlParserT_OPEN = 204
	HplsqlParserT_OR = 205
	HplsqlParserT_ORDER = 206
	HplsqlParserT_OUT = 207
	HplsqlParserT_OUTER = 208
	HplsqlParserT_OVER = 209
	HplsqlParserT_OVERWRITE = 210
	HplsqlParserT_OWNER = 211
	HplsqlParserT_PACKAGE = 212
	HplsqlParserT_PARTITION = 213
	HplsqlParserT_PCTFREE = 214
	HplsqlParserT_PCTUSED = 215
	HplsqlParserT_PLS_INTEGER = 216
	HplsqlParserT_PRECISION = 217
	HplsqlParserT_PRESERVE = 218
	HplsqlParserT_PRIMARY = 219
	HplsqlParserT_PRINT = 220
	HplsqlParserT_PROC = 221
	HplsqlParserT_PROCEDURE = 222
	HplsqlParserT_QUALIFY = 223
	HplsqlParserT_QUERY_BAND = 224
	HplsqlParserT_QUIT = 225
	HplsqlParserT_QUOTED_IDENTIFIER = 226
	HplsqlParserT_RAISE = 227
	HplsqlParserT_REAL = 228
	HplsqlParserT_REFERENCES = 229
	HplsqlParserT_REGEXP = 230
	HplsqlParserT_REPLACE = 231
	HplsqlParserT_RESIGNAL = 232
	HplsqlParserT_RESTRICT = 233
	HplsqlParserT_RESULT = 234
	HplsqlParserT_RESULT_SET_LOCATOR = 235
	HplsqlParserT_RETURN = 236
	HplsqlParserT_RETURNS = 237
	HplsqlParserT_REVERSE = 238
	HplsqlParserT_RIGHT = 239
	HplsqlParserT_RLIKE = 240
	HplsqlParserT_ROLE = 241
	HplsqlParserT_ROLLBACK = 242
	HplsqlParserT_ROW = 243
	HplsqlParserT_ROWS = 244
	HplsqlParserT_ROWTYPE = 245
	HplsqlParserT_ROW_COUNT = 246
	HplsqlParserT_RR = 247
	HplsqlParserT_RS = 248
	HplsqlParserT_PWD = 249
	HplsqlParserT_TRIM = 250
	HplsqlParserT_SCHEMA = 251
	HplsqlParserT_SECOND = 252
	HplsqlParserT_SECONDS = 253
	HplsqlParserT_SECURITY = 254
	HplsqlParserT_SEGMENT = 255
	HplsqlParserT_SEL = 256
	HplsqlParserT_SELECT = 257
	HplsqlParserT_SET = 258
	HplsqlParserT_SESSION = 259
	HplsqlParserT_SESSIONS = 260
	HplsqlParserT_SETS = 261
	HplsqlParserT_SHARE = 262
	HplsqlParserT_SIGNAL = 263
	HplsqlParserT_SIMPLE_DOUBLE = 264
	HplsqlParserT_SIMPLE_FLOAT = 265
	HplsqlParserT_SIMPLE_INTEGER = 266
	HplsqlParserT_SMALLDATETIME = 267
	HplsqlParserT_SMALLINT = 268
	HplsqlParserT_SQL = 269
	HplsqlParserT_SQLEXCEPTION = 270
	HplsqlParserT_SQLINSERT = 271
	HplsqlParserT_SQLSTATE = 272
	HplsqlParserT_SQLWARNING = 273
	HplsqlParserT_STATS = 274
	HplsqlParserT_STATISTICS = 275
	HplsqlParserT_STEP = 276
	HplsqlParserT_STORAGE = 277
	HplsqlParserT_STORED = 278
	HplsqlParserT_STRING = 279
	HplsqlParserT_SUBDIR = 280
	HplsqlParserT_SUBSTRING = 281
	HplsqlParserT_SUM = 282
	HplsqlParserT_SUMMARY = 283
	HplsqlParserT_SYS_REFCURSOR = 284
	HplsqlParserT_TABLE = 285
	HplsqlParserT_TABLESPACE = 286
	HplsqlParserT_TEMPORARY = 287
	HplsqlParserT_TERMINATED = 288
	HplsqlParserT_TEXTIMAGE_ON = 289
	HplsqlParserT_THEN = 290
	HplsqlParserT_TIME = 291
	HplsqlParserT_TIMESTAMP = 292
	HplsqlParserT_TINYINT = 293
	HplsqlParserT_TITLE = 294
	HplsqlParserT_TO = 295
	HplsqlParserT_TOP = 296
	HplsqlParserT_TRANSACTION = 297
	HplsqlParserT_TRUE = 298
	HplsqlParserT_TRUNCATE = 299
	HplsqlParserT_TYPE = 300
	HplsqlParserT_UNION = 301
	HplsqlParserT_UNIQUE = 302
	HplsqlParserT_UPDATE = 303
	HplsqlParserT_UR = 304
	HplsqlParserT_USE = 305
	HplsqlParserT_USING = 306
	HplsqlParserT_VALUE = 307
	HplsqlParserT_VALUES = 308
	HplsqlParserT_VAR = 309
	HplsqlParserT_VARCHAR = 310
	HplsqlParserT_VARCHAR2 = 311
	HplsqlParserT_VARYING = 312
	HplsqlParserT_VOLATILE = 313
	HplsqlParserT_WHEN = 314
	HplsqlParserT_WHERE = 315
	HplsqlParserT_WHILE = 316
	HplsqlParserT_WITH = 317
	HplsqlParserT_WITHOUT = 318
	HplsqlParserT_WORK = 319
	HplsqlParserT_XACT_ABORT = 320
	HplsqlParserT_XML = 321
	HplsqlParserT_YES = 322
	HplsqlParserT_ACTIVITY_COUNT = 323
	HplsqlParserT_CUME_DIST = 324
	HplsqlParserT_CURRENT_DATE = 325
	HplsqlParserT_CURRENT_TIME_MILLIS = 326
	HplsqlParserT_CURRENT_TIMESTAMP = 327
	HplsqlParserT_CURRENT_USER = 328
	HplsqlParserT_DENSE_RANK = 329
	HplsqlParserT_FIRST_VALUE = 330
	HplsqlParserT_LAG = 331
	HplsqlParserT_LAST_VALUE = 332
	HplsqlParserT_LEAD = 333
	HplsqlParserT_MAX_PART_STRING = 334
	HplsqlParserT_MIN_PART_STRING = 335
	HplsqlParserT_MAX_PART_INT = 336
	HplsqlParserT_MIN_PART_INT = 337
	HplsqlParserT_MAX_PART_DATE = 338
	HplsqlParserT_MIN_PART_DATE = 339
	HplsqlParserT_PART_COUNT = 340
	HplsqlParserT_PART_LOC = 341
	HplsqlParserT_RANK = 342
	HplsqlParserT_ROW_NUMBER = 343
	HplsqlParserT_STDEV = 344
	HplsqlParserT_SYSDATE = 345
	HplsqlParserT_VARIANCE = 346
	HplsqlParserT_USER = 347
	HplsqlParserT_ADD = 348
	HplsqlParserT_COLON = 349
	HplsqlParserT_COMMA = 350
	HplsqlParserT_PIPE = 351
	HplsqlParserT_DIV = 352
	HplsqlParserT_DOT = 353
	HplsqlParserT_DOT2 = 354
	HplsqlParserT_EQUAL = 355
	HplsqlParserT_EQUAL2 = 356
	HplsqlParserT_NOTEQUAL = 357
	HplsqlParserT_NOTEQUAL2 = 358
	HplsqlParserT_GREATER = 359
	HplsqlParserT_GREATEREQUAL = 360
	HplsqlParserT_LESS = 361
	HplsqlParserT_LESSEQUAL = 362
	HplsqlParserT_MUL = 363
	HplsqlParserT_OPEN_B = 364
	HplsqlParserT_OPEN_P = 365
	HplsqlParserT_OPEN_SB = 366
	HplsqlParserT_CLOSE_B = 367
	HplsqlParserT_CLOSE_P = 368
	HplsqlParserT_CLOSE_SB = 369
	HplsqlParserT_SEMICOLON = 370
	HplsqlParserT_SUB = 371
	HplsqlParserL_ID = 372
	HplsqlParserL_S_STRING = 373
	HplsqlParserL_D_STRING = 374
	HplsqlParserL_INT = 375
	HplsqlParserL_DEC = 376
	HplsqlParserL_WS = 377
	HplsqlParserL_M_COMMENT = 378
	HplsqlParserL_S_COMMENT = 379
	HplsqlParserL_FILE = 380
	HplsqlParserL_LABEL = 381
)

// HplsqlParser rules.
const (
	HplsqlParserRULE_program = 0
	HplsqlParserRULE_block = 1
	HplsqlParserRULE_begin_end_block = 2
	HplsqlParserRULE_single_block_stmt = 3
	HplsqlParserRULE_block_end = 4
	HplsqlParserRULE_proc_block = 5
	HplsqlParserRULE_stmt = 6
	HplsqlParserRULE_semicolon_stmt = 7
	HplsqlParserRULE_exception_block = 8
	HplsqlParserRULE_exception_block_item = 9
	HplsqlParserRULE_null_stmt = 10
	HplsqlParserRULE_expr_stmt = 11
	HplsqlParserRULE_assignment_stmt = 12
	HplsqlParserRULE_assignment_stmt_item = 13
	HplsqlParserRULE_assignment_stmt_single_item = 14
	HplsqlParserRULE_assignment_stmt_collection_item = 15
	HplsqlParserRULE_assignment_stmt_multiple_item = 16
	HplsqlParserRULE_assignment_stmt_select_item = 17
	HplsqlParserRULE_allocate_cursor_stmt = 18
	HplsqlParserRULE_associate_locator_stmt = 19
	HplsqlParserRULE_begin_transaction_stmt = 20
	HplsqlParserRULE_break_stmt = 21
	HplsqlParserRULE_call_stmt = 22
	HplsqlParserRULE_declare_stmt = 23
	HplsqlParserRULE_declare_block = 24
	HplsqlParserRULE_declare_block_inplace = 25
	HplsqlParserRULE_declare_stmt_item = 26
	HplsqlParserRULE_declare_var_item = 27
	HplsqlParserRULE_declare_condition_item = 28
	HplsqlParserRULE_declare_cursor_item = 29
	HplsqlParserRULE_cursor_with_return = 30
	HplsqlParserRULE_cursor_without_return = 31
	HplsqlParserRULE_declare_handler_item = 32
	HplsqlParserRULE_declare_temporary_table_item = 33
	HplsqlParserRULE_create_table_stmt = 34
	HplsqlParserRULE_create_local_temp_table_stmt = 35
	HplsqlParserRULE_create_table_definition = 36
	HplsqlParserRULE_create_table_column_comment = 37
	HplsqlParserRULE_create_table_columns = 38
	HplsqlParserRULE_create_table_columns_item = 39
	HplsqlParserRULE_create_table_type_stmt = 40
	HplsqlParserRULE_tbl_type = 41
	HplsqlParserRULE_sql_type = 42
	HplsqlParserRULE_column_name = 43
	HplsqlParserRULE_create_table_column_inline_cons = 44
	HplsqlParserRULE_create_table_column_cons = 45
	HplsqlParserRULE_create_table_fk_action = 46
	HplsqlParserRULE_create_table_preoptions = 47
	HplsqlParserRULE_create_table_preoptions_item = 48
	HplsqlParserRULE_create_table_preoptions_td_item = 49
	HplsqlParserRULE_create_table_options = 50
	HplsqlParserRULE_create_table_options_item = 51
	HplsqlParserRULE_create_table_options_ora_item = 52
	HplsqlParserRULE_create_table_options_db2_item = 53
	HplsqlParserRULE_create_table_options_td_item = 54
	HplsqlParserRULE_create_table_options_hive_item = 55
	HplsqlParserRULE_create_table_hive_row_format = 56
	HplsqlParserRULE_create_table_hive_row_format_fields = 57
	HplsqlParserRULE_create_table_options_mssql_item = 58
	HplsqlParserRULE_create_table_options_mysql_item = 59
	HplsqlParserRULE_alter_table_stmt = 60
	HplsqlParserRULE_alter_table_item = 61
	HplsqlParserRULE_alter_table_add_constraint = 62
	HplsqlParserRULE_alter_table_add_constraint_item = 63
	HplsqlParserRULE_dtype = 64
	HplsqlParserRULE_dtype_len = 65
	HplsqlParserRULE_dtype_attr = 66
	HplsqlParserRULE_dtype_default = 67
	HplsqlParserRULE_create_database_stmt = 68
	HplsqlParserRULE_create_database_option = 69
	HplsqlParserRULE_create_function_stmt = 70
	HplsqlParserRULE_create_function_return = 71
	HplsqlParserRULE_create_package_stmt = 72
	HplsqlParserRULE_package_spec = 73
	HplsqlParserRULE_package_spec_item = 74
	HplsqlParserRULE_create_package_body_stmt = 75
	HplsqlParserRULE_package_body = 76
	HplsqlParserRULE_package_body_item = 77
	HplsqlParserRULE_create_procedure_stmt = 78
	HplsqlParserRULE_create_routine_params = 79
	HplsqlParserRULE_create_routine_param_item = 80
	HplsqlParserRULE_create_routine_options = 81
	HplsqlParserRULE_create_routine_option = 82
	HplsqlParserRULE_drop_stmt = 83
	HplsqlParserRULE_end_transaction_stmt = 84
	HplsqlParserRULE_exec_stmt = 85
	HplsqlParserRULE_if_stmt = 86
	HplsqlParserRULE_if_plsql_stmt = 87
	HplsqlParserRULE_if_tsql_stmt = 88
	HplsqlParserRULE_if_bteq_stmt = 89
	HplsqlParserRULE_elseif_block = 90
	HplsqlParserRULE_else_block = 91
	HplsqlParserRULE_include_stmt = 92
	HplsqlParserRULE_insert_stmt = 93
	HplsqlParserRULE_insert_stmt_cols = 94
	HplsqlParserRULE_insert_stmt_rows = 95
	HplsqlParserRULE_insert_stmt_row = 96
	HplsqlParserRULE_insert_directory_stmt = 97
	HplsqlParserRULE_exit_stmt = 98
	HplsqlParserRULE_get_diag_stmt = 99
	HplsqlParserRULE_get_diag_stmt_item = 100
	HplsqlParserRULE_get_diag_stmt_exception_item = 101
	HplsqlParserRULE_get_diag_stmt_rowcount_item = 102
	HplsqlParserRULE_grant_stmt = 103
	HplsqlParserRULE_grant_stmt_item = 104
	HplsqlParserRULE_leave_stmt = 105
	HplsqlParserRULE_map_object_stmt = 106
	HplsqlParserRULE_open_stmt = 107
	HplsqlParserRULE_fetch_stmt = 108
	HplsqlParserRULE_fetch_limit = 109
	HplsqlParserRULE_collect_stats_stmt = 110
	HplsqlParserRULE_collect_stats_clause = 111
	HplsqlParserRULE_close_stmt = 112
	HplsqlParserRULE_cmp_stmt = 113
	HplsqlParserRULE_cmp_source = 114
	HplsqlParserRULE_copy_from_local_stmt = 115
	HplsqlParserRULE_copy_stmt = 116
	HplsqlParserRULE_copy_source = 117
	HplsqlParserRULE_copy_target = 118
	HplsqlParserRULE_copy_option = 119
	HplsqlParserRULE_copy_file_option = 120
	HplsqlParserRULE_commit_stmt = 121
	HplsqlParserRULE_create_index_stmt = 122
	HplsqlParserRULE_create_index_col = 123
	HplsqlParserRULE_index_storage_clause = 124
	HplsqlParserRULE_index_mssql_storage_clause = 125
	HplsqlParserRULE_print_stmt = 126
	HplsqlParserRULE_quit_stmt = 127
	HplsqlParserRULE_raise_stmt = 128
	HplsqlParserRULE_resignal_stmt = 129
	HplsqlParserRULE_return_stmt = 130
	HplsqlParserRULE_rollback_stmt = 131
	HplsqlParserRULE_set_session_option = 132
	HplsqlParserRULE_set_current_schema_option = 133
	HplsqlParserRULE_set_mssql_session_option = 134
	HplsqlParserRULE_set_teradata_session_option = 135
	HplsqlParserRULE_signal_stmt = 136
	HplsqlParserRULE_summary_stmt = 137
	HplsqlParserRULE_truncate_stmt = 138
	HplsqlParserRULE_use_stmt = 139
	HplsqlParserRULE_values_into_stmt = 140
	HplsqlParserRULE_while_stmt = 141
	HplsqlParserRULE_unconditional_loop_stmt = 142
	HplsqlParserRULE_for_cursor_stmt = 143
	HplsqlParserRULE_for_range_stmt = 144
	HplsqlParserRULE_label = 145
	HplsqlParserRULE_using_clause = 146
	HplsqlParserRULE_select_stmt = 147
	HplsqlParserRULE_cte_select_stmt = 148
	HplsqlParserRULE_cte_select_stmt_item = 149
	HplsqlParserRULE_cte_select_cols = 150
	HplsqlParserRULE_fullselect_stmt = 151
	HplsqlParserRULE_fullselect_stmt_item = 152
	HplsqlParserRULE_fullselect_set_clause = 153
	HplsqlParserRULE_subselect_stmt = 154
	HplsqlParserRULE_select_list = 155
	HplsqlParserRULE_select_list_set = 156
	HplsqlParserRULE_select_list_limit = 157
	HplsqlParserRULE_select_list_item = 158
	HplsqlParserRULE_select_list_alias = 159
	HplsqlParserRULE_select_list_asterisk = 160
	HplsqlParserRULE_table_row = 161
	HplsqlParserRULE_into_clause = 162
	HplsqlParserRULE_bulk_collect_clause = 163
	HplsqlParserRULE_from_clause = 164
	HplsqlParserRULE_from_table_clause = 165
	HplsqlParserRULE_from_table_name_clause = 166
	HplsqlParserRULE_from_subselect_clause = 167
	HplsqlParserRULE_from_join_clause = 168
	HplsqlParserRULE_from_join_type_clause = 169
	HplsqlParserRULE_from_table_values_clause = 170
	HplsqlParserRULE_from_table_values_row = 171
	HplsqlParserRULE_from_alias_clause = 172
	HplsqlParserRULE_table_name = 173
	HplsqlParserRULE_where_clause = 174
	HplsqlParserRULE_group_by_clause = 175
	HplsqlParserRULE_having_clause = 176
	HplsqlParserRULE_qualify_clause = 177
	HplsqlParserRULE_order_by_clause = 178
	HplsqlParserRULE_select_options = 179
	HplsqlParserRULE_select_options_item = 180
	HplsqlParserRULE_update_stmt = 181
	HplsqlParserRULE_update_assignment = 182
	HplsqlParserRULE_update_table = 183
	HplsqlParserRULE_update_upsert = 184
	HplsqlParserRULE_merge_stmt = 185
	HplsqlParserRULE_merge_table = 186
	HplsqlParserRULE_merge_condition = 187
	HplsqlParserRULE_merge_action = 188
	HplsqlParserRULE_delete_stmt = 189
	HplsqlParserRULE_delete_alias = 190
	HplsqlParserRULE_describe_stmt = 191
	HplsqlParserRULE_bool_expr = 192
	HplsqlParserRULE_bool_expr_atom = 193
	HplsqlParserRULE_bool_expr_unary = 194
	HplsqlParserRULE_bool_expr_single_in = 195
	HplsqlParserRULE_bool_expr_multi_in = 196
	HplsqlParserRULE_bool_expr_binary = 197
	HplsqlParserRULE_bool_expr_logical_operator = 198
	HplsqlParserRULE_bool_expr_binary_operator = 199
	HplsqlParserRULE_expr = 200
	HplsqlParserRULE_expr_atom = 201
	HplsqlParserRULE_expr_interval = 202
	HplsqlParserRULE_interval_item = 203
	HplsqlParserRULE_expr_concat = 204
	HplsqlParserRULE_expr_concat_item = 205
	HplsqlParserRULE_expr_case = 206
	HplsqlParserRULE_expr_case_simple = 207
	HplsqlParserRULE_expr_case_searched = 208
	HplsqlParserRULE_expr_cursor_attribute = 209
	HplsqlParserRULE_expr_agg_window_func = 210
	HplsqlParserRULE_expr_func_all_distinct = 211
	HplsqlParserRULE_expr_func_over_clause = 212
	HplsqlParserRULE_expr_func_partition_by_clause = 213
	HplsqlParserRULE_expr_spec_func = 214
	HplsqlParserRULE_expr_func = 215
	HplsqlParserRULE_expr_dot = 216
	HplsqlParserRULE_expr_dot_method_call = 217
	HplsqlParserRULE_expr_dot_property_access = 218
	HplsqlParserRULE_expr_func_params = 219
	HplsqlParserRULE_func_param = 220
	HplsqlParserRULE_expr_select = 221
	HplsqlParserRULE_expr_file = 222
	HplsqlParserRULE_hive = 223
	HplsqlParserRULE_hive_item = 224
	HplsqlParserRULE_host = 225
	HplsqlParserRULE_host_cmd = 226
	HplsqlParserRULE_host_stmt = 227
	HplsqlParserRULE_file_name = 228
	HplsqlParserRULE_date_literal = 229
	HplsqlParserRULE_timestamp_literal = 230
	HplsqlParserRULE_ident = 231
	HplsqlParserRULE_qident = 232
	HplsqlParserRULE_string = 233
	HplsqlParserRULE_int_number = 234
	HplsqlParserRULE_dec_number = 235
	HplsqlParserRULE_bool_literal = 236
	HplsqlParserRULE_null_const = 237
	HplsqlParserRULE_non_reserved_words = 238
)

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	EOF() antlr.TerminalNode

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_program
	return p
}

func InitEmptyProgramContext(p *ProgramContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_program
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ProgramContext) EOF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserEOF, 0)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterProgram(s)
	}
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitProgram(s)
	}
}




func (p *HplsqlParser) Program() (localctx IProgramContext) {
	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, HplsqlParserRULE_program)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(478)
		p.Block()
	}
	{
		p.SetState(479)
		p.Match(HplsqlParserEOF)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllBegin_end_block() []IBegin_end_blockContext
	Begin_end_block(i int) IBegin_end_blockContext
	AllStmt() []IStmtContext
	Stmt(i int) IStmtContext
	AllT_GO() []antlr.TerminalNode
	T_GO(i int) antlr.TerminalNode

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_block
	return p
}

func InitEmptyBlockContext(p *BlockContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_block
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) AllBegin_end_block() []IBegin_end_blockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBegin_end_blockContext); ok {
			len++
		}
	}

	tst := make([]IBegin_end_blockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBegin_end_blockContext); ok {
			tst[i] = t.(IBegin_end_blockContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) Begin_end_block(i int) IBegin_end_blockContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBegin_end_blockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBegin_end_blockContext)
}

func (s *BlockContext) AllStmt() []IStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmtContext); ok {
			len++
		}
	}

	tst := make([]IStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmtContext); ok {
			tst[i] = t.(IStmtContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) Stmt(i int) IStmtContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *BlockContext) AllT_GO() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_GO)
}

func (s *BlockContext) T_GO(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GO, i)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBlock(s)
	}
}




func (p *HplsqlParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, HplsqlParserRULE_block)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(488)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				p.SetState(483)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(481)
						p.Begin_end_block()
					}


				case 2:
					{
						p.SetState(482)
						p.Stmt()
					}

				case antlr.ATNInvalidAltNumber:
					goto errorExit
				}
				p.SetState(486)
				p.GetErrorHandler().Sync(p)


				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(485)
						p.Match(HplsqlParserT_GO)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}

					} else if p.HasError() { // JIM
						goto errorExit
				}




		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(490)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBegin_end_blockContext is an interface to support dynamic dispatch.
type IBegin_end_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_BEGIN() antlr.TerminalNode
	Block() IBlockContext
	Block_end() IBlock_endContext
	Declare_block() IDeclare_blockContext
	Exception_block() IException_blockContext

	// IsBegin_end_blockContext differentiates from other interfaces.
	IsBegin_end_blockContext()
}

type Begin_end_blockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBegin_end_blockContext() *Begin_end_blockContext {
	var p = new(Begin_end_blockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_begin_end_block
	return p
}

func InitEmptyBegin_end_blockContext(p *Begin_end_blockContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_begin_end_block
}

func (*Begin_end_blockContext) IsBegin_end_blockContext() {}

func NewBegin_end_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Begin_end_blockContext {
	var p = new(Begin_end_blockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_begin_end_block

	return p
}

func (s *Begin_end_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Begin_end_blockContext) T_BEGIN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BEGIN, 0)
}

func (s *Begin_end_blockContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *Begin_end_blockContext) Block_end() IBlock_endContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlock_endContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlock_endContext)
}

func (s *Begin_end_blockContext) Declare_block() IDeclare_blockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_blockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_blockContext)
}

func (s *Begin_end_blockContext) Exception_block() IException_blockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IException_blockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IException_blockContext)
}

func (s *Begin_end_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Begin_end_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Begin_end_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBegin_end_block(s)
	}
}

func (s *Begin_end_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBegin_end_block(s)
	}
}




func (p *HplsqlParser) Begin_end_block() (localctx IBegin_end_blockContext) {
	localctx = NewBegin_end_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, HplsqlParserRULE_begin_end_block)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(493)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_DECLARE {
		{
			p.SetState(492)
			p.Declare_block()
		}

	}
	{
		p.SetState(495)
		p.Match(HplsqlParserT_BEGIN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(496)
		p.Block()
	}
	p.SetState(498)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(497)
			p.Exception_block()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(500)
		p.Block_end()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISingle_block_stmtContext is an interface to support dynamic dispatch.
type ISingle_block_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_BEGIN() antlr.TerminalNode
	Block() IBlockContext
	Block_end() IBlock_endContext
	Exception_block() IException_blockContext
	Stmt() IStmtContext
	T_SEMICOLON() antlr.TerminalNode

	// IsSingle_block_stmtContext differentiates from other interfaces.
	IsSingle_block_stmtContext()
}

type Single_block_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingle_block_stmtContext() *Single_block_stmtContext {
	var p = new(Single_block_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_single_block_stmt
	return p
}

func InitEmptySingle_block_stmtContext(p *Single_block_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_single_block_stmt
}

func (*Single_block_stmtContext) IsSingle_block_stmtContext() {}

func NewSingle_block_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Single_block_stmtContext {
	var p = new(Single_block_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_single_block_stmt

	return p
}

func (s *Single_block_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Single_block_stmtContext) T_BEGIN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BEGIN, 0)
}

func (s *Single_block_stmtContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *Single_block_stmtContext) Block_end() IBlock_endContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlock_endContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlock_endContext)
}

func (s *Single_block_stmtContext) Exception_block() IException_blockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IException_blockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IException_blockContext)
}

func (s *Single_block_stmtContext) Stmt() IStmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *Single_block_stmtContext) T_SEMICOLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEMICOLON, 0)
}

func (s *Single_block_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Single_block_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Single_block_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSingle_block_stmt(s)
	}
}

func (s *Single_block_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSingle_block_stmt(s)
	}
}




func (p *HplsqlParser) Single_block_stmt() (localctx ISingle_block_stmtContext) {
	localctx = NewSingle_block_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, HplsqlParserRULE_single_block_stmt)
	p.SetState(513)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(502)
			p.Match(HplsqlParserT_BEGIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(503)
			p.Block()
		}
		p.SetState(505)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(504)
				p.Exception_block()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(507)
			p.Block_end()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(509)
			p.Stmt()
		}
		p.SetState(511)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(510)
				p.Match(HplsqlParserT_SEMICOLON)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBlock_endContext is an interface to support dynamic dispatch.
type IBlock_endContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_END() antlr.TerminalNode

	// IsBlock_endContext differentiates from other interfaces.
	IsBlock_endContext()
}

type Block_endContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlock_endContext() *Block_endContext {
	var p = new(Block_endContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_block_end
	return p
}

func InitEmptyBlock_endContext(p *Block_endContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_block_end
}

func (*Block_endContext) IsBlock_endContext() {}

func NewBlock_endContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Block_endContext {
	var p = new(Block_endContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_block_end

	return p
}

func (s *Block_endContext) GetParser() antlr.Parser { return s.parser }

func (s *Block_endContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *Block_endContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Block_endContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Block_endContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBlock_end(s)
	}
}

func (s *Block_endContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBlock_end(s)
	}
}




func (p *HplsqlParser) Block_end() (localctx IBlock_endContext) {
	localctx = NewBlock_endContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, HplsqlParserRULE_block_end)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(515)

	if !(!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "TRANSACTION")) {
		p.SetError(antlr.NewFailedPredicateException(p, "!_input.LT(2).getText().equalsIgnoreCase(\"TRANSACTION\")", ""))
		goto errorExit
	}
	{
		p.SetState(516)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IProc_blockContext is an interface to support dynamic dispatch.
type IProc_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Begin_end_block() IBegin_end_blockContext
	AllStmt() []IStmtContext
	Stmt(i int) IStmtContext
	T_GO() antlr.TerminalNode

	// IsProc_blockContext differentiates from other interfaces.
	IsProc_blockContext()
}

type Proc_blockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProc_blockContext() *Proc_blockContext {
	var p = new(Proc_blockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_proc_block
	return p
}

func InitEmptyProc_blockContext(p *Proc_blockContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_proc_block
}

func (*Proc_blockContext) IsProc_blockContext() {}

func NewProc_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Proc_blockContext {
	var p = new(Proc_blockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_proc_block

	return p
}

func (s *Proc_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Proc_blockContext) Begin_end_block() IBegin_end_blockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBegin_end_blockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBegin_end_blockContext)
}

func (s *Proc_blockContext) AllStmt() []IStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmtContext); ok {
			len++
		}
	}

	tst := make([]IStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmtContext); ok {
			tst[i] = t.(IStmtContext)
			i++
		}
	}

	return tst
}

func (s *Proc_blockContext) Stmt(i int) IStmtContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *Proc_blockContext) T_GO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GO, 0)
}

func (s *Proc_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Proc_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Proc_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterProc_block(s)
	}
}

func (s *Proc_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitProc_block(s)
	}
}




func (p *HplsqlParser) Proc_block() (localctx IProc_blockContext) {
	localctx = NewProc_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, HplsqlParserRULE_proc_block)
	var _alt int

	p.SetState(527)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(518)
			p.Begin_end_block()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(520)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
					{
						p.SetState(519)
						p.Stmt()
					}




			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(522)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(525)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(524)
				p.Match(HplsqlParserT_GO)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IStmtContext is an interface to support dynamic dispatch.
type IStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Assignment_stmt() IAssignment_stmtContext
	Allocate_cursor_stmt() IAllocate_cursor_stmtContext
	Alter_table_stmt() IAlter_table_stmtContext
	Associate_locator_stmt() IAssociate_locator_stmtContext
	Begin_transaction_stmt() IBegin_transaction_stmtContext
	Break_stmt() IBreak_stmtContext
	Call_stmt() ICall_stmtContext
	Collect_stats_stmt() ICollect_stats_stmtContext
	Close_stmt() IClose_stmtContext
	Cmp_stmt() ICmp_stmtContext
	Copy_from_local_stmt() ICopy_from_local_stmtContext
	Copy_stmt() ICopy_stmtContext
	Commit_stmt() ICommit_stmtContext
	Create_database_stmt() ICreate_database_stmtContext
	Create_function_stmt() ICreate_function_stmtContext
	Create_index_stmt() ICreate_index_stmtContext
	Create_local_temp_table_stmt() ICreate_local_temp_table_stmtContext
	Create_package_stmt() ICreate_package_stmtContext
	Create_package_body_stmt() ICreate_package_body_stmtContext
	Create_procedure_stmt() ICreate_procedure_stmtContext
	Create_table_stmt() ICreate_table_stmtContext
	Create_table_type_stmt() ICreate_table_type_stmtContext
	Declare_stmt() IDeclare_stmtContext
	Delete_stmt() IDelete_stmtContext
	Describe_stmt() IDescribe_stmtContext
	Drop_stmt() IDrop_stmtContext
	End_transaction_stmt() IEnd_transaction_stmtContext
	Exec_stmt() IExec_stmtContext
	Exit_stmt() IExit_stmtContext
	Fetch_stmt() IFetch_stmtContext
	For_cursor_stmt() IFor_cursor_stmtContext
	For_range_stmt() IFor_range_stmtContext
	If_stmt() IIf_stmtContext
	Include_stmt() IInclude_stmtContext
	Insert_stmt() IInsert_stmtContext
	Insert_directory_stmt() IInsert_directory_stmtContext
	Get_diag_stmt() IGet_diag_stmtContext
	Grant_stmt() IGrant_stmtContext
	Leave_stmt() ILeave_stmtContext
	Map_object_stmt() IMap_object_stmtContext
	Merge_stmt() IMerge_stmtContext
	Open_stmt() IOpen_stmtContext
	Print_stmt() IPrint_stmtContext
	Quit_stmt() IQuit_stmtContext
	Raise_stmt() IRaise_stmtContext
	Resignal_stmt() IResignal_stmtContext
	Return_stmt() IReturn_stmtContext
	Rollback_stmt() IRollback_stmtContext
	Select_stmt() ISelect_stmtContext
	Signal_stmt() ISignal_stmtContext
	Summary_stmt() ISummary_stmtContext
	Update_stmt() IUpdate_stmtContext
	Use_stmt() IUse_stmtContext
	Truncate_stmt() ITruncate_stmtContext
	Values_into_stmt() IValues_into_stmtContext
	While_stmt() IWhile_stmtContext
	Unconditional_loop_stmt() IUnconditional_loop_stmtContext
	Label() ILabelContext
	Hive() IHiveContext
	Host() IHostContext
	Null_stmt() INull_stmtContext
	Expr_stmt() IExpr_stmtContext
	Semicolon_stmt() ISemicolon_stmtContext

	// IsStmtContext differentiates from other interfaces.
	IsStmtContext()
}

type StmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmtContext() *StmtContext {
	var p = new(StmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_stmt
	return p
}

func InitEmptyStmtContext(p *StmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_stmt
}

func (*StmtContext) IsStmtContext() {}

func NewStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StmtContext {
	var p = new(StmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_stmt

	return p
}

func (s *StmtContext) GetParser() antlr.Parser { return s.parser }

func (s *StmtContext) Assignment_stmt() IAssignment_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignment_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignment_stmtContext)
}

func (s *StmtContext) Allocate_cursor_stmt() IAllocate_cursor_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAllocate_cursor_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAllocate_cursor_stmtContext)
}

func (s *StmtContext) Alter_table_stmt() IAlter_table_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_stmtContext)
}

func (s *StmtContext) Associate_locator_stmt() IAssociate_locator_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssociate_locator_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssociate_locator_stmtContext)
}

func (s *StmtContext) Begin_transaction_stmt() IBegin_transaction_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBegin_transaction_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBegin_transaction_stmtContext)
}

func (s *StmtContext) Break_stmt() IBreak_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreak_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreak_stmtContext)
}

func (s *StmtContext) Call_stmt() ICall_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICall_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICall_stmtContext)
}

func (s *StmtContext) Collect_stats_stmt() ICollect_stats_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollect_stats_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollect_stats_stmtContext)
}

func (s *StmtContext) Close_stmt() IClose_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClose_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClose_stmtContext)
}

func (s *StmtContext) Cmp_stmt() ICmp_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmp_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmp_stmtContext)
}

func (s *StmtContext) Copy_from_local_stmt() ICopy_from_local_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopy_from_local_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopy_from_local_stmtContext)
}

func (s *StmtContext) Copy_stmt() ICopy_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopy_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopy_stmtContext)
}

func (s *StmtContext) Commit_stmt() ICommit_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommit_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommit_stmtContext)
}

func (s *StmtContext) Create_database_stmt() ICreate_database_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_database_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_database_stmtContext)
}

func (s *StmtContext) Create_function_stmt() ICreate_function_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_function_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_function_stmtContext)
}

func (s *StmtContext) Create_index_stmt() ICreate_index_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_index_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_index_stmtContext)
}

func (s *StmtContext) Create_local_temp_table_stmt() ICreate_local_temp_table_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_local_temp_table_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_local_temp_table_stmtContext)
}

func (s *StmtContext) Create_package_stmt() ICreate_package_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_package_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_package_stmtContext)
}

func (s *StmtContext) Create_package_body_stmt() ICreate_package_body_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_package_body_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_package_body_stmtContext)
}

func (s *StmtContext) Create_procedure_stmt() ICreate_procedure_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_procedure_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_procedure_stmtContext)
}

func (s *StmtContext) Create_table_stmt() ICreate_table_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_stmtContext)
}

func (s *StmtContext) Create_table_type_stmt() ICreate_table_type_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_type_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_type_stmtContext)
}

func (s *StmtContext) Declare_stmt() IDeclare_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_stmtContext)
}

func (s *StmtContext) Delete_stmt() IDelete_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelete_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelete_stmtContext)
}

func (s *StmtContext) Describe_stmt() IDescribe_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescribe_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescribe_stmtContext)
}

func (s *StmtContext) Drop_stmt() IDrop_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDrop_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDrop_stmtContext)
}

func (s *StmtContext) End_transaction_stmt() IEnd_transaction_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnd_transaction_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnd_transaction_stmtContext)
}

func (s *StmtContext) Exec_stmt() IExec_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExec_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExec_stmtContext)
}

func (s *StmtContext) Exit_stmt() IExit_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExit_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExit_stmtContext)
}

func (s *StmtContext) Fetch_stmt() IFetch_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFetch_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFetch_stmtContext)
}

func (s *StmtContext) For_cursor_stmt() IFor_cursor_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFor_cursor_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFor_cursor_stmtContext)
}

func (s *StmtContext) For_range_stmt() IFor_range_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFor_range_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFor_range_stmtContext)
}

func (s *StmtContext) If_stmt() IIf_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIf_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIf_stmtContext)
}

func (s *StmtContext) Include_stmt() IInclude_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInclude_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInclude_stmtContext)
}

func (s *StmtContext) Insert_stmt() IInsert_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_stmtContext)
}

func (s *StmtContext) Insert_directory_stmt() IInsert_directory_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_directory_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_directory_stmtContext)
}

func (s *StmtContext) Get_diag_stmt() IGet_diag_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGet_diag_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGet_diag_stmtContext)
}

func (s *StmtContext) Grant_stmt() IGrant_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrant_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrant_stmtContext)
}

func (s *StmtContext) Leave_stmt() ILeave_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILeave_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILeave_stmtContext)
}

func (s *StmtContext) Map_object_stmt() IMap_object_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMap_object_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMap_object_stmtContext)
}

func (s *StmtContext) Merge_stmt() IMerge_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMerge_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMerge_stmtContext)
}

func (s *StmtContext) Open_stmt() IOpen_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpen_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpen_stmtContext)
}

func (s *StmtContext) Print_stmt() IPrint_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrint_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrint_stmtContext)
}

func (s *StmtContext) Quit_stmt() IQuit_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuit_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuit_stmtContext)
}

func (s *StmtContext) Raise_stmt() IRaise_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRaise_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRaise_stmtContext)
}

func (s *StmtContext) Resignal_stmt() IResignal_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResignal_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResignal_stmtContext)
}

func (s *StmtContext) Return_stmt() IReturn_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturn_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturn_stmtContext)
}

func (s *StmtContext) Rollback_stmt() IRollback_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollback_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollback_stmtContext)
}

func (s *StmtContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *StmtContext) Signal_stmt() ISignal_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignal_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignal_stmtContext)
}

func (s *StmtContext) Summary_stmt() ISummary_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISummary_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISummary_stmtContext)
}

func (s *StmtContext) Update_stmt() IUpdate_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdate_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdate_stmtContext)
}

func (s *StmtContext) Use_stmt() IUse_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUse_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUse_stmtContext)
}

func (s *StmtContext) Truncate_stmt() ITruncate_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITruncate_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITruncate_stmtContext)
}

func (s *StmtContext) Values_into_stmt() IValues_into_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValues_into_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValues_into_stmtContext)
}

func (s *StmtContext) While_stmt() IWhile_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhile_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhile_stmtContext)
}

func (s *StmtContext) Unconditional_loop_stmt() IUnconditional_loop_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnconditional_loop_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnconditional_loop_stmtContext)
}

func (s *StmtContext) Label() ILabelContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *StmtContext) Hive() IHiveContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHiveContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHiveContext)
}

func (s *StmtContext) Host() IHostContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHostContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHostContext)
}

func (s *StmtContext) Null_stmt() INull_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INull_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INull_stmtContext)
}

func (s *StmtContext) Expr_stmt() IExpr_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_stmtContext)
}

func (s *StmtContext) Semicolon_stmt() ISemicolon_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISemicolon_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISemicolon_stmtContext)
}

func (s *StmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterStmt(s)
	}
}

func (s *StmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitStmt(s)
	}
}




func (p *HplsqlParser) Stmt() (localctx IStmtContext) {
	localctx = NewStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, HplsqlParserRULE_stmt)
	p.SetState(592)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(529)
			p.Assignment_stmt()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(530)
			p.Allocate_cursor_stmt()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(531)
			p.Alter_table_stmt()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(532)
			p.Associate_locator_stmt()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(533)
			p.Begin_transaction_stmt()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(534)
			p.Break_stmt()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(535)
			p.Call_stmt()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(536)
			p.Collect_stats_stmt()
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(537)
			p.Close_stmt()
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(538)
			p.Cmp_stmt()
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(539)
			p.Copy_from_local_stmt()
		}


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(540)
			p.Copy_stmt()
		}


	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(541)
			p.Commit_stmt()
		}


	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(542)
			p.Create_database_stmt()
		}


	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(543)
			p.Create_function_stmt()
		}


	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(544)
			p.Create_index_stmt()
		}


	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(545)
			p.Create_local_temp_table_stmt()
		}


	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(546)
			p.Create_package_stmt()
		}


	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(547)
			p.Create_package_body_stmt()
		}


	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(548)
			p.Create_procedure_stmt()
		}


	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(549)
			p.Create_table_stmt()
		}


	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(550)
			p.Create_table_type_stmt()
		}


	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(551)
			p.Declare_stmt()
		}


	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(552)
			p.Delete_stmt()
		}


	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(553)
			p.Describe_stmt()
		}


	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(554)
			p.Drop_stmt()
		}


	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(555)
			p.End_transaction_stmt()
		}


	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(556)
			p.Exec_stmt()
		}


	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(557)
			p.Exit_stmt()
		}


	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(558)
			p.Fetch_stmt()
		}


	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(559)
			p.For_cursor_stmt()
		}


	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(560)
			p.For_range_stmt()
		}


	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(561)
			p.If_stmt()
		}


	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(562)
			p.Include_stmt()
		}


	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(563)
			p.Insert_stmt()
		}


	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(564)
			p.Insert_directory_stmt()
		}


	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(565)
			p.Get_diag_stmt()
		}


	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(566)
			p.Grant_stmt()
		}


	case 39:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(567)
			p.Leave_stmt()
		}


	case 40:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(568)
			p.Map_object_stmt()
		}


	case 41:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(569)
			p.Merge_stmt()
		}


	case 42:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(570)
			p.Open_stmt()
		}


	case 43:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(571)
			p.Print_stmt()
		}


	case 44:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(572)
			p.Quit_stmt()
		}


	case 45:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(573)
			p.Raise_stmt()
		}


	case 46:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(574)
			p.Resignal_stmt()
		}


	case 47:
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(575)
			p.Return_stmt()
		}


	case 48:
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(576)
			p.Rollback_stmt()
		}


	case 49:
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(577)
			p.Select_stmt()
		}


	case 50:
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(578)
			p.Signal_stmt()
		}


	case 51:
		p.EnterOuterAlt(localctx, 51)
		{
			p.SetState(579)
			p.Summary_stmt()
		}


	case 52:
		p.EnterOuterAlt(localctx, 52)
		{
			p.SetState(580)
			p.Update_stmt()
		}


	case 53:
		p.EnterOuterAlt(localctx, 53)
		{
			p.SetState(581)
			p.Use_stmt()
		}


	case 54:
		p.EnterOuterAlt(localctx, 54)
		{
			p.SetState(582)
			p.Truncate_stmt()
		}


	case 55:
		p.EnterOuterAlt(localctx, 55)
		{
			p.SetState(583)
			p.Values_into_stmt()
		}


	case 56:
		p.EnterOuterAlt(localctx, 56)
		{
			p.SetState(584)
			p.While_stmt()
		}


	case 57:
		p.EnterOuterAlt(localctx, 57)
		{
			p.SetState(585)
			p.Unconditional_loop_stmt()
		}


	case 58:
		p.EnterOuterAlt(localctx, 58)
		{
			p.SetState(586)
			p.Label()
		}


	case 59:
		p.EnterOuterAlt(localctx, 59)
		{
			p.SetState(587)
			p.Hive()
		}


	case 60:
		p.EnterOuterAlt(localctx, 60)
		{
			p.SetState(588)
			p.Host()
		}


	case 61:
		p.EnterOuterAlt(localctx, 61)
		{
			p.SetState(589)
			p.Null_stmt()
		}


	case 62:
		p.EnterOuterAlt(localctx, 62)
		{
			p.SetState(590)
			p.Expr_stmt()
		}


	case 63:
		p.EnterOuterAlt(localctx, 63)
		{
			p.SetState(591)
			p.Semicolon_stmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISemicolon_stmtContext is an interface to support dynamic dispatch.
type ISemicolon_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_SEMICOLON() antlr.TerminalNode
	T_DIV() antlr.TerminalNode

	// IsSemicolon_stmtContext differentiates from other interfaces.
	IsSemicolon_stmtContext()
}

type Semicolon_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySemicolon_stmtContext() *Semicolon_stmtContext {
	var p = new(Semicolon_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_semicolon_stmt
	return p
}

func InitEmptySemicolon_stmtContext(p *Semicolon_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_semicolon_stmt
}

func (*Semicolon_stmtContext) IsSemicolon_stmtContext() {}

func NewSemicolon_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Semicolon_stmtContext {
	var p = new(Semicolon_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_semicolon_stmt

	return p
}

func (s *Semicolon_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Semicolon_stmtContext) T_SEMICOLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEMICOLON, 0)
}

func (s *Semicolon_stmtContext) T_DIV() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DIV, 0)
}

func (s *Semicolon_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Semicolon_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Semicolon_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSemicolon_stmt(s)
	}
}

func (s *Semicolon_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSemicolon_stmt(s)
	}
}




func (p *HplsqlParser) Semicolon_stmt() (localctx ISemicolon_stmtContext) {
	localctx = NewSemicolon_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, HplsqlParserRULE_semicolon_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(594)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT__0 || _la == HplsqlParserT__1 || _la == HplsqlParserT_DIV || _la == HplsqlParserT_SEMICOLON) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IException_blockContext is an interface to support dynamic dispatch.
type IException_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_EXCEPTION() antlr.TerminalNode
	AllException_block_item() []IException_block_itemContext
	Exception_block_item(i int) IException_block_itemContext

	// IsException_blockContext differentiates from other interfaces.
	IsException_blockContext()
}

type Exception_blockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyException_blockContext() *Exception_blockContext {
	var p = new(Exception_blockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_exception_block
	return p
}

func InitEmptyException_blockContext(p *Exception_blockContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_exception_block
}

func (*Exception_blockContext) IsException_blockContext() {}

func NewException_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exception_blockContext {
	var p = new(Exception_blockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_exception_block

	return p
}

func (s *Exception_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Exception_blockContext) T_EXCEPTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXCEPTION, 0)
}

func (s *Exception_blockContext) AllException_block_item() []IException_block_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IException_block_itemContext); ok {
			len++
		}
	}

	tst := make([]IException_block_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IException_block_itemContext); ok {
			tst[i] = t.(IException_block_itemContext)
			i++
		}
	}

	return tst
}

func (s *Exception_blockContext) Exception_block_item(i int) IException_block_itemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IException_block_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IException_block_itemContext)
}

func (s *Exception_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exception_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Exception_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterException_block(s)
	}
}

func (s *Exception_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitException_block(s)
	}
}




func (p *HplsqlParser) Exception_block() (localctx IException_blockContext) {
	localctx = NewException_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, HplsqlParserRULE_exception_block)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(596)
		p.Match(HplsqlParserT_EXCEPTION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(598)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				{
					p.SetState(597)
					p.Exception_block_item()
				}




		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(600)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IException_block_itemContext is an interface to support dynamic dispatch.
type IException_block_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllT_WHEN() []antlr.TerminalNode
	T_WHEN(i int) antlr.TerminalNode
	L_ID() antlr.TerminalNode
	T_THEN() antlr.TerminalNode
	Block() IBlockContext
	T_END() antlr.TerminalNode

	// IsException_block_itemContext differentiates from other interfaces.
	IsException_block_itemContext()
}

type Exception_block_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyException_block_itemContext() *Exception_block_itemContext {
	var p = new(Exception_block_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_exception_block_item
	return p
}

func InitEmptyException_block_itemContext(p *Exception_block_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_exception_block_item
}

func (*Exception_block_itemContext) IsException_block_itemContext() {}

func NewException_block_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exception_block_itemContext {
	var p = new(Exception_block_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_exception_block_item

	return p
}

func (s *Exception_block_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Exception_block_itemContext) AllT_WHEN() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_WHEN)
}

func (s *Exception_block_itemContext) T_WHEN(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WHEN, i)
}

func (s *Exception_block_itemContext) L_ID() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, 0)
}

func (s *Exception_block_itemContext) T_THEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_THEN, 0)
}

func (s *Exception_block_itemContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *Exception_block_itemContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *Exception_block_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exception_block_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Exception_block_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterException_block_item(s)
	}
}

func (s *Exception_block_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitException_block_item(s)
	}
}




func (p *HplsqlParser) Exception_block_item() (localctx IException_block_itemContext) {
	localctx = NewException_block_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, HplsqlParserRULE_exception_block_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(602)
		p.Match(HplsqlParserT_WHEN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(603)
		p.Match(HplsqlParserL_ID)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(604)
		p.Match(HplsqlParserT_THEN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(605)
		p.Block()
	}
	{
		p.SetState(606)
		_la = p.GetTokenStream().LA(1)

		if _la <= 0 || _la == HplsqlParserT_END || _la == HplsqlParserT_WHEN  {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INull_stmtContext is an interface to support dynamic dispatch.
type INull_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_NULL() antlr.TerminalNode

	// IsNull_stmtContext differentiates from other interfaces.
	IsNull_stmtContext()
}

type Null_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNull_stmtContext() *Null_stmtContext {
	var p = new(Null_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_null_stmt
	return p
}

func InitEmptyNull_stmtContext(p *Null_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_null_stmt
}

func (*Null_stmtContext) IsNull_stmtContext() {}

func NewNull_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Null_stmtContext {
	var p = new(Null_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_null_stmt

	return p
}

func (s *Null_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Null_stmtContext) T_NULL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NULL, 0)
}

func (s *Null_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Null_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Null_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterNull_stmt(s)
	}
}

func (s *Null_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitNull_stmt(s)
	}
}




func (p *HplsqlParser) Null_stmt() (localctx INull_stmtContext) {
	localctx = NewNull_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, HplsqlParserRULE_null_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(608)
		p.Match(HplsqlParserT_NULL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpr_stmtContext is an interface to support dynamic dispatch.
type IExpr_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext

	// IsExpr_stmtContext differentiates from other interfaces.
	IsExpr_stmtContext()
}

type Expr_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_stmtContext() *Expr_stmtContext {
	var p = new(Expr_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_stmt
	return p
}

func InitEmptyExpr_stmtContext(p *Expr_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_stmt
}

func (*Expr_stmtContext) IsExpr_stmtContext() {}

func NewExpr_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_stmtContext {
	var p = new(Expr_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_stmt

	return p
}

func (s *Expr_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expr_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_stmt(s)
	}
}

func (s *Expr_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_stmt(s)
	}
}




func (p *HplsqlParser) Expr_stmt() (localctx IExpr_stmtContext) {
	localctx = NewExpr_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, HplsqlParserRULE_expr_stmt)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(610)

	if !(!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "GO")) {
		p.SetError(antlr.NewFailedPredicateException(p, "!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"GO\")", ""))
		goto errorExit
	}
	{
		p.SetState(611)
		p.expr(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAssignment_stmtContext is an interface to support dynamic dispatch.
type IAssignment_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_SET() antlr.TerminalNode
	Set_session_option() ISet_session_optionContext
	AllAssignment_stmt_item() []IAssignment_stmt_itemContext
	Assignment_stmt_item(i int) IAssignment_stmt_itemContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsAssignment_stmtContext differentiates from other interfaces.
	IsAssignment_stmtContext()
}

type Assignment_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_stmtContext() *Assignment_stmtContext {
	var p = new(Assignment_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt
	return p
}

func InitEmptyAssignment_stmtContext(p *Assignment_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt
}

func (*Assignment_stmtContext) IsAssignment_stmtContext() {}

func NewAssignment_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_stmtContext {
	var p = new(Assignment_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_assignment_stmt

	return p
}

func (s *Assignment_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_stmtContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Assignment_stmtContext) Set_session_option() ISet_session_optionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_session_optionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_session_optionContext)
}

func (s *Assignment_stmtContext) AllAssignment_stmt_item() []IAssignment_stmt_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignment_stmt_itemContext); ok {
			len++
		}
	}

	tst := make([]IAssignment_stmt_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignment_stmt_itemContext); ok {
			tst[i] = t.(IAssignment_stmt_itemContext)
			i++
		}
	}

	return tst
}

func (s *Assignment_stmtContext) Assignment_stmt_item(i int) IAssignment_stmt_itemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignment_stmt_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignment_stmt_itemContext)
}

func (s *Assignment_stmtContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Assignment_stmtContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Assignment_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Assignment_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAssignment_stmt(s)
	}
}

func (s *Assignment_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAssignment_stmt(s)
	}
}




func (p *HplsqlParser) Assignment_stmt() (localctx IAssignment_stmtContext) {
	localctx = NewAssignment_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, HplsqlParserRULE_assignment_stmt)
	var _alt int

	p.SetState(626)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(613)
			p.Match(HplsqlParserT_SET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(614)
			p.Set_session_option()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(616)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(615)
				p.Match(HplsqlParserT_SET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(618)
			p.Assignment_stmt_item()
		}
		p.SetState(623)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(619)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(620)
					p.Assignment_stmt_item()
				}


			}
			p.SetState(625)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAssignment_stmt_itemContext is an interface to support dynamic dispatch.
type IAssignment_stmt_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Assignment_stmt_single_item() IAssignment_stmt_single_itemContext
	Assignment_stmt_multiple_item() IAssignment_stmt_multiple_itemContext
	Assignment_stmt_select_item() IAssignment_stmt_select_itemContext
	Assignment_stmt_collection_item() IAssignment_stmt_collection_itemContext

	// IsAssignment_stmt_itemContext differentiates from other interfaces.
	IsAssignment_stmt_itemContext()
}

type Assignment_stmt_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_stmt_itemContext() *Assignment_stmt_itemContext {
	var p = new(Assignment_stmt_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_item
	return p
}

func InitEmptyAssignment_stmt_itemContext(p *Assignment_stmt_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_item
}

func (*Assignment_stmt_itemContext) IsAssignment_stmt_itemContext() {}

func NewAssignment_stmt_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_stmt_itemContext {
	var p = new(Assignment_stmt_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_item

	return p
}

func (s *Assignment_stmt_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_stmt_itemContext) Assignment_stmt_single_item() IAssignment_stmt_single_itemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignment_stmt_single_itemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignment_stmt_single_itemContext)
}

func (s *Assignment_stmt_itemContext) Assignment_stmt_multiple_item() IAssignment_stmt_multiple_itemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignment_stmt_multiple_itemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignment_stmt_multiple_itemContext)
}

func (s *Assignment_stmt_itemContext) Assignment_stmt_select_item() IAssignment_stmt_select_itemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignment_stmt_select_itemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignment_stmt_select_itemContext)
}

func (s *Assignment_stmt_itemContext) Assignment_stmt_collection_item() IAssignment_stmt_collection_itemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignment_stmt_collection_itemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignment_stmt_collection_itemContext)
}

func (s *Assignment_stmt_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_stmt_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Assignment_stmt_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAssignment_stmt_item(s)
	}
}

func (s *Assignment_stmt_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAssignment_stmt_item(s)
	}
}




func (p *HplsqlParser) Assignment_stmt_item() (localctx IAssignment_stmt_itemContext) {
	localctx = NewAssignment_stmt_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, HplsqlParserRULE_assignment_stmt_item)
	p.SetState(632)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(628)
			p.Assignment_stmt_single_item()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(629)
			p.Assignment_stmt_multiple_item()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(630)
			p.Assignment_stmt_select_item()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(631)
			p.Assignment_stmt_collection_item()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAssignment_stmt_single_itemContext is an interface to support dynamic dispatch.
type IAssignment_stmt_single_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Qident() IQidentContext
	T_EQUAL() antlr.TerminalNode
	Expr() IExprContext
	T_COLON() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode

	// IsAssignment_stmt_single_itemContext differentiates from other interfaces.
	IsAssignment_stmt_single_itemContext()
}

type Assignment_stmt_single_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_stmt_single_itemContext() *Assignment_stmt_single_itemContext {
	var p = new(Assignment_stmt_single_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_single_item
	return p
}

func InitEmptyAssignment_stmt_single_itemContext(p *Assignment_stmt_single_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_single_item
}

func (*Assignment_stmt_single_itemContext) IsAssignment_stmt_single_itemContext() {}

func NewAssignment_stmt_single_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_stmt_single_itemContext {
	var p = new(Assignment_stmt_single_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_single_item

	return p
}

func (s *Assignment_stmt_single_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_stmt_single_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Assignment_stmt_single_itemContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Assignment_stmt_single_itemContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Assignment_stmt_single_itemContext) T_COLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLON, 0)
}

func (s *Assignment_stmt_single_itemContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Assignment_stmt_single_itemContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Assignment_stmt_single_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_stmt_single_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Assignment_stmt_single_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAssignment_stmt_single_item(s)
	}
}

func (s *Assignment_stmt_single_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAssignment_stmt_single_item(s)
	}
}




func (p *HplsqlParser) Assignment_stmt_single_item() (localctx IAssignment_stmt_single_itemContext) {
	localctx = NewAssignment_stmt_single_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, HplsqlParserRULE_assignment_stmt_single_item)
	var _la int

	p.SetState(650)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_SUB, HplsqlParserL_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(634)
			p.Qident()
		}
		p.SetState(636)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_COLON {
			{
				p.SetState(635)
				p.Match(HplsqlParserT_COLON)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(638)
			p.Match(HplsqlParserT_EQUAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(639)
			p.expr(0)
		}


	case HplsqlParserT_OPEN_P:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(641)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(642)
			p.Qident()
		}
		{
			p.SetState(643)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(645)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_COLON {
			{
				p.SetState(644)
				p.Match(HplsqlParserT_COLON)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(647)
			p.Match(HplsqlParserT_EQUAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(648)
			p.expr(0)
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAssignment_stmt_collection_itemContext is an interface to support dynamic dispatch.
type IAssignment_stmt_collection_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr_func() IExpr_funcContext
	T_COLON() antlr.TerminalNode
	T_EQUAL() antlr.TerminalNode
	Expr() IExprContext

	// IsAssignment_stmt_collection_itemContext differentiates from other interfaces.
	IsAssignment_stmt_collection_itemContext()
}

type Assignment_stmt_collection_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_stmt_collection_itemContext() *Assignment_stmt_collection_itemContext {
	var p = new(Assignment_stmt_collection_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_collection_item
	return p
}

func InitEmptyAssignment_stmt_collection_itemContext(p *Assignment_stmt_collection_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_collection_item
}

func (*Assignment_stmt_collection_itemContext) IsAssignment_stmt_collection_itemContext() {}

func NewAssignment_stmt_collection_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_stmt_collection_itemContext {
	var p = new(Assignment_stmt_collection_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_collection_item

	return p
}

func (s *Assignment_stmt_collection_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_stmt_collection_itemContext) Expr_func() IExpr_funcContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_funcContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_funcContext)
}

func (s *Assignment_stmt_collection_itemContext) T_COLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLON, 0)
}

func (s *Assignment_stmt_collection_itemContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Assignment_stmt_collection_itemContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Assignment_stmt_collection_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_stmt_collection_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Assignment_stmt_collection_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAssignment_stmt_collection_item(s)
	}
}

func (s *Assignment_stmt_collection_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAssignment_stmt_collection_item(s)
	}
}




func (p *HplsqlParser) Assignment_stmt_collection_item() (localctx IAssignment_stmt_collection_itemContext) {
	localctx = NewAssignment_stmt_collection_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, HplsqlParserRULE_assignment_stmt_collection_item)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(652)
		p.Expr_func()
	}
	{
		p.SetState(653)
		p.Match(HplsqlParserT_COLON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(654)
		p.Match(HplsqlParserT_EQUAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(655)
		p.expr(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAssignment_stmt_multiple_itemContext is an interface to support dynamic dispatch.
type IAssignment_stmt_multiple_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllT_OPEN_P() []antlr.TerminalNode
	T_OPEN_P(i int) antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	AllT_CLOSE_P() []antlr.TerminalNode
	T_CLOSE_P(i int) antlr.TerminalNode
	T_EQUAL() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	T_COLON() antlr.TerminalNode

	// IsAssignment_stmt_multiple_itemContext differentiates from other interfaces.
	IsAssignment_stmt_multiple_itemContext()
}

type Assignment_stmt_multiple_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_stmt_multiple_itemContext() *Assignment_stmt_multiple_itemContext {
	var p = new(Assignment_stmt_multiple_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_multiple_item
	return p
}

func InitEmptyAssignment_stmt_multiple_itemContext(p *Assignment_stmt_multiple_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_multiple_item
}

func (*Assignment_stmt_multiple_itemContext) IsAssignment_stmt_multiple_itemContext() {}

func NewAssignment_stmt_multiple_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_stmt_multiple_itemContext {
	var p = new(Assignment_stmt_multiple_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_multiple_item

	return p
}

func (s *Assignment_stmt_multiple_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_stmt_multiple_itemContext) AllT_OPEN_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_OPEN_P)
}

func (s *Assignment_stmt_multiple_itemContext) T_OPEN_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, i)
}

func (s *Assignment_stmt_multiple_itemContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Assignment_stmt_multiple_itemContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Assignment_stmt_multiple_itemContext) AllT_CLOSE_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_CLOSE_P)
}

func (s *Assignment_stmt_multiple_itemContext) T_CLOSE_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, i)
}

func (s *Assignment_stmt_multiple_itemContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Assignment_stmt_multiple_itemContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Assignment_stmt_multiple_itemContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Assignment_stmt_multiple_itemContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Assignment_stmt_multiple_itemContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Assignment_stmt_multiple_itemContext) T_COLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLON, 0)
}

func (s *Assignment_stmt_multiple_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_stmt_multiple_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Assignment_stmt_multiple_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAssignment_stmt_multiple_item(s)
	}
}

func (s *Assignment_stmt_multiple_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAssignment_stmt_multiple_item(s)
	}
}




func (p *HplsqlParser) Assignment_stmt_multiple_item() (localctx IAssignment_stmt_multiple_itemContext) {
	localctx = NewAssignment_stmt_multiple_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, HplsqlParserRULE_assignment_stmt_multiple_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(657)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(658)
		p.Ident()
	}
	p.SetState(663)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(659)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(660)
			p.Ident()
		}


		p.SetState(665)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(666)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(668)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_COLON {
		{
			p.SetState(667)
			p.Match(HplsqlParserT_COLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(670)
		p.Match(HplsqlParserT_EQUAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(671)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(672)
		p.expr(0)
	}
	p.SetState(677)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(673)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(674)
			p.expr(0)
		}


		p.SetState(679)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(680)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAssignment_stmt_select_itemContext is an interface to support dynamic dispatch.
type IAssignment_stmt_select_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_EQUAL() antlr.TerminalNode
	AllT_OPEN_P() []antlr.TerminalNode
	T_OPEN_P(i int) antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	AllT_CLOSE_P() []antlr.TerminalNode
	T_CLOSE_P(i int) antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	T_COLON() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsAssignment_stmt_select_itemContext differentiates from other interfaces.
	IsAssignment_stmt_select_itemContext()
}

type Assignment_stmt_select_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_stmt_select_itemContext() *Assignment_stmt_select_itemContext {
	var p = new(Assignment_stmt_select_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_select_item
	return p
}

func InitEmptyAssignment_stmt_select_itemContext(p *Assignment_stmt_select_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_select_item
}

func (*Assignment_stmt_select_itemContext) IsAssignment_stmt_select_itemContext() {}

func NewAssignment_stmt_select_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_stmt_select_itemContext {
	var p = new(Assignment_stmt_select_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_assignment_stmt_select_item

	return p
}

func (s *Assignment_stmt_select_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_stmt_select_itemContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Assignment_stmt_select_itemContext) AllT_OPEN_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_OPEN_P)
}

func (s *Assignment_stmt_select_itemContext) T_OPEN_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, i)
}

func (s *Assignment_stmt_select_itemContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Assignment_stmt_select_itemContext) AllT_CLOSE_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_CLOSE_P)
}

func (s *Assignment_stmt_select_itemContext) T_CLOSE_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, i)
}

func (s *Assignment_stmt_select_itemContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Assignment_stmt_select_itemContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Assignment_stmt_select_itemContext) T_COLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLON, 0)
}

func (s *Assignment_stmt_select_itemContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Assignment_stmt_select_itemContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Assignment_stmt_select_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_stmt_select_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Assignment_stmt_select_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAssignment_stmt_select_item(s)
	}
}

func (s *Assignment_stmt_select_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAssignment_stmt_select_item(s)
	}
}




func (p *HplsqlParser) Assignment_stmt_select_item() (localctx IAssignment_stmt_select_itemContext) {
	localctx = NewAssignment_stmt_select_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, HplsqlParserRULE_assignment_stmt_select_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(694)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_SUB, HplsqlParserL_ID:
		{
			p.SetState(682)
			p.Ident()
		}


	case HplsqlParserT_OPEN_P:
		{
			p.SetState(683)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(684)
			p.Ident()
		}
		p.SetState(689)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(685)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(686)
				p.Ident()
			}


			p.SetState(691)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(692)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}




	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(697)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_COLON {
		{
			p.SetState(696)
			p.Match(HplsqlParserT_COLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(699)
		p.Match(HplsqlParserT_EQUAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(700)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(701)
		p.Select_stmt()
	}
	{
		p.SetState(702)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAllocate_cursor_stmtContext is an interface to support dynamic dispatch.
type IAllocate_cursor_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ALLOCATE() antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	T_CURSOR() antlr.TerminalNode
	T_FOR() antlr.TerminalNode
	T_PROCEDURE() antlr.TerminalNode
	T_RESULT() antlr.TerminalNode
	T_SET() antlr.TerminalNode

	// IsAllocate_cursor_stmtContext differentiates from other interfaces.
	IsAllocate_cursor_stmtContext()
}

type Allocate_cursor_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAllocate_cursor_stmtContext() *Allocate_cursor_stmtContext {
	var p = new(Allocate_cursor_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_allocate_cursor_stmt
	return p
}

func InitEmptyAllocate_cursor_stmtContext(p *Allocate_cursor_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_allocate_cursor_stmt
}

func (*Allocate_cursor_stmtContext) IsAllocate_cursor_stmtContext() {}

func NewAllocate_cursor_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Allocate_cursor_stmtContext {
	var p = new(Allocate_cursor_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_allocate_cursor_stmt

	return p
}

func (s *Allocate_cursor_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Allocate_cursor_stmtContext) T_ALLOCATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALLOCATE, 0)
}

func (s *Allocate_cursor_stmtContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Allocate_cursor_stmtContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Allocate_cursor_stmtContext) T_CURSOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURSOR, 0)
}

func (s *Allocate_cursor_stmtContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *Allocate_cursor_stmtContext) T_PROCEDURE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PROCEDURE, 0)
}

func (s *Allocate_cursor_stmtContext) T_RESULT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESULT, 0)
}

func (s *Allocate_cursor_stmtContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Allocate_cursor_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Allocate_cursor_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Allocate_cursor_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAllocate_cursor_stmt(s)
	}
}

func (s *Allocate_cursor_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAllocate_cursor_stmt(s)
	}
}




func (p *HplsqlParser) Allocate_cursor_stmt() (localctx IAllocate_cursor_stmtContext) {
	localctx = NewAllocate_cursor_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, HplsqlParserRULE_allocate_cursor_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(704)
		p.Match(HplsqlParserT_ALLOCATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(705)
		p.Ident()
	}
	{
		p.SetState(706)
		p.Match(HplsqlParserT_CURSOR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(707)
		p.Match(HplsqlParserT_FOR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(711)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_RESULT:
		{
			p.SetState(708)
			p.Match(HplsqlParserT_RESULT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(709)
			p.Match(HplsqlParserT_SET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	case HplsqlParserT_PROCEDURE:
		{
			p.SetState(710)
			p.Match(HplsqlParserT_PROCEDURE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(713)
		p.Ident()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAssociate_locator_stmtContext is an interface to support dynamic dispatch.
type IAssociate_locator_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ASSOCIATE() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	T_CLOSE_P() antlr.TerminalNode
	T_WITH() antlr.TerminalNode
	T_PROCEDURE() antlr.TerminalNode
	T_LOCATOR() antlr.TerminalNode
	T_LOCATORS() antlr.TerminalNode
	T_RESULT() antlr.TerminalNode
	T_SET() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsAssociate_locator_stmtContext differentiates from other interfaces.
	IsAssociate_locator_stmtContext()
}

type Associate_locator_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssociate_locator_stmtContext() *Associate_locator_stmtContext {
	var p = new(Associate_locator_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_associate_locator_stmt
	return p
}

func InitEmptyAssociate_locator_stmtContext(p *Associate_locator_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_associate_locator_stmt
}

func (*Associate_locator_stmtContext) IsAssociate_locator_stmtContext() {}

func NewAssociate_locator_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Associate_locator_stmtContext {
	var p = new(Associate_locator_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_associate_locator_stmt

	return p
}

func (s *Associate_locator_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Associate_locator_stmtContext) T_ASSOCIATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ASSOCIATE, 0)
}

func (s *Associate_locator_stmtContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Associate_locator_stmtContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Associate_locator_stmtContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Associate_locator_stmtContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Associate_locator_stmtContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITH, 0)
}

func (s *Associate_locator_stmtContext) T_PROCEDURE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PROCEDURE, 0)
}

func (s *Associate_locator_stmtContext) T_LOCATOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCATOR, 0)
}

func (s *Associate_locator_stmtContext) T_LOCATORS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCATORS, 0)
}

func (s *Associate_locator_stmtContext) T_RESULT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESULT, 0)
}

func (s *Associate_locator_stmtContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Associate_locator_stmtContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Associate_locator_stmtContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Associate_locator_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Associate_locator_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Associate_locator_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAssociate_locator_stmt(s)
	}
}

func (s *Associate_locator_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAssociate_locator_stmt(s)
	}
}




func (p *HplsqlParser) Associate_locator_stmt() (localctx IAssociate_locator_stmtContext) {
	localctx = NewAssociate_locator_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, HplsqlParserRULE_associate_locator_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(715)
		p.Match(HplsqlParserT_ASSOCIATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(718)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_RESULT {
		{
			p.SetState(716)
			p.Match(HplsqlParserT_RESULT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(717)
			p.Match(HplsqlParserT_SET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(720)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_LOCATOR || _la == HplsqlParserT_LOCATORS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(721)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(722)
		p.Ident()
	}
	p.SetState(727)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(723)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(724)
			p.Ident()
		}


		p.SetState(729)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(730)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(731)
		p.Match(HplsqlParserT_WITH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(732)
		p.Match(HplsqlParserT_PROCEDURE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(733)
		p.Ident()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBegin_transaction_stmtContext is an interface to support dynamic dispatch.
type IBegin_transaction_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_BEGIN() antlr.TerminalNode
	T_TRANSACTION() antlr.TerminalNode

	// IsBegin_transaction_stmtContext differentiates from other interfaces.
	IsBegin_transaction_stmtContext()
}

type Begin_transaction_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBegin_transaction_stmtContext() *Begin_transaction_stmtContext {
	var p = new(Begin_transaction_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_begin_transaction_stmt
	return p
}

func InitEmptyBegin_transaction_stmtContext(p *Begin_transaction_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_begin_transaction_stmt
}

func (*Begin_transaction_stmtContext) IsBegin_transaction_stmtContext() {}

func NewBegin_transaction_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Begin_transaction_stmtContext {
	var p = new(Begin_transaction_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_begin_transaction_stmt

	return p
}

func (s *Begin_transaction_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Begin_transaction_stmtContext) T_BEGIN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BEGIN, 0)
}

func (s *Begin_transaction_stmtContext) T_TRANSACTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TRANSACTION, 0)
}

func (s *Begin_transaction_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Begin_transaction_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Begin_transaction_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBegin_transaction_stmt(s)
	}
}

func (s *Begin_transaction_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBegin_transaction_stmt(s)
	}
}




func (p *HplsqlParser) Begin_transaction_stmt() (localctx IBegin_transaction_stmtContext) {
	localctx = NewBegin_transaction_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, HplsqlParserRULE_begin_transaction_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(735)
		p.Match(HplsqlParserT_BEGIN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(736)
		p.Match(HplsqlParserT_TRANSACTION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBreak_stmtContext is an interface to support dynamic dispatch.
type IBreak_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_BREAK() antlr.TerminalNode

	// IsBreak_stmtContext differentiates from other interfaces.
	IsBreak_stmtContext()
}

type Break_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreak_stmtContext() *Break_stmtContext {
	var p = new(Break_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_break_stmt
	return p
}

func InitEmptyBreak_stmtContext(p *Break_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_break_stmt
}

func (*Break_stmtContext) IsBreak_stmtContext() {}

func NewBreak_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Break_stmtContext {
	var p = new(Break_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_break_stmt

	return p
}

func (s *Break_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Break_stmtContext) T_BREAK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BREAK, 0)
}

func (s *Break_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Break_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Break_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBreak_stmt(s)
	}
}

func (s *Break_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBreak_stmt(s)
	}
}




func (p *HplsqlParser) Break_stmt() (localctx IBreak_stmtContext) {
	localctx = NewBreak_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, HplsqlParserRULE_break_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(738)
		p.Match(HplsqlParserT_BREAK)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICall_stmtContext is an interface to support dynamic dispatch.
type ICall_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_CALL() antlr.TerminalNode
	Expr_dot() IExpr_dotContext
	Expr_func() IExpr_funcContext
	Ident() IIdentContext

	// IsCall_stmtContext differentiates from other interfaces.
	IsCall_stmtContext()
}

type Call_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCall_stmtContext() *Call_stmtContext {
	var p = new(Call_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_call_stmt
	return p
}

func InitEmptyCall_stmtContext(p *Call_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_call_stmt
}

func (*Call_stmtContext) IsCall_stmtContext() {}

func NewCall_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Call_stmtContext {
	var p = new(Call_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_call_stmt

	return p
}

func (s *Call_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Call_stmtContext) T_CALL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CALL, 0)
}

func (s *Call_stmtContext) Expr_dot() IExpr_dotContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_dotContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_dotContext)
}

func (s *Call_stmtContext) Expr_func() IExpr_funcContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_funcContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_funcContext)
}

func (s *Call_stmtContext) Ident() IIdentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Call_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Call_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Call_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCall_stmt(s)
	}
}

func (s *Call_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCall_stmt(s)
	}
}




func (p *HplsqlParser) Call_stmt() (localctx ICall_stmtContext) {
	localctx = NewCall_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, HplsqlParserRULE_call_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(740)
		p.Match(HplsqlParserT_CALL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(744)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(741)
			p.Expr_dot()
		}


	case 2:
		{
			p.SetState(742)
			p.Expr_func()
		}


	case 3:
		{
			p.SetState(743)
			p.Ident()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDeclare_stmtContext is an interface to support dynamic dispatch.
type IDeclare_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_DECLARE() antlr.TerminalNode
	AllDeclare_stmt_item() []IDeclare_stmt_itemContext
	Declare_stmt_item(i int) IDeclare_stmt_itemContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsDeclare_stmtContext differentiates from other interfaces.
	IsDeclare_stmtContext()
}

type Declare_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclare_stmtContext() *Declare_stmtContext {
	var p = new(Declare_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_stmt
	return p
}

func InitEmptyDeclare_stmtContext(p *Declare_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_stmt
}

func (*Declare_stmtContext) IsDeclare_stmtContext() {}

func NewDeclare_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declare_stmtContext {
	var p = new(Declare_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_declare_stmt

	return p
}

func (s *Declare_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Declare_stmtContext) T_DECLARE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DECLARE, 0)
}

func (s *Declare_stmtContext) AllDeclare_stmt_item() []IDeclare_stmt_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclare_stmt_itemContext); ok {
			len++
		}
	}

	tst := make([]IDeclare_stmt_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclare_stmt_itemContext); ok {
			tst[i] = t.(IDeclare_stmt_itemContext)
			i++
		}
	}

	return tst
}

func (s *Declare_stmtContext) Declare_stmt_item(i int) IDeclare_stmt_itemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_stmt_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_stmt_itemContext)
}

func (s *Declare_stmtContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Declare_stmtContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Declare_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declare_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Declare_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDeclare_stmt(s)
	}
}

func (s *Declare_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDeclare_stmt(s)
	}
}




func (p *HplsqlParser) Declare_stmt() (localctx IDeclare_stmtContext) {
	localctx = NewDeclare_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, HplsqlParserRULE_declare_stmt)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(746)
		p.Match(HplsqlParserT_DECLARE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(747)
		p.Declare_stmt_item()
	}
	p.SetState(752)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(748)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(749)
				p.Declare_stmt_item()
			}


		}
		p.SetState(754)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDeclare_blockContext is an interface to support dynamic dispatch.
type IDeclare_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_DECLARE() antlr.TerminalNode
	AllDeclare_stmt_item() []IDeclare_stmt_itemContext
	Declare_stmt_item(i int) IDeclare_stmt_itemContext
	AllT_SEMICOLON() []antlr.TerminalNode
	T_SEMICOLON(i int) antlr.TerminalNode

	// IsDeclare_blockContext differentiates from other interfaces.
	IsDeclare_blockContext()
}

type Declare_blockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclare_blockContext() *Declare_blockContext {
	var p = new(Declare_blockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_block
	return p
}

func InitEmptyDeclare_blockContext(p *Declare_blockContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_block
}

func (*Declare_blockContext) IsDeclare_blockContext() {}

func NewDeclare_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declare_blockContext {
	var p = new(Declare_blockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_declare_block

	return p
}

func (s *Declare_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Declare_blockContext) T_DECLARE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DECLARE, 0)
}

func (s *Declare_blockContext) AllDeclare_stmt_item() []IDeclare_stmt_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclare_stmt_itemContext); ok {
			len++
		}
	}

	tst := make([]IDeclare_stmt_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclare_stmt_itemContext); ok {
			tst[i] = t.(IDeclare_stmt_itemContext)
			i++
		}
	}

	return tst
}

func (s *Declare_blockContext) Declare_stmt_item(i int) IDeclare_stmt_itemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_stmt_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_stmt_itemContext)
}

func (s *Declare_blockContext) AllT_SEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_SEMICOLON)
}

func (s *Declare_blockContext) T_SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEMICOLON, i)
}

func (s *Declare_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declare_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Declare_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDeclare_block(s)
	}
}

func (s *Declare_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDeclare_block(s)
	}
}




func (p *HplsqlParser) Declare_block() (localctx IDeclare_blockContext) {
	localctx = NewDeclare_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, HplsqlParserRULE_declare_block)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(755)
		p.Match(HplsqlParserT_DECLARE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(756)
		p.Declare_stmt_item()
	}
	{
		p.SetState(757)
		p.Match(HplsqlParserT_SEMICOLON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(763)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(758)
				p.Declare_stmt_item()
			}
			{
				p.SetState(759)
				p.Match(HplsqlParserT_SEMICOLON)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		}
		p.SetState(765)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDeclare_block_inplaceContext is an interface to support dynamic dispatch.
type IDeclare_block_inplaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDeclare_stmt_item() []IDeclare_stmt_itemContext
	Declare_stmt_item(i int) IDeclare_stmt_itemContext
	AllT_SEMICOLON() []antlr.TerminalNode
	T_SEMICOLON(i int) antlr.TerminalNode

	// IsDeclare_block_inplaceContext differentiates from other interfaces.
	IsDeclare_block_inplaceContext()
}

type Declare_block_inplaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclare_block_inplaceContext() *Declare_block_inplaceContext {
	var p = new(Declare_block_inplaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_block_inplace
	return p
}

func InitEmptyDeclare_block_inplaceContext(p *Declare_block_inplaceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_block_inplace
}

func (*Declare_block_inplaceContext) IsDeclare_block_inplaceContext() {}

func NewDeclare_block_inplaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declare_block_inplaceContext {
	var p = new(Declare_block_inplaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_declare_block_inplace

	return p
}

func (s *Declare_block_inplaceContext) GetParser() antlr.Parser { return s.parser }

func (s *Declare_block_inplaceContext) AllDeclare_stmt_item() []IDeclare_stmt_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclare_stmt_itemContext); ok {
			len++
		}
	}

	tst := make([]IDeclare_stmt_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclare_stmt_itemContext); ok {
			tst[i] = t.(IDeclare_stmt_itemContext)
			i++
		}
	}

	return tst
}

func (s *Declare_block_inplaceContext) Declare_stmt_item(i int) IDeclare_stmt_itemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_stmt_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_stmt_itemContext)
}

func (s *Declare_block_inplaceContext) AllT_SEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_SEMICOLON)
}

func (s *Declare_block_inplaceContext) T_SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEMICOLON, i)
}

func (s *Declare_block_inplaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declare_block_inplaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Declare_block_inplaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDeclare_block_inplace(s)
	}
}

func (s *Declare_block_inplaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDeclare_block_inplace(s)
	}
}




func (p *HplsqlParser) Declare_block_inplace() (localctx IDeclare_block_inplaceContext) {
	localctx = NewDeclare_block_inplaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, HplsqlParserRULE_declare_block_inplace)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(766)
		p.Declare_stmt_item()
	}
	{
		p.SetState(767)
		p.Match(HplsqlParserT_SEMICOLON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(773)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(768)
				p.Declare_stmt_item()
			}
			{
				p.SetState(769)
				p.Match(HplsqlParserT_SEMICOLON)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		}
		p.SetState(775)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDeclare_stmt_itemContext is an interface to support dynamic dispatch.
type IDeclare_stmt_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Declare_cursor_item() IDeclare_cursor_itemContext
	Declare_condition_item() IDeclare_condition_itemContext
	Declare_handler_item() IDeclare_handler_itemContext
	Declare_var_item() IDeclare_var_itemContext
	Declare_temporary_table_item() IDeclare_temporary_table_itemContext

	// IsDeclare_stmt_itemContext differentiates from other interfaces.
	IsDeclare_stmt_itemContext()
}

type Declare_stmt_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclare_stmt_itemContext() *Declare_stmt_itemContext {
	var p = new(Declare_stmt_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_stmt_item
	return p
}

func InitEmptyDeclare_stmt_itemContext(p *Declare_stmt_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_stmt_item
}

func (*Declare_stmt_itemContext) IsDeclare_stmt_itemContext() {}

func NewDeclare_stmt_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declare_stmt_itemContext {
	var p = new(Declare_stmt_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_declare_stmt_item

	return p
}

func (s *Declare_stmt_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Declare_stmt_itemContext) Declare_cursor_item() IDeclare_cursor_itemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_cursor_itemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_cursor_itemContext)
}

func (s *Declare_stmt_itemContext) Declare_condition_item() IDeclare_condition_itemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_condition_itemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_condition_itemContext)
}

func (s *Declare_stmt_itemContext) Declare_handler_item() IDeclare_handler_itemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_handler_itemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_handler_itemContext)
}

func (s *Declare_stmt_itemContext) Declare_var_item() IDeclare_var_itemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_var_itemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_var_itemContext)
}

func (s *Declare_stmt_itemContext) Declare_temporary_table_item() IDeclare_temporary_table_itemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_temporary_table_itemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_temporary_table_itemContext)
}

func (s *Declare_stmt_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declare_stmt_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Declare_stmt_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDeclare_stmt_item(s)
	}
}

func (s *Declare_stmt_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDeclare_stmt_item(s)
	}
}




func (p *HplsqlParser) Declare_stmt_item() (localctx IDeclare_stmt_itemContext) {
	localctx = NewDeclare_stmt_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, HplsqlParserRULE_declare_stmt_item)
	p.SetState(781)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(776)
			p.Declare_cursor_item()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(777)
			p.Declare_condition_item()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(778)
			p.Declare_handler_item()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(779)
			p.Declare_var_item()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(780)
			p.Declare_temporary_table_item()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDeclare_var_itemContext is an interface to support dynamic dispatch.
type IDeclare_var_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	Dtype() IDtypeContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	T_AS() antlr.TerminalNode
	Dtype_len() IDtype_lenContext
	AllDtype_attr() []IDtype_attrContext
	Dtype_attr(i int) IDtype_attrContext
	Dtype_default() IDtype_defaultContext
	T_CONSTANT() antlr.TerminalNode

	// IsDeclare_var_itemContext differentiates from other interfaces.
	IsDeclare_var_itemContext()
}

type Declare_var_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclare_var_itemContext() *Declare_var_itemContext {
	var p = new(Declare_var_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_var_item
	return p
}

func InitEmptyDeclare_var_itemContext(p *Declare_var_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_var_item
}

func (*Declare_var_itemContext) IsDeclare_var_itemContext() {}

func NewDeclare_var_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declare_var_itemContext {
	var p = new(Declare_var_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_declare_var_item

	return p
}

func (s *Declare_var_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Declare_var_itemContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Declare_var_itemContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Declare_var_itemContext) Dtype() IDtypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *Declare_var_itemContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Declare_var_itemContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Declare_var_itemContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Declare_var_itemContext) Dtype_len() IDtype_lenContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_lenContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_lenContext)
}

func (s *Declare_var_itemContext) AllDtype_attr() []IDtype_attrContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDtype_attrContext); ok {
			len++
		}
	}

	tst := make([]IDtype_attrContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDtype_attrContext); ok {
			tst[i] = t.(IDtype_attrContext)
			i++
		}
	}

	return tst
}

func (s *Declare_var_itemContext) Dtype_attr(i int) IDtype_attrContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_attrContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_attrContext)
}

func (s *Declare_var_itemContext) Dtype_default() IDtype_defaultContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_defaultContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_defaultContext)
}

func (s *Declare_var_itemContext) T_CONSTANT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONSTANT, 0)
}

func (s *Declare_var_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declare_var_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Declare_var_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDeclare_var_item(s)
	}
}

func (s *Declare_var_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDeclare_var_item(s)
	}
}




func (p *HplsqlParser) Declare_var_item() (localctx IDeclare_var_itemContext) {
	localctx = NewDeclare_var_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, HplsqlParserRULE_declare_var_item)
	var _la int

	var _alt int

	p.SetState(818)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 41, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(783)
			p.Ident()
		}
		p.SetState(788)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(784)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(785)
				p.Ident()
			}


			p.SetState(790)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(792)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(791)
				p.Match(HplsqlParserT_AS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(794)
			p.Dtype()
		}
		p.SetState(796)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(795)
				p.Dtype_len()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(801)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(798)
					p.Dtype_attr()
				}


			}
			p.SetState(803)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(805)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(804)
				p.Dtype_default()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(807)
			p.Ident()
		}
		{
			p.SetState(808)
			p.Match(HplsqlParserT_CONSTANT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(810)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(809)
				p.Match(HplsqlParserT_AS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(812)
			p.Dtype()
		}
		p.SetState(814)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_OPEN_P {
			{
				p.SetState(813)
				p.Dtype_len()
			}

		}
		{
			p.SetState(816)
			p.Dtype_default()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDeclare_condition_itemContext is an interface to support dynamic dispatch.
type IDeclare_condition_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ident() IIdentContext
	T_CONDITION() antlr.TerminalNode

	// IsDeclare_condition_itemContext differentiates from other interfaces.
	IsDeclare_condition_itemContext()
}

type Declare_condition_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclare_condition_itemContext() *Declare_condition_itemContext {
	var p = new(Declare_condition_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_condition_item
	return p
}

func InitEmptyDeclare_condition_itemContext(p *Declare_condition_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_condition_item
}

func (*Declare_condition_itemContext) IsDeclare_condition_itemContext() {}

func NewDeclare_condition_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declare_condition_itemContext {
	var p = new(Declare_condition_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_declare_condition_item

	return p
}

func (s *Declare_condition_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Declare_condition_itemContext) Ident() IIdentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Declare_condition_itemContext) T_CONDITION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONDITION, 0)
}

func (s *Declare_condition_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declare_condition_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Declare_condition_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDeclare_condition_item(s)
	}
}

func (s *Declare_condition_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDeclare_condition_item(s)
	}
}




func (p *HplsqlParser) Declare_condition_item() (localctx IDeclare_condition_itemContext) {
	localctx = NewDeclare_condition_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, HplsqlParserRULE_declare_condition_item)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(820)
		p.Ident()
	}
	{
		p.SetState(821)
		p.Match(HplsqlParserT_CONDITION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDeclare_cursor_itemContext is an interface to support dynamic dispatch.
type IDeclare_cursor_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_IS() antlr.TerminalNode
	T_AS() antlr.TerminalNode
	T_FOR() antlr.TerminalNode
	T_CURSOR() antlr.TerminalNode
	Ident() IIdentContext
	Select_stmt() ISelect_stmtContext
	Expr() IExprContext
	Cursor_with_return() ICursor_with_returnContext
	Cursor_without_return() ICursor_without_returnContext

	// IsDeclare_cursor_itemContext differentiates from other interfaces.
	IsDeclare_cursor_itemContext()
}

type Declare_cursor_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclare_cursor_itemContext() *Declare_cursor_itemContext {
	var p = new(Declare_cursor_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_cursor_item
	return p
}

func InitEmptyDeclare_cursor_itemContext(p *Declare_cursor_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_cursor_item
}

func (*Declare_cursor_itemContext) IsDeclare_cursor_itemContext() {}

func NewDeclare_cursor_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declare_cursor_itemContext {
	var p = new(Declare_cursor_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_declare_cursor_item

	return p
}

func (s *Declare_cursor_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Declare_cursor_itemContext) T_IS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IS, 0)
}

func (s *Declare_cursor_itemContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Declare_cursor_itemContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *Declare_cursor_itemContext) T_CURSOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURSOR, 0)
}

func (s *Declare_cursor_itemContext) Ident() IIdentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Declare_cursor_itemContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Declare_cursor_itemContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Declare_cursor_itemContext) Cursor_with_return() ICursor_with_returnContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICursor_with_returnContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICursor_with_returnContext)
}

func (s *Declare_cursor_itemContext) Cursor_without_return() ICursor_without_returnContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICursor_without_returnContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICursor_without_returnContext)
}

func (s *Declare_cursor_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declare_cursor_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Declare_cursor_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDeclare_cursor_item(s)
	}
}

func (s *Declare_cursor_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDeclare_cursor_item(s)
	}
}




func (p *HplsqlParser) Declare_cursor_item() (localctx IDeclare_cursor_itemContext) {
	localctx = NewDeclare_cursor_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, HplsqlParserRULE_declare_cursor_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(828)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 42, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(823)
			p.Match(HplsqlParserT_CURSOR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(824)
			p.Ident()
		}


	case 2:
		{
			p.SetState(825)
			p.Ident()
		}
		{
			p.SetState(826)
			p.Match(HplsqlParserT_CURSOR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(832)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_WITH:
		{
			p.SetState(830)
			p.Cursor_with_return()
		}


	case HplsqlParserT_WITHOUT:
		{
			p.SetState(831)
			p.Cursor_without_return()
		}


	case HplsqlParserT_AS, HplsqlParserT_FOR, HplsqlParserT_IS:



	default:
	}
	{
		p.SetState(834)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_AS || _la == HplsqlParserT_FOR || _la == HplsqlParserT_IS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(837)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(835)
			p.Select_stmt()
		}


	case 2:
		{
			p.SetState(836)
			p.expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICursor_with_returnContext is an interface to support dynamic dispatch.
type ICursor_with_returnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_WITH() antlr.TerminalNode
	T_RETURN() antlr.TerminalNode
	T_ONLY() antlr.TerminalNode
	T_TO() antlr.TerminalNode
	T_CALLER() antlr.TerminalNode
	T_CLIENT() antlr.TerminalNode

	// IsCursor_with_returnContext differentiates from other interfaces.
	IsCursor_with_returnContext()
}

type Cursor_with_returnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCursor_with_returnContext() *Cursor_with_returnContext {
	var p = new(Cursor_with_returnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cursor_with_return
	return p
}

func InitEmptyCursor_with_returnContext(p *Cursor_with_returnContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cursor_with_return
}

func (*Cursor_with_returnContext) IsCursor_with_returnContext() {}

func NewCursor_with_returnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cursor_with_returnContext {
	var p = new(Cursor_with_returnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_cursor_with_return

	return p
}

func (s *Cursor_with_returnContext) GetParser() antlr.Parser { return s.parser }

func (s *Cursor_with_returnContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITH, 0)
}

func (s *Cursor_with_returnContext) T_RETURN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RETURN, 0)
}

func (s *Cursor_with_returnContext) T_ONLY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ONLY, 0)
}

func (s *Cursor_with_returnContext) T_TO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TO, 0)
}

func (s *Cursor_with_returnContext) T_CALLER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CALLER, 0)
}

func (s *Cursor_with_returnContext) T_CLIENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLIENT, 0)
}

func (s *Cursor_with_returnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cursor_with_returnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Cursor_with_returnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCursor_with_return(s)
	}
}

func (s *Cursor_with_returnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCursor_with_return(s)
	}
}




func (p *HplsqlParser) Cursor_with_return() (localctx ICursor_with_returnContext) {
	localctx = NewCursor_with_returnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, HplsqlParserRULE_cursor_with_return)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(839)
		p.Match(HplsqlParserT_WITH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(840)
		p.Match(HplsqlParserT_RETURN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(842)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_ONLY {
		{
			p.SetState(841)
			p.Match(HplsqlParserT_ONLY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(846)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_TO {
		{
			p.SetState(844)
			p.Match(HplsqlParserT_TO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(845)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_CALLER || _la == HplsqlParserT_CLIENT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICursor_without_returnContext is an interface to support dynamic dispatch.
type ICursor_without_returnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_WITHOUT() antlr.TerminalNode
	T_RETURN() antlr.TerminalNode

	// IsCursor_without_returnContext differentiates from other interfaces.
	IsCursor_without_returnContext()
}

type Cursor_without_returnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCursor_without_returnContext() *Cursor_without_returnContext {
	var p = new(Cursor_without_returnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cursor_without_return
	return p
}

func InitEmptyCursor_without_returnContext(p *Cursor_without_returnContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cursor_without_return
}

func (*Cursor_without_returnContext) IsCursor_without_returnContext() {}

func NewCursor_without_returnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cursor_without_returnContext {
	var p = new(Cursor_without_returnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_cursor_without_return

	return p
}

func (s *Cursor_without_returnContext) GetParser() antlr.Parser { return s.parser }

func (s *Cursor_without_returnContext) T_WITHOUT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITHOUT, 0)
}

func (s *Cursor_without_returnContext) T_RETURN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RETURN, 0)
}

func (s *Cursor_without_returnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cursor_without_returnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Cursor_without_returnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCursor_without_return(s)
	}
}

func (s *Cursor_without_returnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCursor_without_return(s)
	}
}




func (p *HplsqlParser) Cursor_without_return() (localctx ICursor_without_returnContext) {
	localctx = NewCursor_without_returnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, HplsqlParserRULE_cursor_without_return)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(848)
		p.Match(HplsqlParserT_WITHOUT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(849)
		p.Match(HplsqlParserT_RETURN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDeclare_handler_itemContext is an interface to support dynamic dispatch.
type IDeclare_handler_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_HANDLER() antlr.TerminalNode
	T_FOR() antlr.TerminalNode
	Single_block_stmt() ISingle_block_stmtContext
	T_CONTINUE() antlr.TerminalNode
	T_EXIT() antlr.TerminalNode
	T_SQLEXCEPTION() antlr.TerminalNode
	T_SQLWARNING() antlr.TerminalNode
	T_NOT() antlr.TerminalNode
	T_FOUND() antlr.TerminalNode
	Ident() IIdentContext

	// IsDeclare_handler_itemContext differentiates from other interfaces.
	IsDeclare_handler_itemContext()
}

type Declare_handler_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclare_handler_itemContext() *Declare_handler_itemContext {
	var p = new(Declare_handler_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_handler_item
	return p
}

func InitEmptyDeclare_handler_itemContext(p *Declare_handler_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_handler_item
}

func (*Declare_handler_itemContext) IsDeclare_handler_itemContext() {}

func NewDeclare_handler_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declare_handler_itemContext {
	var p = new(Declare_handler_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_declare_handler_item

	return p
}

func (s *Declare_handler_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Declare_handler_itemContext) T_HANDLER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HANDLER, 0)
}

func (s *Declare_handler_itemContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *Declare_handler_itemContext) Single_block_stmt() ISingle_block_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingle_block_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingle_block_stmtContext)
}

func (s *Declare_handler_itemContext) T_CONTINUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONTINUE, 0)
}

func (s *Declare_handler_itemContext) T_EXIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXIT, 0)
}

func (s *Declare_handler_itemContext) T_SQLEXCEPTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SQLEXCEPTION, 0)
}

func (s *Declare_handler_itemContext) T_SQLWARNING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SQLWARNING, 0)
}

func (s *Declare_handler_itemContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Declare_handler_itemContext) T_FOUND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOUND, 0)
}

func (s *Declare_handler_itemContext) Ident() IIdentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Declare_handler_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declare_handler_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Declare_handler_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDeclare_handler_item(s)
	}
}

func (s *Declare_handler_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDeclare_handler_item(s)
	}
}




func (p *HplsqlParser) Declare_handler_item() (localctx IDeclare_handler_itemContext) {
	localctx = NewDeclare_handler_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, HplsqlParserRULE_declare_handler_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(851)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_CONTINUE || _la == HplsqlParserT_EXIT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(852)
		p.Match(HplsqlParserT_HANDLER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(853)
		p.Match(HplsqlParserT_FOR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(859)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(854)
			p.Match(HplsqlParserT_SQLEXCEPTION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		{
			p.SetState(855)
			p.Match(HplsqlParserT_SQLWARNING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		{
			p.SetState(856)
			p.Match(HplsqlParserT_NOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(857)
			p.Match(HplsqlParserT_FOUND)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		{
			p.SetState(858)
			p.Ident()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(861)
		p.Single_block_stmt()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDeclare_temporary_table_itemContext is an interface to support dynamic dispatch.
type IDeclare_temporary_table_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_TEMPORARY() antlr.TerminalNode
	T_TABLE() antlr.TerminalNode
	Qident() IQidentContext
	Create_table_definition() ICreate_table_definitionContext
	T_GLOBAL() antlr.TerminalNode
	Create_table_preoptions() ICreate_table_preoptionsContext

	// IsDeclare_temporary_table_itemContext differentiates from other interfaces.
	IsDeclare_temporary_table_itemContext()
}

type Declare_temporary_table_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclare_temporary_table_itemContext() *Declare_temporary_table_itemContext {
	var p = new(Declare_temporary_table_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_temporary_table_item
	return p
}

func InitEmptyDeclare_temporary_table_itemContext(p *Declare_temporary_table_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_declare_temporary_table_item
}

func (*Declare_temporary_table_itemContext) IsDeclare_temporary_table_itemContext() {}

func NewDeclare_temporary_table_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Declare_temporary_table_itemContext {
	var p = new(Declare_temporary_table_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_declare_temporary_table_item

	return p
}

func (s *Declare_temporary_table_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Declare_temporary_table_itemContext) T_TEMPORARY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TEMPORARY, 0)
}

func (s *Declare_temporary_table_itemContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLE, 0)
}

func (s *Declare_temporary_table_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Declare_temporary_table_itemContext) Create_table_definition() ICreate_table_definitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_definitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_definitionContext)
}

func (s *Declare_temporary_table_itemContext) T_GLOBAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GLOBAL, 0)
}

func (s *Declare_temporary_table_itemContext) Create_table_preoptions() ICreate_table_preoptionsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_preoptionsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_preoptionsContext)
}

func (s *Declare_temporary_table_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Declare_temporary_table_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Declare_temporary_table_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDeclare_temporary_table_item(s)
	}
}

func (s *Declare_temporary_table_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDeclare_temporary_table_item(s)
	}
}




func (p *HplsqlParser) Declare_temporary_table_item() (localctx IDeclare_temporary_table_itemContext) {
	localctx = NewDeclare_temporary_table_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, HplsqlParserRULE_declare_temporary_table_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(864)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_GLOBAL {
		{
			p.SetState(863)
			p.Match(HplsqlParserT_GLOBAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(866)
		p.Match(HplsqlParserT_TEMPORARY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(867)
		p.Match(HplsqlParserT_TABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(868)
		p.Qident()
	}
	p.SetState(870)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_ROW || _la == HplsqlParserT_STORED || _la == HplsqlParserT_COMMA {
		{
			p.SetState(869)
			p.Create_table_preoptions()
		}

	}
	{
		p.SetState(872)
		p.Create_table_definition()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_table_stmtContext is an interface to support dynamic dispatch.
type ICreate_table_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_CREATE() antlr.TerminalNode
	T_TABLE() antlr.TerminalNode
	Table_name() ITable_nameContext
	Create_table_definition() ICreate_table_definitionContext
	T_IF() antlr.TerminalNode
	T_NOT() antlr.TerminalNode
	T_EXISTS() antlr.TerminalNode
	Create_table_preoptions() ICreate_table_preoptionsContext

	// IsCreate_table_stmtContext differentiates from other interfaces.
	IsCreate_table_stmtContext()
}

type Create_table_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_stmtContext() *Create_table_stmtContext {
	var p = new(Create_table_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_stmt
	return p
}

func InitEmptyCreate_table_stmtContext(p *Create_table_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_stmt
}

func (*Create_table_stmtContext) IsCreate_table_stmtContext() {}

func NewCreate_table_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_stmtContext {
	var p = new(Create_table_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_stmt

	return p
}

func (s *Create_table_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_stmtContext) T_CREATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATE, 0)
}

func (s *Create_table_stmtContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLE, 0)
}

func (s *Create_table_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Create_table_stmtContext) Create_table_definition() ICreate_table_definitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_definitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_definitionContext)
}

func (s *Create_table_stmtContext) T_IF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IF, 0)
}

func (s *Create_table_stmtContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Create_table_stmtContext) T_EXISTS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXISTS, 0)
}

func (s *Create_table_stmtContext) Create_table_preoptions() ICreate_table_preoptionsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_preoptionsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_preoptionsContext)
}

func (s *Create_table_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_table_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_stmt(s)
	}
}

func (s *Create_table_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_stmt(s)
	}
}




func (p *HplsqlParser) Create_table_stmt() (localctx ICreate_table_stmtContext) {
	localctx = NewCreate_table_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, HplsqlParserRULE_create_table_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(874)
		p.Match(HplsqlParserT_CREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(875)
		p.Match(HplsqlParserT_TABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(879)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 50, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(876)
			p.Match(HplsqlParserT_IF)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(877)
			p.Match(HplsqlParserT_NOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(878)
			p.Match(HplsqlParserT_EXISTS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(881)
		p.Table_name()
	}
	p.SetState(883)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_ROW || _la == HplsqlParserT_STORED || _la == HplsqlParserT_COMMA {
		{
			p.SetState(882)
			p.Create_table_preoptions()
		}

	}
	{
		p.SetState(885)
		p.Create_table_definition()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_local_temp_table_stmtContext is an interface to support dynamic dispatch.
type ICreate_local_temp_table_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_CREATE() antlr.TerminalNode
	T_TABLE() antlr.TerminalNode
	Qident() IQidentContext
	Create_table_definition() ICreate_table_definitionContext
	T_LOCAL() antlr.TerminalNode
	T_TEMPORARY() antlr.TerminalNode
	T_VOLATILE() antlr.TerminalNode
	Create_table_preoptions() ICreate_table_preoptionsContext
	T_SET() antlr.TerminalNode
	T_MULTISET() antlr.TerminalNode

	// IsCreate_local_temp_table_stmtContext differentiates from other interfaces.
	IsCreate_local_temp_table_stmtContext()
}

type Create_local_temp_table_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_local_temp_table_stmtContext() *Create_local_temp_table_stmtContext {
	var p = new(Create_local_temp_table_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_local_temp_table_stmt
	return p
}

func InitEmptyCreate_local_temp_table_stmtContext(p *Create_local_temp_table_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_local_temp_table_stmt
}

func (*Create_local_temp_table_stmtContext) IsCreate_local_temp_table_stmtContext() {}

func NewCreate_local_temp_table_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_local_temp_table_stmtContext {
	var p = new(Create_local_temp_table_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_local_temp_table_stmt

	return p
}

func (s *Create_local_temp_table_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_local_temp_table_stmtContext) T_CREATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATE, 0)
}

func (s *Create_local_temp_table_stmtContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLE, 0)
}

func (s *Create_local_temp_table_stmtContext) Qident() IQidentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_local_temp_table_stmtContext) Create_table_definition() ICreate_table_definitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_definitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_definitionContext)
}

func (s *Create_local_temp_table_stmtContext) T_LOCAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCAL, 0)
}

func (s *Create_local_temp_table_stmtContext) T_TEMPORARY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TEMPORARY, 0)
}

func (s *Create_local_temp_table_stmtContext) T_VOLATILE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VOLATILE, 0)
}

func (s *Create_local_temp_table_stmtContext) Create_table_preoptions() ICreate_table_preoptionsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_preoptionsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_preoptionsContext)
}

func (s *Create_local_temp_table_stmtContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Create_local_temp_table_stmtContext) T_MULTISET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MULTISET, 0)
}

func (s *Create_local_temp_table_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_local_temp_table_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_local_temp_table_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_local_temp_table_stmt(s)
	}
}

func (s *Create_local_temp_table_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_local_temp_table_stmt(s)
	}
}




func (p *HplsqlParser) Create_local_temp_table_stmt() (localctx ICreate_local_temp_table_stmtContext) {
	localctx = NewCreate_local_temp_table_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, HplsqlParserRULE_create_local_temp_table_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(887)
		p.Match(HplsqlParserT_CREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(894)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_LOCAL:
		{
			p.SetState(888)
			p.Match(HplsqlParserT_LOCAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(889)
			p.Match(HplsqlParserT_TEMPORARY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_MULTISET, HplsqlParserT_SET, HplsqlParserT_VOLATILE:
		p.SetState(891)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_MULTISET || _la == HplsqlParserT_SET {
			{
				p.SetState(890)
				_la = p.GetTokenStream().LA(1)

				if !(_la == HplsqlParserT_MULTISET || _la == HplsqlParserT_SET) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(893)
			p.Match(HplsqlParserT_VOLATILE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(896)
		p.Match(HplsqlParserT_TABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(897)
		p.Qident()
	}
	p.SetState(899)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_ROW || _la == HplsqlParserT_STORED || _la == HplsqlParserT_COMMA {
		{
			p.SetState(898)
			p.Create_table_preoptions()
		}

	}
	{
		p.SetState(901)
		p.Create_table_definition()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_table_definitionContext is an interface to support dynamic dispatch.
type ICreate_table_definitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN_P() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	T_CLOSE_P() antlr.TerminalNode
	Create_table_columns() ICreate_table_columnsContext
	T_LIKE() antlr.TerminalNode
	Table_name() ITable_nameContext
	Create_table_options() ICreate_table_optionsContext
	T_AS() antlr.TerminalNode

	// IsCreate_table_definitionContext differentiates from other interfaces.
	IsCreate_table_definitionContext()
}

type Create_table_definitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_definitionContext() *Create_table_definitionContext {
	var p = new(Create_table_definitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_definition
	return p
}

func InitEmptyCreate_table_definitionContext(p *Create_table_definitionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_definition
}

func (*Create_table_definitionContext) IsCreate_table_definitionContext() {}

func NewCreate_table_definitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_definitionContext {
	var p = new(Create_table_definitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_definition

	return p
}

func (s *Create_table_definitionContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_definitionContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Create_table_definitionContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Create_table_definitionContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Create_table_definitionContext) Create_table_columns() ICreate_table_columnsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_columnsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_columnsContext)
}

func (s *Create_table_definitionContext) T_LIKE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LIKE, 0)
}

func (s *Create_table_definitionContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Create_table_definitionContext) Create_table_options() ICreate_table_optionsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_optionsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_optionsContext)
}

func (s *Create_table_definitionContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Create_table_definitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_definitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_table_definitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_definition(s)
	}
}

func (s *Create_table_definitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_definition(s)
	}
}




func (p *HplsqlParser) Create_table_definition() (localctx ICreate_table_definitionContext) {
	localctx = NewCreate_table_definitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, HplsqlParserRULE_create_table_definition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(920)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) {
	case 1:
		p.SetState(904)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_AS {
			{
				p.SetState(903)
				p.Match(HplsqlParserT_AS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(906)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(907)
			p.Select_stmt()
		}
		{
			p.SetState(908)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.SetState(911)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_AS {
			{
				p.SetState(910)
				p.Match(HplsqlParserT_AS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(913)
			p.Select_stmt()
		}


	case 3:
		{
			p.SetState(914)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(915)
			p.Create_table_columns()
		}
		{
			p.SetState(916)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		{
			p.SetState(918)
			p.Match(HplsqlParserT_LIKE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(919)
			p.Table_name()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(923)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(922)
			p.Create_table_options()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_table_column_commentContext is an interface to support dynamic dispatch.
type ICreate_table_column_commentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_COMMENT() antlr.TerminalNode
	Expr() IExprContext

	// IsCreate_table_column_commentContext differentiates from other interfaces.
	IsCreate_table_column_commentContext()
}

type Create_table_column_commentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_column_commentContext() *Create_table_column_commentContext {
	var p = new(Create_table_column_commentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_column_comment
	return p
}

func InitEmptyCreate_table_column_commentContext(p *Create_table_column_commentContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_column_comment
}

func (*Create_table_column_commentContext) IsCreate_table_column_commentContext() {}

func NewCreate_table_column_commentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_column_commentContext {
	var p = new(Create_table_column_commentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_column_comment

	return p
}

func (s *Create_table_column_commentContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_column_commentContext) T_COMMENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMENT, 0)
}

func (s *Create_table_column_commentContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Create_table_column_commentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_column_commentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_table_column_commentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_column_comment(s)
	}
}

func (s *Create_table_column_commentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_column_comment(s)
	}
}




func (p *HplsqlParser) Create_table_column_comment() (localctx ICreate_table_column_commentContext) {
	localctx = NewCreate_table_column_commentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, HplsqlParserRULE_create_table_column_comment)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(925)
		p.Match(HplsqlParserT_COMMENT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(926)
		p.expr(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_table_columnsContext is an interface to support dynamic dispatch.
type ICreate_table_columnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCreate_table_columns_item() []ICreate_table_columns_itemContext
	Create_table_columns_item(i int) ICreate_table_columns_itemContext
	AllCreate_table_column_comment() []ICreate_table_column_commentContext
	Create_table_column_comment(i int) ICreate_table_column_commentContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsCreate_table_columnsContext differentiates from other interfaces.
	IsCreate_table_columnsContext()
}

type Create_table_columnsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_columnsContext() *Create_table_columnsContext {
	var p = new(Create_table_columnsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_columns
	return p
}

func InitEmptyCreate_table_columnsContext(p *Create_table_columnsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_columns
}

func (*Create_table_columnsContext) IsCreate_table_columnsContext() {}

func NewCreate_table_columnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_columnsContext {
	var p = new(Create_table_columnsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_columns

	return p
}

func (s *Create_table_columnsContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_columnsContext) AllCreate_table_columns_item() []ICreate_table_columns_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_columns_itemContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_columns_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_columns_itemContext); ok {
			tst[i] = t.(ICreate_table_columns_itemContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_columnsContext) Create_table_columns_item(i int) ICreate_table_columns_itemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_columns_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_columns_itemContext)
}

func (s *Create_table_columnsContext) AllCreate_table_column_comment() []ICreate_table_column_commentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_column_commentContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_column_commentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_column_commentContext); ok {
			tst[i] = t.(ICreate_table_column_commentContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_columnsContext) Create_table_column_comment(i int) ICreate_table_column_commentContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_column_commentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_column_commentContext)
}

func (s *Create_table_columnsContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Create_table_columnsContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Create_table_columnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_columnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_table_columnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_columns(s)
	}
}

func (s *Create_table_columnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_columns(s)
	}
}




func (p *HplsqlParser) Create_table_columns() (localctx ICreate_table_columnsContext) {
	localctx = NewCreate_table_columnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, HplsqlParserRULE_create_table_columns)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(928)
		p.Create_table_columns_item()
	}
	p.SetState(930)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_COMMENT {
		{
			p.SetState(929)
			p.Create_table_column_comment()
		}

	}
	p.SetState(939)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(932)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(933)
			p.Create_table_columns_item()
		}
		p.SetState(935)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_COMMENT {
			{
				p.SetState(934)
				p.Create_table_column_comment()
			}

		}


		p.SetState(941)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_table_columns_itemContext is an interface to support dynamic dispatch.
type ICreate_table_columns_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column_name() IColumn_nameContext
	Dtype() IDtypeContext
	Dtype_len() IDtype_lenContext
	AllDtype_attr() []IDtype_attrContext
	Dtype_attr(i int) IDtype_attrContext
	AllCreate_table_column_inline_cons() []ICreate_table_column_inline_consContext
	Create_table_column_inline_cons(i int) ICreate_table_column_inline_consContext
	Create_table_column_cons() ICreate_table_column_consContext
	T_CONSTRAINT() antlr.TerminalNode
	Qident() IQidentContext

	// IsCreate_table_columns_itemContext differentiates from other interfaces.
	IsCreate_table_columns_itemContext()
}

type Create_table_columns_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_columns_itemContext() *Create_table_columns_itemContext {
	var p = new(Create_table_columns_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_columns_item
	return p
}

func InitEmptyCreate_table_columns_itemContext(p *Create_table_columns_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_columns_item
}

func (*Create_table_columns_itemContext) IsCreate_table_columns_itemContext() {}

func NewCreate_table_columns_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_columns_itemContext {
	var p = new(Create_table_columns_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_columns_item

	return p
}

func (s *Create_table_columns_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_columns_itemContext) Column_name() IColumn_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumn_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumn_nameContext)
}

func (s *Create_table_columns_itemContext) Dtype() IDtypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *Create_table_columns_itemContext) Dtype_len() IDtype_lenContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_lenContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_lenContext)
}

func (s *Create_table_columns_itemContext) AllDtype_attr() []IDtype_attrContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDtype_attrContext); ok {
			len++
		}
	}

	tst := make([]IDtype_attrContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDtype_attrContext); ok {
			tst[i] = t.(IDtype_attrContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_columns_itemContext) Dtype_attr(i int) IDtype_attrContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_attrContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_attrContext)
}

func (s *Create_table_columns_itemContext) AllCreate_table_column_inline_cons() []ICreate_table_column_inline_consContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_column_inline_consContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_column_inline_consContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_column_inline_consContext); ok {
			tst[i] = t.(ICreate_table_column_inline_consContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_columns_itemContext) Create_table_column_inline_cons(i int) ICreate_table_column_inline_consContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_column_inline_consContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_column_inline_consContext)
}

func (s *Create_table_columns_itemContext) Create_table_column_cons() ICreate_table_column_consContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_column_consContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_column_consContext)
}

func (s *Create_table_columns_itemContext) T_CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONSTRAINT, 0)
}

func (s *Create_table_columns_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_table_columns_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_columns_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_table_columns_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_columns_item(s)
	}
}

func (s *Create_table_columns_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_columns_item(s)
	}
}




func (p *HplsqlParser) Create_table_columns_item() (localctx ICreate_table_columns_itemContext) {
	localctx = NewCreate_table_columns_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, HplsqlParserRULE_create_table_columns_item)
	var _la int

	var _alt int

	p.SetState(964)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(942)
			p.Column_name()
		}
		{
			p.SetState(943)
			p.Dtype()
		}
		p.SetState(945)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_OPEN_P {
			{
				p.SetState(944)
				p.Dtype_len()
			}

		}
		p.SetState(950)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(947)
					p.Dtype_attr()
				}


			}
			p.SetState(952)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(956)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == HplsqlParserT_AUTO_INCREMENT || ((int64((_la - 75)) & ^0x3f) == 0 && ((int64(1) << (_la - 75)) & 288230376155906049) != 0) || ((int64((_la - 194)) & ^0x3f) == 0 && ((int64(1) << (_la - 194)) & 34393292805) != 0) || ((int64((_la - 302)) & ^0x3f) == 0 && ((int64(1) << (_la - 302)) & 9147936743129089) != 0) {
			{
				p.SetState(953)
				p.Create_table_column_inline_cons()
			}


			p.SetState(958)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(961)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_CONSTRAINT {
			{
				p.SetState(959)
				p.Match(HplsqlParserT_CONSTRAINT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(960)
				p.Qident()
			}

		}
		{
			p.SetState(963)
			p.Create_table_column_cons()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_table_type_stmtContext is an interface to support dynamic dispatch.
type ICreate_table_type_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_TYPE() antlr.TerminalNode
	Ident() IIdentContext
	T_IS() antlr.TerminalNode
	T_TABLE() antlr.TerminalNode
	T_OF() antlr.TerminalNode
	Tbl_type() ITbl_typeContext
	T_INDEX() antlr.TerminalNode
	T_BY() antlr.TerminalNode
	Dtype() IDtypeContext
	T_NOT() antlr.TerminalNode
	T_NULL() antlr.TerminalNode

	// IsCreate_table_type_stmtContext differentiates from other interfaces.
	IsCreate_table_type_stmtContext()
}

type Create_table_type_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_type_stmtContext() *Create_table_type_stmtContext {
	var p = new(Create_table_type_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_type_stmt
	return p
}

func InitEmptyCreate_table_type_stmtContext(p *Create_table_type_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_type_stmt
}

func (*Create_table_type_stmtContext) IsCreate_table_type_stmtContext() {}

func NewCreate_table_type_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_type_stmtContext {
	var p = new(Create_table_type_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_type_stmt

	return p
}

func (s *Create_table_type_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_type_stmtContext) T_TYPE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TYPE, 0)
}

func (s *Create_table_type_stmtContext) Ident() IIdentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Create_table_type_stmtContext) T_IS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IS, 0)
}

func (s *Create_table_type_stmtContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLE, 0)
}

func (s *Create_table_type_stmtContext) T_OF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OF, 0)
}

func (s *Create_table_type_stmtContext) Tbl_type() ITbl_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITbl_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITbl_typeContext)
}

func (s *Create_table_type_stmtContext) T_INDEX() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INDEX, 0)
}

func (s *Create_table_type_stmtContext) T_BY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BY, 0)
}

func (s *Create_table_type_stmtContext) Dtype() IDtypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *Create_table_type_stmtContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Create_table_type_stmtContext) T_NULL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NULL, 0)
}

func (s *Create_table_type_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_type_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_table_type_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_type_stmt(s)
	}
}

func (s *Create_table_type_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_type_stmt(s)
	}
}




func (p *HplsqlParser) Create_table_type_stmt() (localctx ICreate_table_type_stmtContext) {
	localctx = NewCreate_table_type_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, HplsqlParserRULE_create_table_type_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(966)
		p.Match(HplsqlParserT_TYPE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(967)
		p.Ident()
	}
	{
		p.SetState(968)
		p.Match(HplsqlParserT_IS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(969)
		p.Match(HplsqlParserT_TABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(970)
		p.Match(HplsqlParserT_OF)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(971)
		p.Tbl_type()
	}
	p.SetState(974)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_NOT {
		{
			p.SetState(972)
			p.Match(HplsqlParserT_NOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(973)
			p.Match(HplsqlParserT_NULL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(976)
		p.Match(HplsqlParserT_INDEX)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(977)
		p.Match(HplsqlParserT_BY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(978)
		p.Dtype()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITbl_typeContext is an interface to support dynamic dispatch.
type ITbl_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Sql_type() ISql_typeContext
	Dtype() IDtypeContext

	// IsTbl_typeContext differentiates from other interfaces.
	IsTbl_typeContext()
}

type Tbl_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTbl_typeContext() *Tbl_typeContext {
	var p = new(Tbl_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_tbl_type
	return p
}

func InitEmptyTbl_typeContext(p *Tbl_typeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_tbl_type
}

func (*Tbl_typeContext) IsTbl_typeContext() {}

func NewTbl_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tbl_typeContext {
	var p = new(Tbl_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_tbl_type

	return p
}

func (s *Tbl_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Tbl_typeContext) Sql_type() ISql_typeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISql_typeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISql_typeContext)
}

func (s *Tbl_typeContext) Dtype() IDtypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *Tbl_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tbl_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Tbl_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterTbl_type(s)
	}
}

func (s *Tbl_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitTbl_type(s)
	}
}




func (p *HplsqlParser) Tbl_type() (localctx ITbl_typeContext) {
	localctx = NewTbl_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, HplsqlParserRULE_tbl_type)
	p.SetState(982)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(980)
			p.Sql_type()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(981)
			p.Dtype()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISql_typeContext is an interface to support dynamic dispatch.
type ISql_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Qident() IQidentContext
	T_TYPE() antlr.TerminalNode
	T_ROWTYPE() antlr.TerminalNode

	// IsSql_typeContext differentiates from other interfaces.
	IsSql_typeContext()
}

type Sql_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySql_typeContext() *Sql_typeContext {
	var p = new(Sql_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_sql_type
	return p
}

func InitEmptySql_typeContext(p *Sql_typeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_sql_type
}

func (*Sql_typeContext) IsSql_typeContext() {}

func NewSql_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sql_typeContext {
	var p = new(Sql_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_sql_type

	return p
}

func (s *Sql_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Sql_typeContext) Qident() IQidentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Sql_typeContext) T_TYPE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TYPE, 0)
}

func (s *Sql_typeContext) T_ROWTYPE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROWTYPE, 0)
}

func (s *Sql_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sql_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Sql_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSql_type(s)
	}
}

func (s *Sql_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSql_type(s)
	}
}




func (p *HplsqlParser) Sql_type() (localctx ISql_typeContext) {
	localctx = NewSql_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, HplsqlParserRULE_sql_type)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(984)
		p.Qident()
	}
	{
		p.SetState(985)
		p.Match(HplsqlParserT__2)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(986)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_ROWTYPE || _la == HplsqlParserT_TYPE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IColumn_nameContext is an interface to support dynamic dispatch.
type IColumn_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Qident() IQidentContext

	// IsColumn_nameContext differentiates from other interfaces.
	IsColumn_nameContext()
}

type Column_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumn_nameContext() *Column_nameContext {
	var p = new(Column_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_column_name
	return p
}

func InitEmptyColumn_nameContext(p *Column_nameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_column_name
}

func (*Column_nameContext) IsColumn_nameContext() {}

func NewColumn_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Column_nameContext {
	var p = new(Column_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_column_name

	return p
}

func (s *Column_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Column_nameContext) Qident() IQidentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Column_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Column_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Column_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterColumn_name(s)
	}
}

func (s *Column_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitColumn_name(s)
	}
}




func (p *HplsqlParser) Column_name() (localctx IColumn_nameContext) {
	localctx = NewColumn_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, HplsqlParserRULE_column_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(988)
		p.Qident()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_table_column_inline_consContext is an interface to support dynamic dispatch.
type ICreate_table_column_inline_consContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Dtype_default() IDtype_defaultContext
	T_NULL() antlr.TerminalNode
	T_NOT() antlr.TerminalNode
	T_PRIMARY() antlr.TerminalNode
	T_KEY() antlr.TerminalNode
	T_UNIQUE() antlr.TerminalNode
	T_REFERENCES() antlr.TerminalNode
	Table_name() ITable_nameContext
	T_OPEN_P() antlr.TerminalNode
	Qident() IQidentContext
	T_CLOSE_P() antlr.TerminalNode
	AllCreate_table_fk_action() []ICreate_table_fk_actionContext
	Create_table_fk_action(i int) ICreate_table_fk_actionContext
	T_IDENTITY() antlr.TerminalNode
	AllL_INT() []antlr.TerminalNode
	L_INT(i int) antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	T_AUTO_INCREMENT() antlr.TerminalNode
	T_ENABLE() antlr.TerminalNode

	// IsCreate_table_column_inline_consContext differentiates from other interfaces.
	IsCreate_table_column_inline_consContext()
}

type Create_table_column_inline_consContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_column_inline_consContext() *Create_table_column_inline_consContext {
	var p = new(Create_table_column_inline_consContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_column_inline_cons
	return p
}

func InitEmptyCreate_table_column_inline_consContext(p *Create_table_column_inline_consContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_column_inline_cons
}

func (*Create_table_column_inline_consContext) IsCreate_table_column_inline_consContext() {}

func NewCreate_table_column_inline_consContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_column_inline_consContext {
	var p = new(Create_table_column_inline_consContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_column_inline_cons

	return p
}

func (s *Create_table_column_inline_consContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_column_inline_consContext) Dtype_default() IDtype_defaultContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_defaultContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_defaultContext)
}

func (s *Create_table_column_inline_consContext) T_NULL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NULL, 0)
}

func (s *Create_table_column_inline_consContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Create_table_column_inline_consContext) T_PRIMARY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRIMARY, 0)
}

func (s *Create_table_column_inline_consContext) T_KEY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_KEY, 0)
}

func (s *Create_table_column_inline_consContext) T_UNIQUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UNIQUE, 0)
}

func (s *Create_table_column_inline_consContext) T_REFERENCES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REFERENCES, 0)
}

func (s *Create_table_column_inline_consContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Create_table_column_inline_consContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Create_table_column_inline_consContext) Qident() IQidentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_table_column_inline_consContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Create_table_column_inline_consContext) AllCreate_table_fk_action() []ICreate_table_fk_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_fk_actionContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_fk_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_fk_actionContext); ok {
			tst[i] = t.(ICreate_table_fk_actionContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_column_inline_consContext) Create_table_fk_action(i int) ICreate_table_fk_actionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_fk_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_fk_actionContext)
}

func (s *Create_table_column_inline_consContext) T_IDENTITY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IDENTITY, 0)
}

func (s *Create_table_column_inline_consContext) AllL_INT() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserL_INT)
}

func (s *Create_table_column_inline_consContext) L_INT(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_INT, i)
}

func (s *Create_table_column_inline_consContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Create_table_column_inline_consContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Create_table_column_inline_consContext) T_AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AUTO_INCREMENT, 0)
}

func (s *Create_table_column_inline_consContext) T_ENABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ENABLE, 0)
}

func (s *Create_table_column_inline_consContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_column_inline_consContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_table_column_inline_consContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_column_inline_cons(s)
	}
}

func (s *Create_table_column_inline_consContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_column_inline_cons(s)
	}
}




func (p *HplsqlParser) Create_table_column_inline_cons() (localctx ICreate_table_column_inline_consContext) {
	localctx = NewCreate_table_column_inline_consContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, HplsqlParserRULE_create_table_column_inline_cons)
	var _la int

	p.SetState(1022)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_DEFAULT, HplsqlParserT_WITH, HplsqlParserT_COLON, HplsqlParserT_EQUAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(990)
			p.Dtype_default()
		}


	case HplsqlParserT_NOT, HplsqlParserT_NULL:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(992)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_NOT {
			{
				p.SetState(991)
				p.Match(HplsqlParserT_NOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(994)
			p.Match(HplsqlParserT_NULL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_PRIMARY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(995)
			p.Match(HplsqlParserT_PRIMARY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(996)
			p.Match(HplsqlParserT_KEY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_UNIQUE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(997)
			p.Match(HplsqlParserT_UNIQUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_REFERENCES:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(998)
			p.Match(HplsqlParserT_REFERENCES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(999)
			p.Table_name()
		}
		{
			p.SetState(1000)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1001)
			p.Qident()
		}
		{
			p.SetState(1002)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1006)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == HplsqlParserT_ON {
			{
				p.SetState(1003)
				p.Create_table_fk_action()
			}


			p.SetState(1008)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}


	case HplsqlParserT_IDENTITY:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1009)
			p.Match(HplsqlParserT_IDENTITY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1010)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1011)
			p.Match(HplsqlParserL_INT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1016)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(1012)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1013)
				p.Match(HplsqlParserL_INT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


			p.SetState(1018)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1019)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_AUTO_INCREMENT:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1020)
			p.Match(HplsqlParserT_AUTO_INCREMENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_ENABLE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1021)
			p.Match(HplsqlParserT_ENABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_table_column_consContext is an interface to support dynamic dispatch.
type ICreate_table_column_consContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_PRIMARY() antlr.TerminalNode
	T_KEY() antlr.TerminalNode
	AllT_OPEN_P() []antlr.TerminalNode
	T_OPEN_P(i int) antlr.TerminalNode
	AllQident() []IQidentContext
	Qident(i int) IQidentContext
	AllT_CLOSE_P() []antlr.TerminalNode
	T_CLOSE_P(i int) antlr.TerminalNode
	T_CLUSTERED() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	T_ENABLE() antlr.TerminalNode
	Index_storage_clause() IIndex_storage_clauseContext
	AllT_ASC() []antlr.TerminalNode
	T_ASC(i int) antlr.TerminalNode
	AllT_DESC() []antlr.TerminalNode
	T_DESC(i int) antlr.TerminalNode
	T_FOREIGN() antlr.TerminalNode
	T_REFERENCES() antlr.TerminalNode
	Table_name() ITable_nameContext
	AllCreate_table_fk_action() []ICreate_table_fk_actionContext
	Create_table_fk_action(i int) ICreate_table_fk_actionContext

	// IsCreate_table_column_consContext differentiates from other interfaces.
	IsCreate_table_column_consContext()
}

type Create_table_column_consContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_column_consContext() *Create_table_column_consContext {
	var p = new(Create_table_column_consContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_column_cons
	return p
}

func InitEmptyCreate_table_column_consContext(p *Create_table_column_consContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_column_cons
}

func (*Create_table_column_consContext) IsCreate_table_column_consContext() {}

func NewCreate_table_column_consContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_column_consContext {
	var p = new(Create_table_column_consContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_column_cons

	return p
}

func (s *Create_table_column_consContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_column_consContext) T_PRIMARY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRIMARY, 0)
}

func (s *Create_table_column_consContext) T_KEY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_KEY, 0)
}

func (s *Create_table_column_consContext) AllT_OPEN_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_OPEN_P)
}

func (s *Create_table_column_consContext) T_OPEN_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, i)
}

func (s *Create_table_column_consContext) AllQident() []IQidentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQidentContext); ok {
			len++
		}
	}

	tst := make([]IQidentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQidentContext); ok {
			tst[i] = t.(IQidentContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_column_consContext) Qident(i int) IQidentContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_table_column_consContext) AllT_CLOSE_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_CLOSE_P)
}

func (s *Create_table_column_consContext) T_CLOSE_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, i)
}

func (s *Create_table_column_consContext) T_CLUSTERED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLUSTERED, 0)
}

func (s *Create_table_column_consContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Create_table_column_consContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Create_table_column_consContext) T_ENABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ENABLE, 0)
}

func (s *Create_table_column_consContext) Index_storage_clause() IIndex_storage_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_storage_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_storage_clauseContext)
}

func (s *Create_table_column_consContext) AllT_ASC() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_ASC)
}

func (s *Create_table_column_consContext) T_ASC(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ASC, i)
}

func (s *Create_table_column_consContext) AllT_DESC() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_DESC)
}

func (s *Create_table_column_consContext) T_DESC(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DESC, i)
}

func (s *Create_table_column_consContext) T_FOREIGN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOREIGN, 0)
}

func (s *Create_table_column_consContext) T_REFERENCES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REFERENCES, 0)
}

func (s *Create_table_column_consContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Create_table_column_consContext) AllCreate_table_fk_action() []ICreate_table_fk_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_fk_actionContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_fk_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_fk_actionContext); ok {
			tst[i] = t.(ICreate_table_fk_actionContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_column_consContext) Create_table_fk_action(i int) ICreate_table_fk_actionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_fk_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_fk_actionContext)
}

func (s *Create_table_column_consContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_column_consContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_table_column_consContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_column_cons(s)
	}
}

func (s *Create_table_column_consContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_column_cons(s)
	}
}




func (p *HplsqlParser) Create_table_column_cons() (localctx ICreate_table_column_consContext) {
	localctx = NewCreate_table_column_consContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, HplsqlParserRULE_create_table_column_cons)
	var _la int

	p.SetState(1081)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_PRIMARY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1024)
			p.Match(HplsqlParserT_PRIMARY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1025)
			p.Match(HplsqlParserT_KEY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1027)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_CLUSTERED {
			{
				p.SetState(1026)
				p.Match(HplsqlParserT_CLUSTERED)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1029)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1030)
			p.Qident()
		}
		p.SetState(1032)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC {
			{
				p.SetState(1031)
				_la = p.GetTokenStream().LA(1)

				if !(_la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1041)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(1034)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1035)
				p.Qident()
			}
			p.SetState(1037)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC {
				{
					p.SetState(1036)
					_la = p.GetTokenStream().LA(1)

					if !(_la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}


			p.SetState(1043)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1044)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1046)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_ENABLE {
			{
				p.SetState(1045)
				p.Match(HplsqlParserT_ENABLE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		p.SetState(1049)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_WITH {
			{
				p.SetState(1048)
				p.Index_storage_clause()
			}

		}


	case HplsqlParserT_FOREIGN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1051)
			p.Match(HplsqlParserT_FOREIGN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1052)
			p.Match(HplsqlParserT_KEY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1053)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1054)
			p.Qident()
		}
		p.SetState(1059)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(1055)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1056)
				p.Qident()
			}


			p.SetState(1061)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1062)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1063)
			p.Match(HplsqlParserT_REFERENCES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1064)
			p.Table_name()
		}
		{
			p.SetState(1065)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1066)
			p.Qident()
		}
		p.SetState(1071)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(1067)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1068)
				p.Qident()
			}


			p.SetState(1073)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1074)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1078)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == HplsqlParserT_ON {
			{
				p.SetState(1075)
				p.Create_table_fk_action()
			}


			p.SetState(1080)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_table_fk_actionContext is an interface to support dynamic dispatch.
type ICreate_table_fk_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ON() antlr.TerminalNode
	T_UPDATE() antlr.TerminalNode
	T_DELETE() antlr.TerminalNode
	T_NO() antlr.TerminalNode
	T_ACTION() antlr.TerminalNode
	T_RESTRICT() antlr.TerminalNode
	T_SET() antlr.TerminalNode
	T_NULL() antlr.TerminalNode
	T_DEFAULT() antlr.TerminalNode
	T_CASCADE() antlr.TerminalNode

	// IsCreate_table_fk_actionContext differentiates from other interfaces.
	IsCreate_table_fk_actionContext()
}

type Create_table_fk_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_fk_actionContext() *Create_table_fk_actionContext {
	var p = new(Create_table_fk_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_fk_action
	return p
}

func InitEmptyCreate_table_fk_actionContext(p *Create_table_fk_actionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_fk_action
}

func (*Create_table_fk_actionContext) IsCreate_table_fk_actionContext() {}

func NewCreate_table_fk_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_fk_actionContext {
	var p = new(Create_table_fk_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_fk_action

	return p
}

func (s *Create_table_fk_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_fk_actionContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *Create_table_fk_actionContext) T_UPDATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UPDATE, 0)
}

func (s *Create_table_fk_actionContext) T_DELETE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DELETE, 0)
}

func (s *Create_table_fk_actionContext) T_NO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NO, 0)
}

func (s *Create_table_fk_actionContext) T_ACTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ACTION, 0)
}

func (s *Create_table_fk_actionContext) T_RESTRICT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESTRICT, 0)
}

func (s *Create_table_fk_actionContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Create_table_fk_actionContext) T_NULL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NULL, 0)
}

func (s *Create_table_fk_actionContext) T_DEFAULT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFAULT, 0)
}

func (s *Create_table_fk_actionContext) T_CASCADE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CASCADE, 0)
}

func (s *Create_table_fk_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_fk_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_table_fk_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_fk_action(s)
	}
}

func (s *Create_table_fk_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_fk_action(s)
	}
}




func (p *HplsqlParser) Create_table_fk_action() (localctx ICreate_table_fk_actionContext) {
	localctx = NewCreate_table_fk_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, HplsqlParserRULE_create_table_fk_action)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1083)
		p.Match(HplsqlParserT_ON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1084)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_DELETE || _la == HplsqlParserT_UPDATE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1093)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 83, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1085)
			p.Match(HplsqlParserT_NO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1086)
			p.Match(HplsqlParserT_ACTION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		{
			p.SetState(1087)
			p.Match(HplsqlParserT_RESTRICT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		{
			p.SetState(1088)
			p.Match(HplsqlParserT_SET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1089)
			p.Match(HplsqlParserT_NULL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		{
			p.SetState(1090)
			p.Match(HplsqlParserT_SET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1091)
			p.Match(HplsqlParserT_DEFAULT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 5:
		{
			p.SetState(1092)
			p.Match(HplsqlParserT_CASCADE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_table_preoptionsContext is an interface to support dynamic dispatch.
type ICreate_table_preoptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCreate_table_preoptions_item() []ICreate_table_preoptions_itemContext
	Create_table_preoptions_item(i int) ICreate_table_preoptions_itemContext

	// IsCreate_table_preoptionsContext differentiates from other interfaces.
	IsCreate_table_preoptionsContext()
}

type Create_table_preoptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_preoptionsContext() *Create_table_preoptionsContext {
	var p = new(Create_table_preoptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_preoptions
	return p
}

func InitEmptyCreate_table_preoptionsContext(p *Create_table_preoptionsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_preoptions
}

func (*Create_table_preoptionsContext) IsCreate_table_preoptionsContext() {}

func NewCreate_table_preoptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_preoptionsContext {
	var p = new(Create_table_preoptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_preoptions

	return p
}

func (s *Create_table_preoptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_preoptionsContext) AllCreate_table_preoptions_item() []ICreate_table_preoptions_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_preoptions_itemContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_preoptions_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_preoptions_itemContext); ok {
			tst[i] = t.(ICreate_table_preoptions_itemContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_preoptionsContext) Create_table_preoptions_item(i int) ICreate_table_preoptions_itemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_preoptions_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_preoptions_itemContext)
}

func (s *Create_table_preoptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_preoptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_table_preoptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_preoptions(s)
	}
}

func (s *Create_table_preoptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_preoptions(s)
	}
}




func (p *HplsqlParser) Create_table_preoptions() (localctx ICreate_table_preoptionsContext) {
	localctx = NewCreate_table_preoptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, HplsqlParserRULE_create_table_preoptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1096)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = _la == HplsqlParserT_ROW || _la == HplsqlParserT_STORED || _la == HplsqlParserT_COMMA {
		{
			p.SetState(1095)
			p.Create_table_preoptions_item()
		}


		p.SetState(1098)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_table_preoptions_itemContext is an interface to support dynamic dispatch.
type ICreate_table_preoptions_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_COMMA() antlr.TerminalNode
	Create_table_preoptions_td_item() ICreate_table_preoptions_td_itemContext
	Create_table_options_hive_item() ICreate_table_options_hive_itemContext

	// IsCreate_table_preoptions_itemContext differentiates from other interfaces.
	IsCreate_table_preoptions_itemContext()
}

type Create_table_preoptions_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_preoptions_itemContext() *Create_table_preoptions_itemContext {
	var p = new(Create_table_preoptions_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_preoptions_item
	return p
}

func InitEmptyCreate_table_preoptions_itemContext(p *Create_table_preoptions_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_preoptions_item
}

func (*Create_table_preoptions_itemContext) IsCreate_table_preoptions_itemContext() {}

func NewCreate_table_preoptions_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_preoptions_itemContext {
	var p = new(Create_table_preoptions_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_preoptions_item

	return p
}

func (s *Create_table_preoptions_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_preoptions_itemContext) T_COMMA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, 0)
}

func (s *Create_table_preoptions_itemContext) Create_table_preoptions_td_item() ICreate_table_preoptions_td_itemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_preoptions_td_itemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_preoptions_td_itemContext)
}

func (s *Create_table_preoptions_itemContext) Create_table_options_hive_item() ICreate_table_options_hive_itemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_options_hive_itemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_options_hive_itemContext)
}

func (s *Create_table_preoptions_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_preoptions_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_table_preoptions_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_preoptions_item(s)
	}
}

func (s *Create_table_preoptions_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_preoptions_item(s)
	}
}




func (p *HplsqlParser) Create_table_preoptions_item() (localctx ICreate_table_preoptions_itemContext) {
	localctx = NewCreate_table_preoptions_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, HplsqlParserRULE_create_table_preoptions_item)
	p.SetState(1103)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_COMMA:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1100)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1101)
			p.Create_table_preoptions_td_item()
		}


	case HplsqlParserT_ROW, HplsqlParserT_STORED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1102)
			p.Create_table_options_hive_item()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_table_preoptions_td_itemContext is an interface to support dynamic dispatch.
type ICreate_table_preoptions_td_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_LOG() antlr.TerminalNode
	T_FALLBACK() antlr.TerminalNode
	T_NO() antlr.TerminalNode

	// IsCreate_table_preoptions_td_itemContext differentiates from other interfaces.
	IsCreate_table_preoptions_td_itemContext()
}

type Create_table_preoptions_td_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_preoptions_td_itemContext() *Create_table_preoptions_td_itemContext {
	var p = new(Create_table_preoptions_td_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_preoptions_td_item
	return p
}

func InitEmptyCreate_table_preoptions_td_itemContext(p *Create_table_preoptions_td_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_preoptions_td_item
}

func (*Create_table_preoptions_td_itemContext) IsCreate_table_preoptions_td_itemContext() {}

func NewCreate_table_preoptions_td_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_preoptions_td_itemContext {
	var p = new(Create_table_preoptions_td_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_preoptions_td_item

	return p
}

func (s *Create_table_preoptions_td_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_preoptions_td_itemContext) T_LOG() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOG, 0)
}

func (s *Create_table_preoptions_td_itemContext) T_FALLBACK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FALLBACK, 0)
}

func (s *Create_table_preoptions_td_itemContext) T_NO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NO, 0)
}

func (s *Create_table_preoptions_td_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_preoptions_td_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_table_preoptions_td_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_preoptions_td_item(s)
	}
}

func (s *Create_table_preoptions_td_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_preoptions_td_item(s)
	}
}




func (p *HplsqlParser) Create_table_preoptions_td_item() (localctx ICreate_table_preoptions_td_itemContext) {
	localctx = NewCreate_table_preoptions_td_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, HplsqlParserRULE_create_table_preoptions_td_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1106)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_NO {
		{
			p.SetState(1105)
			p.Match(HplsqlParserT_NO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(1108)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_FALLBACK || _la == HplsqlParserT_LOG) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_table_optionsContext is an interface to support dynamic dispatch.
type ICreate_table_optionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCreate_table_options_item() []ICreate_table_options_itemContext
	Create_table_options_item(i int) ICreate_table_options_itemContext

	// IsCreate_table_optionsContext differentiates from other interfaces.
	IsCreate_table_optionsContext()
}

type Create_table_optionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_optionsContext() *Create_table_optionsContext {
	var p = new(Create_table_optionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options
	return p
}

func InitEmptyCreate_table_optionsContext(p *Create_table_optionsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options
}

func (*Create_table_optionsContext) IsCreate_table_optionsContext() {}

func NewCreate_table_optionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_optionsContext {
	var p = new(Create_table_optionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_options

	return p
}

func (s *Create_table_optionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_optionsContext) AllCreate_table_options_item() []ICreate_table_options_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_options_itemContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_options_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_options_itemContext); ok {
			tst[i] = t.(ICreate_table_options_itemContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_optionsContext) Create_table_options_item(i int) ICreate_table_options_itemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_options_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_options_itemContext)
}

func (s *Create_table_optionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_optionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_table_optionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_options(s)
	}
}

func (s *Create_table_optionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_options(s)
	}
}




func (p *HplsqlParser) Create_table_options() (localctx ICreate_table_optionsContext) {
	localctx = NewCreate_table_optionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, HplsqlParserRULE_create_table_options)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1111)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				{
					p.SetState(1110)
					p.Create_table_options_item()
				}




		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1113)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_table_options_itemContext is an interface to support dynamic dispatch.
type ICreate_table_options_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ON() antlr.TerminalNode
	T_COMMIT() antlr.TerminalNode
	T_ROWS() antlr.TerminalNode
	T_DELETE() antlr.TerminalNode
	T_PRESERVE() antlr.TerminalNode
	Create_table_options_ora_item() ICreate_table_options_ora_itemContext
	Create_table_options_db2_item() ICreate_table_options_db2_itemContext
	Create_table_options_td_item() ICreate_table_options_td_itemContext
	Create_table_options_hive_item() ICreate_table_options_hive_itemContext
	Create_table_options_mssql_item() ICreate_table_options_mssql_itemContext
	Create_table_options_mysql_item() ICreate_table_options_mysql_itemContext

	// IsCreate_table_options_itemContext differentiates from other interfaces.
	IsCreate_table_options_itemContext()
}

type Create_table_options_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_options_itemContext() *Create_table_options_itemContext {
	var p = new(Create_table_options_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_item
	return p
}

func InitEmptyCreate_table_options_itemContext(p *Create_table_options_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_item
}

func (*Create_table_options_itemContext) IsCreate_table_options_itemContext() {}

func NewCreate_table_options_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_options_itemContext {
	var p = new(Create_table_options_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_options_item

	return p
}

func (s *Create_table_options_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_options_itemContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *Create_table_options_itemContext) T_COMMIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMIT, 0)
}

func (s *Create_table_options_itemContext) T_ROWS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROWS, 0)
}

func (s *Create_table_options_itemContext) T_DELETE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DELETE, 0)
}

func (s *Create_table_options_itemContext) T_PRESERVE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRESERVE, 0)
}

func (s *Create_table_options_itemContext) Create_table_options_ora_item() ICreate_table_options_ora_itemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_options_ora_itemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_options_ora_itemContext)
}

func (s *Create_table_options_itemContext) Create_table_options_db2_item() ICreate_table_options_db2_itemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_options_db2_itemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_options_db2_itemContext)
}

func (s *Create_table_options_itemContext) Create_table_options_td_item() ICreate_table_options_td_itemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_options_td_itemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_options_td_itemContext)
}

func (s *Create_table_options_itemContext) Create_table_options_hive_item() ICreate_table_options_hive_itemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_options_hive_itemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_options_hive_itemContext)
}

func (s *Create_table_options_itemContext) Create_table_options_mssql_item() ICreate_table_options_mssql_itemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_options_mssql_itemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_options_mssql_itemContext)
}

func (s *Create_table_options_itemContext) Create_table_options_mysql_item() ICreate_table_options_mysql_itemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_options_mysql_itemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_options_mysql_itemContext)
}

func (s *Create_table_options_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_options_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_table_options_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_options_item(s)
	}
}

func (s *Create_table_options_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_options_item(s)
	}
}




func (p *HplsqlParser) Create_table_options_item() (localctx ICreate_table_options_itemContext) {
	localctx = NewCreate_table_options_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, HplsqlParserRULE_create_table_options_item)
	var _la int

	p.SetState(1125)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1115)
			p.Match(HplsqlParserT_ON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1116)
			p.Match(HplsqlParserT_COMMIT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1117)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_DELETE || _la == HplsqlParserT_PRESERVE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1118)
			p.Match(HplsqlParserT_ROWS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1119)
			p.Create_table_options_ora_item()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1120)
			p.Create_table_options_db2_item()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1121)
			p.Create_table_options_td_item()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1122)
			p.Create_table_options_hive_item()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1123)
			p.Create_table_options_mssql_item()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1124)
			p.Create_table_options_mysql_item()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_table_options_ora_itemContext is an interface to support dynamic dispatch.
type ICreate_table_options_ora_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_SEGMENT() antlr.TerminalNode
	T_CREATION() antlr.TerminalNode
	T_IMMEDIATE() antlr.TerminalNode
	T_DEFERRED() antlr.TerminalNode
	AllL_INT() []antlr.TerminalNode
	L_INT(i int) antlr.TerminalNode
	T_PCTFREE() antlr.TerminalNode
	T_PCTUSED() antlr.TerminalNode
	T_INITRANS() antlr.TerminalNode
	T_MAXTRANS() antlr.TerminalNode
	T_NOCOMPRESS() antlr.TerminalNode
	T_LOGGING() antlr.TerminalNode
	T_NOLOGGING() antlr.TerminalNode
	T_STORAGE() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode
	AllQident() []IQidentContext
	Qident(i int) IQidentContext
	T_TABLESPACE() antlr.TerminalNode

	// IsCreate_table_options_ora_itemContext differentiates from other interfaces.
	IsCreate_table_options_ora_itemContext()
}

type Create_table_options_ora_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_options_ora_itemContext() *Create_table_options_ora_itemContext {
	var p = new(Create_table_options_ora_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_ora_item
	return p
}

func InitEmptyCreate_table_options_ora_itemContext(p *Create_table_options_ora_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_ora_item
}

func (*Create_table_options_ora_itemContext) IsCreate_table_options_ora_itemContext() {}

func NewCreate_table_options_ora_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_options_ora_itemContext {
	var p = new(Create_table_options_ora_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_options_ora_item

	return p
}

func (s *Create_table_options_ora_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_options_ora_itemContext) T_SEGMENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEGMENT, 0)
}

func (s *Create_table_options_ora_itemContext) T_CREATION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATION, 0)
}

func (s *Create_table_options_ora_itemContext) T_IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IMMEDIATE, 0)
}

func (s *Create_table_options_ora_itemContext) T_DEFERRED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFERRED, 0)
}

func (s *Create_table_options_ora_itemContext) AllL_INT() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserL_INT)
}

func (s *Create_table_options_ora_itemContext) L_INT(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_INT, i)
}

func (s *Create_table_options_ora_itemContext) T_PCTFREE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PCTFREE, 0)
}

func (s *Create_table_options_ora_itemContext) T_PCTUSED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PCTUSED, 0)
}

func (s *Create_table_options_ora_itemContext) T_INITRANS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INITRANS, 0)
}

func (s *Create_table_options_ora_itemContext) T_MAXTRANS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAXTRANS, 0)
}

func (s *Create_table_options_ora_itemContext) T_NOCOMPRESS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOCOMPRESS, 0)
}

func (s *Create_table_options_ora_itemContext) T_LOGGING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOGGING, 0)
}

func (s *Create_table_options_ora_itemContext) T_NOLOGGING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOLOGGING, 0)
}

func (s *Create_table_options_ora_itemContext) T_STORAGE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STORAGE, 0)
}

func (s *Create_table_options_ora_itemContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Create_table_options_ora_itemContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Create_table_options_ora_itemContext) AllQident() []IQidentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQidentContext); ok {
			len++
		}
	}

	tst := make([]IQidentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQidentContext); ok {
			tst[i] = t.(IQidentContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_options_ora_itemContext) Qident(i int) IQidentContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_table_options_ora_itemContext) T_TABLESPACE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLESPACE, 0)
}

func (s *Create_table_options_ora_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_options_ora_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_table_options_ora_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_options_ora_item(s)
	}
}

func (s *Create_table_options_ora_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_options_ora_item(s)
	}
}




func (p *HplsqlParser) Create_table_options_ora_item() (localctx ICreate_table_options_ora_itemContext) {
	localctx = NewCreate_table_options_ora_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, HplsqlParserRULE_create_table_options_ora_item)
	var _la int

	p.SetState(1145)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_SEGMENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1127)
			p.Match(HplsqlParserT_SEGMENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1128)
			p.Match(HplsqlParserT_CREATION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1129)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_DEFERRED || _la == HplsqlParserT_IMMEDIATE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case HplsqlParserT_INITRANS, HplsqlParserT_MAXTRANS, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1130)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_INITRANS || _la == HplsqlParserT_MAXTRANS || _la == HplsqlParserT_PCTFREE || _la == HplsqlParserT_PCTUSED) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1131)
			p.Match(HplsqlParserL_INT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_NOCOMPRESS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1132)
			p.Match(HplsqlParserT_NOCOMPRESS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_LOGGING, HplsqlParserT_NOLOGGING:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1133)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_LOGGING || _la == HplsqlParserT_NOLOGGING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case HplsqlParserT_STORAGE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1134)
			p.Match(HplsqlParserT_STORAGE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1135)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1138)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -33554464) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -24696061953) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & -36028797018963969) != 0) || ((int64((_la - 192)) & ^0x3f) == 0 && ((int64(1) << (_la - 192)) & -9007199271518737) != 0) || ((int64((_la - 256)) & ^0x3f) == 0 && ((int64(1) << (_la - 256)) & -864744076811961345) != 0) || ((int64((_la - 320)) & ^0x3f) == 0 && ((int64(1) << (_la - 320)) & 42784196727422975) != 0) {
			p.SetState(1138)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_SUB, HplsqlParserL_ID:
				{
					p.SetState(1136)
					p.Qident()
				}


			case HplsqlParserL_INT:
				{
					p.SetState(1137)
					p.Match(HplsqlParserL_INT)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}



			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(1140)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1142)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_TABLESPACE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1143)
			p.Match(HplsqlParserT_TABLESPACE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1144)
			p.Qident()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_table_options_db2_itemContext is an interface to support dynamic dispatch.
type ICreate_table_options_db2_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_IN() antlr.TerminalNode
	AllQident() []IQidentContext
	Qident(i int) IQidentContext
	T_INDEX() antlr.TerminalNode
	T_WITH() antlr.TerminalNode
	T_REPLACE() antlr.TerminalNode
	T_DISTRIBUTE() antlr.TerminalNode
	T_BY() antlr.TerminalNode
	T_HASH() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	T_LOGGED() antlr.TerminalNode
	T_NOT() antlr.TerminalNode
	T_COMPRESS() antlr.TerminalNode
	T_YES() antlr.TerminalNode
	T_NO() antlr.TerminalNode
	T_DEFINITION() antlr.TerminalNode
	T_ONLY() antlr.TerminalNode
	T_RESTRICT() antlr.TerminalNode
	T_ON() antlr.TerminalNode
	T_DROP() antlr.TerminalNode

	// IsCreate_table_options_db2_itemContext differentiates from other interfaces.
	IsCreate_table_options_db2_itemContext()
}

type Create_table_options_db2_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_options_db2_itemContext() *Create_table_options_db2_itemContext {
	var p = new(Create_table_options_db2_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_db2_item
	return p
}

func InitEmptyCreate_table_options_db2_itemContext(p *Create_table_options_db2_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_db2_item
}

func (*Create_table_options_db2_itemContext) IsCreate_table_options_db2_itemContext() {}

func NewCreate_table_options_db2_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_options_db2_itemContext {
	var p = new(Create_table_options_db2_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_options_db2_item

	return p
}

func (s *Create_table_options_db2_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_options_db2_itemContext) T_IN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IN, 0)
}

func (s *Create_table_options_db2_itemContext) AllQident() []IQidentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQidentContext); ok {
			len++
		}
	}

	tst := make([]IQidentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQidentContext); ok {
			tst[i] = t.(IQidentContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_options_db2_itemContext) Qident(i int) IQidentContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_table_options_db2_itemContext) T_INDEX() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INDEX, 0)
}

func (s *Create_table_options_db2_itemContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITH, 0)
}

func (s *Create_table_options_db2_itemContext) T_REPLACE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REPLACE, 0)
}

func (s *Create_table_options_db2_itemContext) T_DISTRIBUTE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DISTRIBUTE, 0)
}

func (s *Create_table_options_db2_itemContext) T_BY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BY, 0)
}

func (s *Create_table_options_db2_itemContext) T_HASH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HASH, 0)
}

func (s *Create_table_options_db2_itemContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Create_table_options_db2_itemContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Create_table_options_db2_itemContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Create_table_options_db2_itemContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Create_table_options_db2_itemContext) T_LOGGED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOGGED, 0)
}

func (s *Create_table_options_db2_itemContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Create_table_options_db2_itemContext) T_COMPRESS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMPRESS, 0)
}

func (s *Create_table_options_db2_itemContext) T_YES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_YES, 0)
}

func (s *Create_table_options_db2_itemContext) T_NO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NO, 0)
}

func (s *Create_table_options_db2_itemContext) T_DEFINITION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFINITION, 0)
}

func (s *Create_table_options_db2_itemContext) T_ONLY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ONLY, 0)
}

func (s *Create_table_options_db2_itemContext) T_RESTRICT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESTRICT, 0)
}

func (s *Create_table_options_db2_itemContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *Create_table_options_db2_itemContext) T_DROP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DROP, 0)
}

func (s *Create_table_options_db2_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_options_db2_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_table_options_db2_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_options_db2_item(s)
	}
}

func (s *Create_table_options_db2_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_options_db2_item(s)
	}
}




func (p *HplsqlParser) Create_table_options_db2_item() (localctx ICreate_table_options_db2_itemContext) {
	localctx = NewCreate_table_options_db2_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, HplsqlParserRULE_create_table_options_db2_item)
	var _la int

	p.SetState(1180)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 95, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1148)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_INDEX {
			{
				p.SetState(1147)
				p.Match(HplsqlParserT_INDEX)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1150)
			p.Match(HplsqlParserT_IN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1151)
			p.Qident()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1152)
			p.Match(HplsqlParserT_WITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1153)
			p.Match(HplsqlParserT_REPLACE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1154)
			p.Match(HplsqlParserT_DISTRIBUTE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1155)
			p.Match(HplsqlParserT_BY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1156)
			p.Match(HplsqlParserT_HASH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1157)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1158)
			p.Qident()
		}
		p.SetState(1163)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(1159)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1160)
				p.Qident()
			}


			p.SetState(1165)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1166)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1169)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_NOT {
			{
				p.SetState(1168)
				p.Match(HplsqlParserT_NOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1171)
			p.Match(HplsqlParserT_LOGGED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1172)
			p.Match(HplsqlParserT_COMPRESS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1173)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_NO || _la == HplsqlParserT_YES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1174)
			p.Match(HplsqlParserT_DEFINITION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1175)
			p.Match(HplsqlParserT_ONLY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1176)
			p.Match(HplsqlParserT_WITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1177)
			p.Match(HplsqlParserT_RESTRICT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1178)
			p.Match(HplsqlParserT_ON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1179)
			p.Match(HplsqlParserT_DROP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_table_options_td_itemContext is an interface to support dynamic dispatch.
type ICreate_table_options_td_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_PRIMARY() antlr.TerminalNode
	T_INDEX() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	AllQident() []IQidentContext
	Qident(i int) IQidentContext
	T_CLOSE_P() antlr.TerminalNode
	T_UNIQUE() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	T_WITH() antlr.TerminalNode
	T_DATA() antlr.TerminalNode

	// IsCreate_table_options_td_itemContext differentiates from other interfaces.
	IsCreate_table_options_td_itemContext()
}

type Create_table_options_td_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_options_td_itemContext() *Create_table_options_td_itemContext {
	var p = new(Create_table_options_td_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_td_item
	return p
}

func InitEmptyCreate_table_options_td_itemContext(p *Create_table_options_td_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_td_item
}

func (*Create_table_options_td_itemContext) IsCreate_table_options_td_itemContext() {}

func NewCreate_table_options_td_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_options_td_itemContext {
	var p = new(Create_table_options_td_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_options_td_item

	return p
}

func (s *Create_table_options_td_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_options_td_itemContext) T_PRIMARY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRIMARY, 0)
}

func (s *Create_table_options_td_itemContext) T_INDEX() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INDEX, 0)
}

func (s *Create_table_options_td_itemContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Create_table_options_td_itemContext) AllQident() []IQidentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQidentContext); ok {
			len++
		}
	}

	tst := make([]IQidentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQidentContext); ok {
			tst[i] = t.(IQidentContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_options_td_itemContext) Qident(i int) IQidentContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_table_options_td_itemContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Create_table_options_td_itemContext) T_UNIQUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UNIQUE, 0)
}

func (s *Create_table_options_td_itemContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Create_table_options_td_itemContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Create_table_options_td_itemContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITH, 0)
}

func (s *Create_table_options_td_itemContext) T_DATA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATA, 0)
}

func (s *Create_table_options_td_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_options_td_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_table_options_td_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_options_td_item(s)
	}
}

func (s *Create_table_options_td_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_options_td_item(s)
	}
}




func (p *HplsqlParser) Create_table_options_td_item() (localctx ICreate_table_options_td_itemContext) {
	localctx = NewCreate_table_options_td_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, HplsqlParserRULE_create_table_options_td_item)
	var _la int

	p.SetState(1200)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_PRIMARY, HplsqlParserT_UNIQUE:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1183)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_UNIQUE {
			{
				p.SetState(1182)
				p.Match(HplsqlParserT_UNIQUE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1185)
			p.Match(HplsqlParserT_PRIMARY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1186)
			p.Match(HplsqlParserT_INDEX)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1187)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1188)
			p.Qident()
		}
		p.SetState(1193)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(1189)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1190)
				p.Qident()
			}


			p.SetState(1195)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1196)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_WITH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1198)
			p.Match(HplsqlParserT_WITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1199)
			p.Match(HplsqlParserT_DATA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_table_options_hive_itemContext is an interface to support dynamic dispatch.
type ICreate_table_options_hive_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Create_table_hive_row_format() ICreate_table_hive_row_formatContext
	T_STORED() antlr.TerminalNode
	T_AS() antlr.TerminalNode
	Qident() IQidentContext

	// IsCreate_table_options_hive_itemContext differentiates from other interfaces.
	IsCreate_table_options_hive_itemContext()
}

type Create_table_options_hive_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_options_hive_itemContext() *Create_table_options_hive_itemContext {
	var p = new(Create_table_options_hive_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_hive_item
	return p
}

func InitEmptyCreate_table_options_hive_itemContext(p *Create_table_options_hive_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_hive_item
}

func (*Create_table_options_hive_itemContext) IsCreate_table_options_hive_itemContext() {}

func NewCreate_table_options_hive_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_options_hive_itemContext {
	var p = new(Create_table_options_hive_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_options_hive_item

	return p
}

func (s *Create_table_options_hive_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_options_hive_itemContext) Create_table_hive_row_format() ICreate_table_hive_row_formatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_hive_row_formatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_hive_row_formatContext)
}

func (s *Create_table_options_hive_itemContext) T_STORED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STORED, 0)
}

func (s *Create_table_options_hive_itemContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Create_table_options_hive_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_table_options_hive_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_options_hive_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_table_options_hive_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_options_hive_item(s)
	}
}

func (s *Create_table_options_hive_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_options_hive_item(s)
	}
}




func (p *HplsqlParser) Create_table_options_hive_item() (localctx ICreate_table_options_hive_itemContext) {
	localctx = NewCreate_table_options_hive_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, HplsqlParserRULE_create_table_options_hive_item)
	p.SetState(1206)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ROW:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1202)
			p.Create_table_hive_row_format()
		}


	case HplsqlParserT_STORED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1203)
			p.Match(HplsqlParserT_STORED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1204)
			p.Match(HplsqlParserT_AS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1205)
			p.Qident()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_table_hive_row_formatContext is an interface to support dynamic dispatch.
type ICreate_table_hive_row_formatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ROW() antlr.TerminalNode
	T_FORMAT() antlr.TerminalNode
	T_DELIMITED() antlr.TerminalNode
	AllCreate_table_hive_row_format_fields() []ICreate_table_hive_row_format_fieldsContext
	Create_table_hive_row_format_fields(i int) ICreate_table_hive_row_format_fieldsContext

	// IsCreate_table_hive_row_formatContext differentiates from other interfaces.
	IsCreate_table_hive_row_formatContext()
}

type Create_table_hive_row_formatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_hive_row_formatContext() *Create_table_hive_row_formatContext {
	var p = new(Create_table_hive_row_formatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_hive_row_format
	return p
}

func InitEmptyCreate_table_hive_row_formatContext(p *Create_table_hive_row_formatContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_hive_row_format
}

func (*Create_table_hive_row_formatContext) IsCreate_table_hive_row_formatContext() {}

func NewCreate_table_hive_row_formatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_hive_row_formatContext {
	var p = new(Create_table_hive_row_formatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_hive_row_format

	return p
}

func (s *Create_table_hive_row_formatContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_hive_row_formatContext) T_ROW() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROW, 0)
}

func (s *Create_table_hive_row_formatContext) T_FORMAT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FORMAT, 0)
}

func (s *Create_table_hive_row_formatContext) T_DELIMITED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DELIMITED, 0)
}

func (s *Create_table_hive_row_formatContext) AllCreate_table_hive_row_format_fields() []ICreate_table_hive_row_format_fieldsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_hive_row_format_fieldsContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_hive_row_format_fieldsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_hive_row_format_fieldsContext); ok {
			tst[i] = t.(ICreate_table_hive_row_format_fieldsContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_hive_row_formatContext) Create_table_hive_row_format_fields(i int) ICreate_table_hive_row_format_fieldsContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_hive_row_format_fieldsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_hive_row_format_fieldsContext)
}

func (s *Create_table_hive_row_formatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_hive_row_formatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_table_hive_row_formatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_hive_row_format(s)
	}
}

func (s *Create_table_hive_row_formatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_hive_row_format(s)
	}
}




func (p *HplsqlParser) Create_table_hive_row_format() (localctx ICreate_table_hive_row_formatContext) {
	localctx = NewCreate_table_hive_row_formatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, HplsqlParserRULE_create_table_hive_row_format)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1208)
		p.Match(HplsqlParserT_ROW)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1209)
		p.Match(HplsqlParserT_FORMAT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1210)
		p.Match(HplsqlParserT_DELIMITED)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1214)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 100, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1211)
				p.Create_table_hive_row_format_fields()
			}


		}
		p.SetState(1216)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 100, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_table_hive_row_format_fieldsContext is an interface to support dynamic dispatch.
type ICreate_table_hive_row_format_fieldsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_FIELDS() antlr.TerminalNode
	T_TERMINATED() antlr.TerminalNode
	AllT_BY() []antlr.TerminalNode
	T_BY(i int) antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_ESCAPED() antlr.TerminalNode
	T_COLLECTION() antlr.TerminalNode
	T_ITEMS() antlr.TerminalNode
	T_MAP() antlr.TerminalNode
	T_KEYS() antlr.TerminalNode
	T_LINES() antlr.TerminalNode
	T_NULL() antlr.TerminalNode
	T_DEFINED() antlr.TerminalNode
	T_AS() antlr.TerminalNode

	// IsCreate_table_hive_row_format_fieldsContext differentiates from other interfaces.
	IsCreate_table_hive_row_format_fieldsContext()
}

type Create_table_hive_row_format_fieldsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_hive_row_format_fieldsContext() *Create_table_hive_row_format_fieldsContext {
	var p = new(Create_table_hive_row_format_fieldsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_hive_row_format_fields
	return p
}

func InitEmptyCreate_table_hive_row_format_fieldsContext(p *Create_table_hive_row_format_fieldsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_hive_row_format_fields
}

func (*Create_table_hive_row_format_fieldsContext) IsCreate_table_hive_row_format_fieldsContext() {}

func NewCreate_table_hive_row_format_fieldsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_hive_row_format_fieldsContext {
	var p = new(Create_table_hive_row_format_fieldsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_hive_row_format_fields

	return p
}

func (s *Create_table_hive_row_format_fieldsContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_hive_row_format_fieldsContext) T_FIELDS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FIELDS, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) T_TERMINATED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TERMINATED, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) AllT_BY() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_BY)
}

func (s *Create_table_hive_row_format_fieldsContext) T_BY(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BY, i)
}

func (s *Create_table_hive_row_format_fieldsContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Create_table_hive_row_format_fieldsContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Create_table_hive_row_format_fieldsContext) T_ESCAPED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ESCAPED, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) T_COLLECTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLLECTION, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) T_ITEMS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ITEMS, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) T_MAP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAP, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) T_KEYS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_KEYS, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) T_LINES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LINES, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) T_NULL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NULL, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) T_DEFINED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFINED, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Create_table_hive_row_format_fieldsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_hive_row_format_fieldsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_table_hive_row_format_fieldsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_hive_row_format_fields(s)
	}
}

func (s *Create_table_hive_row_format_fieldsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_hive_row_format_fields(s)
	}
}




func (p *HplsqlParser) Create_table_hive_row_format_fields() (localctx ICreate_table_hive_row_format_fieldsContext) {
	localctx = NewCreate_table_hive_row_format_fieldsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, HplsqlParserRULE_create_table_hive_row_format_fields)
	p.SetState(1244)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_FIELDS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1217)
			p.Match(HplsqlParserT_FIELDS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1218)
			p.Match(HplsqlParserT_TERMINATED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1219)
			p.Match(HplsqlParserT_BY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1220)
			p.expr(0)
		}
		p.SetState(1224)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1221)
				p.Match(HplsqlParserT_ESCAPED)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1222)
				p.Match(HplsqlParserT_BY)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1223)
				p.expr(0)
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case HplsqlParserT_COLLECTION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1226)
			p.Match(HplsqlParserT_COLLECTION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1227)
			p.Match(HplsqlParserT_ITEMS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1228)
			p.Match(HplsqlParserT_TERMINATED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1229)
			p.Match(HplsqlParserT_BY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1230)
			p.expr(0)
		}


	case HplsqlParserT_MAP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1231)
			p.Match(HplsqlParserT_MAP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1232)
			p.Match(HplsqlParserT_KEYS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1233)
			p.Match(HplsqlParserT_TERMINATED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1234)
			p.Match(HplsqlParserT_BY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1235)
			p.expr(0)
		}


	case HplsqlParserT_LINES:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1236)
			p.Match(HplsqlParserT_LINES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1237)
			p.Match(HplsqlParserT_TERMINATED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1238)
			p.Match(HplsqlParserT_BY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1239)
			p.expr(0)
		}


	case HplsqlParserT_NULL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1240)
			p.Match(HplsqlParserT_NULL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1241)
			p.Match(HplsqlParserT_DEFINED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1242)
			p.Match(HplsqlParserT_AS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1243)
			p.expr(0)
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_table_options_mssql_itemContext is an interface to support dynamic dispatch.
type ICreate_table_options_mssql_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ON() antlr.TerminalNode
	Qident() IQidentContext
	T_TEXTIMAGE_ON() antlr.TerminalNode

	// IsCreate_table_options_mssql_itemContext differentiates from other interfaces.
	IsCreate_table_options_mssql_itemContext()
}

type Create_table_options_mssql_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_options_mssql_itemContext() *Create_table_options_mssql_itemContext {
	var p = new(Create_table_options_mssql_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_mssql_item
	return p
}

func InitEmptyCreate_table_options_mssql_itemContext(p *Create_table_options_mssql_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_mssql_item
}

func (*Create_table_options_mssql_itemContext) IsCreate_table_options_mssql_itemContext() {}

func NewCreate_table_options_mssql_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_options_mssql_itemContext {
	var p = new(Create_table_options_mssql_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_options_mssql_item

	return p
}

func (s *Create_table_options_mssql_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_options_mssql_itemContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *Create_table_options_mssql_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_table_options_mssql_itemContext) T_TEXTIMAGE_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TEXTIMAGE_ON, 0)
}

func (s *Create_table_options_mssql_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_options_mssql_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_table_options_mssql_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_options_mssql_item(s)
	}
}

func (s *Create_table_options_mssql_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_options_mssql_item(s)
	}
}




func (p *HplsqlParser) Create_table_options_mssql_item() (localctx ICreate_table_options_mssql_itemContext) {
	localctx = NewCreate_table_options_mssql_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, HplsqlParserRULE_create_table_options_mssql_item)
	p.SetState(1250)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1246)
			p.Match(HplsqlParserT_ON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1247)
			p.Qident()
		}


	case HplsqlParserT_TEXTIMAGE_ON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1248)
			p.Match(HplsqlParserT_TEXTIMAGE_ON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1249)
			p.Qident()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_table_options_mysql_itemContext is an interface to support dynamic dispatch.
type ICreate_table_options_mysql_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_AUTO_INCREMENT() antlr.TerminalNode
	Expr() IExprContext
	T_EQUAL() antlr.TerminalNode
	T_COMMENT() antlr.TerminalNode
	T_CHARACTER() antlr.TerminalNode
	T_SET() antlr.TerminalNode
	T_CHARSET() antlr.TerminalNode
	T_DEFAULT() antlr.TerminalNode
	T_ENGINE() antlr.TerminalNode

	// IsCreate_table_options_mysql_itemContext differentiates from other interfaces.
	IsCreate_table_options_mysql_itemContext()
}

type Create_table_options_mysql_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_table_options_mysql_itemContext() *Create_table_options_mysql_itemContext {
	var p = new(Create_table_options_mysql_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_mysql_item
	return p
}

func InitEmptyCreate_table_options_mysql_itemContext(p *Create_table_options_mysql_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_table_options_mysql_item
}

func (*Create_table_options_mysql_itemContext) IsCreate_table_options_mysql_itemContext() {}

func NewCreate_table_options_mysql_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_table_options_mysql_itemContext {
	var p = new(Create_table_options_mysql_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_table_options_mysql_item

	return p
}

func (s *Create_table_options_mysql_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_table_options_mysql_itemContext) T_AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AUTO_INCREMENT, 0)
}

func (s *Create_table_options_mysql_itemContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Create_table_options_mysql_itemContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Create_table_options_mysql_itemContext) T_COMMENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMENT, 0)
}

func (s *Create_table_options_mysql_itemContext) T_CHARACTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CHARACTER, 0)
}

func (s *Create_table_options_mysql_itemContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Create_table_options_mysql_itemContext) T_CHARSET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CHARSET, 0)
}

func (s *Create_table_options_mysql_itemContext) T_DEFAULT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFAULT, 0)
}

func (s *Create_table_options_mysql_itemContext) T_ENGINE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ENGINE, 0)
}

func (s *Create_table_options_mysql_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_table_options_mysql_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_table_options_mysql_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_table_options_mysql_item(s)
	}
}

func (s *Create_table_options_mysql_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_table_options_mysql_item(s)
	}
}




func (p *HplsqlParser) Create_table_options_mysql_item() (localctx ICreate_table_options_mysql_itemContext) {
	localctx = NewCreate_table_options_mysql_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, HplsqlParserRULE_create_table_options_mysql_item)
	var _la int

	p.SetState(1279)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_AUTO_INCREMENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1252)
			p.Match(HplsqlParserT_AUTO_INCREMENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1254)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_EQUAL {
			{
				p.SetState(1253)
				p.Match(HplsqlParserT_EQUAL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1256)
			p.expr(0)
		}


	case HplsqlParserT_COMMENT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1257)
			p.Match(HplsqlParserT_COMMENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1259)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_EQUAL {
			{
				p.SetState(1258)
				p.Match(HplsqlParserT_EQUAL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1261)
			p.expr(0)
		}


	case HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_DEFAULT:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1263)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_DEFAULT {
			{
				p.SetState(1262)
				p.Match(HplsqlParserT_DEFAULT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		p.SetState(1268)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case HplsqlParserT_CHARACTER:
			{
				p.SetState(1265)
				p.Match(HplsqlParserT_CHARACTER)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1266)
				p.Match(HplsqlParserT_SET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case HplsqlParserT_CHARSET:
			{
				p.SetState(1267)
				p.Match(HplsqlParserT_CHARSET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(1271)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_EQUAL {
			{
				p.SetState(1270)
				p.Match(HplsqlParserT_EQUAL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1273)
			p.expr(0)
		}


	case HplsqlParserT_ENGINE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1274)
			p.Match(HplsqlParserT_ENGINE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1276)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_EQUAL {
			{
				p.SetState(1275)
				p.Match(HplsqlParserT_EQUAL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1278)
			p.expr(0)
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_table_stmtContext is an interface to support dynamic dispatch.
type IAlter_table_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ALTER() antlr.TerminalNode
	T_TABLE() antlr.TerminalNode
	Table_name() ITable_nameContext
	Alter_table_item() IAlter_table_itemContext

	// IsAlter_table_stmtContext differentiates from other interfaces.
	IsAlter_table_stmtContext()
}

type Alter_table_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_stmtContext() *Alter_table_stmtContext {
	var p = new(Alter_table_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_alter_table_stmt
	return p
}

func InitEmptyAlter_table_stmtContext(p *Alter_table_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_alter_table_stmt
}

func (*Alter_table_stmtContext) IsAlter_table_stmtContext() {}

func NewAlter_table_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_stmtContext {
	var p = new(Alter_table_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_alter_table_stmt

	return p
}

func (s *Alter_table_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_stmtContext) T_ALTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALTER, 0)
}

func (s *Alter_table_stmtContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLE, 0)
}

func (s *Alter_table_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Alter_table_stmtContext) Alter_table_item() IAlter_table_itemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_itemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_itemContext)
}

func (s *Alter_table_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_table_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAlter_table_stmt(s)
	}
}

func (s *Alter_table_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAlter_table_stmt(s)
	}
}




func (p *HplsqlParser) Alter_table_stmt() (localctx IAlter_table_stmtContext) {
	localctx = NewAlter_table_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, HplsqlParserRULE_alter_table_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1281)
		p.Match(HplsqlParserT_ALTER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1282)
		p.Match(HplsqlParserT_TABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1283)
		p.Table_name()
	}
	{
		p.SetState(1284)
		p.Alter_table_item()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_table_itemContext is an interface to support dynamic dispatch.
type IAlter_table_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Alter_table_add_constraint() IAlter_table_add_constraintContext

	// IsAlter_table_itemContext differentiates from other interfaces.
	IsAlter_table_itemContext()
}

type Alter_table_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_itemContext() *Alter_table_itemContext {
	var p = new(Alter_table_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_alter_table_item
	return p
}

func InitEmptyAlter_table_itemContext(p *Alter_table_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_alter_table_item
}

func (*Alter_table_itemContext) IsAlter_table_itemContext() {}

func NewAlter_table_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_itemContext {
	var p = new(Alter_table_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_alter_table_item

	return p
}

func (s *Alter_table_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_itemContext) Alter_table_add_constraint() IAlter_table_add_constraintContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_add_constraintContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_add_constraintContext)
}

func (s *Alter_table_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_table_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAlter_table_item(s)
	}
}

func (s *Alter_table_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAlter_table_item(s)
	}
}




func (p *HplsqlParser) Alter_table_item() (localctx IAlter_table_itemContext) {
	localctx = NewAlter_table_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, HplsqlParserRULE_alter_table_item)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1286)
		p.Alter_table_add_constraint()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_table_add_constraintContext is an interface to support dynamic dispatch.
type IAlter_table_add_constraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ADD2() antlr.TerminalNode
	Alter_table_add_constraint_item() IAlter_table_add_constraint_itemContext
	T_CONSTRAINT() antlr.TerminalNode
	Qident() IQidentContext

	// IsAlter_table_add_constraintContext differentiates from other interfaces.
	IsAlter_table_add_constraintContext()
}

type Alter_table_add_constraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_add_constraintContext() *Alter_table_add_constraintContext {
	var p = new(Alter_table_add_constraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_alter_table_add_constraint
	return p
}

func InitEmptyAlter_table_add_constraintContext(p *Alter_table_add_constraintContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_alter_table_add_constraint
}

func (*Alter_table_add_constraintContext) IsAlter_table_add_constraintContext() {}

func NewAlter_table_add_constraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_add_constraintContext {
	var p = new(Alter_table_add_constraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_alter_table_add_constraint

	return p
}

func (s *Alter_table_add_constraintContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_add_constraintContext) T_ADD2() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ADD2, 0)
}

func (s *Alter_table_add_constraintContext) Alter_table_add_constraint_item() IAlter_table_add_constraint_itemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlter_table_add_constraint_itemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlter_table_add_constraint_itemContext)
}

func (s *Alter_table_add_constraintContext) T_CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONSTRAINT, 0)
}

func (s *Alter_table_add_constraintContext) Qident() IQidentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Alter_table_add_constraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_add_constraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_table_add_constraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAlter_table_add_constraint(s)
	}
}

func (s *Alter_table_add_constraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAlter_table_add_constraint(s)
	}
}




func (p *HplsqlParser) Alter_table_add_constraint() (localctx IAlter_table_add_constraintContext) {
	localctx = NewAlter_table_add_constraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, HplsqlParserRULE_alter_table_add_constraint)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1288)
		p.Match(HplsqlParserT_ADD2)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1291)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_CONSTRAINT {
		{
			p.SetState(1289)
			p.Match(HplsqlParserT_CONSTRAINT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1290)
			p.Qident()
		}

	}
	{
		p.SetState(1293)
		p.Alter_table_add_constraint_item()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAlter_table_add_constraint_itemContext is an interface to support dynamic dispatch.
type IAlter_table_add_constraint_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_PRIMARY() antlr.TerminalNode
	T_KEY() antlr.TerminalNode
	AllT_OPEN_P() []antlr.TerminalNode
	T_OPEN_P(i int) antlr.TerminalNode
	AllQident() []IQidentContext
	Qident(i int) IQidentContext
	AllT_CLOSE_P() []antlr.TerminalNode
	T_CLOSE_P(i int) antlr.TerminalNode
	T_CLUSTERED() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	T_ENABLE() antlr.TerminalNode
	Index_storage_clause() IIndex_storage_clauseContext
	AllT_ASC() []antlr.TerminalNode
	T_ASC(i int) antlr.TerminalNode
	AllT_DESC() []antlr.TerminalNode
	T_DESC(i int) antlr.TerminalNode
	T_FOREIGN() antlr.TerminalNode
	T_REFERENCES() antlr.TerminalNode
	Table_name() ITable_nameContext
	AllCreate_table_fk_action() []ICreate_table_fk_actionContext
	Create_table_fk_action(i int) ICreate_table_fk_actionContext
	T_DEFAULT() antlr.TerminalNode
	Expr() IExprContext
	T_FOR() antlr.TerminalNode

	// IsAlter_table_add_constraint_itemContext differentiates from other interfaces.
	IsAlter_table_add_constraint_itemContext()
}

type Alter_table_add_constraint_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlter_table_add_constraint_itemContext() *Alter_table_add_constraint_itemContext {
	var p = new(Alter_table_add_constraint_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_alter_table_add_constraint_item
	return p
}

func InitEmptyAlter_table_add_constraint_itemContext(p *Alter_table_add_constraint_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_alter_table_add_constraint_item
}

func (*Alter_table_add_constraint_itemContext) IsAlter_table_add_constraint_itemContext() {}

func NewAlter_table_add_constraint_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Alter_table_add_constraint_itemContext {
	var p = new(Alter_table_add_constraint_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_alter_table_add_constraint_item

	return p
}

func (s *Alter_table_add_constraint_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Alter_table_add_constraint_itemContext) T_PRIMARY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRIMARY, 0)
}

func (s *Alter_table_add_constraint_itemContext) T_KEY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_KEY, 0)
}

func (s *Alter_table_add_constraint_itemContext) AllT_OPEN_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_OPEN_P)
}

func (s *Alter_table_add_constraint_itemContext) T_OPEN_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, i)
}

func (s *Alter_table_add_constraint_itemContext) AllQident() []IQidentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQidentContext); ok {
			len++
		}
	}

	tst := make([]IQidentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQidentContext); ok {
			tst[i] = t.(IQidentContext)
			i++
		}
	}

	return tst
}

func (s *Alter_table_add_constraint_itemContext) Qident(i int) IQidentContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Alter_table_add_constraint_itemContext) AllT_CLOSE_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_CLOSE_P)
}

func (s *Alter_table_add_constraint_itemContext) T_CLOSE_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, i)
}

func (s *Alter_table_add_constraint_itemContext) T_CLUSTERED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLUSTERED, 0)
}

func (s *Alter_table_add_constraint_itemContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Alter_table_add_constraint_itemContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Alter_table_add_constraint_itemContext) T_ENABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ENABLE, 0)
}

func (s *Alter_table_add_constraint_itemContext) Index_storage_clause() IIndex_storage_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_storage_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_storage_clauseContext)
}

func (s *Alter_table_add_constraint_itemContext) AllT_ASC() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_ASC)
}

func (s *Alter_table_add_constraint_itemContext) T_ASC(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ASC, i)
}

func (s *Alter_table_add_constraint_itemContext) AllT_DESC() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_DESC)
}

func (s *Alter_table_add_constraint_itemContext) T_DESC(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DESC, i)
}

func (s *Alter_table_add_constraint_itemContext) T_FOREIGN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOREIGN, 0)
}

func (s *Alter_table_add_constraint_itemContext) T_REFERENCES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REFERENCES, 0)
}

func (s *Alter_table_add_constraint_itemContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Alter_table_add_constraint_itemContext) AllCreate_table_fk_action() []ICreate_table_fk_actionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_fk_actionContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_fk_actionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_fk_actionContext); ok {
			tst[i] = t.(ICreate_table_fk_actionContext)
			i++
		}
	}

	return tst
}

func (s *Alter_table_add_constraint_itemContext) Create_table_fk_action(i int) ICreate_table_fk_actionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_fk_actionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_fk_actionContext)
}

func (s *Alter_table_add_constraint_itemContext) T_DEFAULT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFAULT, 0)
}

func (s *Alter_table_add_constraint_itemContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Alter_table_add_constraint_itemContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *Alter_table_add_constraint_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Alter_table_add_constraint_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Alter_table_add_constraint_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterAlter_table_add_constraint_item(s)
	}
}

func (s *Alter_table_add_constraint_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitAlter_table_add_constraint_item(s)
	}
}




func (p *HplsqlParser) Alter_table_add_constraint_item() (localctx IAlter_table_add_constraint_itemContext) {
	localctx = NewAlter_table_add_constraint_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, HplsqlParserRULE_alter_table_add_constraint_item)
	var _la int

	var _alt int

	p.SetState(1357)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_PRIMARY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1295)
			p.Match(HplsqlParserT_PRIMARY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1296)
			p.Match(HplsqlParserT_KEY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1298)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_CLUSTERED {
			{
				p.SetState(1297)
				p.Match(HplsqlParserT_CLUSTERED)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1300)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1301)
			p.Qident()
		}
		p.SetState(1303)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC {
			{
				p.SetState(1302)
				_la = p.GetTokenStream().LA(1)

				if !(_la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1312)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(1305)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1306)
				p.Qident()
			}
			p.SetState(1308)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC {
				{
					p.SetState(1307)
					_la = p.GetTokenStream().LA(1)

					if !(_la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}


			p.SetState(1314)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1315)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1317)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 116, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1316)
				p.Match(HplsqlParserT_ENABLE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(1320)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 117, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1319)
				p.Index_storage_clause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case HplsqlParserT_FOREIGN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1322)
			p.Match(HplsqlParserT_FOREIGN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1323)
			p.Match(HplsqlParserT_KEY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1324)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1325)
			p.Qident()
		}
		p.SetState(1330)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(1326)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1327)
				p.Qident()
			}


			p.SetState(1332)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1333)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1334)
			p.Match(HplsqlParserT_REFERENCES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1335)
			p.Table_name()
		}
		{
			p.SetState(1336)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1337)
			p.Qident()
		}
		p.SetState(1342)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(1338)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1339)
				p.Qident()
			}


			p.SetState(1344)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1345)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1349)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1346)
					p.Create_table_fk_action()
				}


			}
			p.SetState(1351)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}


	case HplsqlParserT_DEFAULT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1352)
			p.Match(HplsqlParserT_DEFAULT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1353)
			p.expr(0)
		}
		{
			p.SetState(1354)
			p.Match(HplsqlParserT_FOR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1355)
			p.Qident()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDtypeContext is an interface to support dynamic dispatch.
type IDtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_CHAR() antlr.TerminalNode
	T_CHARACTER() antlr.TerminalNode
	T_BIGINT() antlr.TerminalNode
	T_BINARY_DOUBLE() antlr.TerminalNode
	T_BINARY_FLOAT() antlr.TerminalNode
	T_BINARY_INTEGER() antlr.TerminalNode
	T_BIT() antlr.TerminalNode
	T_DATE() antlr.TerminalNode
	T_DATETIME() antlr.TerminalNode
	T_DEC() antlr.TerminalNode
	T_DECIMAL() antlr.TerminalNode
	T_DOUBLE() antlr.TerminalNode
	T_PRECISION() antlr.TerminalNode
	T_FLOAT() antlr.TerminalNode
	T_INT() antlr.TerminalNode
	T_INT2() antlr.TerminalNode
	T_INT4() antlr.TerminalNode
	T_INT8() antlr.TerminalNode
	T_INTEGER() antlr.TerminalNode
	T_NCHAR() antlr.TerminalNode
	T_NVARCHAR() antlr.TerminalNode
	T_NUMBER() antlr.TerminalNode
	T_NUMERIC() antlr.TerminalNode
	T_PLS_INTEGER() antlr.TerminalNode
	T_REAL() antlr.TerminalNode
	T_RESULT_SET_LOCATOR() antlr.TerminalNode
	T_VARYING() antlr.TerminalNode
	T_SIMPLE_FLOAT() antlr.TerminalNode
	T_SIMPLE_DOUBLE() antlr.TerminalNode
	T_SIMPLE_INTEGER() antlr.TerminalNode
	T_SMALLINT() antlr.TerminalNode
	T_SMALLDATETIME() antlr.TerminalNode
	T_STRING() antlr.TerminalNode
	T_SYS_REFCURSOR() antlr.TerminalNode
	T_TIMESTAMP() antlr.TerminalNode
	T_TINYINT() antlr.TerminalNode
	T_VARCHAR() antlr.TerminalNode
	T_VARCHAR2() antlr.TerminalNode
	T_XML() antlr.TerminalNode
	Qident() IQidentContext
	T_TYPE() antlr.TerminalNode
	T_ROWTYPE() antlr.TerminalNode

	// IsDtypeContext differentiates from other interfaces.
	IsDtypeContext()
}

type DtypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDtypeContext() *DtypeContext {
	var p = new(DtypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_dtype
	return p
}

func InitEmptyDtypeContext(p *DtypeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_dtype
}

func (*DtypeContext) IsDtypeContext() {}

func NewDtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DtypeContext {
	var p = new(DtypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_dtype

	return p
}

func (s *DtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DtypeContext) T_CHAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CHAR, 0)
}

func (s *DtypeContext) T_CHARACTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CHARACTER, 0)
}

func (s *DtypeContext) T_BIGINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BIGINT, 0)
}

func (s *DtypeContext) T_BINARY_DOUBLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BINARY_DOUBLE, 0)
}

func (s *DtypeContext) T_BINARY_FLOAT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BINARY_FLOAT, 0)
}

func (s *DtypeContext) T_BINARY_INTEGER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BINARY_INTEGER, 0)
}

func (s *DtypeContext) T_BIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BIT, 0)
}

func (s *DtypeContext) T_DATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATE, 0)
}

func (s *DtypeContext) T_DATETIME() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATETIME, 0)
}

func (s *DtypeContext) T_DEC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEC, 0)
}

func (s *DtypeContext) T_DECIMAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DECIMAL, 0)
}

func (s *DtypeContext) T_DOUBLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DOUBLE, 0)
}

func (s *DtypeContext) T_PRECISION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRECISION, 0)
}

func (s *DtypeContext) T_FLOAT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FLOAT, 0)
}

func (s *DtypeContext) T_INT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INT, 0)
}

func (s *DtypeContext) T_INT2() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INT2, 0)
}

func (s *DtypeContext) T_INT4() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INT4, 0)
}

func (s *DtypeContext) T_INT8() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INT8, 0)
}

func (s *DtypeContext) T_INTEGER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTEGER, 0)
}

func (s *DtypeContext) T_NCHAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NCHAR, 0)
}

func (s *DtypeContext) T_NVARCHAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NVARCHAR, 0)
}

func (s *DtypeContext) T_NUMBER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NUMBER, 0)
}

func (s *DtypeContext) T_NUMERIC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NUMERIC, 0)
}

func (s *DtypeContext) T_PLS_INTEGER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PLS_INTEGER, 0)
}

func (s *DtypeContext) T_REAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REAL, 0)
}

func (s *DtypeContext) T_RESULT_SET_LOCATOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESULT_SET_LOCATOR, 0)
}

func (s *DtypeContext) T_VARYING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VARYING, 0)
}

func (s *DtypeContext) T_SIMPLE_FLOAT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SIMPLE_FLOAT, 0)
}

func (s *DtypeContext) T_SIMPLE_DOUBLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SIMPLE_DOUBLE, 0)
}

func (s *DtypeContext) T_SIMPLE_INTEGER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SIMPLE_INTEGER, 0)
}

func (s *DtypeContext) T_SMALLINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SMALLINT, 0)
}

func (s *DtypeContext) T_SMALLDATETIME() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SMALLDATETIME, 0)
}

func (s *DtypeContext) T_STRING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STRING, 0)
}

func (s *DtypeContext) T_SYS_REFCURSOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SYS_REFCURSOR, 0)
}

func (s *DtypeContext) T_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TIMESTAMP, 0)
}

func (s *DtypeContext) T_TINYINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TINYINT, 0)
}

func (s *DtypeContext) T_VARCHAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VARCHAR, 0)
}

func (s *DtypeContext) T_VARCHAR2() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VARCHAR2, 0)
}

func (s *DtypeContext) T_XML() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_XML, 0)
}

func (s *DtypeContext) Qident() IQidentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *DtypeContext) T_TYPE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TYPE, 0)
}

func (s *DtypeContext) T_ROWTYPE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROWTYPE, 0)
}

func (s *DtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDtype(s)
	}
}

func (s *DtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDtype(s)
	}
}




func (p *HplsqlParser) Dtype() (localctx IDtypeContext) {
	localctx = NewDtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, HplsqlParserRULE_dtype)
	var _la int

	p.SetState(1405)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 124, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1359)
			p.Match(HplsqlParserT_CHAR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1360)
			p.Match(HplsqlParserT_CHARACTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1361)
			p.Match(HplsqlParserT_BIGINT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1362)
			p.Match(HplsqlParserT_BINARY_DOUBLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1363)
			p.Match(HplsqlParserT_BINARY_FLOAT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1364)
			p.Match(HplsqlParserT_BINARY_INTEGER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1365)
			p.Match(HplsqlParserT_BIT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1366)
			p.Match(HplsqlParserT_DATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1367)
			p.Match(HplsqlParserT_DATETIME)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1368)
			p.Match(HplsqlParserT_DEC)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1369)
			p.Match(HplsqlParserT_DECIMAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1370)
			p.Match(HplsqlParserT_DOUBLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1372)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 122, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1371)
				p.Match(HplsqlParserT_PRECISION)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1374)
			p.Match(HplsqlParserT_FLOAT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1375)
			p.Match(HplsqlParserT_INT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1376)
			p.Match(HplsqlParserT_INT2)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1377)
			p.Match(HplsqlParserT_INT4)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1378)
			p.Match(HplsqlParserT_INT8)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1379)
			p.Match(HplsqlParserT_INTEGER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1380)
			p.Match(HplsqlParserT_NCHAR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1381)
			p.Match(HplsqlParserT_NVARCHAR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1382)
			p.Match(HplsqlParserT_NUMBER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1383)
			p.Match(HplsqlParserT_NUMERIC)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1384)
			p.Match(HplsqlParserT_PLS_INTEGER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1385)
			p.Match(HplsqlParserT_REAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(1386)
			p.Match(HplsqlParserT_RESULT_SET_LOCATOR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1387)
			p.Match(HplsqlParserT_VARYING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1388)
			p.Match(HplsqlParserT_SIMPLE_FLOAT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(1389)
			p.Match(HplsqlParserT_SIMPLE_DOUBLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(1390)
			p.Match(HplsqlParserT_SIMPLE_INTEGER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(1391)
			p.Match(HplsqlParserT_SMALLINT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(1392)
			p.Match(HplsqlParserT_SMALLDATETIME)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(1393)
			p.Match(HplsqlParserT_STRING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(1394)
			p.Match(HplsqlParserT_SYS_REFCURSOR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(1395)
			p.Match(HplsqlParserT_TIMESTAMP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(1396)
			p.Match(HplsqlParserT_TINYINT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(1397)
			p.Match(HplsqlParserT_VARCHAR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(1398)
			p.Match(HplsqlParserT_VARCHAR2)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(1399)
			p.Match(HplsqlParserT_XML)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(1400)
			p.Qident()
		}
		p.SetState(1403)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 123, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1401)
				p.Match(HplsqlParserT__2)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1402)
				_la = p.GetTokenStream().LA(1)

				if !(_la == HplsqlParserT_ROWTYPE || _la == HplsqlParserT_TYPE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDtype_lenContext is an interface to support dynamic dispatch.
type IDtype_lenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode
	AllL_INT() []antlr.TerminalNode
	L_INT(i int) antlr.TerminalNode
	T_MAX() antlr.TerminalNode
	T_COMMA() antlr.TerminalNode
	T_CHAR() antlr.TerminalNode
	T_BYTE() antlr.TerminalNode

	// IsDtype_lenContext differentiates from other interfaces.
	IsDtype_lenContext()
}

type Dtype_lenContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDtype_lenContext() *Dtype_lenContext {
	var p = new(Dtype_lenContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_dtype_len
	return p
}

func InitEmptyDtype_lenContext(p *Dtype_lenContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_dtype_len
}

func (*Dtype_lenContext) IsDtype_lenContext() {}

func NewDtype_lenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dtype_lenContext {
	var p = new(Dtype_lenContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_dtype_len

	return p
}

func (s *Dtype_lenContext) GetParser() antlr.Parser { return s.parser }

func (s *Dtype_lenContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Dtype_lenContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Dtype_lenContext) AllL_INT() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserL_INT)
}

func (s *Dtype_lenContext) L_INT(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_INT, i)
}

func (s *Dtype_lenContext) T_MAX() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAX, 0)
}

func (s *Dtype_lenContext) T_COMMA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, 0)
}

func (s *Dtype_lenContext) T_CHAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CHAR, 0)
}

func (s *Dtype_lenContext) T_BYTE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BYTE, 0)
}

func (s *Dtype_lenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dtype_lenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Dtype_lenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDtype_len(s)
	}
}

func (s *Dtype_lenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDtype_len(s)
	}
}




func (p *HplsqlParser) Dtype_len() (localctx IDtype_lenContext) {
	localctx = NewDtype_lenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, HplsqlParserRULE_dtype_len)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1407)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1408)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_MAX || _la == HplsqlParserL_INT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1410)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_BYTE || _la == HplsqlParserT_CHAR {
		{
			p.SetState(1409)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_BYTE || _la == HplsqlParserT_CHAR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1414)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_COMMA {
		{
			p.SetState(1412)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1413)
			p.Match(HplsqlParserL_INT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(1416)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDtype_attrContext is an interface to support dynamic dispatch.
type IDtype_attrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_NULL() antlr.TerminalNode
	T_NOT() antlr.TerminalNode
	T_CHARACTER() antlr.TerminalNode
	T_SET() antlr.TerminalNode
	Ident() IIdentContext
	T_CASESPECIFIC() antlr.TerminalNode
	T_CS() antlr.TerminalNode

	// IsDtype_attrContext differentiates from other interfaces.
	IsDtype_attrContext()
}

type Dtype_attrContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDtype_attrContext() *Dtype_attrContext {
	var p = new(Dtype_attrContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_dtype_attr
	return p
}

func InitEmptyDtype_attrContext(p *Dtype_attrContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_dtype_attr
}

func (*Dtype_attrContext) IsDtype_attrContext() {}

func NewDtype_attrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dtype_attrContext {
	var p = new(Dtype_attrContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_dtype_attr

	return p
}

func (s *Dtype_attrContext) GetParser() antlr.Parser { return s.parser }

func (s *Dtype_attrContext) T_NULL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NULL, 0)
}

func (s *Dtype_attrContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Dtype_attrContext) T_CHARACTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CHARACTER, 0)
}

func (s *Dtype_attrContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Dtype_attrContext) Ident() IIdentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Dtype_attrContext) T_CASESPECIFIC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CASESPECIFIC, 0)
}

func (s *Dtype_attrContext) T_CS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CS, 0)
}

func (s *Dtype_attrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dtype_attrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Dtype_attrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDtype_attr(s)
	}
}

func (s *Dtype_attrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDtype_attr(s)
	}
}




func (p *HplsqlParser) Dtype_attr() (localctx IDtype_attrContext) {
	localctx = NewDtype_attrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, HplsqlParserRULE_dtype_attr)
	var _la int

	p.SetState(1429)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 129, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1419)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_NOT {
			{
				p.SetState(1418)
				p.Match(HplsqlParserT_NOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1421)
			p.Match(HplsqlParserT_NULL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1422)
			p.Match(HplsqlParserT_CHARACTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1423)
			p.Match(HplsqlParserT_SET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1424)
			p.Ident()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1426)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_NOT {
			{
				p.SetState(1425)
				p.Match(HplsqlParserT_NOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1428)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_CASESPECIFIC || _la == HplsqlParserT_CS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDtype_defaultContext is an interface to support dynamic dispatch.
type IDtype_defaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_EQUAL() antlr.TerminalNode
	Expr() IExprContext
	T_COLON() antlr.TerminalNode
	T_DEFAULT() antlr.TerminalNode
	T_WITH() antlr.TerminalNode

	// IsDtype_defaultContext differentiates from other interfaces.
	IsDtype_defaultContext()
}

type Dtype_defaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDtype_defaultContext() *Dtype_defaultContext {
	var p = new(Dtype_defaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_dtype_default
	return p
}

func InitEmptyDtype_defaultContext(p *Dtype_defaultContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_dtype_default
}

func (*Dtype_defaultContext) IsDtype_defaultContext() {}

func NewDtype_defaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dtype_defaultContext {
	var p = new(Dtype_defaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_dtype_default

	return p
}

func (s *Dtype_defaultContext) GetParser() antlr.Parser { return s.parser }

func (s *Dtype_defaultContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Dtype_defaultContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Dtype_defaultContext) T_COLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLON, 0)
}

func (s *Dtype_defaultContext) T_DEFAULT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFAULT, 0)
}

func (s *Dtype_defaultContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITH, 0)
}

func (s *Dtype_defaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dtype_defaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Dtype_defaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDtype_default(s)
	}
}

func (s *Dtype_defaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDtype_default(s)
	}
}




func (p *HplsqlParser) Dtype_default() (localctx IDtype_defaultContext) {
	localctx = NewDtype_defaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, HplsqlParserRULE_dtype_default)
	var _la int

	p.SetState(1443)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_COLON, HplsqlParserT_EQUAL:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1432)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_COLON {
			{
				p.SetState(1431)
				p.Match(HplsqlParserT_COLON)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1434)
			p.Match(HplsqlParserT_EQUAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1435)
			p.expr(0)
		}


	case HplsqlParserT_DEFAULT, HplsqlParserT_WITH:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1437)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_WITH {
			{
				p.SetState(1436)
				p.Match(HplsqlParserT_WITH)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1439)
			p.Match(HplsqlParserT_DEFAULT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1441)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 132, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1440)
				p.expr(0)
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_database_stmtContext is an interface to support dynamic dispatch.
type ICreate_database_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_CREATE() antlr.TerminalNode
	Expr() IExprContext
	T_DATABASE() antlr.TerminalNode
	T_SCHEMA() antlr.TerminalNode
	T_IF() antlr.TerminalNode
	T_NOT() antlr.TerminalNode
	T_EXISTS() antlr.TerminalNode
	AllCreate_database_option() []ICreate_database_optionContext
	Create_database_option(i int) ICreate_database_optionContext

	// IsCreate_database_stmtContext differentiates from other interfaces.
	IsCreate_database_stmtContext()
}

type Create_database_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_database_stmtContext() *Create_database_stmtContext {
	var p = new(Create_database_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_database_stmt
	return p
}

func InitEmptyCreate_database_stmtContext(p *Create_database_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_database_stmt
}

func (*Create_database_stmtContext) IsCreate_database_stmtContext() {}

func NewCreate_database_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_database_stmtContext {
	var p = new(Create_database_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_database_stmt

	return p
}

func (s *Create_database_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_database_stmtContext) T_CREATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATE, 0)
}

func (s *Create_database_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Create_database_stmtContext) T_DATABASE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATABASE, 0)
}

func (s *Create_database_stmtContext) T_SCHEMA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SCHEMA, 0)
}

func (s *Create_database_stmtContext) T_IF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IF, 0)
}

func (s *Create_database_stmtContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Create_database_stmtContext) T_EXISTS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXISTS, 0)
}

func (s *Create_database_stmtContext) AllCreate_database_option() []ICreate_database_optionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_database_optionContext); ok {
			len++
		}
	}

	tst := make([]ICreate_database_optionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_database_optionContext); ok {
			tst[i] = t.(ICreate_database_optionContext)
			i++
		}
	}

	return tst
}

func (s *Create_database_stmtContext) Create_database_option(i int) ICreate_database_optionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_database_optionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_database_optionContext)
}

func (s *Create_database_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_database_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_database_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_database_stmt(s)
	}
}

func (s *Create_database_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_database_stmt(s)
	}
}




func (p *HplsqlParser) Create_database_stmt() (localctx ICreate_database_stmtContext) {
	localctx = NewCreate_database_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, HplsqlParserRULE_create_database_stmt)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1445)
		p.Match(HplsqlParserT_CREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1446)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_DATABASE || _la == HplsqlParserT_SCHEMA) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1450)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 134, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1447)
			p.Match(HplsqlParserT_IF)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1448)
			p.Match(HplsqlParserT_NOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1449)
			p.Match(HplsqlParserT_EXISTS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(1452)
		p.expr(0)
	}
	p.SetState(1456)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1453)
				p.Create_database_option()
			}


		}
		p.SetState(1458)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_database_optionContext is an interface to support dynamic dispatch.
type ICreate_database_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_COMMENT() antlr.TerminalNode
	Expr() IExprContext
	T_LOCATION() antlr.TerminalNode

	// IsCreate_database_optionContext differentiates from other interfaces.
	IsCreate_database_optionContext()
}

type Create_database_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_database_optionContext() *Create_database_optionContext {
	var p = new(Create_database_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_database_option
	return p
}

func InitEmptyCreate_database_optionContext(p *Create_database_optionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_database_option
}

func (*Create_database_optionContext) IsCreate_database_optionContext() {}

func NewCreate_database_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_database_optionContext {
	var p = new(Create_database_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_database_option

	return p
}

func (s *Create_database_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_database_optionContext) T_COMMENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMENT, 0)
}

func (s *Create_database_optionContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Create_database_optionContext) T_LOCATION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCATION, 0)
}

func (s *Create_database_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_database_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_database_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_database_option(s)
	}
}

func (s *Create_database_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_database_option(s)
	}
}




func (p *HplsqlParser) Create_database_option() (localctx ICreate_database_optionContext) {
	localctx = NewCreate_database_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, HplsqlParserRULE_create_database_option)
	p.SetState(1463)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_COMMENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1459)
			p.Match(HplsqlParserT_COMMENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1460)
			p.expr(0)
		}


	case HplsqlParserT_LOCATION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1461)
			p.Match(HplsqlParserT_LOCATION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1462)
			p.expr(0)
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_function_stmtContext is an interface to support dynamic dispatch.
type ICreate_function_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_FUNCTION() antlr.TerminalNode
	Ident() IIdentContext
	Create_function_return() ICreate_function_returnContext
	Single_block_stmt() ISingle_block_stmtContext
	T_ALTER() antlr.TerminalNode
	T_CREATE() antlr.TerminalNode
	T_REPLACE() antlr.TerminalNode
	Create_routine_params() ICreate_routine_paramsContext
	Declare_block_inplace() IDeclare_block_inplaceContext
	T_AS() antlr.TerminalNode
	T_IS() antlr.TerminalNode
	T_OR() antlr.TerminalNode

	// IsCreate_function_stmtContext differentiates from other interfaces.
	IsCreate_function_stmtContext()
}

type Create_function_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_function_stmtContext() *Create_function_stmtContext {
	var p = new(Create_function_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_function_stmt
	return p
}

func InitEmptyCreate_function_stmtContext(p *Create_function_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_function_stmt
}

func (*Create_function_stmtContext) IsCreate_function_stmtContext() {}

func NewCreate_function_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_function_stmtContext {
	var p = new(Create_function_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_function_stmt

	return p
}

func (s *Create_function_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_function_stmtContext) T_FUNCTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FUNCTION, 0)
}

func (s *Create_function_stmtContext) Ident() IIdentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Create_function_stmtContext) Create_function_return() ICreate_function_returnContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_function_returnContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_function_returnContext)
}

func (s *Create_function_stmtContext) Single_block_stmt() ISingle_block_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingle_block_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingle_block_stmtContext)
}

func (s *Create_function_stmtContext) T_ALTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALTER, 0)
}

func (s *Create_function_stmtContext) T_CREATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATE, 0)
}

func (s *Create_function_stmtContext) T_REPLACE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REPLACE, 0)
}

func (s *Create_function_stmtContext) Create_routine_params() ICreate_routine_paramsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_routine_paramsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_routine_paramsContext)
}

func (s *Create_function_stmtContext) Declare_block_inplace() IDeclare_block_inplaceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_block_inplaceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_block_inplaceContext)
}

func (s *Create_function_stmtContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Create_function_stmtContext) T_IS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IS, 0)
}

func (s *Create_function_stmtContext) T_OR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OR, 0)
}

func (s *Create_function_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_function_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_function_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_function_stmt(s)
	}
}

func (s *Create_function_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_function_stmt(s)
	}
}




func (p *HplsqlParser) Create_function_stmt() (localctx ICreate_function_stmtContext) {
	localctx = NewCreate_function_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, HplsqlParserRULE_create_function_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1472)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ALTER:
		{
			p.SetState(1465)
			p.Match(HplsqlParserT_ALTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_CREATE:
		{
			p.SetState(1466)
			p.Match(HplsqlParserT_CREATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1469)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_OR {
			{
				p.SetState(1467)
				p.Match(HplsqlParserT_OR)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1468)
				p.Match(HplsqlParserT_REPLACE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case HplsqlParserT_REPLACE:
		{
			p.SetState(1471)
			p.Match(HplsqlParserT_REPLACE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_FUNCTION:



	default:
	}
	{
		p.SetState(1474)
		p.Match(HplsqlParserT_FUNCTION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1475)
		p.Ident()
	}
	p.SetState(1477)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 139, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1476)
			p.Create_routine_params()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(1479)
		p.Create_function_return()
	}
	p.SetState(1481)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 140, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1480)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_AS || _la == HplsqlParserT_IS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(1484)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 141, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1483)
			p.Declare_block_inplace()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(1486)
		p.Single_block_stmt()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_function_returnContext is an interface to support dynamic dispatch.
type ICreate_function_returnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Dtype() IDtypeContext
	T_RETURN() antlr.TerminalNode
	T_RETURNS() antlr.TerminalNode
	Dtype_len() IDtype_lenContext

	// IsCreate_function_returnContext differentiates from other interfaces.
	IsCreate_function_returnContext()
}

type Create_function_returnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_function_returnContext() *Create_function_returnContext {
	var p = new(Create_function_returnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_function_return
	return p
}

func InitEmptyCreate_function_returnContext(p *Create_function_returnContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_function_return
}

func (*Create_function_returnContext) IsCreate_function_returnContext() {}

func NewCreate_function_returnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_function_returnContext {
	var p = new(Create_function_returnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_function_return

	return p
}

func (s *Create_function_returnContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_function_returnContext) Dtype() IDtypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *Create_function_returnContext) T_RETURN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RETURN, 0)
}

func (s *Create_function_returnContext) T_RETURNS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RETURNS, 0)
}

func (s *Create_function_returnContext) Dtype_len() IDtype_lenContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_lenContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_lenContext)
}

func (s *Create_function_returnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_function_returnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_function_returnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_function_return(s)
	}
}

func (s *Create_function_returnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_function_return(s)
	}
}




func (p *HplsqlParser) Create_function_return() (localctx ICreate_function_returnContext) {
	localctx = NewCreate_function_returnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, HplsqlParserRULE_create_function_return)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1488)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_RETURN || _la == HplsqlParserT_RETURNS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1489)
		p.Dtype()
	}
	p.SetState(1491)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 142, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1490)
			p.Dtype_len()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_package_stmtContext is an interface to support dynamic dispatch.
type ICreate_package_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_PACKAGE() antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	Package_spec() IPackage_specContext
	T_END() antlr.TerminalNode
	T_AS() antlr.TerminalNode
	T_IS() antlr.TerminalNode
	T_ALTER() antlr.TerminalNode
	T_CREATE() antlr.TerminalNode
	T_REPLACE() antlr.TerminalNode
	T_SEMICOLON() antlr.TerminalNode
	T_OR() antlr.TerminalNode

	// IsCreate_package_stmtContext differentiates from other interfaces.
	IsCreate_package_stmtContext()
}

type Create_package_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_package_stmtContext() *Create_package_stmtContext {
	var p = new(Create_package_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_package_stmt
	return p
}

func InitEmptyCreate_package_stmtContext(p *Create_package_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_package_stmt
}

func (*Create_package_stmtContext) IsCreate_package_stmtContext() {}

func NewCreate_package_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_package_stmtContext {
	var p = new(Create_package_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_package_stmt

	return p
}

func (s *Create_package_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_package_stmtContext) T_PACKAGE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PACKAGE, 0)
}

func (s *Create_package_stmtContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Create_package_stmtContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Create_package_stmtContext) Package_spec() IPackage_specContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackage_specContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackage_specContext)
}

func (s *Create_package_stmtContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *Create_package_stmtContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Create_package_stmtContext) T_IS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IS, 0)
}

func (s *Create_package_stmtContext) T_ALTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALTER, 0)
}

func (s *Create_package_stmtContext) T_CREATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATE, 0)
}

func (s *Create_package_stmtContext) T_REPLACE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REPLACE, 0)
}

func (s *Create_package_stmtContext) T_SEMICOLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEMICOLON, 0)
}

func (s *Create_package_stmtContext) T_OR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OR, 0)
}

func (s *Create_package_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_package_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_package_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_package_stmt(s)
	}
}

func (s *Create_package_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_package_stmt(s)
	}
}




func (p *HplsqlParser) Create_package_stmt() (localctx ICreate_package_stmtContext) {
	localctx = NewCreate_package_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, HplsqlParserRULE_create_package_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1500)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ALTER:
		{
			p.SetState(1493)
			p.Match(HplsqlParserT_ALTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_CREATE:
		{
			p.SetState(1494)
			p.Match(HplsqlParserT_CREATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1497)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_OR {
			{
				p.SetState(1495)
				p.Match(HplsqlParserT_OR)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1496)
				p.Match(HplsqlParserT_REPLACE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case HplsqlParserT_REPLACE:
		{
			p.SetState(1499)
			p.Match(HplsqlParserT_REPLACE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_PACKAGE:



	default:
	}
	{
		p.SetState(1502)
		p.Match(HplsqlParserT_PACKAGE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1503)
		p.Ident()
	}
	{
		p.SetState(1504)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_AS || _la == HplsqlParserT_IS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1505)
		p.Package_spec()
	}
	{
		p.SetState(1506)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1510)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 145, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1507)
			p.Ident()
		}
		{
			p.SetState(1508)
			p.Match(HplsqlParserT_SEMICOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPackage_specContext is an interface to support dynamic dispatch.
type IPackage_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPackage_spec_item() []IPackage_spec_itemContext
	Package_spec_item(i int) IPackage_spec_itemContext
	AllT_SEMICOLON() []antlr.TerminalNode
	T_SEMICOLON(i int) antlr.TerminalNode

	// IsPackage_specContext differentiates from other interfaces.
	IsPackage_specContext()
}

type Package_specContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_specContext() *Package_specContext {
	var p = new(Package_specContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_package_spec
	return p
}

func InitEmptyPackage_specContext(p *Package_specContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_package_spec
}

func (*Package_specContext) IsPackage_specContext() {}

func NewPackage_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_specContext {
	var p = new(Package_specContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_package_spec

	return p
}

func (s *Package_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_specContext) AllPackage_spec_item() []IPackage_spec_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPackage_spec_itemContext); ok {
			len++
		}
	}

	tst := make([]IPackage_spec_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPackage_spec_itemContext); ok {
			tst[i] = t.(IPackage_spec_itemContext)
			i++
		}
	}

	return tst
}

func (s *Package_specContext) Package_spec_item(i int) IPackage_spec_itemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackage_spec_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackage_spec_itemContext)
}

func (s *Package_specContext) AllT_SEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_SEMICOLON)
}

func (s *Package_specContext) T_SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEMICOLON, i)
}

func (s *Package_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Package_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterPackage_spec(s)
	}
}

func (s *Package_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitPackage_spec(s)
	}
}




func (p *HplsqlParser) Package_spec() (localctx IPackage_specContext) {
	localctx = NewPackage_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, HplsqlParserRULE_package_spec)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1512)
		p.Package_spec_item()
	}
	{
		p.SetState(1513)
		p.Match(HplsqlParserT_SEMICOLON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1519)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -33554464) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -24696061953) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & -36028797018963969) != 0) || ((int64((_la - 192)) & ^0x3f) == 0 && ((int64(1) << (_la - 192)) & -9007199271518737) != 0) || ((int64((_la - 256)) & ^0x3f) == 0 && ((int64(1) << (_la - 256)) & -864744076811961345) != 0) || ((int64((_la - 320)) & ^0x3f) == 0 && ((int64(1) << (_la - 320)) & 6755399708459007) != 0) {
		{
			p.SetState(1514)
			p.Package_spec_item()
		}
		{
			p.SetState(1515)
			p.Match(HplsqlParserT_SEMICOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


		p.SetState(1521)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPackage_spec_itemContext is an interface to support dynamic dispatch.
type IPackage_spec_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Declare_stmt_item() IDeclare_stmt_itemContext
	T_FUNCTION() antlr.TerminalNode
	Ident() IIdentContext
	Create_function_return() ICreate_function_returnContext
	Create_routine_params() ICreate_routine_paramsContext
	T_PROCEDURE() antlr.TerminalNode
	T_PROC() antlr.TerminalNode

	// IsPackage_spec_itemContext differentiates from other interfaces.
	IsPackage_spec_itemContext()
}

type Package_spec_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_spec_itemContext() *Package_spec_itemContext {
	var p = new(Package_spec_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_package_spec_item
	return p
}

func InitEmptyPackage_spec_itemContext(p *Package_spec_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_package_spec_item
}

func (*Package_spec_itemContext) IsPackage_spec_itemContext() {}

func NewPackage_spec_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_spec_itemContext {
	var p = new(Package_spec_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_package_spec_item

	return p
}

func (s *Package_spec_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_spec_itemContext) Declare_stmt_item() IDeclare_stmt_itemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_stmt_itemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_stmt_itemContext)
}

func (s *Package_spec_itemContext) T_FUNCTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FUNCTION, 0)
}

func (s *Package_spec_itemContext) Ident() IIdentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Package_spec_itemContext) Create_function_return() ICreate_function_returnContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_function_returnContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_function_returnContext)
}

func (s *Package_spec_itemContext) Create_routine_params() ICreate_routine_paramsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_routine_paramsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_routine_paramsContext)
}

func (s *Package_spec_itemContext) T_PROCEDURE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PROCEDURE, 0)
}

func (s *Package_spec_itemContext) T_PROC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PROC, 0)
}

func (s *Package_spec_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_spec_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Package_spec_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterPackage_spec_item(s)
	}
}

func (s *Package_spec_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitPackage_spec_item(s)
	}
}




func (p *HplsqlParser) Package_spec_item() (localctx IPackage_spec_itemContext) {
	localctx = NewPackage_spec_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, HplsqlParserRULE_package_spec_item)
	var _la int

	p.SetState(1535)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 149, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1522)
			p.Declare_stmt_item()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1523)
			p.Match(HplsqlParserT_FUNCTION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1524)
			p.Ident()
		}
		p.SetState(1526)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 147, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1525)
				p.Create_routine_params()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(1528)
			p.Create_function_return()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1530)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_PROC || _la == HplsqlParserT_PROCEDURE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1531)
			p.Ident()
		}
		p.SetState(1533)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 148, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1532)
				p.Create_routine_params()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_package_body_stmtContext is an interface to support dynamic dispatch.
type ICreate_package_body_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_PACKAGE() antlr.TerminalNode
	T_BODY() antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	Package_body() IPackage_bodyContext
	T_END() antlr.TerminalNode
	T_AS() antlr.TerminalNode
	T_IS() antlr.TerminalNode
	T_ALTER() antlr.TerminalNode
	T_CREATE() antlr.TerminalNode
	T_REPLACE() antlr.TerminalNode
	T_SEMICOLON() antlr.TerminalNode
	T_OR() antlr.TerminalNode

	// IsCreate_package_body_stmtContext differentiates from other interfaces.
	IsCreate_package_body_stmtContext()
}

type Create_package_body_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_package_body_stmtContext() *Create_package_body_stmtContext {
	var p = new(Create_package_body_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_package_body_stmt
	return p
}

func InitEmptyCreate_package_body_stmtContext(p *Create_package_body_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_package_body_stmt
}

func (*Create_package_body_stmtContext) IsCreate_package_body_stmtContext() {}

func NewCreate_package_body_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_package_body_stmtContext {
	var p = new(Create_package_body_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_package_body_stmt

	return p
}

func (s *Create_package_body_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_package_body_stmtContext) T_PACKAGE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PACKAGE, 0)
}

func (s *Create_package_body_stmtContext) T_BODY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BODY, 0)
}

func (s *Create_package_body_stmtContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Create_package_body_stmtContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Create_package_body_stmtContext) Package_body() IPackage_bodyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackage_bodyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackage_bodyContext)
}

func (s *Create_package_body_stmtContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *Create_package_body_stmtContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Create_package_body_stmtContext) T_IS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IS, 0)
}

func (s *Create_package_body_stmtContext) T_ALTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALTER, 0)
}

func (s *Create_package_body_stmtContext) T_CREATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATE, 0)
}

func (s *Create_package_body_stmtContext) T_REPLACE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REPLACE, 0)
}

func (s *Create_package_body_stmtContext) T_SEMICOLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEMICOLON, 0)
}

func (s *Create_package_body_stmtContext) T_OR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OR, 0)
}

func (s *Create_package_body_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_package_body_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_package_body_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_package_body_stmt(s)
	}
}

func (s *Create_package_body_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_package_body_stmt(s)
	}
}




func (p *HplsqlParser) Create_package_body_stmt() (localctx ICreate_package_body_stmtContext) {
	localctx = NewCreate_package_body_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, HplsqlParserRULE_create_package_body_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1544)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ALTER:
		{
			p.SetState(1537)
			p.Match(HplsqlParserT_ALTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_CREATE:
		{
			p.SetState(1538)
			p.Match(HplsqlParserT_CREATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1541)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_OR {
			{
				p.SetState(1539)
				p.Match(HplsqlParserT_OR)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1540)
				p.Match(HplsqlParserT_REPLACE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case HplsqlParserT_REPLACE:
		{
			p.SetState(1543)
			p.Match(HplsqlParserT_REPLACE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_PACKAGE:



	default:
	}
	{
		p.SetState(1546)
		p.Match(HplsqlParserT_PACKAGE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1547)
		p.Match(HplsqlParserT_BODY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1548)
		p.Ident()
	}
	{
		p.SetState(1549)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_AS || _la == HplsqlParserT_IS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1550)
		p.Package_body()
	}
	{
		p.SetState(1551)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1555)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 152, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1552)
			p.Ident()
		}
		{
			p.SetState(1553)
			p.Match(HplsqlParserT_SEMICOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPackage_bodyContext is an interface to support dynamic dispatch.
type IPackage_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPackage_body_item() []IPackage_body_itemContext
	Package_body_item(i int) IPackage_body_itemContext
	AllT_SEMICOLON() []antlr.TerminalNode
	T_SEMICOLON(i int) antlr.TerminalNode

	// IsPackage_bodyContext differentiates from other interfaces.
	IsPackage_bodyContext()
}

type Package_bodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_bodyContext() *Package_bodyContext {
	var p = new(Package_bodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_package_body
	return p
}

func InitEmptyPackage_bodyContext(p *Package_bodyContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_package_body
}

func (*Package_bodyContext) IsPackage_bodyContext() {}

func NewPackage_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_bodyContext {
	var p = new(Package_bodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_package_body

	return p
}

func (s *Package_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_bodyContext) AllPackage_body_item() []IPackage_body_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPackage_body_itemContext); ok {
			len++
		}
	}

	tst := make([]IPackage_body_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPackage_body_itemContext); ok {
			tst[i] = t.(IPackage_body_itemContext)
			i++
		}
	}

	return tst
}

func (s *Package_bodyContext) Package_body_item(i int) IPackage_body_itemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPackage_body_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPackage_body_itemContext)
}

func (s *Package_bodyContext) AllT_SEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_SEMICOLON)
}

func (s *Package_bodyContext) T_SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEMICOLON, i)
}

func (s *Package_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Package_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterPackage_body(s)
	}
}

func (s *Package_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitPackage_body(s)
	}
}




func (p *HplsqlParser) Package_body() (localctx IPackage_bodyContext) {
	localctx = NewPackage_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, HplsqlParserRULE_package_body)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1557)
		p.Package_body_item()
	}
	{
		p.SetState(1558)
		p.Match(HplsqlParserT_SEMICOLON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1564)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -33554464) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -24696061953) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & -36028797018963969) != 0) || ((int64((_la - 192)) & ^0x3f) == 0 && ((int64(1) << (_la - 192)) & -9007199271518737) != 0) || ((int64((_la - 256)) & ^0x3f) == 0 && ((int64(1) << (_la - 256)) & -864744076811961345) != 0) || ((int64((_la - 320)) & ^0x3f) == 0 && ((int64(1) << (_la - 320)) & 6755399708459007) != 0) {
		{
			p.SetState(1559)
			p.Package_body_item()
		}
		{
			p.SetState(1560)
			p.Match(HplsqlParserT_SEMICOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


		p.SetState(1566)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPackage_body_itemContext is an interface to support dynamic dispatch.
type IPackage_body_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Declare_stmt_item() IDeclare_stmt_itemContext
	Create_function_stmt() ICreate_function_stmtContext
	Create_procedure_stmt() ICreate_procedure_stmtContext

	// IsPackage_body_itemContext differentiates from other interfaces.
	IsPackage_body_itemContext()
}

type Package_body_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackage_body_itemContext() *Package_body_itemContext {
	var p = new(Package_body_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_package_body_item
	return p
}

func InitEmptyPackage_body_itemContext(p *Package_body_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_package_body_item
}

func (*Package_body_itemContext) IsPackage_body_itemContext() {}

func NewPackage_body_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Package_body_itemContext {
	var p = new(Package_body_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_package_body_item

	return p
}

func (s *Package_body_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Package_body_itemContext) Declare_stmt_item() IDeclare_stmt_itemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_stmt_itemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_stmt_itemContext)
}

func (s *Package_body_itemContext) Create_function_stmt() ICreate_function_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_function_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_function_stmtContext)
}

func (s *Package_body_itemContext) Create_procedure_stmt() ICreate_procedure_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_procedure_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_procedure_stmtContext)
}

func (s *Package_body_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Package_body_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Package_body_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterPackage_body_item(s)
	}
}

func (s *Package_body_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitPackage_body_item(s)
	}
}




func (p *HplsqlParser) Package_body_item() (localctx IPackage_body_itemContext) {
	localctx = NewPackage_body_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, HplsqlParserRULE_package_body_item)
	p.SetState(1570)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 154, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1567)
			p.Declare_stmt_item()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1568)
			p.Create_function_stmt()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1569)
			p.Create_procedure_stmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_procedure_stmtContext is an interface to support dynamic dispatch.
type ICreate_procedure_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	Proc_block() IProc_blockContext
	T_PROCEDURE() antlr.TerminalNode
	T_PROC() antlr.TerminalNode
	T_ALTER() antlr.TerminalNode
	T_CREATE() antlr.TerminalNode
	T_REPLACE() antlr.TerminalNode
	Create_routine_params() ICreate_routine_paramsContext
	Create_routine_options() ICreate_routine_optionsContext
	Declare_block_inplace() IDeclare_block_inplaceContext
	Label() ILabelContext
	T_SEMICOLON() antlr.TerminalNode
	T_AS() antlr.TerminalNode
	T_IS() antlr.TerminalNode
	T_OR() antlr.TerminalNode

	// IsCreate_procedure_stmtContext differentiates from other interfaces.
	IsCreate_procedure_stmtContext()
}

type Create_procedure_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_procedure_stmtContext() *Create_procedure_stmtContext {
	var p = new(Create_procedure_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_procedure_stmt
	return p
}

func InitEmptyCreate_procedure_stmtContext(p *Create_procedure_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_procedure_stmt
}

func (*Create_procedure_stmtContext) IsCreate_procedure_stmtContext() {}

func NewCreate_procedure_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_procedure_stmtContext {
	var p = new(Create_procedure_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_procedure_stmt

	return p
}

func (s *Create_procedure_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_procedure_stmtContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Create_procedure_stmtContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Create_procedure_stmtContext) Proc_block() IProc_blockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProc_blockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProc_blockContext)
}

func (s *Create_procedure_stmtContext) T_PROCEDURE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PROCEDURE, 0)
}

func (s *Create_procedure_stmtContext) T_PROC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PROC, 0)
}

func (s *Create_procedure_stmtContext) T_ALTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALTER, 0)
}

func (s *Create_procedure_stmtContext) T_CREATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATE, 0)
}

func (s *Create_procedure_stmtContext) T_REPLACE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REPLACE, 0)
}

func (s *Create_procedure_stmtContext) Create_routine_params() ICreate_routine_paramsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_routine_paramsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_routine_paramsContext)
}

func (s *Create_procedure_stmtContext) Create_routine_options() ICreate_routine_optionsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_routine_optionsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_routine_optionsContext)
}

func (s *Create_procedure_stmtContext) Declare_block_inplace() IDeclare_block_inplaceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclare_block_inplaceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclare_block_inplaceContext)
}

func (s *Create_procedure_stmtContext) Label() ILabelContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *Create_procedure_stmtContext) T_SEMICOLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEMICOLON, 0)
}

func (s *Create_procedure_stmtContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Create_procedure_stmtContext) T_IS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IS, 0)
}

func (s *Create_procedure_stmtContext) T_OR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OR, 0)
}

func (s *Create_procedure_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_procedure_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_procedure_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_procedure_stmt(s)
	}
}

func (s *Create_procedure_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_procedure_stmt(s)
	}
}




func (p *HplsqlParser) Create_procedure_stmt() (localctx ICreate_procedure_stmtContext) {
	localctx = NewCreate_procedure_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, HplsqlParserRULE_create_procedure_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1579)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ALTER:
		{
			p.SetState(1572)
			p.Match(HplsqlParserT_ALTER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_CREATE:
		{
			p.SetState(1573)
			p.Match(HplsqlParserT_CREATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1576)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_OR {
			{
				p.SetState(1574)
				p.Match(HplsqlParserT_OR)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1575)
				p.Match(HplsqlParserT_REPLACE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case HplsqlParserT_REPLACE:
		{
			p.SetState(1578)
			p.Match(HplsqlParserT_REPLACE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_PROC, HplsqlParserT_PROCEDURE:



	default:
	}
	{
		p.SetState(1581)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_PROC || _la == HplsqlParserT_PROCEDURE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1582)
		p.Ident()
	}
	p.SetState(1584)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 157, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1583)
			p.Create_routine_params()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(1587)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 158, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1586)
			p.Create_routine_options()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(1590)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1589)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_AS || _la == HplsqlParserT_IS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(1593)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 160, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1592)
			p.Declare_block_inplace()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(1596)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 161, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1595)
			p.Label()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(1598)
		p.Proc_block()
	}
	p.SetState(1602)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 162, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1599)
			p.Ident()
		}
		{
			p.SetState(1600)
			p.Match(HplsqlParserT_SEMICOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_routine_paramsContext is an interface to support dynamic dispatch.
type ICreate_routine_paramsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode
	AllCreate_routine_param_item() []ICreate_routine_param_itemContext
	Create_routine_param_item(i int) ICreate_routine_param_itemContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsCreate_routine_paramsContext differentiates from other interfaces.
	IsCreate_routine_paramsContext()
}

type Create_routine_paramsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_routine_paramsContext() *Create_routine_paramsContext {
	var p = new(Create_routine_paramsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_routine_params
	return p
}

func InitEmptyCreate_routine_paramsContext(p *Create_routine_paramsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_routine_params
}

func (*Create_routine_paramsContext) IsCreate_routine_paramsContext() {}

func NewCreate_routine_paramsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_routine_paramsContext {
	var p = new(Create_routine_paramsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_routine_params

	return p
}

func (s *Create_routine_paramsContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_routine_paramsContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Create_routine_paramsContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Create_routine_paramsContext) AllCreate_routine_param_item() []ICreate_routine_param_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_routine_param_itemContext); ok {
			len++
		}
	}

	tst := make([]ICreate_routine_param_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_routine_param_itemContext); ok {
			tst[i] = t.(ICreate_routine_param_itemContext)
			i++
		}
	}

	return tst
}

func (s *Create_routine_paramsContext) Create_routine_param_item(i int) ICreate_routine_param_itemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_routine_param_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_routine_param_itemContext)
}

func (s *Create_routine_paramsContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Create_routine_paramsContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Create_routine_paramsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_routine_paramsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_routine_paramsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_routine_params(s)
	}
}

func (s *Create_routine_paramsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_routine_params(s)
	}
}




func (p *HplsqlParser) Create_routine_params() (localctx ICreate_routine_paramsContext) {
	localctx = NewCreate_routine_paramsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, HplsqlParserRULE_create_routine_params)
	var _la int

	var _alt int

	p.SetState(1626)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 165, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1604)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1605)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1606)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1607)
			p.Create_routine_param_item()
		}
		p.SetState(1612)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(1608)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1609)
				p.Create_routine_param_item()
			}


			p.SetState(1614)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1615)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1617)

		if !(!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "IS") &&
		        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "AS") &&
		        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "DYNAMIC") && strings.EqualFold(p.GetTokenStream().LT(2).GetText(), "RESULT")) {
			p.SetError(antlr.NewFailedPredicateException(p, "!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"IS\") &&\n        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"AS\") &&\n        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"DYNAMIC\") && strings.EqualFold(p.GetTokenStream().LT(2).GetText(), \"RESULT\")\n        ", ""))
			goto errorExit
		}
		{
			p.SetState(1618)
			p.Create_routine_param_item()
		}
		p.SetState(1623)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 164, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1619)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(1620)
					p.Create_routine_param_item()
				}


			}
			p.SetState(1625)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 164, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_routine_param_itemContext is an interface to support dynamic dispatch.
type ICreate_routine_param_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ident() IIdentContext
	Dtype() IDtypeContext
	T_IN() antlr.TerminalNode
	T_OUT() antlr.TerminalNode
	T_INOUT() antlr.TerminalNode
	Dtype_len() IDtype_lenContext
	AllDtype_attr() []IDtype_attrContext
	Dtype_attr(i int) IDtype_attrContext
	Dtype_default() IDtype_defaultContext

	// IsCreate_routine_param_itemContext differentiates from other interfaces.
	IsCreate_routine_param_itemContext()
}

type Create_routine_param_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_routine_param_itemContext() *Create_routine_param_itemContext {
	var p = new(Create_routine_param_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_routine_param_item
	return p
}

func InitEmptyCreate_routine_param_itemContext(p *Create_routine_param_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_routine_param_item
}

func (*Create_routine_param_itemContext) IsCreate_routine_param_itemContext() {}

func NewCreate_routine_param_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_routine_param_itemContext {
	var p = new(Create_routine_param_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_routine_param_item

	return p
}

func (s *Create_routine_param_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_routine_param_itemContext) Ident() IIdentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Create_routine_param_itemContext) Dtype() IDtypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *Create_routine_param_itemContext) T_IN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IN, 0)
}

func (s *Create_routine_param_itemContext) T_OUT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OUT, 0)
}

func (s *Create_routine_param_itemContext) T_INOUT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INOUT, 0)
}

func (s *Create_routine_param_itemContext) Dtype_len() IDtype_lenContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_lenContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_lenContext)
}

func (s *Create_routine_param_itemContext) AllDtype_attr() []IDtype_attrContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDtype_attrContext); ok {
			len++
		}
	}

	tst := make([]IDtype_attrContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDtype_attrContext); ok {
			tst[i] = t.(IDtype_attrContext)
			i++
		}
	}

	return tst
}

func (s *Create_routine_param_itemContext) Dtype_attr(i int) IDtype_attrContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_attrContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_attrContext)
}

func (s *Create_routine_param_itemContext) Dtype_default() IDtype_defaultContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_defaultContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_defaultContext)
}

func (s *Create_routine_param_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_routine_param_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_routine_param_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_routine_param_item(s)
	}
}

func (s *Create_routine_param_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_routine_param_item(s)
	}
}




func (p *HplsqlParser) Create_routine_param_item() (localctx ICreate_routine_param_itemContext) {
	localctx = NewCreate_routine_param_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, HplsqlParserRULE_create_routine_param_item)
	var _alt int

	p.SetState(1670)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 174, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1633)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 166, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1628)
				p.Match(HplsqlParserT_IN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 166, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(1629)
				p.Match(HplsqlParserT_OUT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 166, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(1630)
				p.Match(HplsqlParserT_INOUT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 166, p.GetParserRuleContext()) == 4 {
			{
				p.SetState(1631)
				p.Match(HplsqlParserT_IN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1632)
				p.Match(HplsqlParserT_OUT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(1635)
			p.Ident()
		}
		{
			p.SetState(1636)
			p.Dtype()
		}
		p.SetState(1638)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 167, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1637)
				p.Dtype_len()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(1643)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 168, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1640)
					p.Dtype_attr()
				}


			}
			p.SetState(1645)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 168, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1647)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 169, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1646)
				p.Dtype_default()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1649)
			p.Ident()
		}
		p.SetState(1655)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 170, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1650)
				p.Match(HplsqlParserT_IN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 170, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(1651)
				p.Match(HplsqlParserT_OUT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 170, p.GetParserRuleContext()) == 3 {
			{
				p.SetState(1652)
				p.Match(HplsqlParserT_INOUT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 170, p.GetParserRuleContext()) == 4 {
			{
				p.SetState(1653)
				p.Match(HplsqlParserT_IN)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1654)
				p.Match(HplsqlParserT_OUT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(1657)
			p.Dtype()
		}
		p.SetState(1659)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 171, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1658)
				p.Dtype_len()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(1664)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 172, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1661)
					p.Dtype_attr()
				}


			}
			p.SetState(1666)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 172, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1668)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 173, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1667)
				p.Dtype_default()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_routine_optionsContext is an interface to support dynamic dispatch.
type ICreate_routine_optionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCreate_routine_option() []ICreate_routine_optionContext
	Create_routine_option(i int) ICreate_routine_optionContext

	// IsCreate_routine_optionsContext differentiates from other interfaces.
	IsCreate_routine_optionsContext()
}

type Create_routine_optionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_routine_optionsContext() *Create_routine_optionsContext {
	var p = new(Create_routine_optionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_routine_options
	return p
}

func InitEmptyCreate_routine_optionsContext(p *Create_routine_optionsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_routine_options
}

func (*Create_routine_optionsContext) IsCreate_routine_optionsContext() {}

func NewCreate_routine_optionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_routine_optionsContext {
	var p = new(Create_routine_optionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_routine_options

	return p
}

func (s *Create_routine_optionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_routine_optionsContext) AllCreate_routine_option() []ICreate_routine_optionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_routine_optionContext); ok {
			len++
		}
	}

	tst := make([]ICreate_routine_optionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_routine_optionContext); ok {
			tst[i] = t.(ICreate_routine_optionContext)
			i++
		}
	}

	return tst
}

func (s *Create_routine_optionsContext) Create_routine_option(i int) ICreate_routine_optionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_routine_optionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_routine_optionContext)
}

func (s *Create_routine_optionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_routine_optionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_routine_optionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_routine_options(s)
	}
}

func (s *Create_routine_optionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_routine_options(s)
	}
}




func (p *HplsqlParser) Create_routine_options() (localctx ICreate_routine_optionsContext) {
	localctx = NewCreate_routine_optionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, HplsqlParserRULE_create_routine_options)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1673)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				{
					p.SetState(1672)
					p.Create_routine_option()
				}




		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1675)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 175, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_routine_optionContext is an interface to support dynamic dispatch.
type ICreate_routine_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_LANGUAGE() antlr.TerminalNode
	T_SQL() antlr.TerminalNode
	T_SECURITY() antlr.TerminalNode
	T_CREATOR() antlr.TerminalNode
	T_DEFINER() antlr.TerminalNode
	T_INVOKER() antlr.TerminalNode
	T_OWNER() antlr.TerminalNode
	T_RESULT() antlr.TerminalNode
	T_SETS() antlr.TerminalNode
	L_INT() antlr.TerminalNode
	T_DYNAMIC() antlr.TerminalNode

	// IsCreate_routine_optionContext differentiates from other interfaces.
	IsCreate_routine_optionContext()
}

type Create_routine_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_routine_optionContext() *Create_routine_optionContext {
	var p = new(Create_routine_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_routine_option
	return p
}

func InitEmptyCreate_routine_optionContext(p *Create_routine_optionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_routine_option
}

func (*Create_routine_optionContext) IsCreate_routine_optionContext() {}

func NewCreate_routine_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_routine_optionContext {
	var p = new(Create_routine_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_routine_option

	return p
}

func (s *Create_routine_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_routine_optionContext) T_LANGUAGE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LANGUAGE, 0)
}

func (s *Create_routine_optionContext) T_SQL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SQL, 0)
}

func (s *Create_routine_optionContext) T_SECURITY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SECURITY, 0)
}

func (s *Create_routine_optionContext) T_CREATOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATOR, 0)
}

func (s *Create_routine_optionContext) T_DEFINER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFINER, 0)
}

func (s *Create_routine_optionContext) T_INVOKER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INVOKER, 0)
}

func (s *Create_routine_optionContext) T_OWNER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OWNER, 0)
}

func (s *Create_routine_optionContext) T_RESULT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESULT, 0)
}

func (s *Create_routine_optionContext) T_SETS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SETS, 0)
}

func (s *Create_routine_optionContext) L_INT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_INT, 0)
}

func (s *Create_routine_optionContext) T_DYNAMIC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DYNAMIC, 0)
}

func (s *Create_routine_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_routine_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_routine_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_routine_option(s)
	}
}

func (s *Create_routine_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_routine_option(s)
	}
}




func (p *HplsqlParser) Create_routine_option() (localctx ICreate_routine_optionContext) {
	localctx = NewCreate_routine_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, HplsqlParserRULE_create_routine_option)
	var _la int

	p.SetState(1688)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_LANGUAGE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1677)
			p.Match(HplsqlParserT_LANGUAGE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1678)
			p.Match(HplsqlParserT_SQL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_SQL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1679)
			p.Match(HplsqlParserT_SQL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1680)
			p.Match(HplsqlParserT_SECURITY)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1681)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_CREATOR || _la == HplsqlParserT_DEFINER || _la == HplsqlParserT_INVOKER || _la == HplsqlParserT_OWNER) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case HplsqlParserT_DYNAMIC, HplsqlParserT_RESULT:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1683)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_DYNAMIC {
			{
				p.SetState(1682)
				p.Match(HplsqlParserT_DYNAMIC)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(1685)
			p.Match(HplsqlParserT_RESULT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1686)
			p.Match(HplsqlParserT_SETS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1687)
			p.Match(HplsqlParserL_INT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDrop_stmtContext is an interface to support dynamic dispatch.
type IDrop_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_DROP() antlr.TerminalNode
	T_TABLE() antlr.TerminalNode
	Table_name() ITable_nameContext
	T_IF() antlr.TerminalNode
	T_EXISTS() antlr.TerminalNode
	T_PACKAGE() antlr.TerminalNode
	Ident() IIdentContext
	T_PROCEDURE() antlr.TerminalNode
	T_FUNCTION() antlr.TerminalNode
	Expr() IExprContext
	T_DATABASE() antlr.TerminalNode
	T_SCHEMA() antlr.TerminalNode

	// IsDrop_stmtContext differentiates from other interfaces.
	IsDrop_stmtContext()
}

type Drop_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDrop_stmtContext() *Drop_stmtContext {
	var p = new(Drop_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_drop_stmt
	return p
}

func InitEmptyDrop_stmtContext(p *Drop_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_drop_stmt
}

func (*Drop_stmtContext) IsDrop_stmtContext() {}

func NewDrop_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Drop_stmtContext {
	var p = new(Drop_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_drop_stmt

	return p
}

func (s *Drop_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Drop_stmtContext) T_DROP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DROP, 0)
}

func (s *Drop_stmtContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLE, 0)
}

func (s *Drop_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Drop_stmtContext) T_IF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IF, 0)
}

func (s *Drop_stmtContext) T_EXISTS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXISTS, 0)
}

func (s *Drop_stmtContext) T_PACKAGE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PACKAGE, 0)
}

func (s *Drop_stmtContext) Ident() IIdentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Drop_stmtContext) T_PROCEDURE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PROCEDURE, 0)
}

func (s *Drop_stmtContext) T_FUNCTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FUNCTION, 0)
}

func (s *Drop_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Drop_stmtContext) T_DATABASE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATABASE, 0)
}

func (s *Drop_stmtContext) T_SCHEMA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SCHEMA, 0)
}

func (s *Drop_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Drop_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Drop_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDrop_stmt(s)
	}
}

func (s *Drop_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDrop_stmt(s)
	}
}




func (p *HplsqlParser) Drop_stmt() (localctx IDrop_stmtContext) {
	localctx = NewDrop_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, HplsqlParserRULE_drop_stmt)
	var _la int

	p.SetState(1718)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 182, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1690)
			p.Match(HplsqlParserT_DROP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1691)
			p.Match(HplsqlParserT_TABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1694)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 178, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1692)
				p.Match(HplsqlParserT_IF)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1693)
				p.Match(HplsqlParserT_EXISTS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(1696)
			p.Table_name()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1697)
			p.Match(HplsqlParserT_DROP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1698)
			p.Match(HplsqlParserT_PACKAGE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1701)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 179, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1699)
				p.Match(HplsqlParserT_IF)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1700)
				p.Match(HplsqlParserT_EXISTS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(1703)
			p.Ident()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1704)
			p.Match(HplsqlParserT_DROP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1705)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_FUNCTION || _la == HplsqlParserT_PROCEDURE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1708)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 180, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1706)
				p.Match(HplsqlParserT_IF)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1707)
				p.Match(HplsqlParserT_EXISTS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(1710)
			p.Ident()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1711)
			p.Match(HplsqlParserT_DROP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1712)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_DATABASE || _la == HplsqlParserT_SCHEMA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1715)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 181, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1713)
				p.Match(HplsqlParserT_IF)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1714)
				p.Match(HplsqlParserT_EXISTS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(1717)
			p.expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IEnd_transaction_stmtContext is an interface to support dynamic dispatch.
type IEnd_transaction_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_END() antlr.TerminalNode
	T_TRANSACTION() antlr.TerminalNode

	// IsEnd_transaction_stmtContext differentiates from other interfaces.
	IsEnd_transaction_stmtContext()
}

type End_transaction_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnd_transaction_stmtContext() *End_transaction_stmtContext {
	var p = new(End_transaction_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_end_transaction_stmt
	return p
}

func InitEmptyEnd_transaction_stmtContext(p *End_transaction_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_end_transaction_stmt
}

func (*End_transaction_stmtContext) IsEnd_transaction_stmtContext() {}

func NewEnd_transaction_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *End_transaction_stmtContext {
	var p = new(End_transaction_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_end_transaction_stmt

	return p
}

func (s *End_transaction_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *End_transaction_stmtContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *End_transaction_stmtContext) T_TRANSACTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TRANSACTION, 0)
}

func (s *End_transaction_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *End_transaction_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *End_transaction_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterEnd_transaction_stmt(s)
	}
}

func (s *End_transaction_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitEnd_transaction_stmt(s)
	}
}




func (p *HplsqlParser) End_transaction_stmt() (localctx IEnd_transaction_stmtContext) {
	localctx = NewEnd_transaction_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, HplsqlParserRULE_end_transaction_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1720)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1721)
		p.Match(HplsqlParserT_TRANSACTION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExec_stmtContext is an interface to support dynamic dispatch.
type IExec_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	T_EXEC() antlr.TerminalNode
	T_EXECUTE() antlr.TerminalNode
	T_IMMEDIATE() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	Expr_func_params() IExpr_func_paramsContext
	T_CLOSE_P() antlr.TerminalNode
	T_INTO() antlr.TerminalNode
	AllL_ID() []antlr.TerminalNode
	L_ID(i int) antlr.TerminalNode
	Using_clause() IUsing_clauseContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsExec_stmtContext differentiates from other interfaces.
	IsExec_stmtContext()
}

type Exec_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExec_stmtContext() *Exec_stmtContext {
	var p = new(Exec_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_exec_stmt
	return p
}

func InitEmptyExec_stmtContext(p *Exec_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_exec_stmt
}

func (*Exec_stmtContext) IsExec_stmtContext() {}

func NewExec_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exec_stmtContext {
	var p = new(Exec_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_exec_stmt

	return p
}

func (s *Exec_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Exec_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Exec_stmtContext) T_EXEC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXEC, 0)
}

func (s *Exec_stmtContext) T_EXECUTE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXECUTE, 0)
}

func (s *Exec_stmtContext) T_IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IMMEDIATE, 0)
}

func (s *Exec_stmtContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Exec_stmtContext) Expr_func_params() IExpr_func_paramsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_func_paramsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_func_paramsContext)
}

func (s *Exec_stmtContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Exec_stmtContext) T_INTO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTO, 0)
}

func (s *Exec_stmtContext) AllL_ID() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserL_ID)
}

func (s *Exec_stmtContext) L_ID(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, i)
}

func (s *Exec_stmtContext) Using_clause() IUsing_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsing_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsing_clauseContext)
}

func (s *Exec_stmtContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Exec_stmtContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Exec_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exec_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Exec_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExec_stmt(s)
	}
}

func (s *Exec_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExec_stmt(s)
	}
}




func (p *HplsqlParser) Exec_stmt() (localctx IExec_stmtContext) {
	localctx = NewExec_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, HplsqlParserRULE_exec_stmt)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1723)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_EXEC || _la == HplsqlParserT_EXECUTE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1725)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 183, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1724)
			p.Match(HplsqlParserT_IMMEDIATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(1727)
		p.expr(0)
	}
	p.SetState(1733)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 184, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1728)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1729)
			p.Expr_func_params()
		}
		{
			p.SetState(1730)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 184, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1732)
			p.Expr_func_params()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(1744)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 186, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1735)
			p.Match(HplsqlParserT_INTO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1736)
			p.Match(HplsqlParserL_ID)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1741)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 185, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1737)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(1738)
					p.Match(HplsqlParserL_ID)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}


			}
			p.SetState(1743)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 185, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(1747)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 187, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1746)
			p.Using_clause()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIf_stmtContext is an interface to support dynamic dispatch.
type IIf_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	If_plsql_stmt() IIf_plsql_stmtContext
	If_tsql_stmt() IIf_tsql_stmtContext
	If_bteq_stmt() IIf_bteq_stmtContext

	// IsIf_stmtContext differentiates from other interfaces.
	IsIf_stmtContext()
}

type If_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_stmtContext() *If_stmtContext {
	var p = new(If_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_if_stmt
	return p
}

func InitEmptyIf_stmtContext(p *If_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_if_stmt
}

func (*If_stmtContext) IsIf_stmtContext() {}

func NewIf_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_stmtContext {
	var p = new(If_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_if_stmt

	return p
}

func (s *If_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *If_stmtContext) If_plsql_stmt() IIf_plsql_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIf_plsql_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIf_plsql_stmtContext)
}

func (s *If_stmtContext) If_tsql_stmt() IIf_tsql_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIf_tsql_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIf_tsql_stmtContext)
}

func (s *If_stmtContext) If_bteq_stmt() IIf_bteq_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIf_bteq_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIf_bteq_stmtContext)
}

func (s *If_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *If_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterIf_stmt(s)
	}
}

func (s *If_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitIf_stmt(s)
	}
}




func (p *HplsqlParser) If_stmt() (localctx IIf_stmtContext) {
	localctx = NewIf_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, HplsqlParserRULE_if_stmt)
	p.SetState(1752)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 188, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1749)
			p.If_plsql_stmt()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1750)
			p.If_tsql_stmt()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1751)
			p.If_bteq_stmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIf_plsql_stmtContext is an interface to support dynamic dispatch.
type IIf_plsql_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllT_IF() []antlr.TerminalNode
	T_IF(i int) antlr.TerminalNode
	Bool_expr() IBool_exprContext
	T_THEN() antlr.TerminalNode
	Block() IBlockContext
	T_END() antlr.TerminalNode
	AllElseif_block() []IElseif_blockContext
	Elseif_block(i int) IElseif_blockContext
	Else_block() IElse_blockContext

	// IsIf_plsql_stmtContext differentiates from other interfaces.
	IsIf_plsql_stmtContext()
}

type If_plsql_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_plsql_stmtContext() *If_plsql_stmtContext {
	var p = new(If_plsql_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_if_plsql_stmt
	return p
}

func InitEmptyIf_plsql_stmtContext(p *If_plsql_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_if_plsql_stmt
}

func (*If_plsql_stmtContext) IsIf_plsql_stmtContext() {}

func NewIf_plsql_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_plsql_stmtContext {
	var p = new(If_plsql_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_if_plsql_stmt

	return p
}

func (s *If_plsql_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *If_plsql_stmtContext) AllT_IF() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_IF)
}

func (s *If_plsql_stmtContext) T_IF(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IF, i)
}

func (s *If_plsql_stmtContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *If_plsql_stmtContext) T_THEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_THEN, 0)
}

func (s *If_plsql_stmtContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *If_plsql_stmtContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *If_plsql_stmtContext) AllElseif_block() []IElseif_blockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElseif_blockContext); ok {
			len++
		}
	}

	tst := make([]IElseif_blockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElseif_blockContext); ok {
			tst[i] = t.(IElseif_blockContext)
			i++
		}
	}

	return tst
}

func (s *If_plsql_stmtContext) Elseif_block(i int) IElseif_blockContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElseif_blockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElseif_blockContext)
}

func (s *If_plsql_stmtContext) Else_block() IElse_blockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElse_blockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElse_blockContext)
}

func (s *If_plsql_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_plsql_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *If_plsql_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterIf_plsql_stmt(s)
	}
}

func (s *If_plsql_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitIf_plsql_stmt(s)
	}
}




func (p *HplsqlParser) If_plsql_stmt() (localctx IIf_plsql_stmtContext) {
	localctx = NewIf_plsql_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, HplsqlParserRULE_if_plsql_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1754)
		p.Match(HplsqlParserT_IF)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1755)
		p.bool_expr(0)
	}
	{
		p.SetState(1756)
		p.Match(HplsqlParserT_THEN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1757)
		p.Block()
	}
	p.SetState(1761)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HplsqlParserT_ELSEIF || _la == HplsqlParserT_ELSIF {
		{
			p.SetState(1758)
			p.Elseif_block()
		}


		p.SetState(1763)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1765)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_ELSE {
		{
			p.SetState(1764)
			p.Else_block()
		}

	}
	{
		p.SetState(1767)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1768)
		p.Match(HplsqlParserT_IF)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIf_tsql_stmtContext is an interface to support dynamic dispatch.
type IIf_tsql_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_IF() antlr.TerminalNode
	Bool_expr() IBool_exprContext
	AllSingle_block_stmt() []ISingle_block_stmtContext
	Single_block_stmt(i int) ISingle_block_stmtContext
	T_ELSE() antlr.TerminalNode

	// IsIf_tsql_stmtContext differentiates from other interfaces.
	IsIf_tsql_stmtContext()
}

type If_tsql_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_tsql_stmtContext() *If_tsql_stmtContext {
	var p = new(If_tsql_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_if_tsql_stmt
	return p
}

func InitEmptyIf_tsql_stmtContext(p *If_tsql_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_if_tsql_stmt
}

func (*If_tsql_stmtContext) IsIf_tsql_stmtContext() {}

func NewIf_tsql_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_tsql_stmtContext {
	var p = new(If_tsql_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_if_tsql_stmt

	return p
}

func (s *If_tsql_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *If_tsql_stmtContext) T_IF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IF, 0)
}

func (s *If_tsql_stmtContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *If_tsql_stmtContext) AllSingle_block_stmt() []ISingle_block_stmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingle_block_stmtContext); ok {
			len++
		}
	}

	tst := make([]ISingle_block_stmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingle_block_stmtContext); ok {
			tst[i] = t.(ISingle_block_stmtContext)
			i++
		}
	}

	return tst
}

func (s *If_tsql_stmtContext) Single_block_stmt(i int) ISingle_block_stmtContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingle_block_stmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingle_block_stmtContext)
}

func (s *If_tsql_stmtContext) T_ELSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ELSE, 0)
}

func (s *If_tsql_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_tsql_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *If_tsql_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterIf_tsql_stmt(s)
	}
}

func (s *If_tsql_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitIf_tsql_stmt(s)
	}
}




func (p *HplsqlParser) If_tsql_stmt() (localctx IIf_tsql_stmtContext) {
	localctx = NewIf_tsql_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, HplsqlParserRULE_if_tsql_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1770)
		p.Match(HplsqlParserT_IF)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1771)
		p.bool_expr(0)
	}
	{
		p.SetState(1772)
		p.Single_block_stmt()
	}
	p.SetState(1775)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 191, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1773)
			p.Match(HplsqlParserT_ELSE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1774)
			p.Single_block_stmt()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIf_bteq_stmtContext is an interface to support dynamic dispatch.
type IIf_bteq_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_DOT() antlr.TerminalNode
	T_IF() antlr.TerminalNode
	Bool_expr() IBool_exprContext
	T_THEN() antlr.TerminalNode
	Single_block_stmt() ISingle_block_stmtContext

	// IsIf_bteq_stmtContext differentiates from other interfaces.
	IsIf_bteq_stmtContext()
}

type If_bteq_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_bteq_stmtContext() *If_bteq_stmtContext {
	var p = new(If_bteq_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_if_bteq_stmt
	return p
}

func InitEmptyIf_bteq_stmtContext(p *If_bteq_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_if_bteq_stmt
}

func (*If_bteq_stmtContext) IsIf_bteq_stmtContext() {}

func NewIf_bteq_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_bteq_stmtContext {
	var p = new(If_bteq_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_if_bteq_stmt

	return p
}

func (s *If_bteq_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *If_bteq_stmtContext) T_DOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DOT, 0)
}

func (s *If_bteq_stmtContext) T_IF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IF, 0)
}

func (s *If_bteq_stmtContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *If_bteq_stmtContext) T_THEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_THEN, 0)
}

func (s *If_bteq_stmtContext) Single_block_stmt() ISingle_block_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingle_block_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingle_block_stmtContext)
}

func (s *If_bteq_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_bteq_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *If_bteq_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterIf_bteq_stmt(s)
	}
}

func (s *If_bteq_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitIf_bteq_stmt(s)
	}
}




func (p *HplsqlParser) If_bteq_stmt() (localctx IIf_bteq_stmtContext) {
	localctx = NewIf_bteq_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, HplsqlParserRULE_if_bteq_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1777)
		p.Match(HplsqlParserT_DOT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1778)
		p.Match(HplsqlParserT_IF)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1779)
		p.bool_expr(0)
	}
	{
		p.SetState(1780)
		p.Match(HplsqlParserT_THEN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1781)
		p.Single_block_stmt()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IElseif_blockContext is an interface to support dynamic dispatch.
type IElseif_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Bool_expr() IBool_exprContext
	T_THEN() antlr.TerminalNode
	Block() IBlockContext
	T_ELSIF() antlr.TerminalNode
	T_ELSEIF() antlr.TerminalNode

	// IsElseif_blockContext differentiates from other interfaces.
	IsElseif_blockContext()
}

type Elseif_blockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElseif_blockContext() *Elseif_blockContext {
	var p = new(Elseif_blockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_elseif_block
	return p
}

func InitEmptyElseif_blockContext(p *Elseif_blockContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_elseif_block
}

func (*Elseif_blockContext) IsElseif_blockContext() {}

func NewElseif_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Elseif_blockContext {
	var p = new(Elseif_blockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_elseif_block

	return p
}

func (s *Elseif_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Elseif_blockContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *Elseif_blockContext) T_THEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_THEN, 0)
}

func (s *Elseif_blockContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *Elseif_blockContext) T_ELSIF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ELSIF, 0)
}

func (s *Elseif_blockContext) T_ELSEIF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ELSEIF, 0)
}

func (s *Elseif_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Elseif_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Elseif_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterElseif_block(s)
	}
}

func (s *Elseif_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitElseif_block(s)
	}
}




func (p *HplsqlParser) Elseif_block() (localctx IElseif_blockContext) {
	localctx = NewElseif_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, HplsqlParserRULE_elseif_block)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1783)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_ELSEIF || _la == HplsqlParserT_ELSIF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1784)
		p.bool_expr(0)
	}
	{
		p.SetState(1785)
		p.Match(HplsqlParserT_THEN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1786)
		p.Block()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IElse_blockContext is an interface to support dynamic dispatch.
type IElse_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ELSE() antlr.TerminalNode
	Block() IBlockContext

	// IsElse_blockContext differentiates from other interfaces.
	IsElse_blockContext()
}

type Else_blockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElse_blockContext() *Else_blockContext {
	var p = new(Else_blockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_else_block
	return p
}

func InitEmptyElse_blockContext(p *Else_blockContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_else_block
}

func (*Else_blockContext) IsElse_blockContext() {}

func NewElse_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Else_blockContext {
	var p = new(Else_blockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_else_block

	return p
}

func (s *Else_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Else_blockContext) T_ELSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ELSE, 0)
}

func (s *Else_blockContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *Else_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Else_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Else_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterElse_block(s)
	}
}

func (s *Else_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitElse_block(s)
	}
}




func (p *HplsqlParser) Else_block() (localctx IElse_blockContext) {
	localctx = NewElse_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, HplsqlParserRULE_else_block)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1788)
		p.Match(HplsqlParserT_ELSE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1789)
		p.Block()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInclude_stmtContext is an interface to support dynamic dispatch.
type IInclude_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_INCLUDE() antlr.TerminalNode
	File_name() IFile_nameContext
	Expr() IExprContext

	// IsInclude_stmtContext differentiates from other interfaces.
	IsInclude_stmtContext()
}

type Include_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInclude_stmtContext() *Include_stmtContext {
	var p = new(Include_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_include_stmt
	return p
}

func InitEmptyInclude_stmtContext(p *Include_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_include_stmt
}

func (*Include_stmtContext) IsInclude_stmtContext() {}

func NewInclude_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Include_stmtContext {
	var p = new(Include_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_include_stmt

	return p
}

func (s *Include_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Include_stmtContext) T_INCLUDE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INCLUDE, 0)
}

func (s *Include_stmtContext) File_name() IFile_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFile_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFile_nameContext)
}

func (s *Include_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Include_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Include_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Include_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterInclude_stmt(s)
	}
}

func (s *Include_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitInclude_stmt(s)
	}
}




func (p *HplsqlParser) Include_stmt() (localctx IInclude_stmtContext) {
	localctx = NewInclude_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, HplsqlParserRULE_include_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1791)
		p.Match(HplsqlParserT_INCLUDE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1794)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 192, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1792)
			p.File_name()
		}


	case 2:
		{
			p.SetState(1793)
			p.expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInsert_stmtContext is an interface to support dynamic dispatch.
type IInsert_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_INSERT() antlr.TerminalNode
	Table_name() ITable_nameContext
	T_OVERWRITE() antlr.TerminalNode
	T_TABLE() antlr.TerminalNode
	T_INTO() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	Insert_stmt_rows() IInsert_stmt_rowsContext
	Insert_stmt_cols() IInsert_stmt_colsContext

	// IsInsert_stmtContext differentiates from other interfaces.
	IsInsert_stmtContext()
}

type Insert_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsert_stmtContext() *Insert_stmtContext {
	var p = new(Insert_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_insert_stmt
	return p
}

func InitEmptyInsert_stmtContext(p *Insert_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_insert_stmt
}

func (*Insert_stmtContext) IsInsert_stmtContext() {}

func NewInsert_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Insert_stmtContext {
	var p = new(Insert_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_insert_stmt

	return p
}

func (s *Insert_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Insert_stmtContext) T_INSERT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INSERT, 0)
}

func (s *Insert_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Insert_stmtContext) T_OVERWRITE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OVERWRITE, 0)
}

func (s *Insert_stmtContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLE, 0)
}

func (s *Insert_stmtContext) T_INTO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTO, 0)
}

func (s *Insert_stmtContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Insert_stmtContext) Insert_stmt_rows() IInsert_stmt_rowsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_stmt_rowsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_stmt_rowsContext)
}

func (s *Insert_stmtContext) Insert_stmt_cols() IInsert_stmt_colsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_stmt_colsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_stmt_colsContext)
}

func (s *Insert_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Insert_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Insert_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterInsert_stmt(s)
	}
}

func (s *Insert_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitInsert_stmt(s)
	}
}




func (p *HplsqlParser) Insert_stmt() (localctx IInsert_stmtContext) {
	localctx = NewInsert_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, HplsqlParserRULE_insert_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1796)
		p.Match(HplsqlParserT_INSERT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1803)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_OVERWRITE:
		{
			p.SetState(1797)
			p.Match(HplsqlParserT_OVERWRITE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1798)
			p.Match(HplsqlParserT_TABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_INTO:
		{
			p.SetState(1799)
			p.Match(HplsqlParserT_INTO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1801)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 193, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1800)
				p.Match(HplsqlParserT_TABLE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1805)
		p.Table_name()
	}
	p.SetState(1807)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 195, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1806)
			p.Insert_stmt_cols()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(1811)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_WITH, HplsqlParserT_OPEN_P:
		{
			p.SetState(1809)
			p.Select_stmt()
		}


	case HplsqlParserT_VALUES:
		{
			p.SetState(1810)
			p.Insert_stmt_rows()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInsert_stmt_colsContext is an interface to support dynamic dispatch.
type IInsert_stmt_colsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN_P() antlr.TerminalNode
	AllQident() []IQidentContext
	Qident(i int) IQidentContext
	T_CLOSE_P() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsInsert_stmt_colsContext differentiates from other interfaces.
	IsInsert_stmt_colsContext()
}

type Insert_stmt_colsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsert_stmt_colsContext() *Insert_stmt_colsContext {
	var p = new(Insert_stmt_colsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_insert_stmt_cols
	return p
}

func InitEmptyInsert_stmt_colsContext(p *Insert_stmt_colsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_insert_stmt_cols
}

func (*Insert_stmt_colsContext) IsInsert_stmt_colsContext() {}

func NewInsert_stmt_colsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Insert_stmt_colsContext {
	var p = new(Insert_stmt_colsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_insert_stmt_cols

	return p
}

func (s *Insert_stmt_colsContext) GetParser() antlr.Parser { return s.parser }

func (s *Insert_stmt_colsContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Insert_stmt_colsContext) AllQident() []IQidentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQidentContext); ok {
			len++
		}
	}

	tst := make([]IQidentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQidentContext); ok {
			tst[i] = t.(IQidentContext)
			i++
		}
	}

	return tst
}

func (s *Insert_stmt_colsContext) Qident(i int) IQidentContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Insert_stmt_colsContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Insert_stmt_colsContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Insert_stmt_colsContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Insert_stmt_colsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Insert_stmt_colsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Insert_stmt_colsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterInsert_stmt_cols(s)
	}
}

func (s *Insert_stmt_colsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitInsert_stmt_cols(s)
	}
}




func (p *HplsqlParser) Insert_stmt_cols() (localctx IInsert_stmt_colsContext) {
	localctx = NewInsert_stmt_colsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, HplsqlParserRULE_insert_stmt_cols)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1813)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1814)
		p.Qident()
	}
	p.SetState(1819)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(1815)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1816)
			p.Qident()
		}


		p.SetState(1821)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1822)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInsert_stmt_rowsContext is an interface to support dynamic dispatch.
type IInsert_stmt_rowsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_VALUES() antlr.TerminalNode
	AllInsert_stmt_row() []IInsert_stmt_rowContext
	Insert_stmt_row(i int) IInsert_stmt_rowContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsInsert_stmt_rowsContext differentiates from other interfaces.
	IsInsert_stmt_rowsContext()
}

type Insert_stmt_rowsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsert_stmt_rowsContext() *Insert_stmt_rowsContext {
	var p = new(Insert_stmt_rowsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_insert_stmt_rows
	return p
}

func InitEmptyInsert_stmt_rowsContext(p *Insert_stmt_rowsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_insert_stmt_rows
}

func (*Insert_stmt_rowsContext) IsInsert_stmt_rowsContext() {}

func NewInsert_stmt_rowsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Insert_stmt_rowsContext {
	var p = new(Insert_stmt_rowsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_insert_stmt_rows

	return p
}

func (s *Insert_stmt_rowsContext) GetParser() antlr.Parser { return s.parser }

func (s *Insert_stmt_rowsContext) T_VALUES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VALUES, 0)
}

func (s *Insert_stmt_rowsContext) AllInsert_stmt_row() []IInsert_stmt_rowContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInsert_stmt_rowContext); ok {
			len++
		}
	}

	tst := make([]IInsert_stmt_rowContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInsert_stmt_rowContext); ok {
			tst[i] = t.(IInsert_stmt_rowContext)
			i++
		}
	}

	return tst
}

func (s *Insert_stmt_rowsContext) Insert_stmt_row(i int) IInsert_stmt_rowContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_stmt_rowContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_stmt_rowContext)
}

func (s *Insert_stmt_rowsContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Insert_stmt_rowsContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Insert_stmt_rowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Insert_stmt_rowsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Insert_stmt_rowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterInsert_stmt_rows(s)
	}
}

func (s *Insert_stmt_rowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitInsert_stmt_rows(s)
	}
}




func (p *HplsqlParser) Insert_stmt_rows() (localctx IInsert_stmt_rowsContext) {
	localctx = NewInsert_stmt_rowsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, HplsqlParserRULE_insert_stmt_rows)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1824)
		p.Match(HplsqlParserT_VALUES)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1825)
		p.Insert_stmt_row()
	}
	p.SetState(1830)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 198, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1826)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1827)
				p.Insert_stmt_row()
			}


		}
		p.SetState(1832)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 198, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInsert_stmt_rowContext is an interface to support dynamic dispatch.
type IInsert_stmt_rowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN_P() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_CLOSE_P() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsInsert_stmt_rowContext differentiates from other interfaces.
	IsInsert_stmt_rowContext()
}

type Insert_stmt_rowContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsert_stmt_rowContext() *Insert_stmt_rowContext {
	var p = new(Insert_stmt_rowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_insert_stmt_row
	return p
}

func InitEmptyInsert_stmt_rowContext(p *Insert_stmt_rowContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_insert_stmt_row
}

func (*Insert_stmt_rowContext) IsInsert_stmt_rowContext() {}

func NewInsert_stmt_rowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Insert_stmt_rowContext {
	var p = new(Insert_stmt_rowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_insert_stmt_row

	return p
}

func (s *Insert_stmt_rowContext) GetParser() antlr.Parser { return s.parser }

func (s *Insert_stmt_rowContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Insert_stmt_rowContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Insert_stmt_rowContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Insert_stmt_rowContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Insert_stmt_rowContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Insert_stmt_rowContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Insert_stmt_rowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Insert_stmt_rowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Insert_stmt_rowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterInsert_stmt_row(s)
	}
}

func (s *Insert_stmt_rowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitInsert_stmt_row(s)
	}
}




func (p *HplsqlParser) Insert_stmt_row() (localctx IInsert_stmt_rowContext) {
	localctx = NewInsert_stmt_rowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, HplsqlParserRULE_insert_stmt_row)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1833)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1834)
		p.expr(0)
	}
	p.SetState(1839)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(1835)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1836)
			p.expr(0)
		}


		p.SetState(1841)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1842)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInsert_directory_stmtContext is an interface to support dynamic dispatch.
type IInsert_directory_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_INSERT() antlr.TerminalNode
	T_OVERWRITE() antlr.TerminalNode
	T_DIRECTORY() antlr.TerminalNode
	Expr_file() IExpr_fileContext
	Expr_select() IExpr_selectContext
	T_LOCAL() antlr.TerminalNode

	// IsInsert_directory_stmtContext differentiates from other interfaces.
	IsInsert_directory_stmtContext()
}

type Insert_directory_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsert_directory_stmtContext() *Insert_directory_stmtContext {
	var p = new(Insert_directory_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_insert_directory_stmt
	return p
}

func InitEmptyInsert_directory_stmtContext(p *Insert_directory_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_insert_directory_stmt
}

func (*Insert_directory_stmtContext) IsInsert_directory_stmtContext() {}

func NewInsert_directory_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Insert_directory_stmtContext {
	var p = new(Insert_directory_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_insert_directory_stmt

	return p
}

func (s *Insert_directory_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Insert_directory_stmtContext) T_INSERT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INSERT, 0)
}

func (s *Insert_directory_stmtContext) T_OVERWRITE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OVERWRITE, 0)
}

func (s *Insert_directory_stmtContext) T_DIRECTORY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DIRECTORY, 0)
}

func (s *Insert_directory_stmtContext) Expr_file() IExpr_fileContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_fileContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_fileContext)
}

func (s *Insert_directory_stmtContext) Expr_select() IExpr_selectContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_selectContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_selectContext)
}

func (s *Insert_directory_stmtContext) T_LOCAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCAL, 0)
}

func (s *Insert_directory_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Insert_directory_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Insert_directory_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterInsert_directory_stmt(s)
	}
}

func (s *Insert_directory_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitInsert_directory_stmt(s)
	}
}




func (p *HplsqlParser) Insert_directory_stmt() (localctx IInsert_directory_stmtContext) {
	localctx = NewInsert_directory_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, HplsqlParserRULE_insert_directory_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1844)
		p.Match(HplsqlParserT_INSERT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1845)
		p.Match(HplsqlParserT_OVERWRITE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1847)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_LOCAL {
		{
			p.SetState(1846)
			p.Match(HplsqlParserT_LOCAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(1849)
		p.Match(HplsqlParserT_DIRECTORY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1850)
		p.Expr_file()
	}
	{
		p.SetState(1851)
		p.Expr_select()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExit_stmtContext is an interface to support dynamic dispatch.
type IExit_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_EXIT() antlr.TerminalNode
	L_ID() antlr.TerminalNode
	T_WHEN() antlr.TerminalNode
	Bool_expr() IBool_exprContext

	// IsExit_stmtContext differentiates from other interfaces.
	IsExit_stmtContext()
}

type Exit_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExit_stmtContext() *Exit_stmtContext {
	var p = new(Exit_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_exit_stmt
	return p
}

func InitEmptyExit_stmtContext(p *Exit_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_exit_stmt
}

func (*Exit_stmtContext) IsExit_stmtContext() {}

func NewExit_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exit_stmtContext {
	var p = new(Exit_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_exit_stmt

	return p
}

func (s *Exit_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Exit_stmtContext) T_EXIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXIT, 0)
}

func (s *Exit_stmtContext) L_ID() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, 0)
}

func (s *Exit_stmtContext) T_WHEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WHEN, 0)
}

func (s *Exit_stmtContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *Exit_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exit_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Exit_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExit_stmt(s)
	}
}

func (s *Exit_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExit_stmt(s)
	}
}




func (p *HplsqlParser) Exit_stmt() (localctx IExit_stmtContext) {
	localctx = NewExit_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, HplsqlParserRULE_exit_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1853)
		p.Match(HplsqlParserT_EXIT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1855)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 201, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1854)
			p.Match(HplsqlParserL_ID)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(1859)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 202, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1857)
			p.Match(HplsqlParserT_WHEN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1858)
			p.bool_expr(0)
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGet_diag_stmtContext is an interface to support dynamic dispatch.
type IGet_diag_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_GET() antlr.TerminalNode
	T_DIAGNOSTICS() antlr.TerminalNode
	Get_diag_stmt_item() IGet_diag_stmt_itemContext

	// IsGet_diag_stmtContext differentiates from other interfaces.
	IsGet_diag_stmtContext()
}

type Get_diag_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_diag_stmtContext() *Get_diag_stmtContext {
	var p = new(Get_diag_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt
	return p
}

func InitEmptyGet_diag_stmtContext(p *Get_diag_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt
}

func (*Get_diag_stmtContext) IsGet_diag_stmtContext() {}

func NewGet_diag_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_diag_stmtContext {
	var p = new(Get_diag_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt

	return p
}

func (s *Get_diag_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_diag_stmtContext) T_GET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GET, 0)
}

func (s *Get_diag_stmtContext) T_DIAGNOSTICS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DIAGNOSTICS, 0)
}

func (s *Get_diag_stmtContext) Get_diag_stmt_item() IGet_diag_stmt_itemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGet_diag_stmt_itemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGet_diag_stmt_itemContext)
}

func (s *Get_diag_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_diag_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Get_diag_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterGet_diag_stmt(s)
	}
}

func (s *Get_diag_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitGet_diag_stmt(s)
	}
}




func (p *HplsqlParser) Get_diag_stmt() (localctx IGet_diag_stmtContext) {
	localctx = NewGet_diag_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, HplsqlParserRULE_get_diag_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1861)
		p.Match(HplsqlParserT_GET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1862)
		p.Match(HplsqlParserT_DIAGNOSTICS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1863)
		p.Get_diag_stmt_item()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGet_diag_stmt_itemContext is an interface to support dynamic dispatch.
type IGet_diag_stmt_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Get_diag_stmt_exception_item() IGet_diag_stmt_exception_itemContext
	Get_diag_stmt_rowcount_item() IGet_diag_stmt_rowcount_itemContext

	// IsGet_diag_stmt_itemContext differentiates from other interfaces.
	IsGet_diag_stmt_itemContext()
}

type Get_diag_stmt_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_diag_stmt_itemContext() *Get_diag_stmt_itemContext {
	var p = new(Get_diag_stmt_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt_item
	return p
}

func InitEmptyGet_diag_stmt_itemContext(p *Get_diag_stmt_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt_item
}

func (*Get_diag_stmt_itemContext) IsGet_diag_stmt_itemContext() {}

func NewGet_diag_stmt_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_diag_stmt_itemContext {
	var p = new(Get_diag_stmt_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt_item

	return p
}

func (s *Get_diag_stmt_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_diag_stmt_itemContext) Get_diag_stmt_exception_item() IGet_diag_stmt_exception_itemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGet_diag_stmt_exception_itemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGet_diag_stmt_exception_itemContext)
}

func (s *Get_diag_stmt_itemContext) Get_diag_stmt_rowcount_item() IGet_diag_stmt_rowcount_itemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGet_diag_stmt_rowcount_itemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGet_diag_stmt_rowcount_itemContext)
}

func (s *Get_diag_stmt_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_diag_stmt_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Get_diag_stmt_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterGet_diag_stmt_item(s)
	}
}

func (s *Get_diag_stmt_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitGet_diag_stmt_item(s)
	}
}




func (p *HplsqlParser) Get_diag_stmt_item() (localctx IGet_diag_stmt_itemContext) {
	localctx = NewGet_diag_stmt_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, HplsqlParserRULE_get_diag_stmt_item)
	p.SetState(1867)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 203, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1865)
			p.Get_diag_stmt_exception_item()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1866)
			p.Get_diag_stmt_rowcount_item()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGet_diag_stmt_exception_itemContext is an interface to support dynamic dispatch.
type IGet_diag_stmt_exception_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_EXCEPTION() antlr.TerminalNode
	L_INT() antlr.TerminalNode
	Qident() IQidentContext
	T_EQUAL() antlr.TerminalNode
	T_MESSAGE_TEXT() antlr.TerminalNode

	// IsGet_diag_stmt_exception_itemContext differentiates from other interfaces.
	IsGet_diag_stmt_exception_itemContext()
}

type Get_diag_stmt_exception_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_diag_stmt_exception_itemContext() *Get_diag_stmt_exception_itemContext {
	var p = new(Get_diag_stmt_exception_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt_exception_item
	return p
}

func InitEmptyGet_diag_stmt_exception_itemContext(p *Get_diag_stmt_exception_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt_exception_item
}

func (*Get_diag_stmt_exception_itemContext) IsGet_diag_stmt_exception_itemContext() {}

func NewGet_diag_stmt_exception_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_diag_stmt_exception_itemContext {
	var p = new(Get_diag_stmt_exception_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt_exception_item

	return p
}

func (s *Get_diag_stmt_exception_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_diag_stmt_exception_itemContext) T_EXCEPTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXCEPTION, 0)
}

func (s *Get_diag_stmt_exception_itemContext) L_INT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_INT, 0)
}

func (s *Get_diag_stmt_exception_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Get_diag_stmt_exception_itemContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Get_diag_stmt_exception_itemContext) T_MESSAGE_TEXT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MESSAGE_TEXT, 0)
}

func (s *Get_diag_stmt_exception_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_diag_stmt_exception_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Get_diag_stmt_exception_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterGet_diag_stmt_exception_item(s)
	}
}

func (s *Get_diag_stmt_exception_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitGet_diag_stmt_exception_item(s)
	}
}




func (p *HplsqlParser) Get_diag_stmt_exception_item() (localctx IGet_diag_stmt_exception_itemContext) {
	localctx = NewGet_diag_stmt_exception_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, HplsqlParserRULE_get_diag_stmt_exception_item)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1869)
		p.Match(HplsqlParserT_EXCEPTION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1870)
		p.Match(HplsqlParserL_INT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1871)
		p.Qident()
	}
	{
		p.SetState(1872)
		p.Match(HplsqlParserT_EQUAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1873)
		p.Match(HplsqlParserT_MESSAGE_TEXT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGet_diag_stmt_rowcount_itemContext is an interface to support dynamic dispatch.
type IGet_diag_stmt_rowcount_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Qident() IQidentContext
	T_EQUAL() antlr.TerminalNode
	T_ROW_COUNT() antlr.TerminalNode

	// IsGet_diag_stmt_rowcount_itemContext differentiates from other interfaces.
	IsGet_diag_stmt_rowcount_itemContext()
}

type Get_diag_stmt_rowcount_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_diag_stmt_rowcount_itemContext() *Get_diag_stmt_rowcount_itemContext {
	var p = new(Get_diag_stmt_rowcount_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt_rowcount_item
	return p
}

func InitEmptyGet_diag_stmt_rowcount_itemContext(p *Get_diag_stmt_rowcount_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt_rowcount_item
}

func (*Get_diag_stmt_rowcount_itemContext) IsGet_diag_stmt_rowcount_itemContext() {}

func NewGet_diag_stmt_rowcount_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_diag_stmt_rowcount_itemContext {
	var p = new(Get_diag_stmt_rowcount_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_get_diag_stmt_rowcount_item

	return p
}

func (s *Get_diag_stmt_rowcount_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_diag_stmt_rowcount_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Get_diag_stmt_rowcount_itemContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Get_diag_stmt_rowcount_itemContext) T_ROW_COUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROW_COUNT, 0)
}

func (s *Get_diag_stmt_rowcount_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_diag_stmt_rowcount_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Get_diag_stmt_rowcount_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterGet_diag_stmt_rowcount_item(s)
	}
}

func (s *Get_diag_stmt_rowcount_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitGet_diag_stmt_rowcount_item(s)
	}
}




func (p *HplsqlParser) Get_diag_stmt_rowcount_item() (localctx IGet_diag_stmt_rowcount_itemContext) {
	localctx = NewGet_diag_stmt_rowcount_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, HplsqlParserRULE_get_diag_stmt_rowcount_item)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1875)
		p.Qident()
	}
	{
		p.SetState(1876)
		p.Match(HplsqlParserT_EQUAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1877)
		p.Match(HplsqlParserT_ROW_COUNT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGrant_stmtContext is an interface to support dynamic dispatch.
type IGrant_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_GRANT() antlr.TerminalNode
	AllGrant_stmt_item() []IGrant_stmt_itemContext
	Grant_stmt_item(i int) IGrant_stmt_itemContext
	T_TO() antlr.TerminalNode
	T_ROLE() antlr.TerminalNode
	Qident() IQidentContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsGrant_stmtContext differentiates from other interfaces.
	IsGrant_stmtContext()
}

type Grant_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrant_stmtContext() *Grant_stmtContext {
	var p = new(Grant_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_grant_stmt
	return p
}

func InitEmptyGrant_stmtContext(p *Grant_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_grant_stmt
}

func (*Grant_stmtContext) IsGrant_stmtContext() {}

func NewGrant_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Grant_stmtContext {
	var p = new(Grant_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_grant_stmt

	return p
}

func (s *Grant_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Grant_stmtContext) T_GRANT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GRANT, 0)
}

func (s *Grant_stmtContext) AllGrant_stmt_item() []IGrant_stmt_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGrant_stmt_itemContext); ok {
			len++
		}
	}

	tst := make([]IGrant_stmt_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGrant_stmt_itemContext); ok {
			tst[i] = t.(IGrant_stmt_itemContext)
			i++
		}
	}

	return tst
}

func (s *Grant_stmtContext) Grant_stmt_item(i int) IGrant_stmt_itemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrant_stmt_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrant_stmt_itemContext)
}

func (s *Grant_stmtContext) T_TO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TO, 0)
}

func (s *Grant_stmtContext) T_ROLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROLE, 0)
}

func (s *Grant_stmtContext) Qident() IQidentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Grant_stmtContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Grant_stmtContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Grant_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Grant_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Grant_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterGrant_stmt(s)
	}
}

func (s *Grant_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitGrant_stmt(s)
	}
}




func (p *HplsqlParser) Grant_stmt() (localctx IGrant_stmtContext) {
	localctx = NewGrant_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, HplsqlParserRULE_grant_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1879)
		p.Match(HplsqlParserT_GRANT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1880)
		p.Grant_stmt_item()
	}
	p.SetState(1885)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(1881)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1882)
			p.Grant_stmt_item()
		}


		p.SetState(1887)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1888)
		p.Match(HplsqlParserT_TO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1889)
		p.Match(HplsqlParserT_ROLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1890)
		p.Qident()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGrant_stmt_itemContext is an interface to support dynamic dispatch.
type IGrant_stmt_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_EXECUTE() antlr.TerminalNode
	T_ON() antlr.TerminalNode
	T_PROCEDURE() antlr.TerminalNode
	Qident() IQidentContext

	// IsGrant_stmt_itemContext differentiates from other interfaces.
	IsGrant_stmt_itemContext()
}

type Grant_stmt_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrant_stmt_itemContext() *Grant_stmt_itemContext {
	var p = new(Grant_stmt_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_grant_stmt_item
	return p
}

func InitEmptyGrant_stmt_itemContext(p *Grant_stmt_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_grant_stmt_item
}

func (*Grant_stmt_itemContext) IsGrant_stmt_itemContext() {}

func NewGrant_stmt_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Grant_stmt_itemContext {
	var p = new(Grant_stmt_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_grant_stmt_item

	return p
}

func (s *Grant_stmt_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Grant_stmt_itemContext) T_EXECUTE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXECUTE, 0)
}

func (s *Grant_stmt_itemContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *Grant_stmt_itemContext) T_PROCEDURE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PROCEDURE, 0)
}

func (s *Grant_stmt_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Grant_stmt_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Grant_stmt_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Grant_stmt_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterGrant_stmt_item(s)
	}
}

func (s *Grant_stmt_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitGrant_stmt_item(s)
	}
}




func (p *HplsqlParser) Grant_stmt_item() (localctx IGrant_stmt_itemContext) {
	localctx = NewGrant_stmt_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, HplsqlParserRULE_grant_stmt_item)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1892)
		p.Match(HplsqlParserT_EXECUTE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1893)
		p.Match(HplsqlParserT_ON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1894)
		p.Match(HplsqlParserT_PROCEDURE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1895)
		p.Qident()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILeave_stmtContext is an interface to support dynamic dispatch.
type ILeave_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_LEAVE() antlr.TerminalNode
	L_ID() antlr.TerminalNode

	// IsLeave_stmtContext differentiates from other interfaces.
	IsLeave_stmtContext()
}

type Leave_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLeave_stmtContext() *Leave_stmtContext {
	var p = new(Leave_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_leave_stmt
	return p
}

func InitEmptyLeave_stmtContext(p *Leave_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_leave_stmt
}

func (*Leave_stmtContext) IsLeave_stmtContext() {}

func NewLeave_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Leave_stmtContext {
	var p = new(Leave_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_leave_stmt

	return p
}

func (s *Leave_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Leave_stmtContext) T_LEAVE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LEAVE, 0)
}

func (s *Leave_stmtContext) L_ID() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, 0)
}

func (s *Leave_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Leave_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Leave_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterLeave_stmt(s)
	}
}

func (s *Leave_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitLeave_stmt(s)
	}
}




func (p *HplsqlParser) Leave_stmt() (localctx ILeave_stmtContext) {
	localctx = NewLeave_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, HplsqlParserRULE_leave_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1897)
		p.Match(HplsqlParserT_LEAVE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1899)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 205, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1898)
			p.Match(HplsqlParserL_ID)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IMap_object_stmtContext is an interface to support dynamic dispatch.
type IMap_object_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_MAP() antlr.TerminalNode
	T_OBJECT() antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	T_TO() antlr.TerminalNode
	T_AT() antlr.TerminalNode

	// IsMap_object_stmtContext differentiates from other interfaces.
	IsMap_object_stmtContext()
}

type Map_object_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMap_object_stmtContext() *Map_object_stmtContext {
	var p = new(Map_object_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_map_object_stmt
	return p
}

func InitEmptyMap_object_stmtContext(p *Map_object_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_map_object_stmt
}

func (*Map_object_stmtContext) IsMap_object_stmtContext() {}

func NewMap_object_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Map_object_stmtContext {
	var p = new(Map_object_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_map_object_stmt

	return p
}

func (s *Map_object_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Map_object_stmtContext) T_MAP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAP, 0)
}

func (s *Map_object_stmtContext) T_OBJECT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OBJECT, 0)
}

func (s *Map_object_stmtContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Map_object_stmtContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Map_object_stmtContext) T_TO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TO, 0)
}

func (s *Map_object_stmtContext) T_AT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AT, 0)
}

func (s *Map_object_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Map_object_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Map_object_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterMap_object_stmt(s)
	}
}

func (s *Map_object_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitMap_object_stmt(s)
	}
}




func (p *HplsqlParser) Map_object_stmt() (localctx IMap_object_stmtContext) {
	localctx = NewMap_object_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, HplsqlParserRULE_map_object_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1901)
		p.Match(HplsqlParserT_MAP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1902)
		p.Match(HplsqlParserT_OBJECT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1903)
		p.Ident()
	}
	p.SetState(1906)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 206, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1904)
			p.Match(HplsqlParserT_TO)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1905)
			p.Ident()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(1910)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 207, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1908)
			p.Match(HplsqlParserT_AT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1909)
			p.Ident()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOpen_stmtContext is an interface to support dynamic dispatch.
type IOpen_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN() antlr.TerminalNode
	Ident() IIdentContext
	T_FOR() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	Expr() IExprContext

	// IsOpen_stmtContext differentiates from other interfaces.
	IsOpen_stmtContext()
}

type Open_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpen_stmtContext() *Open_stmtContext {
	var p = new(Open_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_open_stmt
	return p
}

func InitEmptyOpen_stmtContext(p *Open_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_open_stmt
}

func (*Open_stmtContext) IsOpen_stmtContext() {}

func NewOpen_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Open_stmtContext {
	var p = new(Open_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_open_stmt

	return p
}

func (s *Open_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Open_stmtContext) T_OPEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN, 0)
}

func (s *Open_stmtContext) Ident() IIdentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Open_stmtContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *Open_stmtContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Open_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Open_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Open_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Open_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterOpen_stmt(s)
	}
}

func (s *Open_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitOpen_stmt(s)
	}
}




func (p *HplsqlParser) Open_stmt() (localctx IOpen_stmtContext) {
	localctx = NewOpen_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, HplsqlParserRULE_open_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1912)
		p.Match(HplsqlParserT_OPEN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1913)
		p.Ident()
	}
	p.SetState(1919)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 209, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1914)
			p.Match(HplsqlParserT_FOR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1917)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 208, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1915)
				p.Select_stmt()
			}


		case 2:
			{
				p.SetState(1916)
				p.expr(0)
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFetch_stmtContext is an interface to support dynamic dispatch.
type IFetch_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_FETCH() antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	T_INTO() antlr.TerminalNode
	T_FROM() antlr.TerminalNode
	Bulk_collect_clause() IBulk_collect_clauseContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	Fetch_limit() IFetch_limitContext

	// IsFetch_stmtContext differentiates from other interfaces.
	IsFetch_stmtContext()
}

type Fetch_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFetch_stmtContext() *Fetch_stmtContext {
	var p = new(Fetch_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_fetch_stmt
	return p
}

func InitEmptyFetch_stmtContext(p *Fetch_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_fetch_stmt
}

func (*Fetch_stmtContext) IsFetch_stmtContext() {}

func NewFetch_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fetch_stmtContext {
	var p = new(Fetch_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_fetch_stmt

	return p
}

func (s *Fetch_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Fetch_stmtContext) T_FETCH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FETCH, 0)
}

func (s *Fetch_stmtContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Fetch_stmtContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Fetch_stmtContext) T_INTO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTO, 0)
}

func (s *Fetch_stmtContext) T_FROM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FROM, 0)
}

func (s *Fetch_stmtContext) Bulk_collect_clause() IBulk_collect_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBulk_collect_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBulk_collect_clauseContext)
}

func (s *Fetch_stmtContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Fetch_stmtContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Fetch_stmtContext) Fetch_limit() IFetch_limitContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFetch_limitContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFetch_limitContext)
}

func (s *Fetch_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fetch_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Fetch_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFetch_stmt(s)
	}
}

func (s *Fetch_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFetch_stmt(s)
	}
}




func (p *HplsqlParser) Fetch_stmt() (localctx IFetch_stmtContext) {
	localctx = NewFetch_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, HplsqlParserRULE_fetch_stmt)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1921)
		p.Match(HplsqlParserT_FETCH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1923)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 210, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1922)
			p.Match(HplsqlParserT_FROM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(1925)
		p.Ident()
	}
	p.SetState(1927)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_BULK {
		{
			p.SetState(1926)
			p.Bulk_collect_clause()
		}

	}
	{
		p.SetState(1929)
		p.Match(HplsqlParserT_INTO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1930)
		p.Ident()
	}
	p.SetState(1935)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 212, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1931)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1932)
				p.Ident()
			}


		}
		p.SetState(1937)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 212, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1939)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 213, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1938)
			p.Fetch_limit()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFetch_limitContext is an interface to support dynamic dispatch.
type IFetch_limitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_LIMIT() antlr.TerminalNode
	Expr() IExprContext

	// IsFetch_limitContext differentiates from other interfaces.
	IsFetch_limitContext()
}

type Fetch_limitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFetch_limitContext() *Fetch_limitContext {
	var p = new(Fetch_limitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_fetch_limit
	return p
}

func InitEmptyFetch_limitContext(p *Fetch_limitContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_fetch_limit
}

func (*Fetch_limitContext) IsFetch_limitContext() {}

func NewFetch_limitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fetch_limitContext {
	var p = new(Fetch_limitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_fetch_limit

	return p
}

func (s *Fetch_limitContext) GetParser() antlr.Parser { return s.parser }

func (s *Fetch_limitContext) T_LIMIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LIMIT, 0)
}

func (s *Fetch_limitContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Fetch_limitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fetch_limitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Fetch_limitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFetch_limit(s)
	}
}

func (s *Fetch_limitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFetch_limit(s)
	}
}




func (p *HplsqlParser) Fetch_limit() (localctx IFetch_limitContext) {
	localctx = NewFetch_limitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, HplsqlParserRULE_fetch_limit)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1941)
		p.Match(HplsqlParserT_LIMIT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1942)
		p.expr(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICollect_stats_stmtContext is an interface to support dynamic dispatch.
type ICollect_stats_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_COLLECT() antlr.TerminalNode
	T_ON() antlr.TerminalNode
	Table_name() ITable_nameContext
	T_STATISTICS() antlr.TerminalNode
	T_STATS() antlr.TerminalNode
	Collect_stats_clause() ICollect_stats_clauseContext

	// IsCollect_stats_stmtContext differentiates from other interfaces.
	IsCollect_stats_stmtContext()
}

type Collect_stats_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollect_stats_stmtContext() *Collect_stats_stmtContext {
	var p = new(Collect_stats_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_collect_stats_stmt
	return p
}

func InitEmptyCollect_stats_stmtContext(p *Collect_stats_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_collect_stats_stmt
}

func (*Collect_stats_stmtContext) IsCollect_stats_stmtContext() {}

func NewCollect_stats_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collect_stats_stmtContext {
	var p = new(Collect_stats_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_collect_stats_stmt

	return p
}

func (s *Collect_stats_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Collect_stats_stmtContext) T_COLLECT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLLECT, 0)
}

func (s *Collect_stats_stmtContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *Collect_stats_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Collect_stats_stmtContext) T_STATISTICS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STATISTICS, 0)
}

func (s *Collect_stats_stmtContext) T_STATS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STATS, 0)
}

func (s *Collect_stats_stmtContext) Collect_stats_clause() ICollect_stats_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollect_stats_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollect_stats_clauseContext)
}

func (s *Collect_stats_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collect_stats_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Collect_stats_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCollect_stats_stmt(s)
	}
}

func (s *Collect_stats_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCollect_stats_stmt(s)
	}
}




func (p *HplsqlParser) Collect_stats_stmt() (localctx ICollect_stats_stmtContext) {
	localctx = NewCollect_stats_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, HplsqlParserRULE_collect_stats_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1944)
		p.Match(HplsqlParserT_COLLECT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1945)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_STATS || _la == HplsqlParserT_STATISTICS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1946)
		p.Match(HplsqlParserT_ON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1947)
		p.Table_name()
	}
	p.SetState(1949)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 214, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1948)
			p.Collect_stats_clause()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICollect_stats_clauseContext is an interface to support dynamic dispatch.
type ICollect_stats_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_COLUMN() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	AllQident() []IQidentContext
	Qident(i int) IQidentContext
	T_CLOSE_P() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsCollect_stats_clauseContext differentiates from other interfaces.
	IsCollect_stats_clauseContext()
}

type Collect_stats_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollect_stats_clauseContext() *Collect_stats_clauseContext {
	var p = new(Collect_stats_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_collect_stats_clause
	return p
}

func InitEmptyCollect_stats_clauseContext(p *Collect_stats_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_collect_stats_clause
}

func (*Collect_stats_clauseContext) IsCollect_stats_clauseContext() {}

func NewCollect_stats_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Collect_stats_clauseContext {
	var p = new(Collect_stats_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_collect_stats_clause

	return p
}

func (s *Collect_stats_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Collect_stats_clauseContext) T_COLUMN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLUMN, 0)
}

func (s *Collect_stats_clauseContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Collect_stats_clauseContext) AllQident() []IQidentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQidentContext); ok {
			len++
		}
	}

	tst := make([]IQidentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQidentContext); ok {
			tst[i] = t.(IQidentContext)
			i++
		}
	}

	return tst
}

func (s *Collect_stats_clauseContext) Qident(i int) IQidentContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Collect_stats_clauseContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Collect_stats_clauseContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Collect_stats_clauseContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Collect_stats_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Collect_stats_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Collect_stats_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCollect_stats_clause(s)
	}
}

func (s *Collect_stats_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCollect_stats_clause(s)
	}
}




func (p *HplsqlParser) Collect_stats_clause() (localctx ICollect_stats_clauseContext) {
	localctx = NewCollect_stats_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, HplsqlParserRULE_collect_stats_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1951)
		p.Match(HplsqlParserT_COLUMN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1952)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1953)
		p.Qident()
	}
	p.SetState(1958)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(1954)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1955)
			p.Qident()
		}


		p.SetState(1960)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1961)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IClose_stmtContext is an interface to support dynamic dispatch.
type IClose_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_CLOSE() antlr.TerminalNode
	L_ID() antlr.TerminalNode

	// IsClose_stmtContext differentiates from other interfaces.
	IsClose_stmtContext()
}

type Close_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClose_stmtContext() *Close_stmtContext {
	var p = new(Close_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_close_stmt
	return p
}

func InitEmptyClose_stmtContext(p *Close_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_close_stmt
}

func (*Close_stmtContext) IsClose_stmtContext() {}

func NewClose_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Close_stmtContext {
	var p = new(Close_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_close_stmt

	return p
}

func (s *Close_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Close_stmtContext) T_CLOSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE, 0)
}

func (s *Close_stmtContext) L_ID() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, 0)
}

func (s *Close_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Close_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Close_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterClose_stmt(s)
	}
}

func (s *Close_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitClose_stmt(s)
	}
}




func (p *HplsqlParser) Close_stmt() (localctx IClose_stmtContext) {
	localctx = NewClose_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, HplsqlParserRULE_close_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1963)
		p.Match(HplsqlParserT_CLOSE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1964)
		p.Match(HplsqlParserL_ID)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICmp_stmtContext is an interface to support dynamic dispatch.
type ICmp_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_CMP() antlr.TerminalNode
	AllCmp_source() []ICmp_sourceContext
	Cmp_source(i int) ICmp_sourceContext
	T_COMMA() antlr.TerminalNode
	T_ROW_COUNT() antlr.TerminalNode
	T_SUM() antlr.TerminalNode

	// IsCmp_stmtContext differentiates from other interfaces.
	IsCmp_stmtContext()
}

type Cmp_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmp_stmtContext() *Cmp_stmtContext {
	var p = new(Cmp_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cmp_stmt
	return p
}

func InitEmptyCmp_stmtContext(p *Cmp_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cmp_stmt
}

func (*Cmp_stmtContext) IsCmp_stmtContext() {}

func NewCmp_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmp_stmtContext {
	var p = new(Cmp_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_cmp_stmt

	return p
}

func (s *Cmp_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmp_stmtContext) T_CMP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CMP, 0)
}

func (s *Cmp_stmtContext) AllCmp_source() []ICmp_sourceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICmp_sourceContext); ok {
			len++
		}
	}

	tst := make([]ICmp_sourceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICmp_sourceContext); ok {
			tst[i] = t.(ICmp_sourceContext)
			i++
		}
	}

	return tst
}

func (s *Cmp_stmtContext) Cmp_source(i int) ICmp_sourceContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICmp_sourceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICmp_sourceContext)
}

func (s *Cmp_stmtContext) T_COMMA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, 0)
}

func (s *Cmp_stmtContext) T_ROW_COUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROW_COUNT, 0)
}

func (s *Cmp_stmtContext) T_SUM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUM, 0)
}

func (s *Cmp_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmp_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Cmp_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCmp_stmt(s)
	}
}

func (s *Cmp_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCmp_stmt(s)
	}
}




func (p *HplsqlParser) Cmp_stmt() (localctx ICmp_stmtContext) {
	localctx = NewCmp_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, HplsqlParserRULE_cmp_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1966)
		p.Match(HplsqlParserT_CMP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1967)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_ROW_COUNT || _la == HplsqlParserT_SUM) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1968)
		p.Cmp_source()
	}
	{
		p.SetState(1969)
		p.Match(HplsqlParserT_COMMA)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1970)
		p.Cmp_source()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICmp_sourceContext is an interface to support dynamic dispatch.
type ICmp_sourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Table_name() ITable_nameContext
	T_OPEN_P() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	T_CLOSE_P() antlr.TerminalNode
	T_AT() antlr.TerminalNode
	Qident() IQidentContext
	Where_clause() IWhere_clauseContext

	// IsCmp_sourceContext differentiates from other interfaces.
	IsCmp_sourceContext()
}

type Cmp_sourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCmp_sourceContext() *Cmp_sourceContext {
	var p = new(Cmp_sourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cmp_source
	return p
}

func InitEmptyCmp_sourceContext(p *Cmp_sourceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cmp_source
}

func (*Cmp_sourceContext) IsCmp_sourceContext() {}

func NewCmp_sourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cmp_sourceContext {
	var p = new(Cmp_sourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_cmp_source

	return p
}

func (s *Cmp_sourceContext) GetParser() antlr.Parser { return s.parser }

func (s *Cmp_sourceContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Cmp_sourceContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Cmp_sourceContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Cmp_sourceContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Cmp_sourceContext) T_AT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AT, 0)
}

func (s *Cmp_sourceContext) Qident() IQidentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Cmp_sourceContext) Where_clause() IWhere_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhere_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhere_clauseContext)
}

func (s *Cmp_sourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cmp_sourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Cmp_sourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCmp_source(s)
	}
}

func (s *Cmp_sourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCmp_source(s)
	}
}




func (p *HplsqlParser) Cmp_source() (localctx ICmp_sourceContext) {
	localctx = NewCmp_sourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, HplsqlParserRULE_cmp_source)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1980)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_SUB, HplsqlParserL_ID:
		{
			p.SetState(1972)
			p.Table_name()
		}
		p.SetState(1974)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 216, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1973)
				p.Where_clause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case HplsqlParserT_OPEN_P:
		{
			p.SetState(1976)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1977)
			p.Select_stmt()
		}
		{
			p.SetState(1978)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1984)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 218, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1982)
			p.Match(HplsqlParserT_AT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1983)
			p.Qident()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICopy_from_local_stmtContext is an interface to support dynamic dispatch.
type ICopy_from_local_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_COPY() antlr.TerminalNode
	T_FROM() antlr.TerminalNode
	T_LOCAL() antlr.TerminalNode
	AllCopy_source() []ICopy_sourceContext
	Copy_source(i int) ICopy_sourceContext
	T_TO() antlr.TerminalNode
	Copy_target() ICopy_targetContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	AllCopy_file_option() []ICopy_file_optionContext
	Copy_file_option(i int) ICopy_file_optionContext

	// IsCopy_from_local_stmtContext differentiates from other interfaces.
	IsCopy_from_local_stmtContext()
}

type Copy_from_local_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCopy_from_local_stmtContext() *Copy_from_local_stmtContext {
	var p = new(Copy_from_local_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_from_local_stmt
	return p
}

func InitEmptyCopy_from_local_stmtContext(p *Copy_from_local_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_from_local_stmt
}

func (*Copy_from_local_stmtContext) IsCopy_from_local_stmtContext() {}

func NewCopy_from_local_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Copy_from_local_stmtContext {
	var p = new(Copy_from_local_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_copy_from_local_stmt

	return p
}

func (s *Copy_from_local_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Copy_from_local_stmtContext) T_COPY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COPY, 0)
}

func (s *Copy_from_local_stmtContext) T_FROM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FROM, 0)
}

func (s *Copy_from_local_stmtContext) T_LOCAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCAL, 0)
}

func (s *Copy_from_local_stmtContext) AllCopy_source() []ICopy_sourceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICopy_sourceContext); ok {
			len++
		}
	}

	tst := make([]ICopy_sourceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICopy_sourceContext); ok {
			tst[i] = t.(ICopy_sourceContext)
			i++
		}
	}

	return tst
}

func (s *Copy_from_local_stmtContext) Copy_source(i int) ICopy_sourceContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopy_sourceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopy_sourceContext)
}

func (s *Copy_from_local_stmtContext) T_TO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TO, 0)
}

func (s *Copy_from_local_stmtContext) Copy_target() ICopy_targetContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopy_targetContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopy_targetContext)
}

func (s *Copy_from_local_stmtContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Copy_from_local_stmtContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Copy_from_local_stmtContext) AllCopy_file_option() []ICopy_file_optionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICopy_file_optionContext); ok {
			len++
		}
	}

	tst := make([]ICopy_file_optionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICopy_file_optionContext); ok {
			tst[i] = t.(ICopy_file_optionContext)
			i++
		}
	}

	return tst
}

func (s *Copy_from_local_stmtContext) Copy_file_option(i int) ICopy_file_optionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopy_file_optionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopy_file_optionContext)
}

func (s *Copy_from_local_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Copy_from_local_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Copy_from_local_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCopy_from_local_stmt(s)
	}
}

func (s *Copy_from_local_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCopy_from_local_stmt(s)
	}
}




func (p *HplsqlParser) Copy_from_local_stmt() (localctx ICopy_from_local_stmtContext) {
	localctx = NewCopy_from_local_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, HplsqlParserRULE_copy_from_local_stmt)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1986)
		p.Match(HplsqlParserT_COPY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1987)
		p.Match(HplsqlParserT_FROM)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1988)
		p.Match(HplsqlParserT_LOCAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1989)
		p.Copy_source()
	}
	p.SetState(1994)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(1990)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1991)
			p.Copy_source()
		}


		p.SetState(1996)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1997)
		p.Match(HplsqlParserT_TO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1998)
		p.Copy_target()
	}
	p.SetState(2002)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 220, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1999)
				p.Copy_file_option()
			}


		}
		p.SetState(2004)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 220, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICopy_stmtContext is an interface to support dynamic dispatch.
type ICopy_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_COPY() antlr.TerminalNode
	T_TO() antlr.TerminalNode
	Copy_target() ICopy_targetContext
	Table_name() ITable_nameContext
	T_OPEN_P() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	T_CLOSE_P() antlr.TerminalNode
	T_HDFS() antlr.TerminalNode
	AllCopy_option() []ICopy_optionContext
	Copy_option(i int) ICopy_optionContext

	// IsCopy_stmtContext differentiates from other interfaces.
	IsCopy_stmtContext()
}

type Copy_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCopy_stmtContext() *Copy_stmtContext {
	var p = new(Copy_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_stmt
	return p
}

func InitEmptyCopy_stmtContext(p *Copy_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_stmt
}

func (*Copy_stmtContext) IsCopy_stmtContext() {}

func NewCopy_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Copy_stmtContext {
	var p = new(Copy_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_copy_stmt

	return p
}

func (s *Copy_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Copy_stmtContext) T_COPY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COPY, 0)
}

func (s *Copy_stmtContext) T_TO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TO, 0)
}

func (s *Copy_stmtContext) Copy_target() ICopy_targetContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopy_targetContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopy_targetContext)
}

func (s *Copy_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Copy_stmtContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Copy_stmtContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Copy_stmtContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Copy_stmtContext) T_HDFS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HDFS, 0)
}

func (s *Copy_stmtContext) AllCopy_option() []ICopy_optionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICopy_optionContext); ok {
			len++
		}
	}

	tst := make([]ICopy_optionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICopy_optionContext); ok {
			tst[i] = t.(ICopy_optionContext)
			i++
		}
	}

	return tst
}

func (s *Copy_stmtContext) Copy_option(i int) ICopy_optionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICopy_optionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICopy_optionContext)
}

func (s *Copy_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Copy_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Copy_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCopy_stmt(s)
	}
}

func (s *Copy_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCopy_stmt(s)
	}
}




func (p *HplsqlParser) Copy_stmt() (localctx ICopy_stmtContext) {
	localctx = NewCopy_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, HplsqlParserRULE_copy_stmt)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2005)
		p.Match(HplsqlParserT_COPY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2011)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_SUB, HplsqlParserL_ID:
		{
			p.SetState(2006)
			p.Table_name()
		}


	case HplsqlParserT_OPEN_P:
		{
			p.SetState(2007)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2008)
			p.Select_stmt()
		}
		{
			p.SetState(2009)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(2013)
		p.Match(HplsqlParserT_TO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2015)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 222, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2014)
			p.Match(HplsqlParserT_HDFS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(2017)
		p.Copy_target()
	}
	p.SetState(2021)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 223, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2018)
				p.Copy_option()
			}


		}
		p.SetState(2023)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 223, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICopy_sourceContext is an interface to support dynamic dispatch.
type ICopy_sourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	File_name() IFile_nameContext
	Expr() IExprContext

	// IsCopy_sourceContext differentiates from other interfaces.
	IsCopy_sourceContext()
}

type Copy_sourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCopy_sourceContext() *Copy_sourceContext {
	var p = new(Copy_sourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_source
	return p
}

func InitEmptyCopy_sourceContext(p *Copy_sourceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_source
}

func (*Copy_sourceContext) IsCopy_sourceContext() {}

func NewCopy_sourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Copy_sourceContext {
	var p = new(Copy_sourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_copy_source

	return p
}

func (s *Copy_sourceContext) GetParser() antlr.Parser { return s.parser }

func (s *Copy_sourceContext) File_name() IFile_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFile_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFile_nameContext)
}

func (s *Copy_sourceContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Copy_sourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Copy_sourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Copy_sourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCopy_source(s)
	}
}

func (s *Copy_sourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCopy_source(s)
	}
}




func (p *HplsqlParser) Copy_source() (localctx ICopy_sourceContext) {
	localctx = NewCopy_sourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, HplsqlParserRULE_copy_source)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(2026)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 224, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2024)
			p.File_name()
		}


	case 2:
		{
			p.SetState(2025)
			p.expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICopy_targetContext is an interface to support dynamic dispatch.
type ICopy_targetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	File_name() IFile_nameContext
	Expr() IExprContext

	// IsCopy_targetContext differentiates from other interfaces.
	IsCopy_targetContext()
}

type Copy_targetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCopy_targetContext() *Copy_targetContext {
	var p = new(Copy_targetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_target
	return p
}

func InitEmptyCopy_targetContext(p *Copy_targetContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_target
}

func (*Copy_targetContext) IsCopy_targetContext() {}

func NewCopy_targetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Copy_targetContext {
	var p = new(Copy_targetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_copy_target

	return p
}

func (s *Copy_targetContext) GetParser() antlr.Parser { return s.parser }

func (s *Copy_targetContext) File_name() IFile_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFile_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFile_nameContext)
}

func (s *Copy_targetContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Copy_targetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Copy_targetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Copy_targetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCopy_target(s)
	}
}

func (s *Copy_targetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCopy_target(s)
	}
}




func (p *HplsqlParser) Copy_target() (localctx ICopy_targetContext) {
	localctx = NewCopy_targetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, HplsqlParserRULE_copy_target)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(2030)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 225, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2028)
			p.File_name()
		}


	case 2:
		{
			p.SetState(2029)
			p.expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICopy_optionContext is an interface to support dynamic dispatch.
type ICopy_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_AT() antlr.TerminalNode
	Qident() IQidentContext
	T_BATCHSIZE() antlr.TerminalNode
	Expr() IExprContext
	T_DELIMITER() antlr.TerminalNode
	T_SQLINSERT() antlr.TerminalNode

	// IsCopy_optionContext differentiates from other interfaces.
	IsCopy_optionContext()
}

type Copy_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCopy_optionContext() *Copy_optionContext {
	var p = new(Copy_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_option
	return p
}

func InitEmptyCopy_optionContext(p *Copy_optionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_option
}

func (*Copy_optionContext) IsCopy_optionContext() {}

func NewCopy_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Copy_optionContext {
	var p = new(Copy_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_copy_option

	return p
}

func (s *Copy_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Copy_optionContext) T_AT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AT, 0)
}

func (s *Copy_optionContext) Qident() IQidentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Copy_optionContext) T_BATCHSIZE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BATCHSIZE, 0)
}

func (s *Copy_optionContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Copy_optionContext) T_DELIMITER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DELIMITER, 0)
}

func (s *Copy_optionContext) T_SQLINSERT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SQLINSERT, 0)
}

func (s *Copy_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Copy_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Copy_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCopy_option(s)
	}
}

func (s *Copy_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCopy_option(s)
	}
}




func (p *HplsqlParser) Copy_option() (localctx ICopy_optionContext) {
	localctx = NewCopy_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, HplsqlParserRULE_copy_option)
	p.SetState(2040)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_AT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2032)
			p.Match(HplsqlParserT_AT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2033)
			p.Qident()
		}


	case HplsqlParserT_BATCHSIZE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2034)
			p.Match(HplsqlParserT_BATCHSIZE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2035)
			p.expr(0)
		}


	case HplsqlParserT_DELIMITER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2036)
			p.Match(HplsqlParserT_DELIMITER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2037)
			p.expr(0)
		}


	case HplsqlParserT_SQLINSERT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2038)
			p.Match(HplsqlParserT_SQLINSERT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2039)
			p.Qident()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICopy_file_optionContext is an interface to support dynamic dispatch.
type ICopy_file_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_DELETE() antlr.TerminalNode
	T_IGNORE() antlr.TerminalNode
	T_OVERWRITE() antlr.TerminalNode

	// IsCopy_file_optionContext differentiates from other interfaces.
	IsCopy_file_optionContext()
}

type Copy_file_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCopy_file_optionContext() *Copy_file_optionContext {
	var p = new(Copy_file_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_file_option
	return p
}

func InitEmptyCopy_file_optionContext(p *Copy_file_optionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_copy_file_option
}

func (*Copy_file_optionContext) IsCopy_file_optionContext() {}

func NewCopy_file_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Copy_file_optionContext {
	var p = new(Copy_file_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_copy_file_option

	return p
}

func (s *Copy_file_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Copy_file_optionContext) T_DELETE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DELETE, 0)
}

func (s *Copy_file_optionContext) T_IGNORE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IGNORE, 0)
}

func (s *Copy_file_optionContext) T_OVERWRITE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OVERWRITE, 0)
}

func (s *Copy_file_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Copy_file_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Copy_file_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCopy_file_option(s)
	}
}

func (s *Copy_file_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCopy_file_option(s)
	}
}




func (p *HplsqlParser) Copy_file_option() (localctx ICopy_file_optionContext) {
	localctx = NewCopy_file_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, HplsqlParserRULE_copy_file_option)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2042)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_DELETE || _la == HplsqlParserT_IGNORE || _la == HplsqlParserT_OVERWRITE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICommit_stmtContext is an interface to support dynamic dispatch.
type ICommit_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_COMMIT() antlr.TerminalNode
	T_WORK() antlr.TerminalNode

	// IsCommit_stmtContext differentiates from other interfaces.
	IsCommit_stmtContext()
}

type Commit_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommit_stmtContext() *Commit_stmtContext {
	var p = new(Commit_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_commit_stmt
	return p
}

func InitEmptyCommit_stmtContext(p *Commit_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_commit_stmt
}

func (*Commit_stmtContext) IsCommit_stmtContext() {}

func NewCommit_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Commit_stmtContext {
	var p = new(Commit_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_commit_stmt

	return p
}

func (s *Commit_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Commit_stmtContext) T_COMMIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMIT, 0)
}

func (s *Commit_stmtContext) T_WORK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WORK, 0)
}

func (s *Commit_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Commit_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Commit_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCommit_stmt(s)
	}
}

func (s *Commit_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCommit_stmt(s)
	}
}




func (p *HplsqlParser) Commit_stmt() (localctx ICommit_stmtContext) {
	localctx = NewCommit_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, HplsqlParserRULE_commit_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2044)
		p.Match(HplsqlParserT_COMMIT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2046)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 227, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2045)
			p.Match(HplsqlParserT_WORK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_index_stmtContext is an interface to support dynamic dispatch.
type ICreate_index_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_CREATE() antlr.TerminalNode
	T_INDEX() antlr.TerminalNode
	Qident() IQidentContext
	T_ON() antlr.TerminalNode
	Table_name() ITable_nameContext
	T_OPEN_P() antlr.TerminalNode
	AllCreate_index_col() []ICreate_index_colContext
	Create_index_col(i int) ICreate_index_colContext
	T_CLOSE_P() antlr.TerminalNode
	T_UNIQUE() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsCreate_index_stmtContext differentiates from other interfaces.
	IsCreate_index_stmtContext()
}

type Create_index_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_index_stmtContext() *Create_index_stmtContext {
	var p = new(Create_index_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_index_stmt
	return p
}

func InitEmptyCreate_index_stmtContext(p *Create_index_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_index_stmt
}

func (*Create_index_stmtContext) IsCreate_index_stmtContext() {}

func NewCreate_index_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_index_stmtContext {
	var p = new(Create_index_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_index_stmt

	return p
}

func (s *Create_index_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_index_stmtContext) T_CREATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATE, 0)
}

func (s *Create_index_stmtContext) T_INDEX() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INDEX, 0)
}

func (s *Create_index_stmtContext) Qident() IQidentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_index_stmtContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *Create_index_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Create_index_stmtContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Create_index_stmtContext) AllCreate_index_col() []ICreate_index_colContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_index_colContext); ok {
			len++
		}
	}

	tst := make([]ICreate_index_colContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_index_colContext); ok {
			tst[i] = t.(ICreate_index_colContext)
			i++
		}
	}

	return tst
}

func (s *Create_index_stmtContext) Create_index_col(i int) ICreate_index_colContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_index_colContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_index_colContext)
}

func (s *Create_index_stmtContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Create_index_stmtContext) T_UNIQUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UNIQUE, 0)
}

func (s *Create_index_stmtContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Create_index_stmtContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Create_index_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_index_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_index_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_index_stmt(s)
	}
}

func (s *Create_index_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_index_stmt(s)
	}
}




func (p *HplsqlParser) Create_index_stmt() (localctx ICreate_index_stmtContext) {
	localctx = NewCreate_index_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, HplsqlParserRULE_create_index_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2048)
		p.Match(HplsqlParserT_CREATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2050)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_UNIQUE {
		{
			p.SetState(2049)
			p.Match(HplsqlParserT_UNIQUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(2052)
		p.Match(HplsqlParserT_INDEX)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2053)
		p.Qident()
	}
	{
		p.SetState(2054)
		p.Match(HplsqlParserT_ON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2055)
		p.Table_name()
	}
	{
		p.SetState(2056)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2057)
		p.Create_index_col()
	}
	p.SetState(2062)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(2058)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2059)
			p.Create_index_col()
		}


		p.SetState(2064)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2065)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICreate_index_colContext is an interface to support dynamic dispatch.
type ICreate_index_colContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Qident() IQidentContext
	T_ASC() antlr.TerminalNode
	T_DESC() antlr.TerminalNode

	// IsCreate_index_colContext differentiates from other interfaces.
	IsCreate_index_colContext()
}

type Create_index_colContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_index_colContext() *Create_index_colContext {
	var p = new(Create_index_colContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_index_col
	return p
}

func InitEmptyCreate_index_colContext(p *Create_index_colContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_create_index_col
}

func (*Create_index_colContext) IsCreate_index_colContext() {}

func NewCreate_index_colContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_index_colContext {
	var p = new(Create_index_colContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_create_index_col

	return p
}

func (s *Create_index_colContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_index_colContext) Qident() IQidentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Create_index_colContext) T_ASC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ASC, 0)
}

func (s *Create_index_colContext) T_DESC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DESC, 0)
}

func (s *Create_index_colContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_index_colContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Create_index_colContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCreate_index_col(s)
	}
}

func (s *Create_index_colContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCreate_index_col(s)
	}
}




func (p *HplsqlParser) Create_index_col() (localctx ICreate_index_colContext) {
	localctx = NewCreate_index_colContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, HplsqlParserRULE_create_index_col)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2067)
		p.Qident()
	}
	p.SetState(2069)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC {
		{
			p.SetState(2068)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIndex_storage_clauseContext is an interface to support dynamic dispatch.
type IIndex_storage_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Index_mssql_storage_clause() IIndex_mssql_storage_clauseContext

	// IsIndex_storage_clauseContext differentiates from other interfaces.
	IsIndex_storage_clauseContext()
}

type Index_storage_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_storage_clauseContext() *Index_storage_clauseContext {
	var p = new(Index_storage_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_index_storage_clause
	return p
}

func InitEmptyIndex_storage_clauseContext(p *Index_storage_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_index_storage_clause
}

func (*Index_storage_clauseContext) IsIndex_storage_clauseContext() {}

func NewIndex_storage_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_storage_clauseContext {
	var p = new(Index_storage_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_index_storage_clause

	return p
}

func (s *Index_storage_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_storage_clauseContext) Index_mssql_storage_clause() IIndex_mssql_storage_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndex_mssql_storage_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndex_mssql_storage_clauseContext)
}

func (s *Index_storage_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_storage_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Index_storage_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterIndex_storage_clause(s)
	}
}

func (s *Index_storage_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitIndex_storage_clause(s)
	}
}




func (p *HplsqlParser) Index_storage_clause() (localctx IIndex_storage_clauseContext) {
	localctx = NewIndex_storage_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, HplsqlParserRULE_index_storage_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2071)
		p.Index_mssql_storage_clause()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIndex_mssql_storage_clauseContext is an interface to support dynamic dispatch.
type IIndex_mssql_storage_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_WITH() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	AllQident() []IQidentContext
	Qident(i int) IQidentContext
	AllT_EQUAL() []antlr.TerminalNode
	T_EQUAL(i int) antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	AllCreate_table_options_mssql_item() []ICreate_table_options_mssql_itemContext
	Create_table_options_mssql_item(i int) ICreate_table_options_mssql_itemContext

	// IsIndex_mssql_storage_clauseContext differentiates from other interfaces.
	IsIndex_mssql_storage_clauseContext()
}

type Index_mssql_storage_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndex_mssql_storage_clauseContext() *Index_mssql_storage_clauseContext {
	var p = new(Index_mssql_storage_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_index_mssql_storage_clause
	return p
}

func InitEmptyIndex_mssql_storage_clauseContext(p *Index_mssql_storage_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_index_mssql_storage_clause
}

func (*Index_mssql_storage_clauseContext) IsIndex_mssql_storage_clauseContext() {}

func NewIndex_mssql_storage_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Index_mssql_storage_clauseContext {
	var p = new(Index_mssql_storage_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_index_mssql_storage_clause

	return p
}

func (s *Index_mssql_storage_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Index_mssql_storage_clauseContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITH, 0)
}

func (s *Index_mssql_storage_clauseContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Index_mssql_storage_clauseContext) AllQident() []IQidentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQidentContext); ok {
			len++
		}
	}

	tst := make([]IQidentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQidentContext); ok {
			tst[i] = t.(IQidentContext)
			i++
		}
	}

	return tst
}

func (s *Index_mssql_storage_clauseContext) Qident(i int) IQidentContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Index_mssql_storage_clauseContext) AllT_EQUAL() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_EQUAL)
}

func (s *Index_mssql_storage_clauseContext) T_EQUAL(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, i)
}

func (s *Index_mssql_storage_clauseContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Index_mssql_storage_clauseContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Index_mssql_storage_clauseContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Index_mssql_storage_clauseContext) AllCreate_table_options_mssql_item() []ICreate_table_options_mssql_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreate_table_options_mssql_itemContext); ok {
			len++
		}
	}

	tst := make([]ICreate_table_options_mssql_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreate_table_options_mssql_itemContext); ok {
			tst[i] = t.(ICreate_table_options_mssql_itemContext)
			i++
		}
	}

	return tst
}

func (s *Index_mssql_storage_clauseContext) Create_table_options_mssql_item(i int) ICreate_table_options_mssql_itemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreate_table_options_mssql_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreate_table_options_mssql_itemContext)
}

func (s *Index_mssql_storage_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Index_mssql_storage_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Index_mssql_storage_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterIndex_mssql_storage_clause(s)
	}
}

func (s *Index_mssql_storage_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitIndex_mssql_storage_clause(s)
	}
}




func (p *HplsqlParser) Index_mssql_storage_clause() (localctx IIndex_mssql_storage_clauseContext) {
	localctx = NewIndex_mssql_storage_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, HplsqlParserRULE_index_mssql_storage_clause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2073)
		p.Match(HplsqlParserT_WITH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2074)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2075)
		p.Qident()
	}
	{
		p.SetState(2076)
		p.Match(HplsqlParserT_EQUAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2077)
		p.Qident()
	}
	p.SetState(2085)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(2078)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2079)
			p.Qident()
		}
		{
			p.SetState(2080)
			p.Match(HplsqlParserT_EQUAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2081)
			p.Qident()
		}


		p.SetState(2087)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2088)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2092)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 232, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2089)
				p.Create_table_options_mssql_item()
			}


		}
		p.SetState(2094)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 232, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPrint_stmtContext is an interface to support dynamic dispatch.
type IPrint_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_PRINT() antlr.TerminalNode
	Expr() IExprContext
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode

	// IsPrint_stmtContext differentiates from other interfaces.
	IsPrint_stmtContext()
}

type Print_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrint_stmtContext() *Print_stmtContext {
	var p = new(Print_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_print_stmt
	return p
}

func InitEmptyPrint_stmtContext(p *Print_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_print_stmt
}

func (*Print_stmtContext) IsPrint_stmtContext() {}

func NewPrint_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Print_stmtContext {
	var p = new(Print_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_print_stmt

	return p
}

func (s *Print_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Print_stmtContext) T_PRINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRINT, 0)
}

func (s *Print_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Print_stmtContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Print_stmtContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Print_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Print_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Print_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterPrint_stmt(s)
	}
}

func (s *Print_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitPrint_stmt(s)
	}
}




func (p *HplsqlParser) Print_stmt() (localctx IPrint_stmtContext) {
	localctx = NewPrint_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, HplsqlParserRULE_print_stmt)
	p.SetState(2102)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 233, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2095)
			p.Match(HplsqlParserT_PRINT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2096)
			p.expr(0)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2097)
			p.Match(HplsqlParserT_PRINT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2098)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2099)
			p.expr(0)
		}
		{
			p.SetState(2100)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQuit_stmtContext is an interface to support dynamic dispatch.
type IQuit_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_QUIT() antlr.TerminalNode
	T_DOT() antlr.TerminalNode
	Expr() IExprContext

	// IsQuit_stmtContext differentiates from other interfaces.
	IsQuit_stmtContext()
}

type Quit_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuit_stmtContext() *Quit_stmtContext {
	var p = new(Quit_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_quit_stmt
	return p
}

func InitEmptyQuit_stmtContext(p *Quit_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_quit_stmt
}

func (*Quit_stmtContext) IsQuit_stmtContext() {}

func NewQuit_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Quit_stmtContext {
	var p = new(Quit_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_quit_stmt

	return p
}

func (s *Quit_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Quit_stmtContext) T_QUIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_QUIT, 0)
}

func (s *Quit_stmtContext) T_DOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DOT, 0)
}

func (s *Quit_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Quit_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Quit_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Quit_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterQuit_stmt(s)
	}
}

func (s *Quit_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitQuit_stmt(s)
	}
}




func (p *HplsqlParser) Quit_stmt() (localctx IQuit_stmtContext) {
	localctx = NewQuit_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, HplsqlParserRULE_quit_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2105)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_DOT {
		{
			p.SetState(2104)
			p.Match(HplsqlParserT_DOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(2107)
		p.Match(HplsqlParserT_QUIT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2109)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 235, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2108)
			p.expr(0)
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRaise_stmtContext is an interface to support dynamic dispatch.
type IRaise_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_RAISE() antlr.TerminalNode

	// IsRaise_stmtContext differentiates from other interfaces.
	IsRaise_stmtContext()
}

type Raise_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRaise_stmtContext() *Raise_stmtContext {
	var p = new(Raise_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_raise_stmt
	return p
}

func InitEmptyRaise_stmtContext(p *Raise_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_raise_stmt
}

func (*Raise_stmtContext) IsRaise_stmtContext() {}

func NewRaise_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Raise_stmtContext {
	var p = new(Raise_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_raise_stmt

	return p
}

func (s *Raise_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Raise_stmtContext) T_RAISE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RAISE, 0)
}

func (s *Raise_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Raise_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Raise_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterRaise_stmt(s)
	}
}

func (s *Raise_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitRaise_stmt(s)
	}
}




func (p *HplsqlParser) Raise_stmt() (localctx IRaise_stmtContext) {
	localctx = NewRaise_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, HplsqlParserRULE_raise_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2111)
		p.Match(HplsqlParserT_RAISE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IResignal_stmtContext is an interface to support dynamic dispatch.
type IResignal_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_RESIGNAL() antlr.TerminalNode
	T_SQLSTATE() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_VALUE() antlr.TerminalNode
	T_SET() antlr.TerminalNode
	T_MESSAGE_TEXT() antlr.TerminalNode
	T_EQUAL() antlr.TerminalNode

	// IsResignal_stmtContext differentiates from other interfaces.
	IsResignal_stmtContext()
}

type Resignal_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResignal_stmtContext() *Resignal_stmtContext {
	var p = new(Resignal_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_resignal_stmt
	return p
}

func InitEmptyResignal_stmtContext(p *Resignal_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_resignal_stmt
}

func (*Resignal_stmtContext) IsResignal_stmtContext() {}

func NewResignal_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Resignal_stmtContext {
	var p = new(Resignal_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_resignal_stmt

	return p
}

func (s *Resignal_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Resignal_stmtContext) T_RESIGNAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESIGNAL, 0)
}

func (s *Resignal_stmtContext) T_SQLSTATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SQLSTATE, 0)
}

func (s *Resignal_stmtContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Resignal_stmtContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Resignal_stmtContext) T_VALUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VALUE, 0)
}

func (s *Resignal_stmtContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Resignal_stmtContext) T_MESSAGE_TEXT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MESSAGE_TEXT, 0)
}

func (s *Resignal_stmtContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Resignal_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Resignal_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Resignal_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterResignal_stmt(s)
	}
}

func (s *Resignal_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitResignal_stmt(s)
	}
}




func (p *HplsqlParser) Resignal_stmt() (localctx IResignal_stmtContext) {
	localctx = NewResignal_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, HplsqlParserRULE_resignal_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2113)
		p.Match(HplsqlParserT_RESIGNAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2125)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 238, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2114)
			p.Match(HplsqlParserT_SQLSTATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2116)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 236, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2115)
				p.Match(HplsqlParserT_VALUE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(2118)
			p.expr(0)
		}
		p.SetState(2123)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 237, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2119)
				p.Match(HplsqlParserT_SET)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2120)
				p.Match(HplsqlParserT_MESSAGE_TEXT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2121)
				p.Match(HplsqlParserT_EQUAL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2122)
				p.expr(0)
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReturn_stmtContext is an interface to support dynamic dispatch.
type IReturn_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_RETURN() antlr.TerminalNode
	Expr() IExprContext

	// IsReturn_stmtContext differentiates from other interfaces.
	IsReturn_stmtContext()
}

type Return_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturn_stmtContext() *Return_stmtContext {
	var p = new(Return_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_return_stmt
	return p
}

func InitEmptyReturn_stmtContext(p *Return_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_return_stmt
}

func (*Return_stmtContext) IsReturn_stmtContext() {}

func NewReturn_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Return_stmtContext {
	var p = new(Return_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_return_stmt

	return p
}

func (s *Return_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Return_stmtContext) T_RETURN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RETURN, 0)
}

func (s *Return_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Return_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Return_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Return_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterReturn_stmt(s)
	}
}

func (s *Return_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitReturn_stmt(s)
	}
}




func (p *HplsqlParser) Return_stmt() (localctx IReturn_stmtContext) {
	localctx = NewReturn_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, HplsqlParserRULE_return_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2127)
		p.Match(HplsqlParserT_RETURN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2129)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 239, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2128)
			p.expr(0)
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRollback_stmtContext is an interface to support dynamic dispatch.
type IRollback_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ROLLBACK() antlr.TerminalNode
	T_WORK() antlr.TerminalNode

	// IsRollback_stmtContext differentiates from other interfaces.
	IsRollback_stmtContext()
}

type Rollback_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRollback_stmtContext() *Rollback_stmtContext {
	var p = new(Rollback_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_rollback_stmt
	return p
}

func InitEmptyRollback_stmtContext(p *Rollback_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_rollback_stmt
}

func (*Rollback_stmtContext) IsRollback_stmtContext() {}

func NewRollback_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Rollback_stmtContext {
	var p = new(Rollback_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_rollback_stmt

	return p
}

func (s *Rollback_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Rollback_stmtContext) T_ROLLBACK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROLLBACK, 0)
}

func (s *Rollback_stmtContext) T_WORK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WORK, 0)
}

func (s *Rollback_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Rollback_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Rollback_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterRollback_stmt(s)
	}
}

func (s *Rollback_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitRollback_stmt(s)
	}
}




func (p *HplsqlParser) Rollback_stmt() (localctx IRollback_stmtContext) {
	localctx = NewRollback_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, HplsqlParserRULE_rollback_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2131)
		p.Match(HplsqlParserT_ROLLBACK)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2133)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 240, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2132)
			p.Match(HplsqlParserT_WORK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISet_session_optionContext is an interface to support dynamic dispatch.
type ISet_session_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Set_current_schema_option() ISet_current_schema_optionContext
	Set_mssql_session_option() ISet_mssql_session_optionContext
	Set_teradata_session_option() ISet_teradata_session_optionContext

	// IsSet_session_optionContext differentiates from other interfaces.
	IsSet_session_optionContext()
}

type Set_session_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_session_optionContext() *Set_session_optionContext {
	var p = new(Set_session_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_set_session_option
	return p
}

func InitEmptySet_session_optionContext(p *Set_session_optionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_set_session_option
}

func (*Set_session_optionContext) IsSet_session_optionContext() {}

func NewSet_session_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_session_optionContext {
	var p = new(Set_session_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_set_session_option

	return p
}

func (s *Set_session_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_session_optionContext) Set_current_schema_option() ISet_current_schema_optionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_current_schema_optionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_current_schema_optionContext)
}

func (s *Set_session_optionContext) Set_mssql_session_option() ISet_mssql_session_optionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_mssql_session_optionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_mssql_session_optionContext)
}

func (s *Set_session_optionContext) Set_teradata_session_option() ISet_teradata_session_optionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISet_teradata_session_optionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISet_teradata_session_optionContext)
}

func (s *Set_session_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_session_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Set_session_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSet_session_option(s)
	}
}

func (s *Set_session_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSet_session_option(s)
	}
}




func (p *HplsqlParser) Set_session_option() (localctx ISet_session_optionContext) {
	localctx = NewSet_session_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, HplsqlParserRULE_set_session_option)
	p.SetState(2138)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_SCHEMA:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2135)
			p.Set_current_schema_option()
		}


	case HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_NOCOUNT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_XACT_ABORT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2136)
			p.Set_mssql_session_option()
		}


	case HplsqlParserT_QUERY_BAND:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2137)
			p.Set_teradata_session_option()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISet_current_schema_optionContext is an interface to support dynamic dispatch.
type ISet_current_schema_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	T_CURRENT_SCHEMA() antlr.TerminalNode
	T_EQUAL() antlr.TerminalNode
	T_SCHEMA() antlr.TerminalNode
	T_CURRENT() antlr.TerminalNode

	// IsSet_current_schema_optionContext differentiates from other interfaces.
	IsSet_current_schema_optionContext()
}

type Set_current_schema_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_current_schema_optionContext() *Set_current_schema_optionContext {
	var p = new(Set_current_schema_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_set_current_schema_option
	return p
}

func InitEmptySet_current_schema_optionContext(p *Set_current_schema_optionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_set_current_schema_option
}

func (*Set_current_schema_optionContext) IsSet_current_schema_optionContext() {}

func NewSet_current_schema_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_current_schema_optionContext {
	var p = new(Set_current_schema_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_set_current_schema_option

	return p
}

func (s *Set_current_schema_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_current_schema_optionContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Set_current_schema_optionContext) T_CURRENT_SCHEMA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT_SCHEMA, 0)
}

func (s *Set_current_schema_optionContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Set_current_schema_optionContext) T_SCHEMA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SCHEMA, 0)
}

func (s *Set_current_schema_optionContext) T_CURRENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT, 0)
}

func (s *Set_current_schema_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_current_schema_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Set_current_schema_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSet_current_schema_option(s)
	}
}

func (s *Set_current_schema_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSet_current_schema_option(s)
	}
}




func (p *HplsqlParser) Set_current_schema_option() (localctx ISet_current_schema_optionContext) {
	localctx = NewSet_current_schema_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, HplsqlParserRULE_set_current_schema_option)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2145)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_CURRENT, HplsqlParserT_SCHEMA:
		p.SetState(2141)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_CURRENT {
			{
				p.SetState(2140)
				p.Match(HplsqlParserT_CURRENT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2143)
			p.Match(HplsqlParserT_SCHEMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	case HplsqlParserT_CURRENT_SCHEMA:
		{
			p.SetState(2144)
			p.Match(HplsqlParserT_CURRENT_SCHEMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(2148)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_EQUAL {
		{
			p.SetState(2147)
			p.Match(HplsqlParserT_EQUAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(2150)
		p.expr(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISet_mssql_session_optionContext is an interface to support dynamic dispatch.
type ISet_mssql_session_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ANSI_NULLS() antlr.TerminalNode
	T_ANSI_PADDING() antlr.TerminalNode
	T_NOCOUNT() antlr.TerminalNode
	T_QUOTED_IDENTIFIER() antlr.TerminalNode
	T_XACT_ABORT() antlr.TerminalNode
	T_ON() antlr.TerminalNode
	T_OFF() antlr.TerminalNode

	// IsSet_mssql_session_optionContext differentiates from other interfaces.
	IsSet_mssql_session_optionContext()
}

type Set_mssql_session_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_mssql_session_optionContext() *Set_mssql_session_optionContext {
	var p = new(Set_mssql_session_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_set_mssql_session_option
	return p
}

func InitEmptySet_mssql_session_optionContext(p *Set_mssql_session_optionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_set_mssql_session_option
}

func (*Set_mssql_session_optionContext) IsSet_mssql_session_optionContext() {}

func NewSet_mssql_session_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_mssql_session_optionContext {
	var p = new(Set_mssql_session_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_set_mssql_session_option

	return p
}

func (s *Set_mssql_session_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_mssql_session_optionContext) T_ANSI_NULLS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ANSI_NULLS, 0)
}

func (s *Set_mssql_session_optionContext) T_ANSI_PADDING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ANSI_PADDING, 0)
}

func (s *Set_mssql_session_optionContext) T_NOCOUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOCOUNT, 0)
}

func (s *Set_mssql_session_optionContext) T_QUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_QUOTED_IDENTIFIER, 0)
}

func (s *Set_mssql_session_optionContext) T_XACT_ABORT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_XACT_ABORT, 0)
}

func (s *Set_mssql_session_optionContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *Set_mssql_session_optionContext) T_OFF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OFF, 0)
}

func (s *Set_mssql_session_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_mssql_session_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Set_mssql_session_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSet_mssql_session_option(s)
	}
}

func (s *Set_mssql_session_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSet_mssql_session_option(s)
	}
}




func (p *HplsqlParser) Set_mssql_session_option() (localctx ISet_mssql_session_optionContext) {
	localctx = NewSet_mssql_session_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, HplsqlParserRULE_set_mssql_session_option)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2152)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_ANSI_NULLS || _la == HplsqlParserT_ANSI_PADDING || _la == HplsqlParserT_NOCOUNT || _la == HplsqlParserT_QUOTED_IDENTIFIER || _la == HplsqlParserT_XACT_ABORT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2153)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_OFF || _la == HplsqlParserT_ON) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISet_teradata_session_optionContext is an interface to support dynamic dispatch.
type ISet_teradata_session_optionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_QUERY_BAND() antlr.TerminalNode
	T_EQUAL() antlr.TerminalNode
	T_FOR() antlr.TerminalNode
	T_TRANSACTION() antlr.TerminalNode
	T_SESSION() antlr.TerminalNode
	Expr() IExprContext
	T_NONE() antlr.TerminalNode
	T_UPDATE() antlr.TerminalNode

	// IsSet_teradata_session_optionContext differentiates from other interfaces.
	IsSet_teradata_session_optionContext()
}

type Set_teradata_session_optionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_teradata_session_optionContext() *Set_teradata_session_optionContext {
	var p = new(Set_teradata_session_optionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_set_teradata_session_option
	return p
}

func InitEmptySet_teradata_session_optionContext(p *Set_teradata_session_optionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_set_teradata_session_option
}

func (*Set_teradata_session_optionContext) IsSet_teradata_session_optionContext() {}

func NewSet_teradata_session_optionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_teradata_session_optionContext {
	var p = new(Set_teradata_session_optionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_set_teradata_session_option

	return p
}

func (s *Set_teradata_session_optionContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_teradata_session_optionContext) T_QUERY_BAND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_QUERY_BAND, 0)
}

func (s *Set_teradata_session_optionContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Set_teradata_session_optionContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *Set_teradata_session_optionContext) T_TRANSACTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TRANSACTION, 0)
}

func (s *Set_teradata_session_optionContext) T_SESSION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SESSION, 0)
}

func (s *Set_teradata_session_optionContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Set_teradata_session_optionContext) T_NONE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NONE, 0)
}

func (s *Set_teradata_session_optionContext) T_UPDATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UPDATE, 0)
}

func (s *Set_teradata_session_optionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_teradata_session_optionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Set_teradata_session_optionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSet_teradata_session_option(s)
	}
}

func (s *Set_teradata_session_optionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSet_teradata_session_option(s)
	}
}




func (p *HplsqlParser) Set_teradata_session_option() (localctx ISet_teradata_session_optionContext) {
	localctx = NewSet_teradata_session_optionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, HplsqlParserRULE_set_teradata_session_option)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2155)
		p.Match(HplsqlParserT_QUERY_BAND)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2156)
		p.Match(HplsqlParserT_EQUAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2159)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 245, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2157)
			p.expr(0)
		}


	case 2:
		{
			p.SetState(2158)
			p.Match(HplsqlParserT_NONE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(2162)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_UPDATE {
		{
			p.SetState(2161)
			p.Match(HplsqlParserT_UPDATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(2164)
		p.Match(HplsqlParserT_FOR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2165)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_SESSION || _la == HplsqlParserT_TRANSACTION) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISignal_stmtContext is an interface to support dynamic dispatch.
type ISignal_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_SIGNAL() antlr.TerminalNode
	Ident() IIdentContext

	// IsSignal_stmtContext differentiates from other interfaces.
	IsSignal_stmtContext()
}

type Signal_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignal_stmtContext() *Signal_stmtContext {
	var p = new(Signal_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_signal_stmt
	return p
}

func InitEmptySignal_stmtContext(p *Signal_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_signal_stmt
}

func (*Signal_stmtContext) IsSignal_stmtContext() {}

func NewSignal_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Signal_stmtContext {
	var p = new(Signal_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_signal_stmt

	return p
}

func (s *Signal_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Signal_stmtContext) T_SIGNAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SIGNAL, 0)
}

func (s *Signal_stmtContext) Ident() IIdentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Signal_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Signal_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Signal_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSignal_stmt(s)
	}
}

func (s *Signal_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSignal_stmt(s)
	}
}




func (p *HplsqlParser) Signal_stmt() (localctx ISignal_stmtContext) {
	localctx = NewSignal_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, HplsqlParserRULE_signal_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2167)
		p.Match(HplsqlParserT_SIGNAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2168)
		p.Ident()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISummary_stmtContext is an interface to support dynamic dispatch.
type ISummary_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_SUMMARY() antlr.TerminalNode
	T_FOR() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	Table_name() ITable_nameContext
	T_TOP() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	Where_clause() IWhere_clauseContext
	T_LIMIT() antlr.TerminalNode

	// IsSummary_stmtContext differentiates from other interfaces.
	IsSummary_stmtContext()
}

type Summary_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySummary_stmtContext() *Summary_stmtContext {
	var p = new(Summary_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_summary_stmt
	return p
}

func InitEmptySummary_stmtContext(p *Summary_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_summary_stmt
}

func (*Summary_stmtContext) IsSummary_stmtContext() {}

func NewSummary_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Summary_stmtContext {
	var p = new(Summary_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_summary_stmt

	return p
}

func (s *Summary_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Summary_stmtContext) T_SUMMARY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUMMARY, 0)
}

func (s *Summary_stmtContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *Summary_stmtContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Summary_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Summary_stmtContext) T_TOP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TOP, 0)
}

func (s *Summary_stmtContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Summary_stmtContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Summary_stmtContext) Where_clause() IWhere_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhere_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhere_clauseContext)
}

func (s *Summary_stmtContext) T_LIMIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LIMIT, 0)
}

func (s *Summary_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Summary_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Summary_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSummary_stmt(s)
	}
}

func (s *Summary_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSummary_stmt(s)
	}
}




func (p *HplsqlParser) Summary_stmt() (localctx ISummary_stmtContext) {
	localctx = NewSummary_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, HplsqlParserRULE_summary_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2170)
		p.Match(HplsqlParserT_SUMMARY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2173)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_TOP {
		{
			p.SetState(2171)
			p.Match(HplsqlParserT_TOP)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2172)
			p.expr(0)
		}

	}
	{
		p.SetState(2175)
		p.Match(HplsqlParserT_FOR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2185)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 250, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2176)
			p.Select_stmt()
		}


	case 2:
		{
			p.SetState(2177)
			p.Table_name()
		}
		p.SetState(2179)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 248, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2178)
				p.Where_clause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(2183)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 249, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2181)
				p.Match(HplsqlParserT_LIMIT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2182)
				p.expr(0)
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITruncate_stmtContext is an interface to support dynamic dispatch.
type ITruncate_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_TRUNCATE() antlr.TerminalNode
	Table_name() ITable_nameContext
	T_TABLE() antlr.TerminalNode

	// IsTruncate_stmtContext differentiates from other interfaces.
	IsTruncate_stmtContext()
}

type Truncate_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTruncate_stmtContext() *Truncate_stmtContext {
	var p = new(Truncate_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_truncate_stmt
	return p
}

func InitEmptyTruncate_stmtContext(p *Truncate_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_truncate_stmt
}

func (*Truncate_stmtContext) IsTruncate_stmtContext() {}

func NewTruncate_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Truncate_stmtContext {
	var p = new(Truncate_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_truncate_stmt

	return p
}

func (s *Truncate_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Truncate_stmtContext) T_TRUNCATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TRUNCATE, 0)
}

func (s *Truncate_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Truncate_stmtContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLE, 0)
}

func (s *Truncate_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Truncate_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Truncate_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterTruncate_stmt(s)
	}
}

func (s *Truncate_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitTruncate_stmt(s)
	}
}




func (p *HplsqlParser) Truncate_stmt() (localctx ITruncate_stmtContext) {
	localctx = NewTruncate_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, HplsqlParserRULE_truncate_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2187)
		p.Match(HplsqlParserT_TRUNCATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2189)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 251, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2188)
			p.Match(HplsqlParserT_TABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(2191)
		p.Table_name()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUse_stmtContext is an interface to support dynamic dispatch.
type IUse_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_USE() antlr.TerminalNode
	Expr() IExprContext

	// IsUse_stmtContext differentiates from other interfaces.
	IsUse_stmtContext()
}

type Use_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUse_stmtContext() *Use_stmtContext {
	var p = new(Use_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_use_stmt
	return p
}

func InitEmptyUse_stmtContext(p *Use_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_use_stmt
}

func (*Use_stmtContext) IsUse_stmtContext() {}

func NewUse_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Use_stmtContext {
	var p = new(Use_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_use_stmt

	return p
}

func (s *Use_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Use_stmtContext) T_USE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_USE, 0)
}

func (s *Use_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Use_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Use_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Use_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterUse_stmt(s)
	}
}

func (s *Use_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitUse_stmt(s)
	}
}




func (p *HplsqlParser) Use_stmt() (localctx IUse_stmtContext) {
	localctx = NewUse_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, HplsqlParserRULE_use_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2193)
		p.Match(HplsqlParserT_USE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2194)
		p.expr(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IValues_into_stmtContext is an interface to support dynamic dispatch.
type IValues_into_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_VALUES() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_INTO() antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	AllT_OPEN_P() []antlr.TerminalNode
	T_OPEN_P(i int) antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	AllT_CLOSE_P() []antlr.TerminalNode
	T_CLOSE_P(i int) antlr.TerminalNode

	// IsValues_into_stmtContext differentiates from other interfaces.
	IsValues_into_stmtContext()
}

type Values_into_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValues_into_stmtContext() *Values_into_stmtContext {
	var p = new(Values_into_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_values_into_stmt
	return p
}

func InitEmptyValues_into_stmtContext(p *Values_into_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_values_into_stmt
}

func (*Values_into_stmtContext) IsValues_into_stmtContext() {}

func NewValues_into_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Values_into_stmtContext {
	var p = new(Values_into_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_values_into_stmt

	return p
}

func (s *Values_into_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Values_into_stmtContext) T_VALUES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VALUES, 0)
}

func (s *Values_into_stmtContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Values_into_stmtContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Values_into_stmtContext) T_INTO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTO, 0)
}

func (s *Values_into_stmtContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Values_into_stmtContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Values_into_stmtContext) AllT_OPEN_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_OPEN_P)
}

func (s *Values_into_stmtContext) T_OPEN_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, i)
}

func (s *Values_into_stmtContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Values_into_stmtContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Values_into_stmtContext) AllT_CLOSE_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_CLOSE_P)
}

func (s *Values_into_stmtContext) T_CLOSE_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, i)
}

func (s *Values_into_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Values_into_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Values_into_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterValues_into_stmt(s)
	}
}

func (s *Values_into_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitValues_into_stmt(s)
	}
}




func (p *HplsqlParser) Values_into_stmt() (localctx IValues_into_stmtContext) {
	localctx = NewValues_into_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, HplsqlParserRULE_values_into_stmt)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2196)
		p.Match(HplsqlParserT_VALUES)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2198)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 252, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2197)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(2200)
		p.expr(0)
	}
	p.SetState(2205)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(2201)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2202)
			p.expr(0)
		}


		p.SetState(2207)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2209)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_CLOSE_P {
		{
			p.SetState(2208)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(2211)
		p.Match(HplsqlParserT_INTO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2213)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_OPEN_P {
		{
			p.SetState(2212)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(2215)
		p.Ident()
	}
	p.SetState(2220)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 256, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2216)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2217)
				p.Ident()
			}


		}
		p.SetState(2222)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 256, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2224)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 257, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2223)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWhile_stmtContext is an interface to support dynamic dispatch.
type IWhile_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllT_WHILE() []antlr.TerminalNode
	T_WHILE(i int) antlr.TerminalNode
	Bool_expr() IBool_exprContext
	Block() IBlockContext
	T_END() antlr.TerminalNode
	T_DO() antlr.TerminalNode
	AllT_LOOP() []antlr.TerminalNode
	T_LOOP(i int) antlr.TerminalNode
	T_THEN() antlr.TerminalNode
	T_BEGIN() antlr.TerminalNode

	// IsWhile_stmtContext differentiates from other interfaces.
	IsWhile_stmtContext()
}

type While_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhile_stmtContext() *While_stmtContext {
	var p = new(While_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_while_stmt
	return p
}

func InitEmptyWhile_stmtContext(p *While_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_while_stmt
}

func (*While_stmtContext) IsWhile_stmtContext() {}

func NewWhile_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *While_stmtContext {
	var p = new(While_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_while_stmt

	return p
}

func (s *While_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *While_stmtContext) AllT_WHILE() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_WHILE)
}

func (s *While_stmtContext) T_WHILE(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WHILE, i)
}

func (s *While_stmtContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *While_stmtContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *While_stmtContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *While_stmtContext) T_DO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DO, 0)
}

func (s *While_stmtContext) AllT_LOOP() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_LOOP)
}

func (s *While_stmtContext) T_LOOP(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOOP, i)
}

func (s *While_stmtContext) T_THEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_THEN, 0)
}

func (s *While_stmtContext) T_BEGIN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BEGIN, 0)
}

func (s *While_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *While_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *While_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterWhile_stmt(s)
	}
}

func (s *While_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitWhile_stmt(s)
	}
}




func (p *HplsqlParser) While_stmt() (localctx IWhile_stmtContext) {
	localctx = NewWhile_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, HplsqlParserRULE_while_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2226)
		p.Match(HplsqlParserT_WHILE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2227)
		p.bool_expr(0)
	}
	{
		p.SetState(2228)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_BEGIN || _la == HplsqlParserT_DO || _la == HplsqlParserT_LOOP || _la == HplsqlParserT_THEN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2229)
		p.Block()
	}
	{
		p.SetState(2230)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2232)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 258, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2231)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_LOOP || _la == HplsqlParserT_WHILE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUnconditional_loop_stmtContext is an interface to support dynamic dispatch.
type IUnconditional_loop_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllT_LOOP() []antlr.TerminalNode
	T_LOOP(i int) antlr.TerminalNode
	Block() IBlockContext
	T_END() antlr.TerminalNode

	// IsUnconditional_loop_stmtContext differentiates from other interfaces.
	IsUnconditional_loop_stmtContext()
}

type Unconditional_loop_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnconditional_loop_stmtContext() *Unconditional_loop_stmtContext {
	var p = new(Unconditional_loop_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_unconditional_loop_stmt
	return p
}

func InitEmptyUnconditional_loop_stmtContext(p *Unconditional_loop_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_unconditional_loop_stmt
}

func (*Unconditional_loop_stmtContext) IsUnconditional_loop_stmtContext() {}

func NewUnconditional_loop_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unconditional_loop_stmtContext {
	var p = new(Unconditional_loop_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_unconditional_loop_stmt

	return p
}

func (s *Unconditional_loop_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Unconditional_loop_stmtContext) AllT_LOOP() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_LOOP)
}

func (s *Unconditional_loop_stmtContext) T_LOOP(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOOP, i)
}

func (s *Unconditional_loop_stmtContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *Unconditional_loop_stmtContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *Unconditional_loop_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unconditional_loop_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Unconditional_loop_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterUnconditional_loop_stmt(s)
	}
}

func (s *Unconditional_loop_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitUnconditional_loop_stmt(s)
	}
}




func (p *HplsqlParser) Unconditional_loop_stmt() (localctx IUnconditional_loop_stmtContext) {
	localctx = NewUnconditional_loop_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, HplsqlParserRULE_unconditional_loop_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2234)
		p.Match(HplsqlParserT_LOOP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2235)
		p.Block()
	}
	{
		p.SetState(2236)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2237)
		p.Match(HplsqlParserT_LOOP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFor_cursor_stmtContext is an interface to support dynamic dispatch.
type IFor_cursor_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_FOR() antlr.TerminalNode
	L_ID() antlr.TerminalNode
	T_IN() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	AllT_LOOP() []antlr.TerminalNode
	T_LOOP(i int) antlr.TerminalNode
	Block() IBlockContext
	T_END() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode

	// IsFor_cursor_stmtContext differentiates from other interfaces.
	IsFor_cursor_stmtContext()
}

type For_cursor_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_cursor_stmtContext() *For_cursor_stmtContext {
	var p = new(For_cursor_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_for_cursor_stmt
	return p
}

func InitEmptyFor_cursor_stmtContext(p *For_cursor_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_for_cursor_stmt
}

func (*For_cursor_stmtContext) IsFor_cursor_stmtContext() {}

func NewFor_cursor_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_cursor_stmtContext {
	var p = new(For_cursor_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_for_cursor_stmt

	return p
}

func (s *For_cursor_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *For_cursor_stmtContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *For_cursor_stmtContext) L_ID() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, 0)
}

func (s *For_cursor_stmtContext) T_IN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IN, 0)
}

func (s *For_cursor_stmtContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *For_cursor_stmtContext) AllT_LOOP() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_LOOP)
}

func (s *For_cursor_stmtContext) T_LOOP(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOOP, i)
}

func (s *For_cursor_stmtContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *For_cursor_stmtContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *For_cursor_stmtContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *For_cursor_stmtContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *For_cursor_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_cursor_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *For_cursor_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFor_cursor_stmt(s)
	}
}

func (s *For_cursor_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFor_cursor_stmt(s)
	}
}




func (p *HplsqlParser) For_cursor_stmt() (localctx IFor_cursor_stmtContext) {
	localctx = NewFor_cursor_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, HplsqlParserRULE_for_cursor_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2239)
		p.Match(HplsqlParserT_FOR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2240)
		p.Match(HplsqlParserL_ID)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2241)
		p.Match(HplsqlParserT_IN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2243)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 259, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2242)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(2245)
		p.Select_stmt()
	}
	p.SetState(2247)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_CLOSE_P {
		{
			p.SetState(2246)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(2249)
		p.Match(HplsqlParserT_LOOP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2250)
		p.Block()
	}
	{
		p.SetState(2251)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2252)
		p.Match(HplsqlParserT_LOOP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFor_range_stmtContext is an interface to support dynamic dispatch.
type IFor_range_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_FOR() antlr.TerminalNode
	L_ID() antlr.TerminalNode
	T_IN() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_DOT2() antlr.TerminalNode
	AllT_LOOP() []antlr.TerminalNode
	T_LOOP(i int) antlr.TerminalNode
	Block() IBlockContext
	T_END() antlr.TerminalNode
	T_REVERSE() antlr.TerminalNode
	T_BY() antlr.TerminalNode
	T_STEP() antlr.TerminalNode

	// IsFor_range_stmtContext differentiates from other interfaces.
	IsFor_range_stmtContext()
}

type For_range_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_range_stmtContext() *For_range_stmtContext {
	var p = new(For_range_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_for_range_stmt
	return p
}

func InitEmptyFor_range_stmtContext(p *For_range_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_for_range_stmt
}

func (*For_range_stmtContext) IsFor_range_stmtContext() {}

func NewFor_range_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_range_stmtContext {
	var p = new(For_range_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_for_range_stmt

	return p
}

func (s *For_range_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *For_range_stmtContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *For_range_stmtContext) L_ID() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, 0)
}

func (s *For_range_stmtContext) T_IN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IN, 0)
}

func (s *For_range_stmtContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *For_range_stmtContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *For_range_stmtContext) T_DOT2() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DOT2, 0)
}

func (s *For_range_stmtContext) AllT_LOOP() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_LOOP)
}

func (s *For_range_stmtContext) T_LOOP(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOOP, i)
}

func (s *For_range_stmtContext) Block() IBlockContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *For_range_stmtContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *For_range_stmtContext) T_REVERSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REVERSE, 0)
}

func (s *For_range_stmtContext) T_BY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BY, 0)
}

func (s *For_range_stmtContext) T_STEP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STEP, 0)
}

func (s *For_range_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_range_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *For_range_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFor_range_stmt(s)
	}
}

func (s *For_range_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFor_range_stmt(s)
	}
}




func (p *HplsqlParser) For_range_stmt() (localctx IFor_range_stmtContext) {
	localctx = NewFor_range_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, HplsqlParserRULE_for_range_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2254)
		p.Match(HplsqlParserT_FOR)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2255)
		p.Match(HplsqlParserL_ID)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2256)
		p.Match(HplsqlParserT_IN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2258)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 261, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2257)
			p.Match(HplsqlParserT_REVERSE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(2260)
		p.expr(0)
	}
	{
		p.SetState(2261)
		p.Match(HplsqlParserT_DOT2)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2262)
		p.expr(0)
	}
	p.SetState(2265)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_BY || _la == HplsqlParserT_STEP {
		{
			p.SetState(2263)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_BY || _la == HplsqlParserT_STEP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2264)
			p.expr(0)
		}

	}
	{
		p.SetState(2267)
		p.Match(HplsqlParserT_LOOP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2268)
		p.Block()
	}
	{
		p.SetState(2269)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2270)
		p.Match(HplsqlParserT_LOOP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILabelContext is an interface to support dynamic dispatch.
type ILabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_LABEL() antlr.TerminalNode
	AllT_LESS() []antlr.TerminalNode
	T_LESS(i int) antlr.TerminalNode
	L_ID() antlr.TerminalNode
	AllT_GREATER() []antlr.TerminalNode
	T_GREATER(i int) antlr.TerminalNode

	// IsLabelContext differentiates from other interfaces.
	IsLabelContext()
}

type LabelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelContext() *LabelContext {
	var p = new(LabelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_label
	return p
}

func InitEmptyLabelContext(p *LabelContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_label
}

func (*LabelContext) IsLabelContext() {}

func NewLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelContext {
	var p = new(LabelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_label

	return p
}

func (s *LabelContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelContext) L_LABEL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_LABEL, 0)
}

func (s *LabelContext) AllT_LESS() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_LESS)
}

func (s *LabelContext) T_LESS(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LESS, i)
}

func (s *LabelContext) L_ID() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, 0)
}

func (s *LabelContext) AllT_GREATER() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_GREATER)
}

func (s *LabelContext) T_GREATER(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GREATER, i)
}

func (s *LabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterLabel(s)
	}
}

func (s *LabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitLabel(s)
	}
}




func (p *HplsqlParser) Label() (localctx ILabelContext) {
	localctx = NewLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, HplsqlParserRULE_label)
	p.SetState(2278)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserL_LABEL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2272)
			p.Match(HplsqlParserL_LABEL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_LESS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2273)
			p.Match(HplsqlParserT_LESS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2274)
			p.Match(HplsqlParserT_LESS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2275)
			p.Match(HplsqlParserL_ID)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2276)
			p.Match(HplsqlParserT_GREATER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2277)
			p.Match(HplsqlParserT_GREATER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUsing_clauseContext is an interface to support dynamic dispatch.
type IUsing_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_USING() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsUsing_clauseContext differentiates from other interfaces.
	IsUsing_clauseContext()
}

type Using_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsing_clauseContext() *Using_clauseContext {
	var p = new(Using_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_using_clause
	return p
}

func InitEmptyUsing_clauseContext(p *Using_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_using_clause
}

func (*Using_clauseContext) IsUsing_clauseContext() {}

func NewUsing_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Using_clauseContext {
	var p = new(Using_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_using_clause

	return p
}

func (s *Using_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Using_clauseContext) T_USING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_USING, 0)
}

func (s *Using_clauseContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Using_clauseContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Using_clauseContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Using_clauseContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Using_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Using_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Using_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterUsing_clause(s)
	}
}

func (s *Using_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitUsing_clause(s)
	}
}




func (p *HplsqlParser) Using_clause() (localctx IUsing_clauseContext) {
	localctx = NewUsing_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, HplsqlParserRULE_using_clause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2280)
		p.Match(HplsqlParserT_USING)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2281)
		p.expr(0)
	}
	p.SetState(2286)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 264, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2282)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2283)
				p.expr(0)
			}


		}
		p.SetState(2288)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 264, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelect_stmtContext is an interface to support dynamic dispatch.
type ISelect_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Fullselect_stmt() IFullselect_stmtContext
	Cte_select_stmt() ICte_select_stmtContext

	// IsSelect_stmtContext differentiates from other interfaces.
	IsSelect_stmtContext()
}

type Select_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_stmtContext() *Select_stmtContext {
	var p = new(Select_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_stmt
	return p
}

func InitEmptySelect_stmtContext(p *Select_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_stmt
}

func (*Select_stmtContext) IsSelect_stmtContext() {}

func NewSelect_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_stmtContext {
	var p = new(Select_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_select_stmt

	return p
}

func (s *Select_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_stmtContext) Fullselect_stmt() IFullselect_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullselect_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullselect_stmtContext)
}

func (s *Select_stmtContext) Cte_select_stmt() ICte_select_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICte_select_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICte_select_stmtContext)
}

func (s *Select_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSelect_stmt(s)
	}
}

func (s *Select_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSelect_stmt(s)
	}
}




func (p *HplsqlParser) Select_stmt() (localctx ISelect_stmtContext) {
	localctx = NewSelect_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, HplsqlParserRULE_select_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2290)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_WITH {
		{
			p.SetState(2289)
			p.Cte_select_stmt()
		}

	}
	{
		p.SetState(2292)
		p.Fullselect_stmt()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICte_select_stmtContext is an interface to support dynamic dispatch.
type ICte_select_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_WITH() antlr.TerminalNode
	AllCte_select_stmt_item() []ICte_select_stmt_itemContext
	Cte_select_stmt_item(i int) ICte_select_stmt_itemContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsCte_select_stmtContext differentiates from other interfaces.
	IsCte_select_stmtContext()
}

type Cte_select_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCte_select_stmtContext() *Cte_select_stmtContext {
	var p = new(Cte_select_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cte_select_stmt
	return p
}

func InitEmptyCte_select_stmtContext(p *Cte_select_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cte_select_stmt
}

func (*Cte_select_stmtContext) IsCte_select_stmtContext() {}

func NewCte_select_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cte_select_stmtContext {
	var p = new(Cte_select_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_cte_select_stmt

	return p
}

func (s *Cte_select_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Cte_select_stmtContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITH, 0)
}

func (s *Cte_select_stmtContext) AllCte_select_stmt_item() []ICte_select_stmt_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICte_select_stmt_itemContext); ok {
			len++
		}
	}

	tst := make([]ICte_select_stmt_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICte_select_stmt_itemContext); ok {
			tst[i] = t.(ICte_select_stmt_itemContext)
			i++
		}
	}

	return tst
}

func (s *Cte_select_stmtContext) Cte_select_stmt_item(i int) ICte_select_stmt_itemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICte_select_stmt_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICte_select_stmt_itemContext)
}

func (s *Cte_select_stmtContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Cte_select_stmtContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Cte_select_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cte_select_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Cte_select_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCte_select_stmt(s)
	}
}

func (s *Cte_select_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCte_select_stmt(s)
	}
}




func (p *HplsqlParser) Cte_select_stmt() (localctx ICte_select_stmtContext) {
	localctx = NewCte_select_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, HplsqlParserRULE_cte_select_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2294)
		p.Match(HplsqlParserT_WITH)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2295)
		p.Cte_select_stmt_item()
	}
	p.SetState(2300)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(2296)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2297)
			p.Cte_select_stmt_item()
		}


		p.SetState(2302)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICte_select_stmt_itemContext is an interface to support dynamic dispatch.
type ICte_select_stmt_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Qident() IQidentContext
	T_AS() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	Fullselect_stmt() IFullselect_stmtContext
	T_CLOSE_P() antlr.TerminalNode
	Cte_select_cols() ICte_select_colsContext

	// IsCte_select_stmt_itemContext differentiates from other interfaces.
	IsCte_select_stmt_itemContext()
}

type Cte_select_stmt_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCte_select_stmt_itemContext() *Cte_select_stmt_itemContext {
	var p = new(Cte_select_stmt_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cte_select_stmt_item
	return p
}

func InitEmptyCte_select_stmt_itemContext(p *Cte_select_stmt_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cte_select_stmt_item
}

func (*Cte_select_stmt_itemContext) IsCte_select_stmt_itemContext() {}

func NewCte_select_stmt_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cte_select_stmt_itemContext {
	var p = new(Cte_select_stmt_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_cte_select_stmt_item

	return p
}

func (s *Cte_select_stmt_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Cte_select_stmt_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Cte_select_stmt_itemContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Cte_select_stmt_itemContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Cte_select_stmt_itemContext) Fullselect_stmt() IFullselect_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullselect_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullselect_stmtContext)
}

func (s *Cte_select_stmt_itemContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Cte_select_stmt_itemContext) Cte_select_cols() ICte_select_colsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICte_select_colsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICte_select_colsContext)
}

func (s *Cte_select_stmt_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cte_select_stmt_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Cte_select_stmt_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCte_select_stmt_item(s)
	}
}

func (s *Cte_select_stmt_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCte_select_stmt_item(s)
	}
}




func (p *HplsqlParser) Cte_select_stmt_item() (localctx ICte_select_stmt_itemContext) {
	localctx = NewCte_select_stmt_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, HplsqlParserRULE_cte_select_stmt_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2303)
		p.Qident()
	}
	p.SetState(2305)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_OPEN_P {
		{
			p.SetState(2304)
			p.Cte_select_cols()
		}

	}
	{
		p.SetState(2307)
		p.Match(HplsqlParserT_AS)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2308)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2309)
		p.Fullselect_stmt()
	}
	{
		p.SetState(2310)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICte_select_colsContext is an interface to support dynamic dispatch.
type ICte_select_colsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN_P() antlr.TerminalNode
	AllQident() []IQidentContext
	Qident(i int) IQidentContext
	T_CLOSE_P() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsCte_select_colsContext differentiates from other interfaces.
	IsCte_select_colsContext()
}

type Cte_select_colsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCte_select_colsContext() *Cte_select_colsContext {
	var p = new(Cte_select_colsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cte_select_cols
	return p
}

func InitEmptyCte_select_colsContext(p *Cte_select_colsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_cte_select_cols
}

func (*Cte_select_colsContext) IsCte_select_colsContext() {}

func NewCte_select_colsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cte_select_colsContext {
	var p = new(Cte_select_colsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_cte_select_cols

	return p
}

func (s *Cte_select_colsContext) GetParser() antlr.Parser { return s.parser }

func (s *Cte_select_colsContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Cte_select_colsContext) AllQident() []IQidentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQidentContext); ok {
			len++
		}
	}

	tst := make([]IQidentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQidentContext); ok {
			tst[i] = t.(IQidentContext)
			i++
		}
	}

	return tst
}

func (s *Cte_select_colsContext) Qident(i int) IQidentContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Cte_select_colsContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Cte_select_colsContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Cte_select_colsContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Cte_select_colsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cte_select_colsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Cte_select_colsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterCte_select_cols(s)
	}
}

func (s *Cte_select_colsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitCte_select_cols(s)
	}
}




func (p *HplsqlParser) Cte_select_cols() (localctx ICte_select_colsContext) {
	localctx = NewCte_select_colsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, HplsqlParserRULE_cte_select_cols)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2312)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2313)
		p.Qident()
	}
	p.SetState(2318)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(2314)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2315)
			p.Qident()
		}


		p.SetState(2320)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2321)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFullselect_stmtContext is an interface to support dynamic dispatch.
type IFullselect_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFullselect_stmt_item() []IFullselect_stmt_itemContext
	Fullselect_stmt_item(i int) IFullselect_stmt_itemContext
	AllFullselect_set_clause() []IFullselect_set_clauseContext
	Fullselect_set_clause(i int) IFullselect_set_clauseContext

	// IsFullselect_stmtContext differentiates from other interfaces.
	IsFullselect_stmtContext()
}

type Fullselect_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullselect_stmtContext() *Fullselect_stmtContext {
	var p = new(Fullselect_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_fullselect_stmt
	return p
}

func InitEmptyFullselect_stmtContext(p *Fullselect_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_fullselect_stmt
}

func (*Fullselect_stmtContext) IsFullselect_stmtContext() {}

func NewFullselect_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fullselect_stmtContext {
	var p = new(Fullselect_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_fullselect_stmt

	return p
}

func (s *Fullselect_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Fullselect_stmtContext) AllFullselect_stmt_item() []IFullselect_stmt_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullselect_stmt_itemContext); ok {
			len++
		}
	}

	tst := make([]IFullselect_stmt_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullselect_stmt_itemContext); ok {
			tst[i] = t.(IFullselect_stmt_itemContext)
			i++
		}
	}

	return tst
}

func (s *Fullselect_stmtContext) Fullselect_stmt_item(i int) IFullselect_stmt_itemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullselect_stmt_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullselect_stmt_itemContext)
}

func (s *Fullselect_stmtContext) AllFullselect_set_clause() []IFullselect_set_clauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFullselect_set_clauseContext); ok {
			len++
		}
	}

	tst := make([]IFullselect_set_clauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFullselect_set_clauseContext); ok {
			tst[i] = t.(IFullselect_set_clauseContext)
			i++
		}
	}

	return tst
}

func (s *Fullselect_stmtContext) Fullselect_set_clause(i int) IFullselect_set_clauseContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullselect_set_clauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullselect_set_clauseContext)
}

func (s *Fullselect_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fullselect_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Fullselect_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFullselect_stmt(s)
	}
}

func (s *Fullselect_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFullselect_stmt(s)
	}
}




func (p *HplsqlParser) Fullselect_stmt() (localctx IFullselect_stmtContext) {
	localctx = NewFullselect_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, HplsqlParserRULE_fullselect_stmt)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2323)
		p.Fullselect_stmt_item()
	}
	p.SetState(2329)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 269, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2324)
				p.Fullselect_set_clause()
			}
			{
				p.SetState(2325)
				p.Fullselect_stmt_item()
			}


		}
		p.SetState(2331)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 269, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFullselect_stmt_itemContext is an interface to support dynamic dispatch.
type IFullselect_stmt_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Subselect_stmt() ISubselect_stmtContext
	T_OPEN_P() antlr.TerminalNode
	Fullselect_stmt() IFullselect_stmtContext
	T_CLOSE_P() antlr.TerminalNode

	// IsFullselect_stmt_itemContext differentiates from other interfaces.
	IsFullselect_stmt_itemContext()
}

type Fullselect_stmt_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullselect_stmt_itemContext() *Fullselect_stmt_itemContext {
	var p = new(Fullselect_stmt_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_fullselect_stmt_item
	return p
}

func InitEmptyFullselect_stmt_itemContext(p *Fullselect_stmt_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_fullselect_stmt_item
}

func (*Fullselect_stmt_itemContext) IsFullselect_stmt_itemContext() {}

func NewFullselect_stmt_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fullselect_stmt_itemContext {
	var p = new(Fullselect_stmt_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_fullselect_stmt_item

	return p
}

func (s *Fullselect_stmt_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Fullselect_stmt_itemContext) Subselect_stmt() ISubselect_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubselect_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubselect_stmtContext)
}

func (s *Fullselect_stmt_itemContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Fullselect_stmt_itemContext) Fullselect_stmt() IFullselect_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFullselect_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFullselect_stmtContext)
}

func (s *Fullselect_stmt_itemContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Fullselect_stmt_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fullselect_stmt_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Fullselect_stmt_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFullselect_stmt_item(s)
	}
}

func (s *Fullselect_stmt_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFullselect_stmt_item(s)
	}
}




func (p *HplsqlParser) Fullselect_stmt_item() (localctx IFullselect_stmt_itemContext) {
	localctx = NewFullselect_stmt_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, HplsqlParserRULE_fullselect_stmt_item)
	p.SetState(2337)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_SEL, HplsqlParserT_SELECT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2332)
			p.Subselect_stmt()
		}


	case HplsqlParserT_OPEN_P:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2333)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2334)
			p.Fullselect_stmt()
		}
		{
			p.SetState(2335)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFullselect_set_clauseContext is an interface to support dynamic dispatch.
type IFullselect_set_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_UNION() antlr.TerminalNode
	T_ALL() antlr.TerminalNode
	T_EXCEPT() antlr.TerminalNode
	T_INTERSECT() antlr.TerminalNode

	// IsFullselect_set_clauseContext differentiates from other interfaces.
	IsFullselect_set_clauseContext()
}

type Fullselect_set_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullselect_set_clauseContext() *Fullselect_set_clauseContext {
	var p = new(Fullselect_set_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_fullselect_set_clause
	return p
}

func InitEmptyFullselect_set_clauseContext(p *Fullselect_set_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_fullselect_set_clause
}

func (*Fullselect_set_clauseContext) IsFullselect_set_clauseContext() {}

func NewFullselect_set_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fullselect_set_clauseContext {
	var p = new(Fullselect_set_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_fullselect_set_clause

	return p
}

func (s *Fullselect_set_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Fullselect_set_clauseContext) T_UNION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UNION, 0)
}

func (s *Fullselect_set_clauseContext) T_ALL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALL, 0)
}

func (s *Fullselect_set_clauseContext) T_EXCEPT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXCEPT, 0)
}

func (s *Fullselect_set_clauseContext) T_INTERSECT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTERSECT, 0)
}

func (s *Fullselect_set_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fullselect_set_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Fullselect_set_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFullselect_set_clause(s)
	}
}

func (s *Fullselect_set_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFullselect_set_clause(s)
	}
}




func (p *HplsqlParser) Fullselect_set_clause() (localctx IFullselect_set_clauseContext) {
	localctx = NewFullselect_set_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, HplsqlParserRULE_fullselect_set_clause)
	var _la int

	p.SetState(2351)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_UNION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2339)
			p.Match(HplsqlParserT_UNION)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2341)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_ALL {
			{
				p.SetState(2340)
				p.Match(HplsqlParserT_ALL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case HplsqlParserT_EXCEPT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2343)
			p.Match(HplsqlParserT_EXCEPT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2345)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_ALL {
			{
				p.SetState(2344)
				p.Match(HplsqlParserT_ALL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case HplsqlParserT_INTERSECT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2347)
			p.Match(HplsqlParserT_INTERSECT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2349)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_ALL {
			{
				p.SetState(2348)
				p.Match(HplsqlParserT_ALL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISubselect_stmtContext is an interface to support dynamic dispatch.
type ISubselect_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Select_list() ISelect_listContext
	T_SELECT() antlr.TerminalNode
	T_SEL() antlr.TerminalNode
	Into_clause() IInto_clauseContext
	From_clause() IFrom_clauseContext
	Where_clause() IWhere_clauseContext
	Group_by_clause() IGroup_by_clauseContext
	Having_clause() IHaving_clauseContext
	Qualify_clause() IQualify_clauseContext
	Order_by_clause() IOrder_by_clauseContext
	Select_options() ISelect_optionsContext

	// IsSubselect_stmtContext differentiates from other interfaces.
	IsSubselect_stmtContext()
}

type Subselect_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubselect_stmtContext() *Subselect_stmtContext {
	var p = new(Subselect_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_subselect_stmt
	return p
}

func InitEmptySubselect_stmtContext(p *Subselect_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_subselect_stmt
}

func (*Subselect_stmtContext) IsSubselect_stmtContext() {}

func NewSubselect_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subselect_stmtContext {
	var p = new(Subselect_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_subselect_stmt

	return p
}

func (s *Subselect_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Subselect_stmtContext) Select_list() ISelect_listContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_listContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_listContext)
}

func (s *Subselect_stmtContext) T_SELECT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SELECT, 0)
}

func (s *Subselect_stmtContext) T_SEL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEL, 0)
}

func (s *Subselect_stmtContext) Into_clause() IInto_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInto_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInto_clauseContext)
}

func (s *Subselect_stmtContext) From_clause() IFrom_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_clauseContext)
}

func (s *Subselect_stmtContext) Where_clause() IWhere_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhere_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhere_clauseContext)
}

func (s *Subselect_stmtContext) Group_by_clause() IGroup_by_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroup_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroup_by_clauseContext)
}

func (s *Subselect_stmtContext) Having_clause() IHaving_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHaving_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHaving_clauseContext)
}

func (s *Subselect_stmtContext) Qualify_clause() IQualify_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualify_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualify_clauseContext)
}

func (s *Subselect_stmtContext) Order_by_clause() IOrder_by_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_by_clauseContext)
}

func (s *Subselect_stmtContext) Select_options() ISelect_optionsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_optionsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_optionsContext)
}

func (s *Subselect_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subselect_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Subselect_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSubselect_stmt(s)
	}
}

func (s *Subselect_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSubselect_stmt(s)
	}
}




func (p *HplsqlParser) Subselect_stmt() (localctx ISubselect_stmtContext) {
	localctx = NewSubselect_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, HplsqlParserRULE_subselect_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2353)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_SEL || _la == HplsqlParserT_SELECT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2354)
		p.Select_list()
	}
	p.SetState(2356)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 275, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2355)
			p.Into_clause()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(2359)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 276, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2358)
			p.From_clause()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(2362)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 277, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2361)
			p.Where_clause()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(2365)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 278, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2364)
			p.Group_by_clause()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(2369)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 279, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2367)
			p.Having_clause()
		}

		} else if p.HasError() { // JIM
			goto errorExit} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 279, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(2368)
			p.Qualify_clause()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(2372)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 280, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2371)
			p.Order_by_clause()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(2375)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 281, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2374)
			p.Select_options()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelect_listContext is an interface to support dynamic dispatch.
type ISelect_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSelect_list_item() []ISelect_list_itemContext
	Select_list_item(i int) ISelect_list_itemContext
	Select_list_set() ISelect_list_setContext
	Select_list_limit() ISelect_list_limitContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsSelect_listContext differentiates from other interfaces.
	IsSelect_listContext()
}

type Select_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_listContext() *Select_listContext {
	var p = new(Select_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list
	return p
}

func InitEmptySelect_listContext(p *Select_listContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list
}

func (*Select_listContext) IsSelect_listContext() {}

func NewSelect_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_listContext {
	var p = new(Select_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_select_list

	return p
}

func (s *Select_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_listContext) AllSelect_list_item() []ISelect_list_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelect_list_itemContext); ok {
			len++
		}
	}

	tst := make([]ISelect_list_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelect_list_itemContext); ok {
			tst[i] = t.(ISelect_list_itemContext)
			i++
		}
	}

	return tst
}

func (s *Select_listContext) Select_list_item(i int) ISelect_list_itemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_list_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_list_itemContext)
}

func (s *Select_listContext) Select_list_set() ISelect_list_setContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_list_setContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_list_setContext)
}

func (s *Select_listContext) Select_list_limit() ISelect_list_limitContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_list_limitContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_list_limitContext)
}

func (s *Select_listContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Select_listContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Select_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSelect_list(s)
	}
}

func (s *Select_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSelect_list(s)
	}
}




func (p *HplsqlParser) Select_list() (localctx ISelect_listContext) {
	localctx = NewSelect_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, HplsqlParserRULE_select_list)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2378)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 282, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2377)
			p.Select_list_set()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(2381)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 283, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2380)
			p.Select_list_limit()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(2383)
		p.Select_list_item()
	}
	p.SetState(2388)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 284, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2384)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2385)
				p.Select_list_item()
			}


		}
		p.SetState(2390)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 284, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelect_list_setContext is an interface to support dynamic dispatch.
type ISelect_list_setContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ALL() antlr.TerminalNode
	T_DISTINCT() antlr.TerminalNode

	// IsSelect_list_setContext differentiates from other interfaces.
	IsSelect_list_setContext()
}

type Select_list_setContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_list_setContext() *Select_list_setContext {
	var p = new(Select_list_setContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list_set
	return p
}

func InitEmptySelect_list_setContext(p *Select_list_setContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list_set
}

func (*Select_list_setContext) IsSelect_list_setContext() {}

func NewSelect_list_setContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_list_setContext {
	var p = new(Select_list_setContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_select_list_set

	return p
}

func (s *Select_list_setContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_list_setContext) T_ALL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALL, 0)
}

func (s *Select_list_setContext) T_DISTINCT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DISTINCT, 0)
}

func (s *Select_list_setContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_list_setContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_list_setContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSelect_list_set(s)
	}
}

func (s *Select_list_setContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSelect_list_set(s)
	}
}




func (p *HplsqlParser) Select_list_set() (localctx ISelect_list_setContext) {
	localctx = NewSelect_list_setContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, HplsqlParserRULE_select_list_set)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2391)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_ALL || _la == HplsqlParserT_DISTINCT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelect_list_limitContext is an interface to support dynamic dispatch.
type ISelect_list_limitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_TOP() antlr.TerminalNode
	Expr() IExprContext

	// IsSelect_list_limitContext differentiates from other interfaces.
	IsSelect_list_limitContext()
}

type Select_list_limitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_list_limitContext() *Select_list_limitContext {
	var p = new(Select_list_limitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list_limit
	return p
}

func InitEmptySelect_list_limitContext(p *Select_list_limitContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list_limit
}

func (*Select_list_limitContext) IsSelect_list_limitContext() {}

func NewSelect_list_limitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_list_limitContext {
	var p = new(Select_list_limitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_select_list_limit

	return p
}

func (s *Select_list_limitContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_list_limitContext) T_TOP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TOP, 0)
}

func (s *Select_list_limitContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Select_list_limitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_list_limitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_list_limitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSelect_list_limit(s)
	}
}

func (s *Select_list_limitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSelect_list_limit(s)
	}
}




func (p *HplsqlParser) Select_list_limit() (localctx ISelect_list_limitContext) {
	localctx = NewSelect_list_limitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, HplsqlParserRULE_select_list_limit)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2393)
		p.Match(HplsqlParserT_TOP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2394)
		p.expr(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelect_list_itemContext is an interface to support dynamic dispatch.
type ISelect_list_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	Select_list_asterisk() ISelect_list_asteriskContext
	Qident() IQidentContext
	T_EQUAL() antlr.TerminalNode
	Select_list_alias() ISelect_list_aliasContext

	// IsSelect_list_itemContext differentiates from other interfaces.
	IsSelect_list_itemContext()
}

type Select_list_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_list_itemContext() *Select_list_itemContext {
	var p = new(Select_list_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list_item
	return p
}

func InitEmptySelect_list_itemContext(p *Select_list_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list_item
}

func (*Select_list_itemContext) IsSelect_list_itemContext() {}

func NewSelect_list_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_list_itemContext {
	var p = new(Select_list_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_select_list_item

	return p
}

func (s *Select_list_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_list_itemContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Select_list_itemContext) Select_list_asterisk() ISelect_list_asteriskContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_list_asteriskContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_list_asteriskContext)
}

func (s *Select_list_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Select_list_itemContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Select_list_itemContext) Select_list_alias() ISelect_list_aliasContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_list_aliasContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_list_aliasContext)
}

func (s *Select_list_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_list_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_list_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSelect_list_item(s)
	}
}

func (s *Select_list_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSelect_list_item(s)
	}
}




func (p *HplsqlParser) Select_list_item() (localctx ISelect_list_itemContext) {
	localctx = NewSelect_list_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, HplsqlParserRULE_select_list_item)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(2406)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 287, p.GetParserRuleContext()) {
	case 1:
		p.SetState(2399)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 285, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2396)
				p.Qident()
			}
			{
				p.SetState(2397)
				p.Match(HplsqlParserT_EQUAL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(2401)
			p.expr(0)
		}
		p.SetState(2403)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 286, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2402)
				p.Select_list_alias()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 2:
		{
			p.SetState(2405)
			p.Select_list_asterisk()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelect_list_aliasContext is an interface to support dynamic dispatch.
type ISelect_list_aliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Qident() IQidentContext
	T_AS() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	T_TITLE() antlr.TerminalNode
	L_S_STRING() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode

	// IsSelect_list_aliasContext differentiates from other interfaces.
	IsSelect_list_aliasContext()
}

type Select_list_aliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_list_aliasContext() *Select_list_aliasContext {
	var p = new(Select_list_aliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list_alias
	return p
}

func InitEmptySelect_list_aliasContext(p *Select_list_aliasContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list_alias
}

func (*Select_list_aliasContext) IsSelect_list_aliasContext() {}

func NewSelect_list_aliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_list_aliasContext {
	var p = new(Select_list_aliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_select_list_alias

	return p
}

func (s *Select_list_aliasContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_list_aliasContext) Qident() IQidentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Select_list_aliasContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Select_list_aliasContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Select_list_aliasContext) T_TITLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TITLE, 0)
}

func (s *Select_list_aliasContext) L_S_STRING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_S_STRING, 0)
}

func (s *Select_list_aliasContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Select_list_aliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_list_aliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_list_aliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSelect_list_alias(s)
	}
}

func (s *Select_list_aliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSelect_list_alias(s)
	}
}




func (p *HplsqlParser) Select_list_alias() (localctx ISelect_list_aliasContext) {
	localctx = NewSelect_list_aliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, HplsqlParserRULE_select_list_alias)
	p.SetState(2417)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 289, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2408)

		if !(!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "INTO") && !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "FROM")) {
			p.SetError(antlr.NewFailedPredicateException(p, "!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"INTO\") && !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"FROM\")", ""))
			goto errorExit
		}
		p.SetState(2410)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 288, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2409)
				p.Match(HplsqlParserT_AS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(2412)
			p.Qident()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2413)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2414)
			p.Match(HplsqlParserT_TITLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2415)
			p.Match(HplsqlParserL_S_STRING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2416)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelect_list_asteriskContext is an interface to support dynamic dispatch.
type ISelect_list_asteriskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_MUL() antlr.TerminalNode
	L_ID() antlr.TerminalNode
	T_DOT() antlr.TerminalNode

	// IsSelect_list_asteriskContext differentiates from other interfaces.
	IsSelect_list_asteriskContext()
}

type Select_list_asteriskContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_list_asteriskContext() *Select_list_asteriskContext {
	var p = new(Select_list_asteriskContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list_asterisk
	return p
}

func InitEmptySelect_list_asteriskContext(p *Select_list_asteriskContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_list_asterisk
}

func (*Select_list_asteriskContext) IsSelect_list_asteriskContext() {}

func NewSelect_list_asteriskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_list_asteriskContext {
	var p = new(Select_list_asteriskContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_select_list_asterisk

	return p
}

func (s *Select_list_asteriskContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_list_asteriskContext) T_MUL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MUL, 0)
}

func (s *Select_list_asteriskContext) L_ID() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, 0)
}

func (s *Select_list_asteriskContext) T_DOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DOT, 0)
}

func (s *Select_list_asteriskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_list_asteriskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_list_asteriskContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSelect_list_asterisk(s)
	}
}

func (s *Select_list_asteriskContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSelect_list_asterisk(s)
	}
}




func (p *HplsqlParser) Select_list_asterisk() (localctx ISelect_list_asteriskContext) {
	localctx = NewSelect_list_asteriskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, HplsqlParserRULE_select_list_asterisk)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2421)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserL_ID {
		{
			p.SetState(2419)
			p.Match(HplsqlParserL_ID)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2420)
			p.Match(HplsqlParserT_DOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(2423)
		p.Match(HplsqlParserT_MUL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITable_rowContext is an interface to support dynamic dispatch.
type ITable_rowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ident() IIdentContext
	T_OPEN_P() antlr.TerminalNode
	L_INT() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode

	// IsTable_rowContext differentiates from other interfaces.
	IsTable_rowContext()
}

type Table_rowContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_rowContext() *Table_rowContext {
	var p = new(Table_rowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_table_row
	return p
}

func InitEmptyTable_rowContext(p *Table_rowContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_table_row
}

func (*Table_rowContext) IsTable_rowContext() {}

func NewTable_rowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_rowContext {
	var p = new(Table_rowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_table_row

	return p
}

func (s *Table_rowContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_rowContext) Ident() IIdentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Table_rowContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Table_rowContext) L_INT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_INT, 0)
}

func (s *Table_rowContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Table_rowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_rowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Table_rowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterTable_row(s)
	}
}

func (s *Table_rowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitTable_row(s)
	}
}




func (p *HplsqlParser) Table_row() (localctx ITable_rowContext) {
	localctx = NewTable_rowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, HplsqlParserRULE_table_row)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2425)
		p.Ident()
	}
	{
		p.SetState(2426)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2427)
		p.Match(HplsqlParserL_INT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2428)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInto_clauseContext is an interface to support dynamic dispatch.
type IInto_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_INTO() antlr.TerminalNode
	AllTable_row() []ITable_rowContext
	Table_row(i int) ITable_rowContext
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	Bulk_collect_clause() IBulk_collect_clauseContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsInto_clauseContext differentiates from other interfaces.
	IsInto_clauseContext()
}

type Into_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInto_clauseContext() *Into_clauseContext {
	var p = new(Into_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_into_clause
	return p
}

func InitEmptyInto_clauseContext(p *Into_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_into_clause
}

func (*Into_clauseContext) IsInto_clauseContext() {}

func NewInto_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Into_clauseContext {
	var p = new(Into_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_into_clause

	return p
}

func (s *Into_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Into_clauseContext) T_INTO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTO, 0)
}

func (s *Into_clauseContext) AllTable_row() []ITable_rowContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITable_rowContext); ok {
			len++
		}
	}

	tst := make([]ITable_rowContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITable_rowContext); ok {
			tst[i] = t.(ITable_rowContext)
			i++
		}
	}

	return tst
}

func (s *Into_clauseContext) Table_row(i int) ITable_rowContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_rowContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_rowContext)
}

func (s *Into_clauseContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Into_clauseContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Into_clauseContext) Bulk_collect_clause() IBulk_collect_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBulk_collect_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBulk_collect_clauseContext)
}

func (s *Into_clauseContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Into_clauseContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Into_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Into_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Into_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterInto_clause(s)
	}
}

func (s *Into_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitInto_clause(s)
	}
}




func (p *HplsqlParser) Into_clause() (localctx IInto_clauseContext) {
	localctx = NewInto_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, HplsqlParserRULE_into_clause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2431)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_BULK {
		{
			p.SetState(2430)
			p.Bulk_collect_clause()
		}

	}
	{
		p.SetState(2433)
		p.Match(HplsqlParserT_INTO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2436)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 292, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2434)
			p.Table_row()
		}


	case 2:
		{
			p.SetState(2435)
			p.Ident()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(2445)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 294, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2438)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(2441)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 293, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(2439)
					p.Table_row()
				}


			case 2:
				{
					p.SetState(2440)
					p.Ident()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}


		}
		p.SetState(2447)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 294, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBulk_collect_clauseContext is an interface to support dynamic dispatch.
type IBulk_collect_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_BULK() antlr.TerminalNode
	T_COLLECT() antlr.TerminalNode

	// IsBulk_collect_clauseContext differentiates from other interfaces.
	IsBulk_collect_clauseContext()
}

type Bulk_collect_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBulk_collect_clauseContext() *Bulk_collect_clauseContext {
	var p = new(Bulk_collect_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bulk_collect_clause
	return p
}

func InitEmptyBulk_collect_clauseContext(p *Bulk_collect_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bulk_collect_clause
}

func (*Bulk_collect_clauseContext) IsBulk_collect_clauseContext() {}

func NewBulk_collect_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bulk_collect_clauseContext {
	var p = new(Bulk_collect_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_bulk_collect_clause

	return p
}

func (s *Bulk_collect_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Bulk_collect_clauseContext) T_BULK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BULK, 0)
}

func (s *Bulk_collect_clauseContext) T_COLLECT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLLECT, 0)
}

func (s *Bulk_collect_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bulk_collect_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Bulk_collect_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBulk_collect_clause(s)
	}
}

func (s *Bulk_collect_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBulk_collect_clause(s)
	}
}




func (p *HplsqlParser) Bulk_collect_clause() (localctx IBulk_collect_clauseContext) {
	localctx = NewBulk_collect_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, HplsqlParserRULE_bulk_collect_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2448)
		p.Match(HplsqlParserT_BULK)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2449)
		p.Match(HplsqlParserT_COLLECT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFrom_clauseContext is an interface to support dynamic dispatch.
type IFrom_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_FROM() antlr.TerminalNode
	From_table_clause() IFrom_table_clauseContext
	AllFrom_join_clause() []IFrom_join_clauseContext
	From_join_clause(i int) IFrom_join_clauseContext

	// IsFrom_clauseContext differentiates from other interfaces.
	IsFrom_clauseContext()
}

type From_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_clauseContext() *From_clauseContext {
	var p = new(From_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_clause
	return p
}

func InitEmptyFrom_clauseContext(p *From_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_clause
}

func (*From_clauseContext) IsFrom_clauseContext() {}

func NewFrom_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_clauseContext {
	var p = new(From_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_from_clause

	return p
}

func (s *From_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *From_clauseContext) T_FROM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FROM, 0)
}

func (s *From_clauseContext) From_table_clause() IFrom_table_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_table_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_table_clauseContext)
}

func (s *From_clauseContext) AllFrom_join_clause() []IFrom_join_clauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFrom_join_clauseContext); ok {
			len++
		}
	}

	tst := make([]IFrom_join_clauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFrom_join_clauseContext); ok {
			tst[i] = t.(IFrom_join_clauseContext)
			i++
		}
	}

	return tst
}

func (s *From_clauseContext) From_join_clause(i int) IFrom_join_clauseContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_join_clauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_join_clauseContext)
}

func (s *From_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *From_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFrom_clause(s)
	}
}

func (s *From_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFrom_clause(s)
	}
}




func (p *HplsqlParser) From_clause() (localctx IFrom_clauseContext) {
	localctx = NewFrom_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, HplsqlParserRULE_from_clause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2451)
		p.Match(HplsqlParserT_FROM)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2452)
		p.From_table_clause()
	}
	p.SetState(2456)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 295, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2453)
				p.From_join_clause()
			}


		}
		p.SetState(2458)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 295, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFrom_table_clauseContext is an interface to support dynamic dispatch.
type IFrom_table_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	From_table_name_clause() IFrom_table_name_clauseContext
	From_subselect_clause() IFrom_subselect_clauseContext
	From_table_values_clause() IFrom_table_values_clauseContext

	// IsFrom_table_clauseContext differentiates from other interfaces.
	IsFrom_table_clauseContext()
}

type From_table_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_table_clauseContext() *From_table_clauseContext {
	var p = new(From_table_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_table_clause
	return p
}

func InitEmptyFrom_table_clauseContext(p *From_table_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_table_clause
}

func (*From_table_clauseContext) IsFrom_table_clauseContext() {}

func NewFrom_table_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_table_clauseContext {
	var p = new(From_table_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_from_table_clause

	return p
}

func (s *From_table_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *From_table_clauseContext) From_table_name_clause() IFrom_table_name_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_table_name_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_table_name_clauseContext)
}

func (s *From_table_clauseContext) From_subselect_clause() IFrom_subselect_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_subselect_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_subselect_clauseContext)
}

func (s *From_table_clauseContext) From_table_values_clause() IFrom_table_values_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_table_values_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_table_values_clauseContext)
}

func (s *From_table_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_table_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *From_table_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFrom_table_clause(s)
	}
}

func (s *From_table_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFrom_table_clause(s)
	}
}




func (p *HplsqlParser) From_table_clause() (localctx IFrom_table_clauseContext) {
	localctx = NewFrom_table_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, HplsqlParserRULE_from_table_clause)
	p.SetState(2462)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 296, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2459)
			p.From_table_name_clause()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2460)
			p.From_subselect_clause()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2461)
			p.From_table_values_clause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFrom_table_name_clauseContext is an interface to support dynamic dispatch.
type IFrom_table_name_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Table_name() ITable_nameContext
	From_alias_clause() IFrom_alias_clauseContext

	// IsFrom_table_name_clauseContext differentiates from other interfaces.
	IsFrom_table_name_clauseContext()
}

type From_table_name_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_table_name_clauseContext() *From_table_name_clauseContext {
	var p = new(From_table_name_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_table_name_clause
	return p
}

func InitEmptyFrom_table_name_clauseContext(p *From_table_name_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_table_name_clause
}

func (*From_table_name_clauseContext) IsFrom_table_name_clauseContext() {}

func NewFrom_table_name_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_table_name_clauseContext {
	var p = new(From_table_name_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_from_table_name_clause

	return p
}

func (s *From_table_name_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *From_table_name_clauseContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *From_table_name_clauseContext) From_alias_clause() IFrom_alias_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_alias_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_alias_clauseContext)
}

func (s *From_table_name_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_table_name_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *From_table_name_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFrom_table_name_clause(s)
	}
}

func (s *From_table_name_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFrom_table_name_clause(s)
	}
}




func (p *HplsqlParser) From_table_name_clause() (localctx IFrom_table_name_clauseContext) {
	localctx = NewFrom_table_name_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, HplsqlParserRULE_from_table_name_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2464)
		p.Table_name()
	}
	p.SetState(2466)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 297, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2465)
			p.From_alias_clause()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFrom_subselect_clauseContext is an interface to support dynamic dispatch.
type IFrom_subselect_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN_P() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	T_CLOSE_P() antlr.TerminalNode
	From_alias_clause() IFrom_alias_clauseContext

	// IsFrom_subselect_clauseContext differentiates from other interfaces.
	IsFrom_subselect_clauseContext()
}

type From_subselect_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_subselect_clauseContext() *From_subselect_clauseContext {
	var p = new(From_subselect_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_subselect_clause
	return p
}

func InitEmptyFrom_subselect_clauseContext(p *From_subselect_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_subselect_clause
}

func (*From_subselect_clauseContext) IsFrom_subselect_clauseContext() {}

func NewFrom_subselect_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_subselect_clauseContext {
	var p = new(From_subselect_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_from_subselect_clause

	return p
}

func (s *From_subselect_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *From_subselect_clauseContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *From_subselect_clauseContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *From_subselect_clauseContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *From_subselect_clauseContext) From_alias_clause() IFrom_alias_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_alias_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_alias_clauseContext)
}

func (s *From_subselect_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_subselect_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *From_subselect_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFrom_subselect_clause(s)
	}
}

func (s *From_subselect_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFrom_subselect_clause(s)
	}
}




func (p *HplsqlParser) From_subselect_clause() (localctx IFrom_subselect_clauseContext) {
	localctx = NewFrom_subselect_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, HplsqlParserRULE_from_subselect_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2468)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2469)
		p.Select_stmt()
	}
	{
		p.SetState(2470)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2472)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 298, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2471)
			p.From_alias_clause()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFrom_join_clauseContext is an interface to support dynamic dispatch.
type IFrom_join_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_COMMA() antlr.TerminalNode
	From_table_clause() IFrom_table_clauseContext
	From_join_type_clause() IFrom_join_type_clauseContext
	T_ON() antlr.TerminalNode
	Bool_expr() IBool_exprContext

	// IsFrom_join_clauseContext differentiates from other interfaces.
	IsFrom_join_clauseContext()
}

type From_join_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_join_clauseContext() *From_join_clauseContext {
	var p = new(From_join_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_join_clause
	return p
}

func InitEmptyFrom_join_clauseContext(p *From_join_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_join_clause
}

func (*From_join_clauseContext) IsFrom_join_clauseContext() {}

func NewFrom_join_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_join_clauseContext {
	var p = new(From_join_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_from_join_clause

	return p
}

func (s *From_join_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *From_join_clauseContext) T_COMMA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, 0)
}

func (s *From_join_clauseContext) From_table_clause() IFrom_table_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_table_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_table_clauseContext)
}

func (s *From_join_clauseContext) From_join_type_clause() IFrom_join_type_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_join_type_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_join_type_clauseContext)
}

func (s *From_join_clauseContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *From_join_clauseContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *From_join_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_join_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *From_join_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFrom_join_clause(s)
	}
}

func (s *From_join_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFrom_join_clause(s)
	}
}




func (p *HplsqlParser) From_join_clause() (localctx IFrom_join_clauseContext) {
	localctx = NewFrom_join_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, HplsqlParserRULE_from_join_clause)
	p.SetState(2481)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_COMMA:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2474)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2475)
			p.From_table_clause()
		}


	case HplsqlParserT_FULL, HplsqlParserT_INNER, HplsqlParserT_JOIN, HplsqlParserT_LEFT, HplsqlParserT_RIGHT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2476)
			p.From_join_type_clause()
		}
		{
			p.SetState(2477)
			p.From_table_clause()
		}
		{
			p.SetState(2478)
			p.Match(HplsqlParserT_ON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2479)
			p.bool_expr(0)
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFrom_join_type_clauseContext is an interface to support dynamic dispatch.
type IFrom_join_type_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_JOIN() antlr.TerminalNode
	T_INNER() antlr.TerminalNode
	T_LEFT() antlr.TerminalNode
	T_RIGHT() antlr.TerminalNode
	T_FULL() antlr.TerminalNode
	T_OUTER() antlr.TerminalNode

	// IsFrom_join_type_clauseContext differentiates from other interfaces.
	IsFrom_join_type_clauseContext()
}

type From_join_type_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_join_type_clauseContext() *From_join_type_clauseContext {
	var p = new(From_join_type_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_join_type_clause
	return p
}

func InitEmptyFrom_join_type_clauseContext(p *From_join_type_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_join_type_clause
}

func (*From_join_type_clauseContext) IsFrom_join_type_clauseContext() {}

func NewFrom_join_type_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_join_type_clauseContext {
	var p = new(From_join_type_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_from_join_type_clause

	return p
}

func (s *From_join_type_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *From_join_type_clauseContext) T_JOIN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_JOIN, 0)
}

func (s *From_join_type_clauseContext) T_INNER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INNER, 0)
}

func (s *From_join_type_clauseContext) T_LEFT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LEFT, 0)
}

func (s *From_join_type_clauseContext) T_RIGHT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RIGHT, 0)
}

func (s *From_join_type_clauseContext) T_FULL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FULL, 0)
}

func (s *From_join_type_clauseContext) T_OUTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OUTER, 0)
}

func (s *From_join_type_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_join_type_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *From_join_type_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFrom_join_type_clause(s)
	}
}

func (s *From_join_type_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFrom_join_type_clause(s)
	}
}




func (p *HplsqlParser) From_join_type_clause() (localctx IFrom_join_type_clauseContext) {
	localctx = NewFrom_join_type_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, HplsqlParserRULE_from_join_type_clause)
	var _la int

	p.SetState(2492)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_INNER, HplsqlParserT_JOIN:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2484)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_INNER {
			{
				p.SetState(2483)
				p.Match(HplsqlParserT_INNER)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2486)
			p.Match(HplsqlParserT_JOIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_FULL, HplsqlParserT_LEFT, HplsqlParserT_RIGHT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2487)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_FULL || _la == HplsqlParserT_LEFT || _la == HplsqlParserT_RIGHT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2489)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_OUTER {
			{
				p.SetState(2488)
				p.Match(HplsqlParserT_OUTER)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2491)
			p.Match(HplsqlParserT_JOIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFrom_table_values_clauseContext is an interface to support dynamic dispatch.
type IFrom_table_values_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_TABLE() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	T_VALUES() antlr.TerminalNode
	AllFrom_table_values_row() []IFrom_table_values_rowContext
	From_table_values_row(i int) IFrom_table_values_rowContext
	T_CLOSE_P() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	From_alias_clause() IFrom_alias_clauseContext

	// IsFrom_table_values_clauseContext differentiates from other interfaces.
	IsFrom_table_values_clauseContext()
}

type From_table_values_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_table_values_clauseContext() *From_table_values_clauseContext {
	var p = new(From_table_values_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_table_values_clause
	return p
}

func InitEmptyFrom_table_values_clauseContext(p *From_table_values_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_table_values_clause
}

func (*From_table_values_clauseContext) IsFrom_table_values_clauseContext() {}

func NewFrom_table_values_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_table_values_clauseContext {
	var p = new(From_table_values_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_from_table_values_clause

	return p
}

func (s *From_table_values_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *From_table_values_clauseContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLE, 0)
}

func (s *From_table_values_clauseContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *From_table_values_clauseContext) T_VALUES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VALUES, 0)
}

func (s *From_table_values_clauseContext) AllFrom_table_values_row() []IFrom_table_values_rowContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFrom_table_values_rowContext); ok {
			len++
		}
	}

	tst := make([]IFrom_table_values_rowContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFrom_table_values_rowContext); ok {
			tst[i] = t.(IFrom_table_values_rowContext)
			i++
		}
	}

	return tst
}

func (s *From_table_values_clauseContext) From_table_values_row(i int) IFrom_table_values_rowContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_table_values_rowContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_table_values_rowContext)
}

func (s *From_table_values_clauseContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *From_table_values_clauseContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *From_table_values_clauseContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *From_table_values_clauseContext) From_alias_clause() IFrom_alias_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_alias_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_alias_clauseContext)
}

func (s *From_table_values_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_table_values_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *From_table_values_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFrom_table_values_clause(s)
	}
}

func (s *From_table_values_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFrom_table_values_clause(s)
	}
}




func (p *HplsqlParser) From_table_values_clause() (localctx IFrom_table_values_clauseContext) {
	localctx = NewFrom_table_values_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, HplsqlParserRULE_from_table_values_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2494)
		p.Match(HplsqlParserT_TABLE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2495)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2496)
		p.Match(HplsqlParserT_VALUES)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2497)
		p.From_table_values_row()
	}
	p.SetState(2502)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(2498)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2499)
			p.From_table_values_row()
		}


		p.SetState(2504)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2505)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2507)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 304, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2506)
			p.From_alias_clause()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFrom_table_values_rowContext is an interface to support dynamic dispatch.
type IFrom_table_values_rowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsFrom_table_values_rowContext differentiates from other interfaces.
	IsFrom_table_values_rowContext()
}

type From_table_values_rowContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_table_values_rowContext() *From_table_values_rowContext {
	var p = new(From_table_values_rowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_table_values_row
	return p
}

func InitEmptyFrom_table_values_rowContext(p *From_table_values_rowContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_table_values_row
}

func (*From_table_values_rowContext) IsFrom_table_values_rowContext() {}

func NewFrom_table_values_rowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_table_values_rowContext {
	var p = new(From_table_values_rowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_from_table_values_row

	return p
}

func (s *From_table_values_rowContext) GetParser() antlr.Parser { return s.parser }

func (s *From_table_values_rowContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *From_table_values_rowContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *From_table_values_rowContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *From_table_values_rowContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *From_table_values_rowContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *From_table_values_rowContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *From_table_values_rowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_table_values_rowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *From_table_values_rowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFrom_table_values_row(s)
	}
}

func (s *From_table_values_rowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFrom_table_values_row(s)
	}
}




func (p *HplsqlParser) From_table_values_row() (localctx IFrom_table_values_rowContext) {
	localctx = NewFrom_table_values_rowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, HplsqlParserRULE_from_table_values_row)
	var _la int

	p.SetState(2521)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 306, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2509)
			p.expr(0)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2510)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2511)
			p.expr(0)
		}
		p.SetState(2516)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(2512)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2513)
				p.expr(0)
			}


			p.SetState(2518)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2519)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFrom_alias_clauseContext is an interface to support dynamic dispatch.
type IFrom_alias_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Qident() IQidentContext
	T_AS() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	AllL_ID() []antlr.TerminalNode
	L_ID(i int) antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsFrom_alias_clauseContext differentiates from other interfaces.
	IsFrom_alias_clauseContext()
}

type From_alias_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrom_alias_clauseContext() *From_alias_clauseContext {
	var p = new(From_alias_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_alias_clause
	return p
}

func InitEmptyFrom_alias_clauseContext(p *From_alias_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_from_alias_clause
}

func (*From_alias_clauseContext) IsFrom_alias_clauseContext() {}

func NewFrom_alias_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *From_alias_clauseContext {
	var p = new(From_alias_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_from_alias_clause

	return p
}

func (s *From_alias_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *From_alias_clauseContext) Qident() IQidentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *From_alias_clauseContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *From_alias_clauseContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *From_alias_clauseContext) AllL_ID() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserL_ID)
}

func (s *From_alias_clauseContext) L_ID(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, i)
}

func (s *From_alias_clauseContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *From_alias_clauseContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *From_alias_clauseContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *From_alias_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *From_alias_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *From_alias_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFrom_alias_clause(s)
	}
}

func (s *From_alias_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFrom_alias_clause(s)
	}
}




func (p *HplsqlParser) From_alias_clause() (localctx IFrom_alias_clauseContext) {
	localctx = NewFrom_alias_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, HplsqlParserRULE_from_alias_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2523)

	if !(!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "EXEC") &&
	        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "EXECUTE") && 
	        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "INNER") &&
	        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "LEFT") &&
	        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "GROUP") &&
	        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "ORDER") &&
	        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "LIMIT") &&
	        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "WITH")) {
		p.SetError(antlr.NewFailedPredicateException(p, "!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"EXEC\") &&\n        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"EXECUTE\") && \n        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"INNER\") &&\n        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"LEFT\") &&\n        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"GROUP\") &&\n        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"ORDER\") &&\n        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"LIMIT\") &&\n        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"WITH\")", ""))
		goto errorExit
	}
	p.SetState(2525)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 307, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2524)
			p.Match(HplsqlParserT_AS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(2527)
		p.Qident()
	}
	p.SetState(2538)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 309, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2528)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2529)
			p.Match(HplsqlParserL_ID)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2534)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(2530)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2531)
				p.Match(HplsqlParserL_ID)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


			p.SetState(2536)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2537)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITable_nameContext is an interface to support dynamic dispatch.
type ITable_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Qident() IQidentContext

	// IsTable_nameContext differentiates from other interfaces.
	IsTable_nameContext()
}

type Table_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTable_nameContext() *Table_nameContext {
	var p = new(Table_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_table_name
	return p
}

func InitEmptyTable_nameContext(p *Table_nameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_table_name
}

func (*Table_nameContext) IsTable_nameContext() {}

func NewTable_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Table_nameContext {
	var p = new(Table_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_table_name

	return p
}

func (s *Table_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Table_nameContext) Qident() IQidentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Table_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Table_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Table_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterTable_name(s)
	}
}

func (s *Table_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitTable_name(s)
	}
}




func (p *HplsqlParser) Table_name() (localctx ITable_nameContext) {
	localctx = NewTable_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, HplsqlParserRULE_table_name)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2540)
		p.Qident()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWhere_clauseContext is an interface to support dynamic dispatch.
type IWhere_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_WHERE() antlr.TerminalNode
	Bool_expr() IBool_exprContext

	// IsWhere_clauseContext differentiates from other interfaces.
	IsWhere_clauseContext()
}

type Where_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhere_clauseContext() *Where_clauseContext {
	var p = new(Where_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_where_clause
	return p
}

func InitEmptyWhere_clauseContext(p *Where_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_where_clause
}

func (*Where_clauseContext) IsWhere_clauseContext() {}

func NewWhere_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Where_clauseContext {
	var p = new(Where_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_where_clause

	return p
}

func (s *Where_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Where_clauseContext) T_WHERE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WHERE, 0)
}

func (s *Where_clauseContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *Where_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Where_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Where_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterWhere_clause(s)
	}
}

func (s *Where_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitWhere_clause(s)
	}
}




func (p *HplsqlParser) Where_clause() (localctx IWhere_clauseContext) {
	localctx = NewWhere_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, HplsqlParserRULE_where_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2542)
		p.Match(HplsqlParserT_WHERE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2543)
		p.bool_expr(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IGroup_by_clauseContext is an interface to support dynamic dispatch.
type IGroup_by_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_GROUP() antlr.TerminalNode
	T_BY() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsGroup_by_clauseContext differentiates from other interfaces.
	IsGroup_by_clauseContext()
}

type Group_by_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroup_by_clauseContext() *Group_by_clauseContext {
	var p = new(Group_by_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_group_by_clause
	return p
}

func InitEmptyGroup_by_clauseContext(p *Group_by_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_group_by_clause
}

func (*Group_by_clauseContext) IsGroup_by_clauseContext() {}

func NewGroup_by_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Group_by_clauseContext {
	var p = new(Group_by_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_group_by_clause

	return p
}

func (s *Group_by_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Group_by_clauseContext) T_GROUP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GROUP, 0)
}

func (s *Group_by_clauseContext) T_BY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BY, 0)
}

func (s *Group_by_clauseContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Group_by_clauseContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Group_by_clauseContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Group_by_clauseContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Group_by_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Group_by_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Group_by_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterGroup_by_clause(s)
	}
}

func (s *Group_by_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitGroup_by_clause(s)
	}
}




func (p *HplsqlParser) Group_by_clause() (localctx IGroup_by_clauseContext) {
	localctx = NewGroup_by_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, HplsqlParserRULE_group_by_clause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2545)
		p.Match(HplsqlParserT_GROUP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2546)
		p.Match(HplsqlParserT_BY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2547)
		p.expr(0)
	}
	p.SetState(2552)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 310, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2548)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2549)
				p.expr(0)
			}


		}
		p.SetState(2554)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 310, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IHaving_clauseContext is an interface to support dynamic dispatch.
type IHaving_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_HAVING() antlr.TerminalNode
	Bool_expr() IBool_exprContext

	// IsHaving_clauseContext differentiates from other interfaces.
	IsHaving_clauseContext()
}

type Having_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHaving_clauseContext() *Having_clauseContext {
	var p = new(Having_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_having_clause
	return p
}

func InitEmptyHaving_clauseContext(p *Having_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_having_clause
}

func (*Having_clauseContext) IsHaving_clauseContext() {}

func NewHaving_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Having_clauseContext {
	var p = new(Having_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_having_clause

	return p
}

func (s *Having_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Having_clauseContext) T_HAVING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HAVING, 0)
}

func (s *Having_clauseContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *Having_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Having_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Having_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterHaving_clause(s)
	}
}

func (s *Having_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitHaving_clause(s)
	}
}




func (p *HplsqlParser) Having_clause() (localctx IHaving_clauseContext) {
	localctx = NewHaving_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, HplsqlParserRULE_having_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2555)
		p.Match(HplsqlParserT_HAVING)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2556)
		p.bool_expr(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQualify_clauseContext is an interface to support dynamic dispatch.
type IQualify_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_QUALIFY() antlr.TerminalNode
	Bool_expr() IBool_exprContext

	// IsQualify_clauseContext differentiates from other interfaces.
	IsQualify_clauseContext()
}

type Qualify_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualify_clauseContext() *Qualify_clauseContext {
	var p = new(Qualify_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_qualify_clause
	return p
}

func InitEmptyQualify_clauseContext(p *Qualify_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_qualify_clause
}

func (*Qualify_clauseContext) IsQualify_clauseContext() {}

func NewQualify_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Qualify_clauseContext {
	var p = new(Qualify_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_qualify_clause

	return p
}

func (s *Qualify_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Qualify_clauseContext) T_QUALIFY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_QUALIFY, 0)
}

func (s *Qualify_clauseContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *Qualify_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Qualify_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Qualify_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterQualify_clause(s)
	}
}

func (s *Qualify_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitQualify_clause(s)
	}
}




func (p *HplsqlParser) Qualify_clause() (localctx IQualify_clauseContext) {
	localctx = NewQualify_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, HplsqlParserRULE_qualify_clause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2558)
		p.Match(HplsqlParserT_QUALIFY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2559)
		p.bool_expr(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOrder_by_clauseContext is an interface to support dynamic dispatch.
type IOrder_by_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ORDER() antlr.TerminalNode
	T_BY() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	AllT_ASC() []antlr.TerminalNode
	T_ASC(i int) antlr.TerminalNode
	AllT_DESC() []antlr.TerminalNode
	T_DESC(i int) antlr.TerminalNode

	// IsOrder_by_clauseContext differentiates from other interfaces.
	IsOrder_by_clauseContext()
}

type Order_by_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrder_by_clauseContext() *Order_by_clauseContext {
	var p = new(Order_by_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_order_by_clause
	return p
}

func InitEmptyOrder_by_clauseContext(p *Order_by_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_order_by_clause
}

func (*Order_by_clauseContext) IsOrder_by_clauseContext() {}

func NewOrder_by_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Order_by_clauseContext {
	var p = new(Order_by_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_order_by_clause

	return p
}

func (s *Order_by_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Order_by_clauseContext) T_ORDER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ORDER, 0)
}

func (s *Order_by_clauseContext) T_BY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BY, 0)
}

func (s *Order_by_clauseContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Order_by_clauseContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Order_by_clauseContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Order_by_clauseContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Order_by_clauseContext) AllT_ASC() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_ASC)
}

func (s *Order_by_clauseContext) T_ASC(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ASC, i)
}

func (s *Order_by_clauseContext) AllT_DESC() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_DESC)
}

func (s *Order_by_clauseContext) T_DESC(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DESC, i)
}

func (s *Order_by_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Order_by_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Order_by_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterOrder_by_clause(s)
	}
}

func (s *Order_by_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitOrder_by_clause(s)
	}
}




func (p *HplsqlParser) Order_by_clause() (localctx IOrder_by_clauseContext) {
	localctx = NewOrder_by_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, HplsqlParserRULE_order_by_clause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2561)
		p.Match(HplsqlParserT_ORDER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2562)
		p.Match(HplsqlParserT_BY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2563)
		p.expr(0)
	}
	p.SetState(2565)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 311, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2564)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(2574)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 313, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2567)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2568)
				p.expr(0)
			}
			p.SetState(2570)
			p.GetErrorHandler().Sync(p)


			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 312, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(2569)
					_la = p.GetTokenStream().LA(1)

					if !(_la == HplsqlParserT_ASC || _la == HplsqlParserT_DESC) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

				} else if p.HasError() { // JIM
					goto errorExit
			}


		}
		p.SetState(2576)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 313, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelect_optionsContext is an interface to support dynamic dispatch.
type ISelect_optionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSelect_options_item() []ISelect_options_itemContext
	Select_options_item(i int) ISelect_options_itemContext

	// IsSelect_optionsContext differentiates from other interfaces.
	IsSelect_optionsContext()
}

type Select_optionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_optionsContext() *Select_optionsContext {
	var p = new(Select_optionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_options
	return p
}

func InitEmptySelect_optionsContext(p *Select_optionsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_options
}

func (*Select_optionsContext) IsSelect_optionsContext() {}

func NewSelect_optionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_optionsContext {
	var p = new(Select_optionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_select_options

	return p
}

func (s *Select_optionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_optionsContext) AllSelect_options_item() []ISelect_options_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelect_options_itemContext); ok {
			len++
		}
	}

	tst := make([]ISelect_options_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelect_options_itemContext); ok {
			tst[i] = t.(ISelect_options_itemContext)
			i++
		}
	}

	return tst
}

func (s *Select_optionsContext) Select_options_item(i int) ISelect_options_itemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_options_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_options_itemContext)
}

func (s *Select_optionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_optionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_optionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSelect_options(s)
	}
}

func (s *Select_optionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSelect_options(s)
	}
}




func (p *HplsqlParser) Select_options() (localctx ISelect_optionsContext) {
	localctx = NewSelect_optionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, HplsqlParserRULE_select_options)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2578)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				{
					p.SetState(2577)
					p.Select_options_item()
				}




		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(2580)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 314, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISelect_options_itemContext is an interface to support dynamic dispatch.
type ISelect_options_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_LIMIT() antlr.TerminalNode
	Expr() IExprContext
	T_WITH() antlr.TerminalNode
	T_RR() antlr.TerminalNode
	T_RS() antlr.TerminalNode
	T_CS() antlr.TerminalNode
	T_UR() antlr.TerminalNode
	T_USE() antlr.TerminalNode
	T_AND() antlr.TerminalNode
	T_KEEP() antlr.TerminalNode
	T_LOCKS() antlr.TerminalNode
	T_EXCLUSIVE() antlr.TerminalNode
	T_UPDATE() antlr.TerminalNode
	T_SHARE() antlr.TerminalNode

	// IsSelect_options_itemContext differentiates from other interfaces.
	IsSelect_options_itemContext()
}

type Select_options_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_options_itemContext() *Select_options_itemContext {
	var p = new(Select_options_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_options_item
	return p
}

func InitEmptySelect_options_itemContext(p *Select_options_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_select_options_item
}

func (*Select_options_itemContext) IsSelect_options_itemContext() {}

func NewSelect_options_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_options_itemContext {
	var p = new(Select_options_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_select_options_item

	return p
}

func (s *Select_options_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Select_options_itemContext) T_LIMIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LIMIT, 0)
}

func (s *Select_options_itemContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Select_options_itemContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITH, 0)
}

func (s *Select_options_itemContext) T_RR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RR, 0)
}

func (s *Select_options_itemContext) T_RS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RS, 0)
}

func (s *Select_options_itemContext) T_CS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CS, 0)
}

func (s *Select_options_itemContext) T_UR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UR, 0)
}

func (s *Select_options_itemContext) T_USE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_USE, 0)
}

func (s *Select_options_itemContext) T_AND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AND, 0)
}

func (s *Select_options_itemContext) T_KEEP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_KEEP, 0)
}

func (s *Select_options_itemContext) T_LOCKS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCKS, 0)
}

func (s *Select_options_itemContext) T_EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXCLUSIVE, 0)
}

func (s *Select_options_itemContext) T_UPDATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UPDATE, 0)
}

func (s *Select_options_itemContext) T_SHARE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SHARE, 0)
}

func (s *Select_options_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_options_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Select_options_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSelect_options_item(s)
	}
}

func (s *Select_options_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSelect_options_item(s)
	}
}




func (p *HplsqlParser) Select_options_item() (localctx ISelect_options_itemContext) {
	localctx = NewSelect_options_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, HplsqlParserRULE_select_options_item)
	var _la int

	p.SetState(2593)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_LIMIT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2582)
			p.Match(HplsqlParserT_LIMIT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2583)
			p.expr(0)
		}


	case HplsqlParserT_WITH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2584)
			p.Match(HplsqlParserT_WITH)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2585)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_CS || ((int64((_la - 247)) & ^0x3f) == 0 && ((int64(1) << (_la - 247)) & 144115188075855875) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2591)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 315, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2586)
				p.Match(HplsqlParserT_USE)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2587)
				p.Match(HplsqlParserT_AND)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2588)
				p.Match(HplsqlParserT_KEEP)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2589)
				_la = p.GetTokenStream().LA(1)

				if !(_la == HplsqlParserT_EXCLUSIVE || _la == HplsqlParserT_SHARE || _la == HplsqlParserT_UPDATE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2590)
				p.Match(HplsqlParserT_LOCKS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUpdate_stmtContext is an interface to support dynamic dispatch.
type IUpdate_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_UPDATE() antlr.TerminalNode
	Update_table() IUpdate_tableContext
	T_SET() antlr.TerminalNode
	Update_assignment() IUpdate_assignmentContext
	Where_clause() IWhere_clauseContext
	Update_upsert() IUpdate_upsertContext

	// IsUpdate_stmtContext differentiates from other interfaces.
	IsUpdate_stmtContext()
}

type Update_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdate_stmtContext() *Update_stmtContext {
	var p = new(Update_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_update_stmt
	return p
}

func InitEmptyUpdate_stmtContext(p *Update_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_update_stmt
}

func (*Update_stmtContext) IsUpdate_stmtContext() {}

func NewUpdate_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Update_stmtContext {
	var p = new(Update_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_update_stmt

	return p
}

func (s *Update_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Update_stmtContext) T_UPDATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UPDATE, 0)
}

func (s *Update_stmtContext) Update_table() IUpdate_tableContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdate_tableContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdate_tableContext)
}

func (s *Update_stmtContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Update_stmtContext) Update_assignment() IUpdate_assignmentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdate_assignmentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdate_assignmentContext)
}

func (s *Update_stmtContext) Where_clause() IWhere_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhere_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhere_clauseContext)
}

func (s *Update_stmtContext) Update_upsert() IUpdate_upsertContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdate_upsertContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdate_upsertContext)
}

func (s *Update_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Update_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Update_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterUpdate_stmt(s)
	}
}

func (s *Update_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitUpdate_stmt(s)
	}
}




func (p *HplsqlParser) Update_stmt() (localctx IUpdate_stmtContext) {
	localctx = NewUpdate_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, HplsqlParserRULE_update_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2595)
		p.Match(HplsqlParserT_UPDATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2596)
		p.Update_table()
	}
	{
		p.SetState(2597)
		p.Match(HplsqlParserT_SET)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2598)
		p.Update_assignment()
	}
	p.SetState(2600)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 317, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2599)
			p.Where_clause()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(2603)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 318, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2602)
			p.Update_upsert()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUpdate_assignmentContext is an interface to support dynamic dispatch.
type IUpdate_assignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAssignment_stmt_item() []IAssignment_stmt_itemContext
	Assignment_stmt_item(i int) IAssignment_stmt_itemContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsUpdate_assignmentContext differentiates from other interfaces.
	IsUpdate_assignmentContext()
}

type Update_assignmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdate_assignmentContext() *Update_assignmentContext {
	var p = new(Update_assignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_update_assignment
	return p
}

func InitEmptyUpdate_assignmentContext(p *Update_assignmentContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_update_assignment
}

func (*Update_assignmentContext) IsUpdate_assignmentContext() {}

func NewUpdate_assignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Update_assignmentContext {
	var p = new(Update_assignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_update_assignment

	return p
}

func (s *Update_assignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *Update_assignmentContext) AllAssignment_stmt_item() []IAssignment_stmt_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignment_stmt_itemContext); ok {
			len++
		}
	}

	tst := make([]IAssignment_stmt_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignment_stmt_itemContext); ok {
			tst[i] = t.(IAssignment_stmt_itemContext)
			i++
		}
	}

	return tst
}

func (s *Update_assignmentContext) Assignment_stmt_item(i int) IAssignment_stmt_itemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignment_stmt_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignment_stmt_itemContext)
}

func (s *Update_assignmentContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Update_assignmentContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Update_assignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Update_assignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Update_assignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterUpdate_assignment(s)
	}
}

func (s *Update_assignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitUpdate_assignment(s)
	}
}




func (p *HplsqlParser) Update_assignment() (localctx IUpdate_assignmentContext) {
	localctx = NewUpdate_assignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, HplsqlParserRULE_update_assignment)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2605)
		p.Assignment_stmt_item()
	}
	p.SetState(2610)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 319, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2606)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2607)
				p.Assignment_stmt_item()
			}


		}
		p.SetState(2612)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 319, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUpdate_tableContext is an interface to support dynamic dispatch.
type IUpdate_tableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Table_name() ITable_nameContext
	T_OPEN_P() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	T_CLOSE_P() antlr.TerminalNode
	Qident() IQidentContext
	From_clause() IFrom_clauseContext
	T_AS() antlr.TerminalNode

	// IsUpdate_tableContext differentiates from other interfaces.
	IsUpdate_tableContext()
}

type Update_tableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdate_tableContext() *Update_tableContext {
	var p = new(Update_tableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_update_table
	return p
}

func InitEmptyUpdate_tableContext(p *Update_tableContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_update_table
}

func (*Update_tableContext) IsUpdate_tableContext() {}

func NewUpdate_tableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Update_tableContext {
	var p = new(Update_tableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_update_table

	return p
}

func (s *Update_tableContext) GetParser() antlr.Parser { return s.parser }

func (s *Update_tableContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Update_tableContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Update_tableContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Update_tableContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Update_tableContext) Qident() IQidentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Update_tableContext) From_clause() IFrom_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrom_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrom_clauseContext)
}

func (s *Update_tableContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Update_tableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Update_tableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Update_tableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterUpdate_table(s)
	}
}

func (s *Update_tableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitUpdate_table(s)
	}
}




func (p *HplsqlParser) Update_table() (localctx IUpdate_tableContext) {
	localctx = NewUpdate_tableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, HplsqlParserRULE_update_table)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(2621)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_SUB, HplsqlParserL_ID:
		{
			p.SetState(2613)
			p.Table_name()
		}
		p.SetState(2615)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 320, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2614)
				p.From_clause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case HplsqlParserT_OPEN_P:
		{
			p.SetState(2617)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2618)
			p.Select_stmt()
		}
		{
			p.SetState(2619)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(2627)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 323, p.GetParserRuleContext()) == 1 {
		p.SetState(2624)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 322, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2623)
				p.Match(HplsqlParserT_AS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(2626)
			p.Qident()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUpdate_upsertContext is an interface to support dynamic dispatch.
type IUpdate_upsertContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ELSE() antlr.TerminalNode
	Insert_stmt() IInsert_stmtContext

	// IsUpdate_upsertContext differentiates from other interfaces.
	IsUpdate_upsertContext()
}

type Update_upsertContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdate_upsertContext() *Update_upsertContext {
	var p = new(Update_upsertContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_update_upsert
	return p
}

func InitEmptyUpdate_upsertContext(p *Update_upsertContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_update_upsert
}

func (*Update_upsertContext) IsUpdate_upsertContext() {}

func NewUpdate_upsertContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Update_upsertContext {
	var p = new(Update_upsertContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_update_upsert

	return p
}

func (s *Update_upsertContext) GetParser() antlr.Parser { return s.parser }

func (s *Update_upsertContext) T_ELSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ELSE, 0)
}

func (s *Update_upsertContext) Insert_stmt() IInsert_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_stmtContext)
}

func (s *Update_upsertContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Update_upsertContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Update_upsertContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterUpdate_upsert(s)
	}
}

func (s *Update_upsertContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitUpdate_upsert(s)
	}
}




func (p *HplsqlParser) Update_upsert() (localctx IUpdate_upsertContext) {
	localctx = NewUpdate_upsertContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, HplsqlParserRULE_update_upsert)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2629)
		p.Match(HplsqlParserT_ELSE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2630)
		p.Insert_stmt()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IMerge_stmtContext is an interface to support dynamic dispatch.
type IMerge_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_MERGE() antlr.TerminalNode
	T_INTO() antlr.TerminalNode
	AllMerge_table() []IMerge_tableContext
	Merge_table(i int) IMerge_tableContext
	T_USING() antlr.TerminalNode
	T_ON() antlr.TerminalNode
	Bool_expr() IBool_exprContext
	AllMerge_condition() []IMerge_conditionContext
	Merge_condition(i int) IMerge_conditionContext

	// IsMerge_stmtContext differentiates from other interfaces.
	IsMerge_stmtContext()
}

type Merge_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMerge_stmtContext() *Merge_stmtContext {
	var p = new(Merge_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_merge_stmt
	return p
}

func InitEmptyMerge_stmtContext(p *Merge_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_merge_stmt
}

func (*Merge_stmtContext) IsMerge_stmtContext() {}

func NewMerge_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Merge_stmtContext {
	var p = new(Merge_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_merge_stmt

	return p
}

func (s *Merge_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Merge_stmtContext) T_MERGE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MERGE, 0)
}

func (s *Merge_stmtContext) T_INTO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTO, 0)
}

func (s *Merge_stmtContext) AllMerge_table() []IMerge_tableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMerge_tableContext); ok {
			len++
		}
	}

	tst := make([]IMerge_tableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMerge_tableContext); ok {
			tst[i] = t.(IMerge_tableContext)
			i++
		}
	}

	return tst
}

func (s *Merge_stmtContext) Merge_table(i int) IMerge_tableContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMerge_tableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMerge_tableContext)
}

func (s *Merge_stmtContext) T_USING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_USING, 0)
}

func (s *Merge_stmtContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *Merge_stmtContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *Merge_stmtContext) AllMerge_condition() []IMerge_conditionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMerge_conditionContext); ok {
			len++
		}
	}

	tst := make([]IMerge_conditionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMerge_conditionContext); ok {
			tst[i] = t.(IMerge_conditionContext)
			i++
		}
	}

	return tst
}

func (s *Merge_stmtContext) Merge_condition(i int) IMerge_conditionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMerge_conditionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMerge_conditionContext)
}

func (s *Merge_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Merge_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Merge_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterMerge_stmt(s)
	}
}

func (s *Merge_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitMerge_stmt(s)
	}
}




func (p *HplsqlParser) Merge_stmt() (localctx IMerge_stmtContext) {
	localctx = NewMerge_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, HplsqlParserRULE_merge_stmt)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2632)
		p.Match(HplsqlParserT_MERGE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2633)
		p.Match(HplsqlParserT_INTO)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2634)
		p.Merge_table()
	}
	{
		p.SetState(2635)
		p.Match(HplsqlParserT_USING)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2636)
		p.Merge_table()
	}
	{
		p.SetState(2637)
		p.Match(HplsqlParserT_ON)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2638)
		p.bool_expr(0)
	}
	p.SetState(2640)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				{
					p.SetState(2639)
					p.Merge_condition()
				}




		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(2642)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 324, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IMerge_tableContext is an interface to support dynamic dispatch.
type IMerge_tableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Table_name() ITable_nameContext
	Qident() IQidentContext
	T_OPEN_P() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	T_CLOSE_P() antlr.TerminalNode
	T_AS() antlr.TerminalNode

	// IsMerge_tableContext differentiates from other interfaces.
	IsMerge_tableContext()
}

type Merge_tableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMerge_tableContext() *Merge_tableContext {
	var p = new(Merge_tableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_merge_table
	return p
}

func InitEmptyMerge_tableContext(p *Merge_tableContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_merge_table
}

func (*Merge_tableContext) IsMerge_tableContext() {}

func NewMerge_tableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Merge_tableContext {
	var p = new(Merge_tableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_merge_table

	return p
}

func (s *Merge_tableContext) GetParser() antlr.Parser { return s.parser }

func (s *Merge_tableContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Merge_tableContext) Qident() IQidentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Merge_tableContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Merge_tableContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Merge_tableContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Merge_tableContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Merge_tableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Merge_tableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Merge_tableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterMerge_table(s)
	}
}

func (s *Merge_tableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitMerge_table(s)
	}
}




func (p *HplsqlParser) Merge_table() (localctx IMerge_tableContext) {
	localctx = NewMerge_tableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, HplsqlParserRULE_merge_table)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(2649)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_SUB, HplsqlParserL_ID:
		{
			p.SetState(2644)
			p.Table_name()
		}


	case HplsqlParserT_OPEN_P:
		{
			p.SetState(2645)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2646)
			p.Select_stmt()
		}
		{
			p.SetState(2647)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}




	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(2655)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 327, p.GetParserRuleContext()) == 1 {
		p.SetState(2652)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 326, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2651)
				p.Match(HplsqlParserT_AS)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(2654)
			p.Qident()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IMerge_conditionContext is an interface to support dynamic dispatch.
type IMerge_conditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_WHEN() antlr.TerminalNode
	T_MATCHED() antlr.TerminalNode
	T_THEN() antlr.TerminalNode
	Merge_action() IMerge_actionContext
	T_NOT() antlr.TerminalNode
	T_AND() antlr.TerminalNode
	Bool_expr() IBool_exprContext
	T_ELSE() antlr.TerminalNode
	T_IGNORE() antlr.TerminalNode

	// IsMerge_conditionContext differentiates from other interfaces.
	IsMerge_conditionContext()
}

type Merge_conditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMerge_conditionContext() *Merge_conditionContext {
	var p = new(Merge_conditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_merge_condition
	return p
}

func InitEmptyMerge_conditionContext(p *Merge_conditionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_merge_condition
}

func (*Merge_conditionContext) IsMerge_conditionContext() {}

func NewMerge_conditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Merge_conditionContext {
	var p = new(Merge_conditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_merge_condition

	return p
}

func (s *Merge_conditionContext) GetParser() antlr.Parser { return s.parser }

func (s *Merge_conditionContext) T_WHEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WHEN, 0)
}

func (s *Merge_conditionContext) T_MATCHED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MATCHED, 0)
}

func (s *Merge_conditionContext) T_THEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_THEN, 0)
}

func (s *Merge_conditionContext) Merge_action() IMerge_actionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMerge_actionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMerge_actionContext)
}

func (s *Merge_conditionContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Merge_conditionContext) T_AND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AND, 0)
}

func (s *Merge_conditionContext) Bool_expr() IBool_exprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *Merge_conditionContext) T_ELSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ELSE, 0)
}

func (s *Merge_conditionContext) T_IGNORE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IGNORE, 0)
}

func (s *Merge_conditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Merge_conditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Merge_conditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterMerge_condition(s)
	}
}

func (s *Merge_conditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitMerge_condition(s)
	}
}




func (p *HplsqlParser) Merge_condition() (localctx IMerge_conditionContext) {
	localctx = NewMerge_conditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, HplsqlParserRULE_merge_condition)
	var _la int

	p.SetState(2670)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_WHEN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2657)
			p.Match(HplsqlParserT_WHEN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2659)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_NOT {
			{
				p.SetState(2658)
				p.Match(HplsqlParserT_NOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2661)
			p.Match(HplsqlParserT_MATCHED)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2664)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_AND {
			{
				p.SetState(2662)
				p.Match(HplsqlParserT_AND)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2663)
				p.bool_expr(0)
			}

		}
		{
			p.SetState(2666)
			p.Match(HplsqlParserT_THEN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2667)
			p.Merge_action()
		}


	case HplsqlParserT_ELSE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2668)
			p.Match(HplsqlParserT_ELSE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2669)
			p.Match(HplsqlParserT_IGNORE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IMerge_actionContext is an interface to support dynamic dispatch.
type IMerge_actionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_INSERT() antlr.TerminalNode
	T_VALUES() antlr.TerminalNode
	Insert_stmt_row() IInsert_stmt_rowContext
	Insert_stmt_cols() IInsert_stmt_colsContext
	T_UPDATE() antlr.TerminalNode
	T_SET() antlr.TerminalNode
	AllAssignment_stmt_item() []IAssignment_stmt_itemContext
	Assignment_stmt_item(i int) IAssignment_stmt_itemContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	Where_clause() IWhere_clauseContext
	T_DELETE() antlr.TerminalNode

	// IsMerge_actionContext differentiates from other interfaces.
	IsMerge_actionContext()
}

type Merge_actionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMerge_actionContext() *Merge_actionContext {
	var p = new(Merge_actionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_merge_action
	return p
}

func InitEmptyMerge_actionContext(p *Merge_actionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_merge_action
}

func (*Merge_actionContext) IsMerge_actionContext() {}

func NewMerge_actionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Merge_actionContext {
	var p = new(Merge_actionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_merge_action

	return p
}

func (s *Merge_actionContext) GetParser() antlr.Parser { return s.parser }

func (s *Merge_actionContext) T_INSERT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INSERT, 0)
}

func (s *Merge_actionContext) T_VALUES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VALUES, 0)
}

func (s *Merge_actionContext) Insert_stmt_row() IInsert_stmt_rowContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_stmt_rowContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_stmt_rowContext)
}

func (s *Merge_actionContext) Insert_stmt_cols() IInsert_stmt_colsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsert_stmt_colsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsert_stmt_colsContext)
}

func (s *Merge_actionContext) T_UPDATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UPDATE, 0)
}

func (s *Merge_actionContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Merge_actionContext) AllAssignment_stmt_item() []IAssignment_stmt_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignment_stmt_itemContext); ok {
			len++
		}
	}

	tst := make([]IAssignment_stmt_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignment_stmt_itemContext); ok {
			tst[i] = t.(IAssignment_stmt_itemContext)
			i++
		}
	}

	return tst
}

func (s *Merge_actionContext) Assignment_stmt_item(i int) IAssignment_stmt_itemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignment_stmt_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignment_stmt_itemContext)
}

func (s *Merge_actionContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Merge_actionContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Merge_actionContext) Where_clause() IWhere_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhere_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhere_clauseContext)
}

func (s *Merge_actionContext) T_DELETE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DELETE, 0)
}

func (s *Merge_actionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Merge_actionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Merge_actionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterMerge_action(s)
	}
}

func (s *Merge_actionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitMerge_action(s)
	}
}




func (p *HplsqlParser) Merge_action() (localctx IMerge_actionContext) {
	localctx = NewMerge_actionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, HplsqlParserRULE_merge_action)
	var _la int

	var _alt int

	p.SetState(2692)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_INSERT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2672)
			p.Match(HplsqlParserT_INSERT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2674)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_OPEN_P {
			{
				p.SetState(2673)
				p.Insert_stmt_cols()
			}

		}
		{
			p.SetState(2676)
			p.Match(HplsqlParserT_VALUES)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2677)
			p.Insert_stmt_row()
		}


	case HplsqlParserT_UPDATE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2678)
			p.Match(HplsqlParserT_UPDATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2679)
			p.Match(HplsqlParserT_SET)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2680)
			p.Assignment_stmt_item()
		}
		p.SetState(2685)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 332, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2681)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(2682)
					p.Assignment_stmt_item()
				}


			}
			p.SetState(2687)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 332, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(2689)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 333, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2688)
				p.Where_clause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case HplsqlParserT_DELETE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2691)
			p.Match(HplsqlParserT_DELETE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDelete_stmtContext is an interface to support dynamic dispatch.
type IDelete_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_DELETE() antlr.TerminalNode
	Table_name() ITable_nameContext
	T_FROM() antlr.TerminalNode
	Delete_alias() IDelete_aliasContext
	Where_clause() IWhere_clauseContext
	T_ALL() antlr.TerminalNode

	// IsDelete_stmtContext differentiates from other interfaces.
	IsDelete_stmtContext()
}

type Delete_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelete_stmtContext() *Delete_stmtContext {
	var p = new(Delete_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_delete_stmt
	return p
}

func InitEmptyDelete_stmtContext(p *Delete_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_delete_stmt
}

func (*Delete_stmtContext) IsDelete_stmtContext() {}

func NewDelete_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delete_stmtContext {
	var p = new(Delete_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_delete_stmt

	return p
}

func (s *Delete_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Delete_stmtContext) T_DELETE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DELETE, 0)
}

func (s *Delete_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Delete_stmtContext) T_FROM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FROM, 0)
}

func (s *Delete_stmtContext) Delete_alias() IDelete_aliasContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelete_aliasContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelete_aliasContext)
}

func (s *Delete_stmtContext) Where_clause() IWhere_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhere_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhere_clauseContext)
}

func (s *Delete_stmtContext) T_ALL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALL, 0)
}

func (s *Delete_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delete_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Delete_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDelete_stmt(s)
	}
}

func (s *Delete_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDelete_stmt(s)
	}
}




func (p *HplsqlParser) Delete_stmt() (localctx IDelete_stmtContext) {
	localctx = NewDelete_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, HplsqlParserRULE_delete_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2694)
		p.Match(HplsqlParserT_DELETE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2696)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 335, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2695)
			p.Match(HplsqlParserT_FROM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(2698)
		p.Table_name()
	}
	p.SetState(2700)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 336, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2699)
			p.Delete_alias()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(2704)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 337, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2702)
			p.Where_clause()
		}

		} else if p.HasError() { // JIM
			goto errorExit} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 337, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(2703)
			p.Match(HplsqlParserT_ALL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDelete_aliasContext is an interface to support dynamic dispatch.
type IDelete_aliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Qident() IQidentContext
	T_AS() antlr.TerminalNode

	// IsDelete_aliasContext differentiates from other interfaces.
	IsDelete_aliasContext()
}

type Delete_aliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelete_aliasContext() *Delete_aliasContext {
	var p = new(Delete_aliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_delete_alias
	return p
}

func InitEmptyDelete_aliasContext(p *Delete_aliasContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_delete_alias
}

func (*Delete_aliasContext) IsDelete_aliasContext() {}

func NewDelete_aliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delete_aliasContext {
	var p = new(Delete_aliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_delete_alias

	return p
}

func (s *Delete_aliasContext) GetParser() antlr.Parser { return s.parser }

func (s *Delete_aliasContext) Qident() IQidentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Delete_aliasContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Delete_aliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delete_aliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Delete_aliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDelete_alias(s)
	}
}

func (s *Delete_aliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDelete_alias(s)
	}
}




func (p *HplsqlParser) Delete_alias() (localctx IDelete_aliasContext) {
	localctx = NewDelete_aliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, HplsqlParserRULE_delete_alias)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(2706)

	if !(!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "ALL")) {
		p.SetError(antlr.NewFailedPredicateException(p, "!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"ALL\")", ""))
		goto errorExit
	}
	p.SetState(2708)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 338, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2707)
			p.Match(HplsqlParserT_AS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(2710)
		p.Qident()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDescribe_stmtContext is an interface to support dynamic dispatch.
type IDescribe_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Table_name() ITable_nameContext
	T_DESCRIBE() antlr.TerminalNode
	T_DESC() antlr.TerminalNode
	T_TABLE() antlr.TerminalNode

	// IsDescribe_stmtContext differentiates from other interfaces.
	IsDescribe_stmtContext()
}

type Describe_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescribe_stmtContext() *Describe_stmtContext {
	var p = new(Describe_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_describe_stmt
	return p
}

func InitEmptyDescribe_stmtContext(p *Describe_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_describe_stmt
}

func (*Describe_stmtContext) IsDescribe_stmtContext() {}

func NewDescribe_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Describe_stmtContext {
	var p = new(Describe_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_describe_stmt

	return p
}

func (s *Describe_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Describe_stmtContext) Table_name() ITable_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITable_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITable_nameContext)
}

func (s *Describe_stmtContext) T_DESCRIBE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DESCRIBE, 0)
}

func (s *Describe_stmtContext) T_DESC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DESC, 0)
}

func (s *Describe_stmtContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLE, 0)
}

func (s *Describe_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Describe_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Describe_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDescribe_stmt(s)
	}
}

func (s *Describe_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDescribe_stmt(s)
	}
}




func (p *HplsqlParser) Describe_stmt() (localctx IDescribe_stmtContext) {
	localctx = NewDescribe_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, HplsqlParserRULE_describe_stmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2712)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_DESC || _la == HplsqlParserT_DESCRIBE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2714)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 339, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2713)
			p.Match(HplsqlParserT_TABLE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(2716)
		p.Table_name()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBool_exprContext is an interface to support dynamic dispatch.
type IBool_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN_P() antlr.TerminalNode
	AllBool_expr() []IBool_exprContext
	Bool_expr(i int) IBool_exprContext
	T_CLOSE_P() antlr.TerminalNode
	T_NOT() antlr.TerminalNode
	Bool_expr_atom() IBool_expr_atomContext
	Bool_expr_logical_operator() IBool_expr_logical_operatorContext

	// IsBool_exprContext differentiates from other interfaces.
	IsBool_exprContext()
}

type Bool_exprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_exprContext() *Bool_exprContext {
	var p = new(Bool_exprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr
	return p
}

func InitEmptyBool_exprContext(p *Bool_exprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr
}

func (*Bool_exprContext) IsBool_exprContext() {}

func NewBool_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_exprContext {
	var p = new(Bool_exprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_bool_expr

	return p
}

func (s *Bool_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_exprContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Bool_exprContext) AllBool_expr() []IBool_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBool_exprContext); ok {
			len++
		}
	}

	tst := make([]IBool_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBool_exprContext); ok {
			tst[i] = t.(IBool_exprContext)
			i++
		}
	}

	return tst
}

func (s *Bool_exprContext) Bool_expr(i int) IBool_exprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *Bool_exprContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Bool_exprContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Bool_exprContext) Bool_expr_atom() IBool_expr_atomContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_expr_atomContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_expr_atomContext)
}

func (s *Bool_exprContext) Bool_expr_logical_operator() IBool_expr_logical_operatorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_expr_logical_operatorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_expr_logical_operatorContext)
}

func (s *Bool_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Bool_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBool_expr(s)
	}
}

func (s *Bool_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBool_expr(s)
	}
}





func (p *HplsqlParser) Bool_expr() (localctx IBool_exprContext) {
	return p.bool_expr(0)
}

func (p *HplsqlParser) bool_expr(_p int) (localctx IBool_exprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBool_exprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBool_exprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 384
	p.EnterRecursionRule(localctx, 384, HplsqlParserRULE_bool_expr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2727)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 341, p.GetParserRuleContext()) {
	case 1:
		p.SetState(2720)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_NOT {
			{
				p.SetState(2719)
				p.Match(HplsqlParserT_NOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2722)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2723)
			p.bool_expr(0)
		}
		{
			p.SetState(2724)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		{
			p.SetState(2726)
			p.Bool_expr_atom()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2735)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 342, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewBool_exprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, HplsqlParserRULE_bool_expr)
			p.SetState(2729)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			{
				p.SetState(2730)
				p.Bool_expr_logical_operator()
			}
			{
				p.SetState(2731)
				p.bool_expr(3)
			}


		}
		p.SetState(2737)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 342, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



	errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBool_expr_atomContext is an interface to support dynamic dispatch.
type IBool_expr_atomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Bool_expr_unary() IBool_expr_unaryContext
	Bool_expr_binary() IBool_expr_binaryContext
	Expr() IExprContext

	// IsBool_expr_atomContext differentiates from other interfaces.
	IsBool_expr_atomContext()
}

type Bool_expr_atomContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_expr_atomContext() *Bool_expr_atomContext {
	var p = new(Bool_expr_atomContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_atom
	return p
}

func InitEmptyBool_expr_atomContext(p *Bool_expr_atomContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_atom
}

func (*Bool_expr_atomContext) IsBool_expr_atomContext() {}

func NewBool_expr_atomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_expr_atomContext {
	var p = new(Bool_expr_atomContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_bool_expr_atom

	return p
}

func (s *Bool_expr_atomContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_expr_atomContext) Bool_expr_unary() IBool_expr_unaryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_expr_unaryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_expr_unaryContext)
}

func (s *Bool_expr_atomContext) Bool_expr_binary() IBool_expr_binaryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_expr_binaryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_expr_binaryContext)
}

func (s *Bool_expr_atomContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Bool_expr_atomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_expr_atomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Bool_expr_atomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBool_expr_atom(s)
	}
}

func (s *Bool_expr_atomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBool_expr_atom(s)
	}
}




func (p *HplsqlParser) Bool_expr_atom() (localctx IBool_expr_atomContext) {
	localctx = NewBool_expr_atomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, HplsqlParserRULE_bool_expr_atom)
	p.SetState(2741)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 343, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2738)
			p.Bool_expr_unary()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2739)
			p.Bool_expr_binary()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2740)
			p.expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBool_expr_unaryContext is an interface to support dynamic dispatch.
type IBool_expr_unaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_IS() antlr.TerminalNode
	T_NULL() antlr.TerminalNode
	T_NOT() antlr.TerminalNode
	T_BETWEEN() antlr.TerminalNode
	T_AND() antlr.TerminalNode
	T_EXISTS() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	T_CLOSE_P() antlr.TerminalNode
	Bool_expr_single_in() IBool_expr_single_inContext
	Bool_expr_multi_in() IBool_expr_multi_inContext

	// IsBool_expr_unaryContext differentiates from other interfaces.
	IsBool_expr_unaryContext()
}

type Bool_expr_unaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_expr_unaryContext() *Bool_expr_unaryContext {
	var p = new(Bool_expr_unaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_unary
	return p
}

func InitEmptyBool_expr_unaryContext(p *Bool_expr_unaryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_unary
}

func (*Bool_expr_unaryContext) IsBool_expr_unaryContext() {}

func NewBool_expr_unaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_expr_unaryContext {
	var p = new(Bool_expr_unaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_bool_expr_unary

	return p
}

func (s *Bool_expr_unaryContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_expr_unaryContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Bool_expr_unaryContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Bool_expr_unaryContext) T_IS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IS, 0)
}

func (s *Bool_expr_unaryContext) T_NULL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NULL, 0)
}

func (s *Bool_expr_unaryContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Bool_expr_unaryContext) T_BETWEEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BETWEEN, 0)
}

func (s *Bool_expr_unaryContext) T_AND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AND, 0)
}

func (s *Bool_expr_unaryContext) T_EXISTS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXISTS, 0)
}

func (s *Bool_expr_unaryContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Bool_expr_unaryContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Bool_expr_unaryContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Bool_expr_unaryContext) Bool_expr_single_in() IBool_expr_single_inContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_expr_single_inContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_expr_single_inContext)
}

func (s *Bool_expr_unaryContext) Bool_expr_multi_in() IBool_expr_multi_inContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_expr_multi_inContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_expr_multi_inContext)
}

func (s *Bool_expr_unaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_expr_unaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Bool_expr_unaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBool_expr_unary(s)
	}
}

func (s *Bool_expr_unaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBool_expr_unary(s)
	}
}




func (p *HplsqlParser) Bool_expr_unary() (localctx IBool_expr_unaryContext) {
	localctx = NewBool_expr_unaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, HplsqlParserRULE_bool_expr_unary)
	var _la int

	p.SetState(2766)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 346, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2743)
			p.expr(0)
		}
		{
			p.SetState(2744)
			p.Match(HplsqlParserT_IS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2746)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_NOT {
			{
				p.SetState(2745)
				p.Match(HplsqlParserT_NOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2748)
			p.Match(HplsqlParserT_NULL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2750)
			p.expr(0)
		}
		{
			p.SetState(2751)
			p.Match(HplsqlParserT_BETWEEN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2752)
			p.expr(0)
		}
		{
			p.SetState(2753)
			p.Match(HplsqlParserT_AND)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2754)
			p.expr(0)
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(2757)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_NOT {
			{
				p.SetState(2756)
				p.Match(HplsqlParserT_NOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2759)
			p.Match(HplsqlParserT_EXISTS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2760)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2761)
			p.Select_stmt()
		}
		{
			p.SetState(2762)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2764)
			p.Bool_expr_single_in()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2765)
			p.Bool_expr_multi_in()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBool_expr_single_inContext is an interface to support dynamic dispatch.
type IBool_expr_single_inContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_IN() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	T_NOT() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsBool_expr_single_inContext differentiates from other interfaces.
	IsBool_expr_single_inContext()
}

type Bool_expr_single_inContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_expr_single_inContext() *Bool_expr_single_inContext {
	var p = new(Bool_expr_single_inContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_single_in
	return p
}

func InitEmptyBool_expr_single_inContext(p *Bool_expr_single_inContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_single_in
}

func (*Bool_expr_single_inContext) IsBool_expr_single_inContext() {}

func NewBool_expr_single_inContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_expr_single_inContext {
	var p = new(Bool_expr_single_inContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_bool_expr_single_in

	return p
}

func (s *Bool_expr_single_inContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_expr_single_inContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Bool_expr_single_inContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Bool_expr_single_inContext) T_IN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IN, 0)
}

func (s *Bool_expr_single_inContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Bool_expr_single_inContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Bool_expr_single_inContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Bool_expr_single_inContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Bool_expr_single_inContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Bool_expr_single_inContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Bool_expr_single_inContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_expr_single_inContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Bool_expr_single_inContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBool_expr_single_in(s)
	}
}

func (s *Bool_expr_single_inContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBool_expr_single_in(s)
	}
}




func (p *HplsqlParser) Bool_expr_single_in() (localctx IBool_expr_single_inContext) {
	localctx = NewBool_expr_single_inContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, HplsqlParserRULE_bool_expr_single_in)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2768)
		p.expr(0)
	}
	p.SetState(2770)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_NOT {
		{
			p.SetState(2769)
			p.Match(HplsqlParserT_NOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(2772)
		p.Match(HplsqlParserT_IN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2773)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2783)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 349, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2774)
			p.expr(0)
		}
		p.SetState(2779)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(2775)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2776)
				p.expr(0)
			}


			p.SetState(2781)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}



	case 2:
		{
			p.SetState(2782)
			p.Select_stmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(2785)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBool_expr_multi_inContext is an interface to support dynamic dispatch.
type IBool_expr_multi_inContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllT_OPEN_P() []antlr.TerminalNode
	T_OPEN_P(i int) antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllT_CLOSE_P() []antlr.TerminalNode
	T_CLOSE_P(i int) antlr.TerminalNode
	T_IN() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	T_NOT() antlr.TerminalNode

	// IsBool_expr_multi_inContext differentiates from other interfaces.
	IsBool_expr_multi_inContext()
}

type Bool_expr_multi_inContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_expr_multi_inContext() *Bool_expr_multi_inContext {
	var p = new(Bool_expr_multi_inContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_multi_in
	return p
}

func InitEmptyBool_expr_multi_inContext(p *Bool_expr_multi_inContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_multi_in
}

func (*Bool_expr_multi_inContext) IsBool_expr_multi_inContext() {}

func NewBool_expr_multi_inContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_expr_multi_inContext {
	var p = new(Bool_expr_multi_inContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_bool_expr_multi_in

	return p
}

func (s *Bool_expr_multi_inContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_expr_multi_inContext) AllT_OPEN_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_OPEN_P)
}

func (s *Bool_expr_multi_inContext) T_OPEN_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, i)
}

func (s *Bool_expr_multi_inContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Bool_expr_multi_inContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Bool_expr_multi_inContext) AllT_CLOSE_P() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_CLOSE_P)
}

func (s *Bool_expr_multi_inContext) T_CLOSE_P(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, i)
}

func (s *Bool_expr_multi_inContext) T_IN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IN, 0)
}

func (s *Bool_expr_multi_inContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Bool_expr_multi_inContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Bool_expr_multi_inContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Bool_expr_multi_inContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Bool_expr_multi_inContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_expr_multi_inContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Bool_expr_multi_inContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBool_expr_multi_in(s)
	}
}

func (s *Bool_expr_multi_inContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBool_expr_multi_in(s)
	}
}




func (p *HplsqlParser) Bool_expr_multi_in() (localctx IBool_expr_multi_inContext) {
	localctx = NewBool_expr_multi_inContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, HplsqlParserRULE_bool_expr_multi_in)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2787)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2788)
		p.expr(0)
	}
	p.SetState(2793)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(2789)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2790)
			p.expr(0)
		}


		p.SetState(2795)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2796)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2798)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_NOT {
		{
			p.SetState(2797)
			p.Match(HplsqlParserT_NOT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(2800)
		p.Match(HplsqlParserT_IN)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2801)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2802)
		p.Select_stmt()
	}
	{
		p.SetState(2803)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBool_expr_binaryContext is an interface to support dynamic dispatch.
type IBool_expr_binaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	Bool_expr_binary_operator() IBool_expr_binary_operatorContext

	// IsBool_expr_binaryContext differentiates from other interfaces.
	IsBool_expr_binaryContext()
}

type Bool_expr_binaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_expr_binaryContext() *Bool_expr_binaryContext {
	var p = new(Bool_expr_binaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_binary
	return p
}

func InitEmptyBool_expr_binaryContext(p *Bool_expr_binaryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_binary
}

func (*Bool_expr_binaryContext) IsBool_expr_binaryContext() {}

func NewBool_expr_binaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_expr_binaryContext {
	var p = new(Bool_expr_binaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_bool_expr_binary

	return p
}

func (s *Bool_expr_binaryContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_expr_binaryContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Bool_expr_binaryContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Bool_expr_binaryContext) Bool_expr_binary_operator() IBool_expr_binary_operatorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_expr_binary_operatorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_expr_binary_operatorContext)
}

func (s *Bool_expr_binaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_expr_binaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Bool_expr_binaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBool_expr_binary(s)
	}
}

func (s *Bool_expr_binaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBool_expr_binary(s)
	}
}




func (p *HplsqlParser) Bool_expr_binary() (localctx IBool_expr_binaryContext) {
	localctx = NewBool_expr_binaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, HplsqlParserRULE_bool_expr_binary)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2805)
		p.expr(0)
	}
	{
		p.SetState(2806)
		p.Bool_expr_binary_operator()
	}
	{
		p.SetState(2807)
		p.expr(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBool_expr_logical_operatorContext is an interface to support dynamic dispatch.
type IBool_expr_logical_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_AND() antlr.TerminalNode
	T_OR() antlr.TerminalNode

	// IsBool_expr_logical_operatorContext differentiates from other interfaces.
	IsBool_expr_logical_operatorContext()
}

type Bool_expr_logical_operatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_expr_logical_operatorContext() *Bool_expr_logical_operatorContext {
	var p = new(Bool_expr_logical_operatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_logical_operator
	return p
}

func InitEmptyBool_expr_logical_operatorContext(p *Bool_expr_logical_operatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_logical_operator
}

func (*Bool_expr_logical_operatorContext) IsBool_expr_logical_operatorContext() {}

func NewBool_expr_logical_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_expr_logical_operatorContext {
	var p = new(Bool_expr_logical_operatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_bool_expr_logical_operator

	return p
}

func (s *Bool_expr_logical_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_expr_logical_operatorContext) T_AND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AND, 0)
}

func (s *Bool_expr_logical_operatorContext) T_OR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OR, 0)
}

func (s *Bool_expr_logical_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_expr_logical_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Bool_expr_logical_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBool_expr_logical_operator(s)
	}
}

func (s *Bool_expr_logical_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBool_expr_logical_operator(s)
	}
}




func (p *HplsqlParser) Bool_expr_logical_operator() (localctx IBool_expr_logical_operatorContext) {
	localctx = NewBool_expr_logical_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, HplsqlParserRULE_bool_expr_logical_operator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2809)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_AND || _la == HplsqlParserT_OR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBool_expr_binary_operatorContext is an interface to support dynamic dispatch.
type IBool_expr_binary_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_EQUAL() antlr.TerminalNode
	T_EQUAL2() antlr.TerminalNode
	T_NOTEQUAL() antlr.TerminalNode
	T_NOTEQUAL2() antlr.TerminalNode
	T_LESS() antlr.TerminalNode
	T_LESSEQUAL() antlr.TerminalNode
	T_GREATER() antlr.TerminalNode
	T_GREATEREQUAL() antlr.TerminalNode
	T_LIKE() antlr.TerminalNode
	T_RLIKE() antlr.TerminalNode
	T_REGEXP() antlr.TerminalNode
	T_NOT() antlr.TerminalNode

	// IsBool_expr_binary_operatorContext differentiates from other interfaces.
	IsBool_expr_binary_operatorContext()
}

type Bool_expr_binary_operatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_expr_binary_operatorContext() *Bool_expr_binary_operatorContext {
	var p = new(Bool_expr_binary_operatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_binary_operator
	return p
}

func InitEmptyBool_expr_binary_operatorContext(p *Bool_expr_binary_operatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_expr_binary_operator
}

func (*Bool_expr_binary_operatorContext) IsBool_expr_binary_operatorContext() {}

func NewBool_expr_binary_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_expr_binary_operatorContext {
	var p = new(Bool_expr_binary_operatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_bool_expr_binary_operator

	return p
}

func (s *Bool_expr_binary_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_expr_binary_operatorContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Bool_expr_binary_operatorContext) T_EQUAL2() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL2, 0)
}

func (s *Bool_expr_binary_operatorContext) T_NOTEQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOTEQUAL, 0)
}

func (s *Bool_expr_binary_operatorContext) T_NOTEQUAL2() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOTEQUAL2, 0)
}

func (s *Bool_expr_binary_operatorContext) T_LESS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LESS, 0)
}

func (s *Bool_expr_binary_operatorContext) T_LESSEQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LESSEQUAL, 0)
}

func (s *Bool_expr_binary_operatorContext) T_GREATER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GREATER, 0)
}

func (s *Bool_expr_binary_operatorContext) T_GREATEREQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GREATEREQUAL, 0)
}

func (s *Bool_expr_binary_operatorContext) T_LIKE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LIKE, 0)
}

func (s *Bool_expr_binary_operatorContext) T_RLIKE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RLIKE, 0)
}

func (s *Bool_expr_binary_operatorContext) T_REGEXP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REGEXP, 0)
}

func (s *Bool_expr_binary_operatorContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Bool_expr_binary_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_expr_binary_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Bool_expr_binary_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBool_expr_binary_operator(s)
	}
}

func (s *Bool_expr_binary_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBool_expr_binary_operator(s)
	}
}




func (p *HplsqlParser) Bool_expr_binary_operator() (localctx IBool_expr_binary_operatorContext) {
	localctx = NewBool_expr_binary_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, HplsqlParserRULE_bool_expr_binary_operator)
	var _la int

	p.SetState(2823)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_EQUAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2811)
			p.Match(HplsqlParserT_EQUAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_EQUAL2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2812)
			p.Match(HplsqlParserT_EQUAL2)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_NOTEQUAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2813)
			p.Match(HplsqlParserT_NOTEQUAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_NOTEQUAL2:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2814)
			p.Match(HplsqlParserT_NOTEQUAL2)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_LESS:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2815)
			p.Match(HplsqlParserT_LESS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_LESSEQUAL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2816)
			p.Match(HplsqlParserT_LESSEQUAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_GREATER:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2817)
			p.Match(HplsqlParserT_GREATER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_GREATEREQUAL:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2818)
			p.Match(HplsqlParserT_GREATEREQUAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_LIKE, HplsqlParserT_NOT, HplsqlParserT_REGEXP, HplsqlParserT_RLIKE:
		p.EnterOuterAlt(localctx, 9)
		p.SetState(2820)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_NOT {
			{
				p.SetState(2819)
				p.Match(HplsqlParserT_NOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(2822)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_LIKE || _la == HplsqlParserT_REGEXP || _la == HplsqlParserT_RLIKE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN_P() antlr.TerminalNode
	Select_stmt() ISelect_stmtContext
	T_CLOSE_P() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	Expr_interval() IExpr_intervalContext
	Expr_concat() IExpr_concatContext
	Expr_dot() IExpr_dotContext
	Expr_case() IExpr_caseContext
	Expr_cursor_attribute() IExpr_cursor_attributeContext
	Expr_agg_window_func() IExpr_agg_window_funcContext
	Expr_spec_func() IExpr_spec_funcContext
	Expr_func() IExpr_funcContext
	Expr_atom() IExpr_atomContext
	T_MUL() antlr.TerminalNode
	T_DIV() antlr.TerminalNode
	T_ADD() antlr.TerminalNode
	T_SUB() antlr.TerminalNode
	Interval_item() IInterval_itemContext

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr
	return p
}

func InitEmptyExprContext(p *ExprContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *ExprContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *ExprContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *ExprContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ExprContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprContext) Expr_interval() IExpr_intervalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_intervalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_intervalContext)
}

func (s *ExprContext) Expr_concat() IExpr_concatContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_concatContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_concatContext)
}

func (s *ExprContext) Expr_dot() IExpr_dotContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_dotContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_dotContext)
}

func (s *ExprContext) Expr_case() IExpr_caseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_caseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_caseContext)
}

func (s *ExprContext) Expr_cursor_attribute() IExpr_cursor_attributeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_cursor_attributeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_cursor_attributeContext)
}

func (s *ExprContext) Expr_agg_window_func() IExpr_agg_window_funcContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_agg_window_funcContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_agg_window_funcContext)
}

func (s *ExprContext) Expr_spec_func() IExpr_spec_funcContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_spec_funcContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_spec_funcContext)
}

func (s *ExprContext) Expr_func() IExpr_funcContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_funcContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_funcContext)
}

func (s *ExprContext) Expr_atom() IExpr_atomContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_atomContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_atomContext)
}

func (s *ExprContext) T_MUL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MUL, 0)
}

func (s *ExprContext) T_DIV() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DIV, 0)
}

func (s *ExprContext) T_ADD() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ADD, 0)
}

func (s *ExprContext) T_SUB() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUB, 0)
}

func (s *ExprContext) Interval_item() IInterval_itemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterval_itemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterval_itemContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr(s)
	}
}





func (p *HplsqlParser) Expr() (localctx IExprContext) {
	return p.expr(0)
}

func (p *HplsqlParser) expr(_p int) (localctx IExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 400
	p.EnterRecursionRule(localctx, 400, HplsqlParserRULE_expr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2843)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 354, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2826)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2827)
			p.Select_stmt()
		}
		{
			p.SetState(2828)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		{
			p.SetState(2830)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2831)
			p.expr(0)
		}
		{
			p.SetState(2832)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		{
			p.SetState(2834)
			p.Expr_interval()
		}


	case 4:
		{
			p.SetState(2835)
			p.Expr_concat()
		}


	case 5:
		{
			p.SetState(2836)
			p.Expr_dot()
		}


	case 6:
		{
			p.SetState(2837)
			p.Expr_case()
		}


	case 7:
		{
			p.SetState(2838)
			p.Expr_cursor_attribute()
		}


	case 8:
		{
			p.SetState(2839)
			p.Expr_agg_window_func()
		}


	case 9:
		{
			p.SetState(2840)
			p.Expr_spec_func()
		}


	case 10:
		{
			p.SetState(2841)
			p.Expr_func()
		}


	case 11:
		{
			p.SetState(2842)
			p.Expr_atom()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2855)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 356, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(2853)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 355, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, HplsqlParserRULE_expr)
				p.SetState(2845)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
					goto errorExit
				}
				{
					p.SetState(2846)
					_la = p.GetTokenStream().LA(1)

					if !(_la == HplsqlParserT_DIV || _la == HplsqlParserT_MUL) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(2847)
					p.expr(14)
				}


			case 2:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, HplsqlParserRULE_expr)
				p.SetState(2848)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
					goto errorExit
				}
				{
					p.SetState(2849)
					_la = p.GetTokenStream().LA(1)

					if !(_la == HplsqlParserT_ADD || _la == HplsqlParserT_SUB) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(2850)
					p.expr(13)
				}


			case 3:
				localctx = NewExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, HplsqlParserRULE_expr)
				p.SetState(2851)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
					goto errorExit
				}
				{
					p.SetState(2852)
					p.Interval_item()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(2857)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 356, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



	errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpr_atomContext is an interface to support dynamic dispatch.
type IExpr_atomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Date_literal() IDate_literalContext
	Timestamp_literal() ITimestamp_literalContext
	Bool_literal() IBool_literalContext
	Qident() IQidentContext
	String_() IStringContext
	Dec_number() IDec_numberContext
	Int_number() IInt_numberContext
	Null_const() INull_constContext

	// IsExpr_atomContext differentiates from other interfaces.
	IsExpr_atomContext()
}

type Expr_atomContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_atomContext() *Expr_atomContext {
	var p = new(Expr_atomContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_atom
	return p
}

func InitEmptyExpr_atomContext(p *Expr_atomContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_atom
}

func (*Expr_atomContext) IsExpr_atomContext() {}

func NewExpr_atomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_atomContext {
	var p = new(Expr_atomContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_atom

	return p
}

func (s *Expr_atomContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_atomContext) Date_literal() IDate_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDate_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDate_literalContext)
}

func (s *Expr_atomContext) Timestamp_literal() ITimestamp_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimestamp_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimestamp_literalContext)
}

func (s *Expr_atomContext) Bool_literal() IBool_literalContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_literalContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_literalContext)
}

func (s *Expr_atomContext) Qident() IQidentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Expr_atomContext) String_() IStringContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *Expr_atomContext) Dec_number() IDec_numberContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDec_numberContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDec_numberContext)
}

func (s *Expr_atomContext) Int_number() IInt_numberContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInt_numberContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInt_numberContext)
}

func (s *Expr_atomContext) Null_const() INull_constContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INull_constContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INull_constContext)
}

func (s *Expr_atomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_atomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expr_atomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_atom(s)
	}
}

func (s *Expr_atomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_atom(s)
	}
}




func (p *HplsqlParser) Expr_atom() (localctx IExpr_atomContext) {
	localctx = NewExpr_atomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, HplsqlParserRULE_expr_atom)
	p.SetState(2866)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 357, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2858)
			p.Date_literal()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2859)
			p.Timestamp_literal()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2860)
			p.Bool_literal()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2861)
			p.Qident()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2862)
			p.String_()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2863)
			p.Dec_number()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2864)
			p.Int_number()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2865)
			p.Null_const()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpr_intervalContext is an interface to support dynamic dispatch.
type IExpr_intervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_INTERVAL() antlr.TerminalNode
	Expr() IExprContext
	Interval_item() IInterval_itemContext

	// IsExpr_intervalContext differentiates from other interfaces.
	IsExpr_intervalContext()
}

type Expr_intervalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_intervalContext() *Expr_intervalContext {
	var p = new(Expr_intervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_interval
	return p
}

func InitEmptyExpr_intervalContext(p *Expr_intervalContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_interval
}

func (*Expr_intervalContext) IsExpr_intervalContext() {}

func NewExpr_intervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_intervalContext {
	var p = new(Expr_intervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_interval

	return p
}

func (s *Expr_intervalContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_intervalContext) T_INTERVAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTERVAL, 0)
}

func (s *Expr_intervalContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_intervalContext) Interval_item() IInterval_itemContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterval_itemContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterval_itemContext)
}

func (s *Expr_intervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_intervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expr_intervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_interval(s)
	}
}

func (s *Expr_intervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_interval(s)
	}
}




func (p *HplsqlParser) Expr_interval() (localctx IExpr_intervalContext) {
	localctx = NewExpr_intervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, HplsqlParserRULE_expr_interval)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2868)
		p.Match(HplsqlParserT_INTERVAL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2869)
		p.expr(0)
	}
	{
		p.SetState(2870)
		p.Interval_item()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInterval_itemContext is an interface to support dynamic dispatch.
type IInterval_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_DAY() antlr.TerminalNode
	T_DAYS() antlr.TerminalNode
	T_MICROSECOND() antlr.TerminalNode
	T_MICROSECONDS() antlr.TerminalNode
	T_SECOND() antlr.TerminalNode
	T_SECONDS() antlr.TerminalNode

	// IsInterval_itemContext differentiates from other interfaces.
	IsInterval_itemContext()
}

type Interval_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterval_itemContext() *Interval_itemContext {
	var p = new(Interval_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_interval_item
	return p
}

func InitEmptyInterval_itemContext(p *Interval_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_interval_item
}

func (*Interval_itemContext) IsInterval_itemContext() {}

func NewInterval_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interval_itemContext {
	var p = new(Interval_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_interval_item

	return p
}

func (s *Interval_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Interval_itemContext) T_DAY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DAY, 0)
}

func (s *Interval_itemContext) T_DAYS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DAYS, 0)
}

func (s *Interval_itemContext) T_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MICROSECOND, 0)
}

func (s *Interval_itemContext) T_MICROSECONDS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MICROSECONDS, 0)
}

func (s *Interval_itemContext) T_SECOND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SECOND, 0)
}

func (s *Interval_itemContext) T_SECONDS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SECONDS, 0)
}

func (s *Interval_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interval_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Interval_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterInterval_item(s)
	}
}

func (s *Interval_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitInterval_item(s)
	}
}




func (p *HplsqlParser) Interval_item() (localctx IInterval_itemContext) {
	localctx = NewInterval_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, HplsqlParserRULE_interval_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2872)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_DAY || _la == HplsqlParserT_DAYS || _la == HplsqlParserT_MICROSECOND || _la == HplsqlParserT_MICROSECONDS || _la == HplsqlParserT_SECOND || _la == HplsqlParserT_SECONDS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpr_concatContext is an interface to support dynamic dispatch.
type IExpr_concatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr_concat_item() []IExpr_concat_itemContext
	Expr_concat_item(i int) IExpr_concat_itemContext
	AllT_PIPE() []antlr.TerminalNode
	T_PIPE(i int) antlr.TerminalNode
	AllT_CONCAT() []antlr.TerminalNode
	T_CONCAT(i int) antlr.TerminalNode

	// IsExpr_concatContext differentiates from other interfaces.
	IsExpr_concatContext()
}

type Expr_concatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_concatContext() *Expr_concatContext {
	var p = new(Expr_concatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_concat
	return p
}

func InitEmptyExpr_concatContext(p *Expr_concatContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_concat
}

func (*Expr_concatContext) IsExpr_concatContext() {}

func NewExpr_concatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_concatContext {
	var p = new(Expr_concatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_concat

	return p
}

func (s *Expr_concatContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_concatContext) AllExpr_concat_item() []IExpr_concat_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpr_concat_itemContext); ok {
			len++
		}
	}

	tst := make([]IExpr_concat_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpr_concat_itemContext); ok {
			tst[i] = t.(IExpr_concat_itemContext)
			i++
		}
	}

	return tst
}

func (s *Expr_concatContext) Expr_concat_item(i int) IExpr_concat_itemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_concat_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_concat_itemContext)
}

func (s *Expr_concatContext) AllT_PIPE() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_PIPE)
}

func (s *Expr_concatContext) T_PIPE(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PIPE, i)
}

func (s *Expr_concatContext) AllT_CONCAT() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_CONCAT)
}

func (s *Expr_concatContext) T_CONCAT(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONCAT, i)
}

func (s *Expr_concatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_concatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expr_concatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_concat(s)
	}
}

func (s *Expr_concatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_concat(s)
	}
}




func (p *HplsqlParser) Expr_concat() (localctx IExpr_concatContext) {
	localctx = NewExpr_concatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, HplsqlParserRULE_expr_concat)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2874)
		p.Expr_concat_item()
	}
	{
		p.SetState(2875)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_CONCAT || _la == HplsqlParserT_PIPE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2876)
		p.Expr_concat_item()
	}
	p.SetState(2881)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 358, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2877)
				_la = p.GetTokenStream().LA(1)

				if !(_la == HplsqlParserT_CONCAT || _la == HplsqlParserT_PIPE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2878)
				p.Expr_concat_item()
			}


		}
		p.SetState(2883)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 358, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpr_concat_itemContext is an interface to support dynamic dispatch.
type IExpr_concat_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OPEN_P() antlr.TerminalNode
	Expr() IExprContext
	T_CLOSE_P() antlr.TerminalNode
	Expr_case() IExpr_caseContext
	Expr_agg_window_func() IExpr_agg_window_funcContext
	Expr_spec_func() IExpr_spec_funcContext
	Expr_dot() IExpr_dotContext
	Expr_func() IExpr_funcContext
	Expr_atom() IExpr_atomContext

	// IsExpr_concat_itemContext differentiates from other interfaces.
	IsExpr_concat_itemContext()
}

type Expr_concat_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_concat_itemContext() *Expr_concat_itemContext {
	var p = new(Expr_concat_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_concat_item
	return p
}

func InitEmptyExpr_concat_itemContext(p *Expr_concat_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_concat_item
}

func (*Expr_concat_itemContext) IsExpr_concat_itemContext() {}

func NewExpr_concat_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_concat_itemContext {
	var p = new(Expr_concat_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_concat_item

	return p
}

func (s *Expr_concat_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_concat_itemContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Expr_concat_itemContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_concat_itemContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Expr_concat_itemContext) Expr_case() IExpr_caseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_caseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_caseContext)
}

func (s *Expr_concat_itemContext) Expr_agg_window_func() IExpr_agg_window_funcContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_agg_window_funcContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_agg_window_funcContext)
}

func (s *Expr_concat_itemContext) Expr_spec_func() IExpr_spec_funcContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_spec_funcContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_spec_funcContext)
}

func (s *Expr_concat_itemContext) Expr_dot() IExpr_dotContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_dotContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_dotContext)
}

func (s *Expr_concat_itemContext) Expr_func() IExpr_funcContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_funcContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_funcContext)
}

func (s *Expr_concat_itemContext) Expr_atom() IExpr_atomContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_atomContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_atomContext)
}

func (s *Expr_concat_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_concat_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expr_concat_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_concat_item(s)
	}
}

func (s *Expr_concat_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_concat_item(s)
	}
}




func (p *HplsqlParser) Expr_concat_item() (localctx IExpr_concat_itemContext) {
	localctx = NewExpr_concat_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, HplsqlParserRULE_expr_concat_item)
	p.SetState(2894)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 359, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2884)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2885)
			p.expr(0)
		}
		{
			p.SetState(2886)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2888)
			p.Expr_case()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2889)
			p.Expr_agg_window_func()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2890)
			p.Expr_spec_func()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2891)
			p.Expr_dot()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2892)
			p.Expr_func()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2893)
			p.Expr_atom()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpr_caseContext is an interface to support dynamic dispatch.
type IExpr_caseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr_case_simple() IExpr_case_simpleContext
	Expr_case_searched() IExpr_case_searchedContext

	// IsExpr_caseContext differentiates from other interfaces.
	IsExpr_caseContext()
}

type Expr_caseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_caseContext() *Expr_caseContext {
	var p = new(Expr_caseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_case
	return p
}

func InitEmptyExpr_caseContext(p *Expr_caseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_case
}

func (*Expr_caseContext) IsExpr_caseContext() {}

func NewExpr_caseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_caseContext {
	var p = new(Expr_caseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_case

	return p
}

func (s *Expr_caseContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_caseContext) Expr_case_simple() IExpr_case_simpleContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_case_simpleContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_case_simpleContext)
}

func (s *Expr_caseContext) Expr_case_searched() IExpr_case_searchedContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_case_searchedContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_case_searchedContext)
}

func (s *Expr_caseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_caseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expr_caseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_case(s)
	}
}

func (s *Expr_caseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_case(s)
	}
}




func (p *HplsqlParser) Expr_case() (localctx IExpr_caseContext) {
	localctx = NewExpr_caseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, HplsqlParserRULE_expr_case)
	p.SetState(2898)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 360, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2896)
			p.Expr_case_simple()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2897)
			p.Expr_case_searched()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpr_case_simpleContext is an interface to support dynamic dispatch.
type IExpr_case_simpleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_CASE() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_END() antlr.TerminalNode
	AllT_WHEN() []antlr.TerminalNode
	T_WHEN(i int) antlr.TerminalNode
	AllT_THEN() []antlr.TerminalNode
	T_THEN(i int) antlr.TerminalNode
	T_ELSE() antlr.TerminalNode

	// IsExpr_case_simpleContext differentiates from other interfaces.
	IsExpr_case_simpleContext()
}

type Expr_case_simpleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_case_simpleContext() *Expr_case_simpleContext {
	var p = new(Expr_case_simpleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_case_simple
	return p
}

func InitEmptyExpr_case_simpleContext(p *Expr_case_simpleContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_case_simple
}

func (*Expr_case_simpleContext) IsExpr_case_simpleContext() {}

func NewExpr_case_simpleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_case_simpleContext {
	var p = new(Expr_case_simpleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_case_simple

	return p
}

func (s *Expr_case_simpleContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_case_simpleContext) T_CASE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CASE, 0)
}

func (s *Expr_case_simpleContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Expr_case_simpleContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_case_simpleContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *Expr_case_simpleContext) AllT_WHEN() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_WHEN)
}

func (s *Expr_case_simpleContext) T_WHEN(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WHEN, i)
}

func (s *Expr_case_simpleContext) AllT_THEN() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_THEN)
}

func (s *Expr_case_simpleContext) T_THEN(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_THEN, i)
}

func (s *Expr_case_simpleContext) T_ELSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ELSE, 0)
}

func (s *Expr_case_simpleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_case_simpleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expr_case_simpleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_case_simple(s)
	}
}

func (s *Expr_case_simpleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_case_simple(s)
	}
}




func (p *HplsqlParser) Expr_case_simple() (localctx IExpr_case_simpleContext) {
	localctx = NewExpr_case_simpleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, HplsqlParserRULE_expr_case_simple)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2900)
		p.Match(HplsqlParserT_CASE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2901)
		p.expr(0)
	}
	p.SetState(2907)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = _la == HplsqlParserT_WHEN {
		{
			p.SetState(2902)
			p.Match(HplsqlParserT_WHEN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2903)
			p.expr(0)
		}
		{
			p.SetState(2904)
			p.Match(HplsqlParserT_THEN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2905)
			p.expr(0)
		}


		p.SetState(2909)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2913)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_ELSE {
		{
			p.SetState(2911)
			p.Match(HplsqlParserT_ELSE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2912)
			p.expr(0)
		}

	}
	{
		p.SetState(2915)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpr_case_searchedContext is an interface to support dynamic dispatch.
type IExpr_case_searchedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_CASE() antlr.TerminalNode
	T_END() antlr.TerminalNode
	AllT_WHEN() []antlr.TerminalNode
	T_WHEN(i int) antlr.TerminalNode
	AllBool_expr() []IBool_exprContext
	Bool_expr(i int) IBool_exprContext
	AllT_THEN() []antlr.TerminalNode
	T_THEN(i int) antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_ELSE() antlr.TerminalNode

	// IsExpr_case_searchedContext differentiates from other interfaces.
	IsExpr_case_searchedContext()
}

type Expr_case_searchedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_case_searchedContext() *Expr_case_searchedContext {
	var p = new(Expr_case_searchedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_case_searched
	return p
}

func InitEmptyExpr_case_searchedContext(p *Expr_case_searchedContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_case_searched
}

func (*Expr_case_searchedContext) IsExpr_case_searchedContext() {}

func NewExpr_case_searchedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_case_searchedContext {
	var p = new(Expr_case_searchedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_case_searched

	return p
}

func (s *Expr_case_searchedContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_case_searchedContext) T_CASE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CASE, 0)
}

func (s *Expr_case_searchedContext) T_END() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_END, 0)
}

func (s *Expr_case_searchedContext) AllT_WHEN() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_WHEN)
}

func (s *Expr_case_searchedContext) T_WHEN(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WHEN, i)
}

func (s *Expr_case_searchedContext) AllBool_expr() []IBool_exprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBool_exprContext); ok {
			len++
		}
	}

	tst := make([]IBool_exprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBool_exprContext); ok {
			tst[i] = t.(IBool_exprContext)
			i++
		}
	}

	return tst
}

func (s *Expr_case_searchedContext) Bool_expr(i int) IBool_exprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBool_exprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBool_exprContext)
}

func (s *Expr_case_searchedContext) AllT_THEN() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_THEN)
}

func (s *Expr_case_searchedContext) T_THEN(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_THEN, i)
}

func (s *Expr_case_searchedContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Expr_case_searchedContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_case_searchedContext) T_ELSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ELSE, 0)
}

func (s *Expr_case_searchedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_case_searchedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expr_case_searchedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_case_searched(s)
	}
}

func (s *Expr_case_searchedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_case_searched(s)
	}
}




func (p *HplsqlParser) Expr_case_searched() (localctx IExpr_case_searchedContext) {
	localctx = NewExpr_case_searchedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, HplsqlParserRULE_expr_case_searched)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2917)
		p.Match(HplsqlParserT_CASE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(2923)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ok := true; ok; ok = _la == HplsqlParserT_WHEN {
		{
			p.SetState(2918)
			p.Match(HplsqlParserT_WHEN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2919)
			p.bool_expr(0)
		}
		{
			p.SetState(2920)
			p.Match(HplsqlParserT_THEN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2921)
			p.expr(0)
		}


		p.SetState(2925)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(2929)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_ELSE {
		{
			p.SetState(2927)
			p.Match(HplsqlParserT_ELSE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2928)
			p.expr(0)
		}

	}
	{
		p.SetState(2931)
		p.Match(HplsqlParserT_END)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpr_cursor_attributeContext is an interface to support dynamic dispatch.
type IExpr_cursor_attributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ident() IIdentContext
	T_ISOPEN() antlr.TerminalNode
	T_FOUND() antlr.TerminalNode
	T_NOTFOUND() antlr.TerminalNode

	// IsExpr_cursor_attributeContext differentiates from other interfaces.
	IsExpr_cursor_attributeContext()
}

type Expr_cursor_attributeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_cursor_attributeContext() *Expr_cursor_attributeContext {
	var p = new(Expr_cursor_attributeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_cursor_attribute
	return p
}

func InitEmptyExpr_cursor_attributeContext(p *Expr_cursor_attributeContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_cursor_attribute
}

func (*Expr_cursor_attributeContext) IsExpr_cursor_attributeContext() {}

func NewExpr_cursor_attributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_cursor_attributeContext {
	var p = new(Expr_cursor_attributeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_cursor_attribute

	return p
}

func (s *Expr_cursor_attributeContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_cursor_attributeContext) Ident() IIdentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Expr_cursor_attributeContext) T_ISOPEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ISOPEN, 0)
}

func (s *Expr_cursor_attributeContext) T_FOUND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOUND, 0)
}

func (s *Expr_cursor_attributeContext) T_NOTFOUND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOTFOUND, 0)
}

func (s *Expr_cursor_attributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_cursor_attributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expr_cursor_attributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_cursor_attribute(s)
	}
}

func (s *Expr_cursor_attributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_cursor_attribute(s)
	}
}




func (p *HplsqlParser) Expr_cursor_attribute() (localctx IExpr_cursor_attributeContext) {
	localctx = NewExpr_cursor_attributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, HplsqlParserRULE_expr_cursor_attribute)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2933)
		p.Ident()
	}
	{
		p.SetState(2934)
		p.Match(HplsqlParserT__2)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(2935)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_FOUND || _la == HplsqlParserT_ISOPEN || _la == HplsqlParserT_NOTFOUND) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpr_agg_window_funcContext is an interface to support dynamic dispatch.
type IExpr_agg_window_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_AVG() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_CLOSE_P() antlr.TerminalNode
	Expr_func_all_distinct() IExpr_func_all_distinctContext
	Expr_func_over_clause() IExpr_func_over_clauseContext
	T_COUNT() antlr.TerminalNode
	T_MUL() antlr.TerminalNode
	T_COUNT_BIG() antlr.TerminalNode
	T_CUME_DIST() antlr.TerminalNode
	T_DENSE_RANK() antlr.TerminalNode
	T_FIRST_VALUE() antlr.TerminalNode
	T_LAG() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	T_LAST_VALUE() antlr.TerminalNode
	T_LEAD() antlr.TerminalNode
	T_MAX() antlr.TerminalNode
	T_MIN() antlr.TerminalNode
	T_RANK() antlr.TerminalNode
	T_ROW_NUMBER() antlr.TerminalNode
	T_STDEV() antlr.TerminalNode
	T_SUM() antlr.TerminalNode
	T_VAR() antlr.TerminalNode
	T_VARIANCE() antlr.TerminalNode

	// IsExpr_agg_window_funcContext differentiates from other interfaces.
	IsExpr_agg_window_funcContext()
}

type Expr_agg_window_funcContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_agg_window_funcContext() *Expr_agg_window_funcContext {
	var p = new(Expr_agg_window_funcContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_agg_window_func
	return p
}

func InitEmptyExpr_agg_window_funcContext(p *Expr_agg_window_funcContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_agg_window_func
}

func (*Expr_agg_window_funcContext) IsExpr_agg_window_funcContext() {}

func NewExpr_agg_window_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_agg_window_funcContext {
	var p = new(Expr_agg_window_funcContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_agg_window_func

	return p
}

func (s *Expr_agg_window_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_agg_window_funcContext) T_AVG() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AVG, 0)
}

func (s *Expr_agg_window_funcContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Expr_agg_window_funcContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Expr_agg_window_funcContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_agg_window_funcContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Expr_agg_window_funcContext) Expr_func_all_distinct() IExpr_func_all_distinctContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_func_all_distinctContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_func_all_distinctContext)
}

func (s *Expr_agg_window_funcContext) Expr_func_over_clause() IExpr_func_over_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_func_over_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_func_over_clauseContext)
}

func (s *Expr_agg_window_funcContext) T_COUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COUNT, 0)
}

func (s *Expr_agg_window_funcContext) T_MUL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MUL, 0)
}

func (s *Expr_agg_window_funcContext) T_COUNT_BIG() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COUNT_BIG, 0)
}

func (s *Expr_agg_window_funcContext) T_CUME_DIST() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CUME_DIST, 0)
}

func (s *Expr_agg_window_funcContext) T_DENSE_RANK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DENSE_RANK, 0)
}

func (s *Expr_agg_window_funcContext) T_FIRST_VALUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FIRST_VALUE, 0)
}

func (s *Expr_agg_window_funcContext) T_LAG() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LAG, 0)
}

func (s *Expr_agg_window_funcContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Expr_agg_window_funcContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Expr_agg_window_funcContext) T_LAST_VALUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LAST_VALUE, 0)
}

func (s *Expr_agg_window_funcContext) T_LEAD() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LEAD, 0)
}

func (s *Expr_agg_window_funcContext) T_MAX() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAX, 0)
}

func (s *Expr_agg_window_funcContext) T_MIN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MIN, 0)
}

func (s *Expr_agg_window_funcContext) T_RANK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RANK, 0)
}

func (s *Expr_agg_window_funcContext) T_ROW_NUMBER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROW_NUMBER, 0)
}

func (s *Expr_agg_window_funcContext) T_STDEV() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STDEV, 0)
}

func (s *Expr_agg_window_funcContext) T_SUM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUM, 0)
}

func (s *Expr_agg_window_funcContext) T_VAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VAR, 0)
}

func (s *Expr_agg_window_funcContext) T_VARIANCE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VARIANCE, 0)
}

func (s *Expr_agg_window_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_agg_window_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expr_agg_window_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_agg_window_func(s)
	}
}

func (s *Expr_agg_window_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_agg_window_func(s)
	}
}




func (p *HplsqlParser) Expr_agg_window_func() (localctx IExpr_agg_window_funcContext) {
	localctx = NewExpr_agg_window_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, HplsqlParserRULE_expr_agg_window_func)
	var _la int

	p.SetState(3089)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT_AVG:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2937)
			p.Match(HplsqlParserT_AVG)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2938)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2940)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 365, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2939)
				p.Expr_func_all_distinct()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(2942)
			p.expr(0)
		}
		{
			p.SetState(2943)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2945)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 366, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2944)
				p.Expr_func_over_clause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case HplsqlParserT_COUNT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2947)
			p.Match(HplsqlParserT_COUNT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2948)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2954)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NULL, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_MAX_PART_STRING, HplsqlParserT_MIN_PART_STRING, HplsqlParserT_MAX_PART_INT, HplsqlParserT_MIN_PART_INT, HplsqlParserT_MAX_PART_DATE, HplsqlParserT_MIN_PART_DATE, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_ADD, HplsqlParserT_OPEN_P, HplsqlParserT_SUB, HplsqlParserL_ID, HplsqlParserL_S_STRING, HplsqlParserL_D_STRING, HplsqlParserL_INT, HplsqlParserL_DEC:
			p.SetState(2950)
			p.GetErrorHandler().Sync(p)


			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 367, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(2949)
					p.Expr_func_all_distinct()
				}

				} else if p.HasError() { // JIM
					goto errorExit
			}
			{
				p.SetState(2952)
				p.expr(0)
			}



		case HplsqlParserT_MUL:
			{
				p.SetState(2953)
				p.Match(HplsqlParserT_MUL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(2956)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2958)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 369, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2957)
				p.Expr_func_over_clause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case HplsqlParserT_COUNT_BIG:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2960)
			p.Match(HplsqlParserT_COUNT_BIG)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2961)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2967)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NULL, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_MAX_PART_STRING, HplsqlParserT_MIN_PART_STRING, HplsqlParserT_MAX_PART_INT, HplsqlParserT_MIN_PART_INT, HplsqlParserT_MAX_PART_DATE, HplsqlParserT_MIN_PART_DATE, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_ADD, HplsqlParserT_OPEN_P, HplsqlParserT_SUB, HplsqlParserL_ID, HplsqlParserL_S_STRING, HplsqlParserL_D_STRING, HplsqlParserL_INT, HplsqlParserL_DEC:
			p.SetState(2963)
			p.GetErrorHandler().Sync(p)


			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 370, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(2962)
					p.Expr_func_all_distinct()
				}

				} else if p.HasError() { // JIM
					goto errorExit
			}
			{
				p.SetState(2965)
				p.expr(0)
			}



		case HplsqlParserT_MUL:
			{
				p.SetState(2966)
				p.Match(HplsqlParserT_MUL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(2969)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(2971)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 372, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2970)
				p.Expr_func_over_clause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case HplsqlParserT_CUME_DIST:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2973)
			p.Match(HplsqlParserT_CUME_DIST)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2974)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2975)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2976)
			p.Expr_func_over_clause()
		}


	case HplsqlParserT_DENSE_RANK:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2977)
			p.Match(HplsqlParserT_DENSE_RANK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2978)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2979)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2980)
			p.Expr_func_over_clause()
		}


	case HplsqlParserT_FIRST_VALUE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2981)
			p.Match(HplsqlParserT_FIRST_VALUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2982)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2983)
			p.expr(0)
		}
		{
			p.SetState(2984)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2985)
			p.Expr_func_over_clause()
		}


	case HplsqlParserT_LAG:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2987)
			p.Match(HplsqlParserT_LAG)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2988)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2989)
			p.expr(0)
		}
		p.SetState(2996)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_COMMA {
			{
				p.SetState(2990)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(2991)
				p.expr(0)
			}
			p.SetState(2994)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HplsqlParserT_COMMA {
				{
					p.SetState(2992)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(2993)
					p.expr(0)
				}

			}

		}
		{
			p.SetState(2998)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(2999)
			p.Expr_func_over_clause()
		}


	case HplsqlParserT_LAST_VALUE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3001)
			p.Match(HplsqlParserT_LAST_VALUE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3002)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3003)
			p.expr(0)
		}
		{
			p.SetState(3004)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3005)
			p.Expr_func_over_clause()
		}


	case HplsqlParserT_LEAD:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3007)
			p.Match(HplsqlParserT_LEAD)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3008)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3009)
			p.expr(0)
		}
		p.SetState(3016)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_COMMA {
			{
				p.SetState(3010)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3011)
				p.expr(0)
			}
			p.SetState(3014)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			if _la == HplsqlParserT_COMMA {
				{
					p.SetState(3012)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(3013)
					p.expr(0)
				}

			}

		}
		{
			p.SetState(3018)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3019)
			p.Expr_func_over_clause()
		}


	case HplsqlParserT_MAX:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3021)
			p.Match(HplsqlParserT_MAX)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3022)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3024)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 377, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3023)
				p.Expr_func_all_distinct()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(3026)
			p.expr(0)
		}
		{
			p.SetState(3027)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3029)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 378, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3028)
				p.Expr_func_over_clause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case HplsqlParserT_MIN:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3031)
			p.Match(HplsqlParserT_MIN)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3032)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3034)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 379, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3033)
				p.Expr_func_all_distinct()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(3036)
			p.expr(0)
		}
		{
			p.SetState(3037)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3039)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 380, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3038)
				p.Expr_func_over_clause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case HplsqlParserT_RANK:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3041)
			p.Match(HplsqlParserT_RANK)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3042)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3043)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3044)
			p.Expr_func_over_clause()
		}


	case HplsqlParserT_ROW_NUMBER:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(3045)
			p.Match(HplsqlParserT_ROW_NUMBER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3046)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3047)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3048)
			p.Expr_func_over_clause()
		}


	case HplsqlParserT_STDEV:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(3049)
			p.Match(HplsqlParserT_STDEV)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3050)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3052)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 381, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3051)
				p.Expr_func_all_distinct()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(3054)
			p.expr(0)
		}
		{
			p.SetState(3055)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3057)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 382, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3056)
				p.Expr_func_over_clause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case HplsqlParserT_SUM:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(3059)
			p.Match(HplsqlParserT_SUM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3060)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3062)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 383, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3061)
				p.Expr_func_all_distinct()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(3064)
			p.expr(0)
		}
		{
			p.SetState(3065)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3067)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 384, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3066)
				p.Expr_func_over_clause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case HplsqlParserT_VAR:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(3069)
			p.Match(HplsqlParserT_VAR)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3070)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3072)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 385, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3071)
				p.Expr_func_all_distinct()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(3074)
			p.expr(0)
		}
		{
			p.SetState(3075)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3077)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 386, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3076)
				p.Expr_func_over_clause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case HplsqlParserT_VARIANCE:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(3079)
			p.Match(HplsqlParserT_VARIANCE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3080)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3082)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 387, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3081)
				p.Expr_func_all_distinct()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(3084)
			p.expr(0)
		}
		{
			p.SetState(3085)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3087)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 388, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3086)
				p.Expr_func_over_clause()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpr_func_all_distinctContext is an interface to support dynamic dispatch.
type IExpr_func_all_distinctContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ALL() antlr.TerminalNode
	T_DISTINCT() antlr.TerminalNode

	// IsExpr_func_all_distinctContext differentiates from other interfaces.
	IsExpr_func_all_distinctContext()
}

type Expr_func_all_distinctContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_func_all_distinctContext() *Expr_func_all_distinctContext {
	var p = new(Expr_func_all_distinctContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_func_all_distinct
	return p
}

func InitEmptyExpr_func_all_distinctContext(p *Expr_func_all_distinctContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_func_all_distinct
}

func (*Expr_func_all_distinctContext) IsExpr_func_all_distinctContext() {}

func NewExpr_func_all_distinctContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_func_all_distinctContext {
	var p = new(Expr_func_all_distinctContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_func_all_distinct

	return p
}

func (s *Expr_func_all_distinctContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_func_all_distinctContext) T_ALL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALL, 0)
}

func (s *Expr_func_all_distinctContext) T_DISTINCT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DISTINCT, 0)
}

func (s *Expr_func_all_distinctContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_func_all_distinctContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expr_func_all_distinctContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_func_all_distinct(s)
	}
}

func (s *Expr_func_all_distinctContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_func_all_distinct(s)
	}
}




func (p *HplsqlParser) Expr_func_all_distinct() (localctx IExpr_func_all_distinctContext) {
	localctx = NewExpr_func_all_distinctContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, HplsqlParserRULE_expr_func_all_distinct)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3091)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_ALL || _la == HplsqlParserT_DISTINCT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpr_func_over_clauseContext is an interface to support dynamic dispatch.
type IExpr_func_over_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_OVER() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode
	Expr_func_partition_by_clause() IExpr_func_partition_by_clauseContext
	Order_by_clause() IOrder_by_clauseContext

	// IsExpr_func_over_clauseContext differentiates from other interfaces.
	IsExpr_func_over_clauseContext()
}

type Expr_func_over_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_func_over_clauseContext() *Expr_func_over_clauseContext {
	var p = new(Expr_func_over_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_func_over_clause
	return p
}

func InitEmptyExpr_func_over_clauseContext(p *Expr_func_over_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_func_over_clause
}

func (*Expr_func_over_clauseContext) IsExpr_func_over_clauseContext() {}

func NewExpr_func_over_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_func_over_clauseContext {
	var p = new(Expr_func_over_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_func_over_clause

	return p
}

func (s *Expr_func_over_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_func_over_clauseContext) T_OVER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OVER, 0)
}

func (s *Expr_func_over_clauseContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Expr_func_over_clauseContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Expr_func_over_clauseContext) Expr_func_partition_by_clause() IExpr_func_partition_by_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_func_partition_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_func_partition_by_clauseContext)
}

func (s *Expr_func_over_clauseContext) Order_by_clause() IOrder_by_clauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrder_by_clauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrder_by_clauseContext)
}

func (s *Expr_func_over_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_func_over_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expr_func_over_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_func_over_clause(s)
	}
}

func (s *Expr_func_over_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_func_over_clause(s)
	}
}




func (p *HplsqlParser) Expr_func_over_clause() (localctx IExpr_func_over_clauseContext) {
	localctx = NewExpr_func_over_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, HplsqlParserRULE_expr_func_over_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3093)
		p.Match(HplsqlParserT_OVER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3094)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3096)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_PARTITION {
		{
			p.SetState(3095)
			p.Expr_func_partition_by_clause()
		}

	}
	p.SetState(3099)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_ORDER {
		{
			p.SetState(3098)
			p.Order_by_clause()
		}

	}
	{
		p.SetState(3101)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpr_func_partition_by_clauseContext is an interface to support dynamic dispatch.
type IExpr_func_partition_by_clauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_PARTITION() antlr.TerminalNode
	T_BY() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsExpr_func_partition_by_clauseContext differentiates from other interfaces.
	IsExpr_func_partition_by_clauseContext()
}

type Expr_func_partition_by_clauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_func_partition_by_clauseContext() *Expr_func_partition_by_clauseContext {
	var p = new(Expr_func_partition_by_clauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_func_partition_by_clause
	return p
}

func InitEmptyExpr_func_partition_by_clauseContext(p *Expr_func_partition_by_clauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_func_partition_by_clause
}

func (*Expr_func_partition_by_clauseContext) IsExpr_func_partition_by_clauseContext() {}

func NewExpr_func_partition_by_clauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_func_partition_by_clauseContext {
	var p = new(Expr_func_partition_by_clauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_func_partition_by_clause

	return p
}

func (s *Expr_func_partition_by_clauseContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_func_partition_by_clauseContext) T_PARTITION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PARTITION, 0)
}

func (s *Expr_func_partition_by_clauseContext) T_BY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BY, 0)
}

func (s *Expr_func_partition_by_clauseContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Expr_func_partition_by_clauseContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_func_partition_by_clauseContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Expr_func_partition_by_clauseContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Expr_func_partition_by_clauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_func_partition_by_clauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expr_func_partition_by_clauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_func_partition_by_clause(s)
	}
}

func (s *Expr_func_partition_by_clauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_func_partition_by_clause(s)
	}
}




func (p *HplsqlParser) Expr_func_partition_by_clause() (localctx IExpr_func_partition_by_clauseContext) {
	localctx = NewExpr_func_partition_by_clauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, HplsqlParserRULE_expr_func_partition_by_clause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3103)
		p.Match(HplsqlParserT_PARTITION)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3104)
		p.Match(HplsqlParserT_BY)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3105)
		p.expr(0)
	}
	p.SetState(3110)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == HplsqlParserT_COMMA {
		{
			p.SetState(3106)
			p.Match(HplsqlParserT_COMMA)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3107)
			p.expr(0)
		}


		p.SetState(3112)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpr_spec_funcContext is an interface to support dynamic dispatch.
type IExpr_spec_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ACTIVITY_COUNT() antlr.TerminalNode
	T_CAST() antlr.TerminalNode
	T_OPEN_P() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	T_AS() antlr.TerminalNode
	Dtype() IDtypeContext
	T_CLOSE_P() antlr.TerminalNode
	Dtype_len() IDtype_lenContext
	T_COUNT() antlr.TerminalNode
	T_MUL() antlr.TerminalNode
	T_CURRENT_DATE() antlr.TerminalNode
	T_CURRENT() antlr.TerminalNode
	T_DATE() antlr.TerminalNode
	T_CURRENT_TIMESTAMP() antlr.TerminalNode
	T_TIMESTAMP() antlr.TerminalNode
	T_CURRENT_USER() antlr.TerminalNode
	T_USER() antlr.TerminalNode
	T_MAX_PART_STRING() antlr.TerminalNode
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode
	AllT_EQUAL() []antlr.TerminalNode
	T_EQUAL(i int) antlr.TerminalNode
	T_MIN_PART_STRING() antlr.TerminalNode
	T_MAX_PART_INT() antlr.TerminalNode
	T_MIN_PART_INT() antlr.TerminalNode
	T_MAX_PART_DATE() antlr.TerminalNode
	T_MIN_PART_DATE() antlr.TerminalNode
	T_PART_COUNT() antlr.TerminalNode
	T_PART_LOC() antlr.TerminalNode
	T_TRIM() antlr.TerminalNode
	T_SUBSTRING() antlr.TerminalNode
	T_FROM() antlr.TerminalNode
	T_FOR() antlr.TerminalNode
	T_SYSDATE() antlr.TerminalNode

	// IsExpr_spec_funcContext differentiates from other interfaces.
	IsExpr_spec_funcContext()
}

type Expr_spec_funcContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_spec_funcContext() *Expr_spec_funcContext {
	var p = new(Expr_spec_funcContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_spec_func
	return p
}

func InitEmptyExpr_spec_funcContext(p *Expr_spec_funcContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_spec_func
}

func (*Expr_spec_funcContext) IsExpr_spec_funcContext() {}

func NewExpr_spec_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_spec_funcContext {
	var p = new(Expr_spec_funcContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_spec_func

	return p
}

func (s *Expr_spec_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_spec_funcContext) T_ACTIVITY_COUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ACTIVITY_COUNT, 0)
}

func (s *Expr_spec_funcContext) T_CAST() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CAST, 0)
}

func (s *Expr_spec_funcContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Expr_spec_funcContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Expr_spec_funcContext) Expr(i int) IExprContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_spec_funcContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Expr_spec_funcContext) Dtype() IDtypeContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtypeContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtypeContext)
}

func (s *Expr_spec_funcContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Expr_spec_funcContext) Dtype_len() IDtype_lenContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDtype_lenContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDtype_lenContext)
}

func (s *Expr_spec_funcContext) T_COUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COUNT, 0)
}

func (s *Expr_spec_funcContext) T_MUL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MUL, 0)
}

func (s *Expr_spec_funcContext) T_CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT_DATE, 0)
}

func (s *Expr_spec_funcContext) T_CURRENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT, 0)
}

func (s *Expr_spec_funcContext) T_DATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATE, 0)
}

func (s *Expr_spec_funcContext) T_CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT_TIMESTAMP, 0)
}

func (s *Expr_spec_funcContext) T_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TIMESTAMP, 0)
}

func (s *Expr_spec_funcContext) T_CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT_USER, 0)
}

func (s *Expr_spec_funcContext) T_USER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_USER, 0)
}

func (s *Expr_spec_funcContext) T_MAX_PART_STRING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAX_PART_STRING, 0)
}

func (s *Expr_spec_funcContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Expr_spec_funcContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Expr_spec_funcContext) AllT_EQUAL() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_EQUAL)
}

func (s *Expr_spec_funcContext) T_EQUAL(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, i)
}

func (s *Expr_spec_funcContext) T_MIN_PART_STRING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MIN_PART_STRING, 0)
}

func (s *Expr_spec_funcContext) T_MAX_PART_INT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAX_PART_INT, 0)
}

func (s *Expr_spec_funcContext) T_MIN_PART_INT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MIN_PART_INT, 0)
}

func (s *Expr_spec_funcContext) T_MAX_PART_DATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAX_PART_DATE, 0)
}

func (s *Expr_spec_funcContext) T_MIN_PART_DATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MIN_PART_DATE, 0)
}

func (s *Expr_spec_funcContext) T_PART_COUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PART_COUNT, 0)
}

func (s *Expr_spec_funcContext) T_PART_LOC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PART_LOC, 0)
}

func (s *Expr_spec_funcContext) T_TRIM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TRIM, 0)
}

func (s *Expr_spec_funcContext) T_SUBSTRING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUBSTRING, 0)
}

func (s *Expr_spec_funcContext) T_FROM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FROM, 0)
}

func (s *Expr_spec_funcContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *Expr_spec_funcContext) T_SYSDATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SYSDATE, 0)
}

func (s *Expr_spec_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_spec_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expr_spec_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_spec_func(s)
	}
}

func (s *Expr_spec_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_spec_func(s)
	}
}




func (p *HplsqlParser) Expr_spec_func() (localctx IExpr_spec_funcContext) {
	localctx = NewExpr_spec_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, HplsqlParserRULE_expr_spec_func)
	var _la int

	var _alt int

	p.SetState(3313)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 413, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3113)
			p.Match(HplsqlParserT_ACTIVITY_COUNT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3114)
			p.Match(HplsqlParserT_CAST)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3115)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3116)
			p.expr(0)
		}
		{
			p.SetState(3117)
			p.Match(HplsqlParserT_AS)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3118)
			p.Dtype()
		}
		p.SetState(3120)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_OPEN_P {
			{
				p.SetState(3119)
				p.Dtype_len()
			}

		}
		{
			p.SetState(3122)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3124)
			p.Match(HplsqlParserT_COUNT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3125)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3128)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NULL, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_MAX_PART_STRING, HplsqlParserT_MIN_PART_STRING, HplsqlParserT_MAX_PART_INT, HplsqlParserT_MIN_PART_INT, HplsqlParserT_MAX_PART_DATE, HplsqlParserT_MIN_PART_DATE, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_ADD, HplsqlParserT_OPEN_P, HplsqlParserT_SUB, HplsqlParserL_ID, HplsqlParserL_S_STRING, HplsqlParserL_D_STRING, HplsqlParserL_INT, HplsqlParserL_DEC:
			{
				p.SetState(3126)
				p.expr(0)
			}


		case HplsqlParserT_MUL:
			{
				p.SetState(3127)
				p.Match(HplsqlParserT_MUL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(3130)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3131)
			p.Match(HplsqlParserT_CURRENT_DATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3132)
			p.Match(HplsqlParserT_CURRENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3133)
			p.Match(HplsqlParserT_DATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(3137)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case HplsqlParserT_CURRENT_TIMESTAMP:
			{
				p.SetState(3134)
				p.Match(HplsqlParserT_CURRENT_TIMESTAMP)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case HplsqlParserT_CURRENT:
			{
				p.SetState(3135)
				p.Match(HplsqlParserT_CURRENT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3136)
				p.Match(HplsqlParserT_TIMESTAMP)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(3143)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 396, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3139)
				p.Match(HplsqlParserT_OPEN_P)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3140)
				p.expr(0)
			}
			{
				p.SetState(3141)
				p.Match(HplsqlParserT_CLOSE_P)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3145)
			p.Match(HplsqlParserT_CURRENT_USER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3146)
			p.Match(HplsqlParserT_CURRENT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3147)
			p.Match(HplsqlParserT_USER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3148)
			p.Match(HplsqlParserT_MAX_PART_STRING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3149)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3150)
			p.expr(0)
		}
		p.SetState(3163)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_COMMA {
			{
				p.SetState(3151)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3152)
				p.expr(0)
			}
			p.SetState(3160)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			for _la == HplsqlParserT_COMMA {
				{
					p.SetState(3153)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(3154)
					p.expr(0)
				}
				{
					p.SetState(3155)
					p.Match(HplsqlParserT_EQUAL)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(3156)
					p.expr(0)
				}


				p.SetState(3162)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
			    	goto errorExit
			    }
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(3165)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3167)
			p.Match(HplsqlParserT_MIN_PART_STRING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3168)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3169)
			p.expr(0)
		}
		p.SetState(3182)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_COMMA {
			{
				p.SetState(3170)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3171)
				p.expr(0)
			}
			p.SetState(3179)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			for _la == HplsqlParserT_COMMA {
				{
					p.SetState(3172)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(3173)
					p.expr(0)
				}
				{
					p.SetState(3174)
					p.Match(HplsqlParserT_EQUAL)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(3175)
					p.expr(0)
				}


				p.SetState(3181)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
			    	goto errorExit
			    }
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(3184)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3186)
			p.Match(HplsqlParserT_MAX_PART_INT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3187)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3188)
			p.expr(0)
		}
		p.SetState(3201)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_COMMA {
			{
				p.SetState(3189)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3190)
				p.expr(0)
			}
			p.SetState(3198)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			for _la == HplsqlParserT_COMMA {
				{
					p.SetState(3191)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(3192)
					p.expr(0)
				}
				{
					p.SetState(3193)
					p.Match(HplsqlParserT_EQUAL)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(3194)
					p.expr(0)
				}


				p.SetState(3200)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
			    	goto errorExit
			    }
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(3203)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3205)
			p.Match(HplsqlParserT_MIN_PART_INT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3206)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3207)
			p.expr(0)
		}
		p.SetState(3220)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_COMMA {
			{
				p.SetState(3208)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3209)
				p.expr(0)
			}
			p.SetState(3217)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			for _la == HplsqlParserT_COMMA {
				{
					p.SetState(3210)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(3211)
					p.expr(0)
				}
				{
					p.SetState(3212)
					p.Match(HplsqlParserT_EQUAL)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(3213)
					p.expr(0)
				}


				p.SetState(3219)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
			    	goto errorExit
			    }
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(3222)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(3224)
			p.Match(HplsqlParserT_MAX_PART_DATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3225)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3226)
			p.expr(0)
		}
		p.SetState(3239)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_COMMA {
			{
				p.SetState(3227)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3228)
				p.expr(0)
			}
			p.SetState(3236)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			for _la == HplsqlParserT_COMMA {
				{
					p.SetState(3229)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(3230)
					p.expr(0)
				}
				{
					p.SetState(3231)
					p.Match(HplsqlParserT_EQUAL)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(3232)
					p.expr(0)
				}


				p.SetState(3238)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
			    	goto errorExit
			    }
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(3241)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(3243)
			p.Match(HplsqlParserT_MIN_PART_DATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3244)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3245)
			p.expr(0)
		}
		p.SetState(3258)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_COMMA {
			{
				p.SetState(3246)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3247)
				p.expr(0)
			}
			p.SetState(3255)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)


			for _la == HplsqlParserT_COMMA {
				{
					p.SetState(3248)
					p.Match(HplsqlParserT_COMMA)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(3249)
					p.expr(0)
				}
				{
					p.SetState(3250)
					p.Match(HplsqlParserT_EQUAL)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(3251)
					p.expr(0)
				}


				p.SetState(3257)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
			    	goto errorExit
			    }
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(3260)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(3262)
			p.Match(HplsqlParserT_PART_COUNT)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3263)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3264)
			p.expr(0)
		}
		p.SetState(3272)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == HplsqlParserT_COMMA {
			{
				p.SetState(3265)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3266)
				p.expr(0)
			}
			{
				p.SetState(3267)
				p.Match(HplsqlParserT_EQUAL)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3268)
				p.expr(0)
			}


			p.SetState(3274)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3275)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(3277)
			p.Match(HplsqlParserT_PART_LOC)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3278)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3279)
			p.expr(0)
		}
		p.SetState(3285)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
					{
						p.SetState(3280)
						p.Match(HplsqlParserT_COMMA)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}
					{
						p.SetState(3281)
						p.expr(0)
					}
					{
						p.SetState(3282)
						p.Match(HplsqlParserT_EQUAL)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}
					{
						p.SetState(3283)
						p.expr(0)
					}




			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(3287)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 410, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(3291)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_COMMA {
			{
				p.SetState(3289)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3290)
				p.expr(0)
			}

		}
		{
			p.SetState(3293)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(3295)
			p.Match(HplsqlParserT_TRIM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3296)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3297)
			p.expr(0)
		}
		{
			p.SetState(3298)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(3300)
			p.Match(HplsqlParserT_SUBSTRING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3301)
			p.Match(HplsqlParserT_OPEN_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3302)
			p.expr(0)
		}
		{
			p.SetState(3303)
			p.Match(HplsqlParserT_FROM)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3304)
			p.expr(0)
		}
		p.SetState(3307)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_FOR {
			{
				p.SetState(3305)
				p.Match(HplsqlParserT_FOR)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3306)
				p.expr(0)
			}

		}
		{
			p.SetState(3309)
			p.Match(HplsqlParserT_CLOSE_P)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(3311)
			p.Match(HplsqlParserT_SYSDATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(3312)
			p.Match(HplsqlParserT_USER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpr_funcContext is an interface to support dynamic dispatch.
type IExpr_funcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ident() IIdentContext
	T_OPEN_P() antlr.TerminalNode
	T_CLOSE_P() antlr.TerminalNode
	Expr_func_params() IExpr_func_paramsContext

	// IsExpr_funcContext differentiates from other interfaces.
	IsExpr_funcContext()
}

type Expr_funcContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_funcContext() *Expr_funcContext {
	var p = new(Expr_funcContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_func
	return p
}

func InitEmptyExpr_funcContext(p *Expr_funcContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_func
}

func (*Expr_funcContext) IsExpr_funcContext() {}

func NewExpr_funcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_funcContext {
	var p = new(Expr_funcContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_func

	return p
}

func (s *Expr_funcContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_funcContext) Ident() IIdentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Expr_funcContext) T_OPEN_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN_P, 0)
}

func (s *Expr_funcContext) T_CLOSE_P() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE_P, 0)
}

func (s *Expr_funcContext) Expr_func_params() IExpr_func_paramsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_func_paramsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_func_paramsContext)
}

func (s *Expr_funcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_funcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expr_funcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_func(s)
	}
}

func (s *Expr_funcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_func(s)
	}
}




func (p *HplsqlParser) Expr_func() (localctx IExpr_funcContext) {
	localctx = NewExpr_funcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, HplsqlParserRULE_expr_func)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3315)
		p.Ident()
	}
	{
		p.SetState(3316)
		p.Match(HplsqlParserT_OPEN_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3318)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 414, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3317)
			p.Expr_func_params()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(3320)
		p.Match(HplsqlParserT_CLOSE_P)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpr_dotContext is an interface to support dynamic dispatch.
type IExpr_dotContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr_dot_method_call() IExpr_dot_method_callContext
	Expr_dot_property_access() IExpr_dot_property_accessContext

	// IsExpr_dotContext differentiates from other interfaces.
	IsExpr_dotContext()
}

type Expr_dotContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_dotContext() *Expr_dotContext {
	var p = new(Expr_dotContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_dot
	return p
}

func InitEmptyExpr_dotContext(p *Expr_dotContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_dot
}

func (*Expr_dotContext) IsExpr_dotContext() {}

func NewExpr_dotContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_dotContext {
	var p = new(Expr_dotContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_dot

	return p
}

func (s *Expr_dotContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_dotContext) Expr_dot_method_call() IExpr_dot_method_callContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_dot_method_callContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_dot_method_callContext)
}

func (s *Expr_dotContext) Expr_dot_property_access() IExpr_dot_property_accessContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_dot_property_accessContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_dot_property_accessContext)
}

func (s *Expr_dotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_dotContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expr_dotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_dot(s)
	}
}

func (s *Expr_dotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_dot(s)
	}
}




func (p *HplsqlParser) Expr_dot() (localctx IExpr_dotContext) {
	localctx = NewExpr_dotContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, HplsqlParserRULE_expr_dot)
	p.SetState(3324)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 415, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3322)
			p.Expr_dot_method_call()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3323)
			p.Expr_dot_property_access()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpr_dot_method_callContext is an interface to support dynamic dispatch.
type IExpr_dot_method_callContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_DOT() antlr.TerminalNode
	AllExpr_func() []IExpr_funcContext
	Expr_func(i int) IExpr_funcContext
	Ident() IIdentContext

	// IsExpr_dot_method_callContext differentiates from other interfaces.
	IsExpr_dot_method_callContext()
}

type Expr_dot_method_callContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_dot_method_callContext() *Expr_dot_method_callContext {
	var p = new(Expr_dot_method_callContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_dot_method_call
	return p
}

func InitEmptyExpr_dot_method_callContext(p *Expr_dot_method_callContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_dot_method_call
}

func (*Expr_dot_method_callContext) IsExpr_dot_method_callContext() {}

func NewExpr_dot_method_callContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_dot_method_callContext {
	var p = new(Expr_dot_method_callContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_dot_method_call

	return p
}

func (s *Expr_dot_method_callContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_dot_method_callContext) T_DOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DOT, 0)
}

func (s *Expr_dot_method_callContext) AllExpr_func() []IExpr_funcContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpr_funcContext); ok {
			len++
		}
	}

	tst := make([]IExpr_funcContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpr_funcContext); ok {
			tst[i] = t.(IExpr_funcContext)
			i++
		}
	}

	return tst
}

func (s *Expr_dot_method_callContext) Expr_func(i int) IExpr_funcContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_funcContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_funcContext)
}

func (s *Expr_dot_method_callContext) Ident() IIdentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Expr_dot_method_callContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_dot_method_callContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expr_dot_method_callContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_dot_method_call(s)
	}
}

func (s *Expr_dot_method_callContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_dot_method_call(s)
	}
}




func (p *HplsqlParser) Expr_dot_method_call() (localctx IExpr_dot_method_callContext) {
	localctx = NewExpr_dot_method_callContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, HplsqlParserRULE_expr_dot_method_call)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(3328)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 416, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3326)
			p.Ident()
		}


	case 2:
		{
			p.SetState(3327)
			p.Expr_func()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(3330)
		p.Match(HplsqlParserT_DOT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3331)
		p.Expr_func()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpr_dot_property_accessContext is an interface to support dynamic dispatch.
type IExpr_dot_property_accessContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_DOT() antlr.TerminalNode
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	Expr_func() IExpr_funcContext

	// IsExpr_dot_property_accessContext differentiates from other interfaces.
	IsExpr_dot_property_accessContext()
}

type Expr_dot_property_accessContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_dot_property_accessContext() *Expr_dot_property_accessContext {
	var p = new(Expr_dot_property_accessContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_dot_property_access
	return p
}

func InitEmptyExpr_dot_property_accessContext(p *Expr_dot_property_accessContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_dot_property_access
}

func (*Expr_dot_property_accessContext) IsExpr_dot_property_accessContext() {}

func NewExpr_dot_property_accessContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_dot_property_accessContext {
	var p = new(Expr_dot_property_accessContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_dot_property_access

	return p
}

func (s *Expr_dot_property_accessContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_dot_property_accessContext) T_DOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DOT, 0)
}

func (s *Expr_dot_property_accessContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *Expr_dot_property_accessContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Expr_dot_property_accessContext) Expr_func() IExpr_funcContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpr_funcContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpr_funcContext)
}

func (s *Expr_dot_property_accessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_dot_property_accessContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expr_dot_property_accessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_dot_property_access(s)
	}
}

func (s *Expr_dot_property_accessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_dot_property_access(s)
	}
}




func (p *HplsqlParser) Expr_dot_property_access() (localctx IExpr_dot_property_accessContext) {
	localctx = NewExpr_dot_property_accessContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, HplsqlParserRULE_expr_dot_property_access)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(3335)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 417, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3333)
			p.Ident()
		}


	case 2:
		{
			p.SetState(3334)
			p.Expr_func()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(3337)
		p.Match(HplsqlParserT_DOT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3338)
		p.Ident()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpr_func_paramsContext is an interface to support dynamic dispatch.
type IExpr_func_paramsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFunc_param() []IFunc_paramContext
	Func_param(i int) IFunc_paramContext
	AllT_COMMA() []antlr.TerminalNode
	T_COMMA(i int) antlr.TerminalNode

	// IsExpr_func_paramsContext differentiates from other interfaces.
	IsExpr_func_paramsContext()
}

type Expr_func_paramsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_func_paramsContext() *Expr_func_paramsContext {
	var p = new(Expr_func_paramsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_func_params
	return p
}

func InitEmptyExpr_func_paramsContext(p *Expr_func_paramsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_func_params
}

func (*Expr_func_paramsContext) IsExpr_func_paramsContext() {}

func NewExpr_func_paramsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_func_paramsContext {
	var p = new(Expr_func_paramsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_func_params

	return p
}

func (s *Expr_func_paramsContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_func_paramsContext) AllFunc_param() []IFunc_paramContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunc_paramContext); ok {
			len++
		}
	}

	tst := make([]IFunc_paramContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunc_paramContext); ok {
			tst[i] = t.(IFunc_paramContext)
			i++
		}
	}

	return tst
}

func (s *Expr_func_paramsContext) Func_param(i int) IFunc_paramContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunc_paramContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunc_paramContext)
}

func (s *Expr_func_paramsContext) AllT_COMMA() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_COMMA)
}

func (s *Expr_func_paramsContext) T_COMMA(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMA, i)
}

func (s *Expr_func_paramsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_func_paramsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expr_func_paramsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_func_params(s)
	}
}

func (s *Expr_func_paramsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_func_params(s)
	}
}




func (p *HplsqlParser) Expr_func_params() (localctx IExpr_func_paramsContext) {
	localctx = NewExpr_func_paramsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, HplsqlParserRULE_expr_func_params)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3340)
		p.Func_param()
	}
	p.SetState(3345)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 418, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3341)
				p.Match(HplsqlParserT_COMMA)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3342)
				p.Func_param()
			}


		}
		p.SetState(3347)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 418, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFunc_paramContext is an interface to support dynamic dispatch.
type IFunc_paramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	Ident() IIdentContext
	T_EQUAL() antlr.TerminalNode
	T_GREATER() antlr.TerminalNode

	// IsFunc_paramContext differentiates from other interfaces.
	IsFunc_paramContext()
}

type Func_paramContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunc_paramContext() *Func_paramContext {
	var p = new(Func_paramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_func_param
	return p
}

func InitEmptyFunc_paramContext(p *Func_paramContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_func_param
}

func (*Func_paramContext) IsFunc_paramContext() {}

func NewFunc_paramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Func_paramContext {
	var p = new(Func_paramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_func_param

	return p
}

func (s *Func_paramContext) GetParser() antlr.Parser { return s.parser }

func (s *Func_paramContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Func_paramContext) Ident() IIdentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *Func_paramContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Func_paramContext) T_GREATER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GREATER, 0)
}

func (s *Func_paramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Func_paramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Func_paramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFunc_param(s)
	}
}

func (s *Func_paramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFunc_param(s)
	}
}




func (p *HplsqlParser) Func_param() (localctx IFunc_paramContext) {
	localctx = NewFunc_paramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, HplsqlParserRULE_func_param)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3348)

	if !(!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "INTO")) {
		p.SetError(antlr.NewFailedPredicateException(p, "!strings.EqualFold(p.GetTokenStream().LT(1).GetText(), \"INTO\")", ""))
		goto errorExit
	}
	p.SetState(3354)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 420, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3349)
			p.Ident()
		}
		{
			p.SetState(3350)
			p.Match(HplsqlParserT_EQUAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(3352)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == HplsqlParserT_GREATER {
			{
				p.SetState(3351)
				p.Match(HplsqlParserT_GREATER)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(3356)
		p.expr(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpr_selectContext is an interface to support dynamic dispatch.
type IExpr_selectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Select_stmt() ISelect_stmtContext
	Expr() IExprContext

	// IsExpr_selectContext differentiates from other interfaces.
	IsExpr_selectContext()
}

type Expr_selectContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_selectContext() *Expr_selectContext {
	var p = new(Expr_selectContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_select
	return p
}

func InitEmptyExpr_selectContext(p *Expr_selectContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_select
}

func (*Expr_selectContext) IsExpr_selectContext() {}

func NewExpr_selectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_selectContext {
	var p = new(Expr_selectContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_select

	return p
}

func (s *Expr_selectContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_selectContext) Select_stmt() ISelect_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_stmtContext)
}

func (s *Expr_selectContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_selectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_selectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expr_selectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_select(s)
	}
}

func (s *Expr_selectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_select(s)
	}
}




func (p *HplsqlParser) Expr_select() (localctx IExpr_selectContext) {
	localctx = NewExpr_selectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, HplsqlParserRULE_expr_select)
	p.SetState(3360)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 421, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3358)
			p.Select_stmt()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3359)
			p.expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpr_fileContext is an interface to support dynamic dispatch.
type IExpr_fileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	File_name() IFile_nameContext
	Expr() IExprContext

	// IsExpr_fileContext differentiates from other interfaces.
	IsExpr_fileContext()
}

type Expr_fileContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpr_fileContext() *Expr_fileContext {
	var p = new(Expr_fileContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_file
	return p
}

func InitEmptyExpr_fileContext(p *Expr_fileContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_expr_file
}

func (*Expr_fileContext) IsExpr_fileContext() {}

func NewExpr_fileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expr_fileContext {
	var p = new(Expr_fileContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_expr_file

	return p
}

func (s *Expr_fileContext) GetParser() antlr.Parser { return s.parser }

func (s *Expr_fileContext) File_name() IFile_nameContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFile_nameContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFile_nameContext)
}

func (s *Expr_fileContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Expr_fileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expr_fileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Expr_fileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterExpr_file(s)
	}
}

func (s *Expr_fileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitExpr_file(s)
	}
}




func (p *HplsqlParser) Expr_file() (localctx IExpr_fileContext) {
	localctx = NewExpr_fileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, HplsqlParserRULE_expr_file)
	p.SetState(3364)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 422, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3362)
			p.File_name()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3363)
			p.expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IHiveContext is an interface to support dynamic dispatch.
type IHiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_HIVE() antlr.TerminalNode
	AllHive_item() []IHive_itemContext
	Hive_item(i int) IHive_itemContext

	// IsHiveContext differentiates from other interfaces.
	IsHiveContext()
}

type HiveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHiveContext() *HiveContext {
	var p = new(HiveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_hive
	return p
}

func InitEmptyHiveContext(p *HiveContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_hive
}

func (*HiveContext) IsHiveContext() {}

func NewHiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HiveContext {
	var p = new(HiveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_hive

	return p
}

func (s *HiveContext) GetParser() antlr.Parser { return s.parser }

func (s *HiveContext) T_HIVE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HIVE, 0)
}

func (s *HiveContext) AllHive_item() []IHive_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHive_itemContext); ok {
			len++
		}
	}

	tst := make([]IHive_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHive_itemContext); ok {
			tst[i] = t.(IHive_itemContext)
			i++
		}
	}

	return tst
}

func (s *HiveContext) Hive_item(i int) IHive_itemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHive_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHive_itemContext)
}

func (s *HiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterHive(s)
	}
}

func (s *HiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitHive(s)
	}
}




func (p *HplsqlParser) Hive() (localctx IHiveContext) {
	localctx = NewHiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, HplsqlParserRULE_hive)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3366)
		p.Match(HplsqlParserT_HIVE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(3370)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 423, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3367)
				p.Hive_item()
			}


		}
		p.SetState(3372)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 423, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IHive_itemContext is an interface to support dynamic dispatch.
type IHive_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_SUB() antlr.TerminalNode
	Qident() IQidentContext
	Expr() IExprContext
	L_ID() antlr.TerminalNode
	T_EQUAL() antlr.TerminalNode

	// IsHive_itemContext differentiates from other interfaces.
	IsHive_itemContext()
}

type Hive_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHive_itemContext() *Hive_itemContext {
	var p = new(Hive_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_hive_item
	return p
}

func InitEmptyHive_itemContext(p *Hive_itemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_hive_item
}

func (*Hive_itemContext) IsHive_itemContext() {}

func NewHive_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Hive_itemContext {
	var p = new(Hive_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_hive_item

	return p
}

func (s *Hive_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Hive_itemContext) T_SUB() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUB, 0)
}

func (s *Hive_itemContext) Qident() IQidentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *Hive_itemContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Hive_itemContext) L_ID() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, 0)
}

func (s *Hive_itemContext) T_EQUAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EQUAL, 0)
}

func (s *Hive_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Hive_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Hive_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterHive_item(s)
	}
}

func (s *Hive_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitHive_item(s)
	}
}




func (p *HplsqlParser) Hive_item() (localctx IHive_itemContext) {
	localctx = NewHive_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, HplsqlParserRULE_hive_item)
	p.SetState(3385)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 424, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3373)
			p.Match(HplsqlParserT_SUB)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3374)
			p.Qident()
		}
		{
			p.SetState(3375)
			p.expr(0)
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3377)
			p.Match(HplsqlParserT_SUB)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3378)
			p.Qident()
		}
		{
			p.SetState(3379)
			p.Match(HplsqlParserL_ID)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3380)
			p.Match(HplsqlParserT_EQUAL)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3381)
			p.expr(0)
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3383)
			p.Match(HplsqlParserT_SUB)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3384)
			p.Qident()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IHostContext is an interface to support dynamic dispatch.
type IHostContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Host_cmd() IHost_cmdContext
	T_SEMICOLON() antlr.TerminalNode
	Host_stmt() IHost_stmtContext

	// IsHostContext differentiates from other interfaces.
	IsHostContext()
}

type HostContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHostContext() *HostContext {
	var p = new(HostContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_host
	return p
}

func InitEmptyHostContext(p *HostContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_host
}

func (*HostContext) IsHostContext() {}

func NewHostContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HostContext {
	var p = new(HostContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_host

	return p
}

func (s *HostContext) GetParser() antlr.Parser { return s.parser }

func (s *HostContext) Host_cmd() IHost_cmdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHost_cmdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHost_cmdContext)
}

func (s *HostContext) T_SEMICOLON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEMICOLON, 0)
}

func (s *HostContext) Host_stmt() IHost_stmtContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHost_stmtContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHost_stmtContext)
}

func (s *HostContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HostContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *HostContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterHost(s)
	}
}

func (s *HostContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitHost(s)
	}
}




func (p *HplsqlParser) Host() (localctx IHostContext) {
	localctx = NewHostContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, HplsqlParserRULE_host)
	p.SetState(3392)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserT__3:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3387)
			p.Match(HplsqlParserT__3)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(3388)
			p.Host_cmd()
		}
		{
			p.SetState(3389)
			p.Match(HplsqlParserT_SEMICOLON)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_HOST:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3391)
			p.Host_stmt()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IHost_cmdContext is an interface to support dynamic dispatch.
type IHost_cmdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsHost_cmdContext differentiates from other interfaces.
	IsHost_cmdContext()
}

type Host_cmdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHost_cmdContext() *Host_cmdContext {
	var p = new(Host_cmdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_host_cmd
	return p
}

func InitEmptyHost_cmdContext(p *Host_cmdContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_host_cmd
}

func (*Host_cmdContext) IsHost_cmdContext() {}

func NewHost_cmdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Host_cmdContext {
	var p = new(Host_cmdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_host_cmd

	return p
}

func (s *Host_cmdContext) GetParser() antlr.Parser { return s.parser }
func (s *Host_cmdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Host_cmdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Host_cmdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterHost_cmd(s)
	}
}

func (s *Host_cmdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitHost_cmd(s)
	}
}




func (p *HplsqlParser) Host_cmd() (localctx IHost_cmdContext) {
	localctx = NewHost_cmdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, HplsqlParserRULE_host_cmd)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3397)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 426, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1+1 {
			p.SetState(3394)
			p.MatchWildcard()



		}
		p.SetState(3399)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 426, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IHost_stmtContext is an interface to support dynamic dispatch.
type IHost_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_HOST() antlr.TerminalNode
	Expr() IExprContext

	// IsHost_stmtContext differentiates from other interfaces.
	IsHost_stmtContext()
}

type Host_stmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHost_stmtContext() *Host_stmtContext {
	var p = new(Host_stmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_host_stmt
	return p
}

func InitEmptyHost_stmtContext(p *Host_stmtContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_host_stmt
}

func (*Host_stmtContext) IsHost_stmtContext() {}

func NewHost_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Host_stmtContext {
	var p = new(Host_stmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_host_stmt

	return p
}

func (s *Host_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Host_stmtContext) T_HOST() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HOST, 0)
}

func (s *Host_stmtContext) Expr() IExprContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Host_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Host_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Host_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterHost_stmt(s)
	}
}

func (s *Host_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitHost_stmt(s)
	}
}




func (p *HplsqlParser) Host_stmt() (localctx IHost_stmtContext) {
	localctx = NewHost_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, HplsqlParserRULE_host_stmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3400)
		p.Match(HplsqlParserT_HOST)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3401)
		p.expr(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFile_nameContext is an interface to support dynamic dispatch.
type IFile_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_FILE() antlr.TerminalNode
	AllQident() []IQidentContext
	Qident(i int) IQidentContext
	AllT_DIV() []antlr.TerminalNode
	T_DIV(i int) antlr.TerminalNode
	T_DOT() antlr.TerminalNode

	// IsFile_nameContext differentiates from other interfaces.
	IsFile_nameContext()
}

type File_nameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFile_nameContext() *File_nameContext {
	var p = new(File_nameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_file_name
	return p
}

func InitEmptyFile_nameContext(p *File_nameContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_file_name
}

func (*File_nameContext) IsFile_nameContext() {}

func NewFile_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *File_nameContext {
	var p = new(File_nameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_file_name

	return p
}

func (s *File_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *File_nameContext) L_FILE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_FILE, 0)
}

func (s *File_nameContext) AllQident() []IQidentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQidentContext); ok {
			len++
		}
	}

	tst := make([]IQidentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQidentContext); ok {
			tst[i] = t.(IQidentContext)
			i++
		}
	}

	return tst
}

func (s *File_nameContext) Qident(i int) IQidentContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQidentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQidentContext)
}

func (s *File_nameContext) AllT_DIV() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_DIV)
}

func (s *File_nameContext) T_DIV(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DIV, i)
}

func (s *File_nameContext) T_DOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DOT, 0)
}

func (s *File_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *File_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *File_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterFile_name(s)
	}
}

func (s *File_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitFile_name(s)
	}
}




func (p *HplsqlParser) File_name() (localctx IFile_nameContext) {
	localctx = NewFile_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, HplsqlParserRULE_file_name)
	var _alt int

	p.SetState(3417)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserL_FILE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3403)
			p.Match(HplsqlParserL_FILE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_DIV, HplsqlParserT_DOT, HplsqlParserT_SUB, HplsqlParserL_ID:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3407)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case HplsqlParserT_DIV:
			{
				p.SetState(3404)
				p.Match(HplsqlParserT_DIV)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case HplsqlParserT_DOT:
			{
				p.SetState(3405)
				p.Match(HplsqlParserT_DOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3406)
				p.Match(HplsqlParserT_DIV)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER, HplsqlParserT_SUB, HplsqlParserL_ID:



		default:
		}
		{
			p.SetState(3409)
			p.Qident()
		}
		p.SetState(3414)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 428, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3410)
					p.Match(HplsqlParserT_DIV)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(3411)
					p.Qident()
				}


			}
			p.SetState(3416)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 428, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDate_literalContext is an interface to support dynamic dispatch.
type IDate_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_DATE() antlr.TerminalNode
	String_() IStringContext

	// IsDate_literalContext differentiates from other interfaces.
	IsDate_literalContext()
}

type Date_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDate_literalContext() *Date_literalContext {
	var p = new(Date_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_date_literal
	return p
}

func InitEmptyDate_literalContext(p *Date_literalContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_date_literal
}

func (*Date_literalContext) IsDate_literalContext() {}

func NewDate_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Date_literalContext {
	var p = new(Date_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_date_literal

	return p
}

func (s *Date_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Date_literalContext) T_DATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATE, 0)
}

func (s *Date_literalContext) String_() IStringContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *Date_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Date_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Date_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDate_literal(s)
	}
}

func (s *Date_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDate_literal(s)
	}
}




func (p *HplsqlParser) Date_literal() (localctx IDate_literalContext) {
	localctx = NewDate_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, HplsqlParserRULE_date_literal)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3419)
		p.Match(HplsqlParserT_DATE)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3420)
		p.String_()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITimestamp_literalContext is an interface to support dynamic dispatch.
type ITimestamp_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_TIMESTAMP() antlr.TerminalNode
	String_() IStringContext

	// IsTimestamp_literalContext differentiates from other interfaces.
	IsTimestamp_literalContext()
}

type Timestamp_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimestamp_literalContext() *Timestamp_literalContext {
	var p = new(Timestamp_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_timestamp_literal
	return p
}

func InitEmptyTimestamp_literalContext(p *Timestamp_literalContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_timestamp_literal
}

func (*Timestamp_literalContext) IsTimestamp_literalContext() {}

func NewTimestamp_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Timestamp_literalContext {
	var p = new(Timestamp_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_timestamp_literal

	return p
}

func (s *Timestamp_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Timestamp_literalContext) T_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TIMESTAMP, 0)
}

func (s *Timestamp_literalContext) String_() IStringContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *Timestamp_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Timestamp_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Timestamp_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterTimestamp_literal(s)
	}
}

func (s *Timestamp_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitTimestamp_literal(s)
	}
}




func (p *HplsqlParser) Timestamp_literal() (localctx ITimestamp_literalContext) {
	localctx = NewTimestamp_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, HplsqlParserRULE_timestamp_literal)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3422)
		p.Match(HplsqlParserT_TIMESTAMP)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(3423)
		p.String_()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIdentContext is an interface to support dynamic dispatch.
type IIdentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_ID() antlr.TerminalNode
	Non_reserved_words() INon_reserved_wordsContext
	T_SUB() antlr.TerminalNode

	// IsIdentContext differentiates from other interfaces.
	IsIdentContext()
}

type IdentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentContext() *IdentContext {
	var p = new(IdentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_ident
	return p
}

func InitEmptyIdentContext(p *IdentContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_ident
}

func (*IdentContext) IsIdentContext() {}

func NewIdentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentContext {
	var p = new(IdentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_ident

	return p
}

func (s *IdentContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentContext) L_ID() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_ID, 0)
}

func (s *IdentContext) Non_reserved_words() INon_reserved_wordsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INon_reserved_wordsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INon_reserved_wordsContext)
}

func (s *IdentContext) T_SUB() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUB, 0)
}

func (s *IdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IdentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterIdent(s)
	}
}

func (s *IdentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitIdent(s)
	}
}




func (p *HplsqlParser) Ident() (localctx IIdentContext) {
	localctx = NewIdentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, HplsqlParserRULE_ident)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3426)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_SUB {
		{
			p.SetState(3425)
			p.Match(HplsqlParserT_SUB)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	p.SetState(3430)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserL_ID:
		{
			p.SetState(3428)
			p.Match(HplsqlParserL_ID)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserT_ACTION, HplsqlParserT_ADD2, HplsqlParserT_ALL, HplsqlParserT_ALLOCATE, HplsqlParserT_ALTER, HplsqlParserT_AND, HplsqlParserT_ANSI_NULLS, HplsqlParserT_ANSI_PADDING, HplsqlParserT_AS, HplsqlParserT_ASC, HplsqlParserT_ASSOCIATE, HplsqlParserT_AT, HplsqlParserT_AUTO_INCREMENT, HplsqlParserT_AVG, HplsqlParserT_BATCHSIZE, HplsqlParserT_BEGIN, HplsqlParserT_BETWEEN, HplsqlParserT_BIGINT, HplsqlParserT_BINARY_DOUBLE, HplsqlParserT_BINARY_FLOAT, HplsqlParserT_BIT, HplsqlParserT_BODY, HplsqlParserT_BREAK, HplsqlParserT_BULK, HplsqlParserT_BY, HplsqlParserT_BYTE, HplsqlParserT_CALL, HplsqlParserT_CALLER, HplsqlParserT_CASCADE, HplsqlParserT_CASE, HplsqlParserT_CASESPECIFIC, HplsqlParserT_CAST, HplsqlParserT_CHAR, HplsqlParserT_CHARACTER, HplsqlParserT_CHARSET, HplsqlParserT_CLIENT, HplsqlParserT_CLOSE, HplsqlParserT_CLUSTERED, HplsqlParserT_CMP, HplsqlParserT_COLLECT, HplsqlParserT_COLLECTION, HplsqlParserT_COLUMN, HplsqlParserT_COMMENT, HplsqlParserT_CONSTANT, HplsqlParserT_COMMIT, HplsqlParserT_COMPRESS, HplsqlParserT_CONCAT, HplsqlParserT_CONDITION, HplsqlParserT_CONSTRAINT, HplsqlParserT_CONTINUE, HplsqlParserT_COPY, HplsqlParserT_COUNT, HplsqlParserT_COUNT_BIG, HplsqlParserT_CREATE, HplsqlParserT_CREATION, HplsqlParserT_CREATOR, HplsqlParserT_CS, HplsqlParserT_CURRENT, HplsqlParserT_CURRENT_SCHEMA, HplsqlParserT_CURSOR, HplsqlParserT_DATABASE, HplsqlParserT_DATA, HplsqlParserT_DATE, HplsqlParserT_DATETIME, HplsqlParserT_DAY, HplsqlParserT_DAYS, HplsqlParserT_DEC, HplsqlParserT_DECIMAL, HplsqlParserT_DECLARE, HplsqlParserT_DEFAULT, HplsqlParserT_DEFERRED, HplsqlParserT_DEFINED, HplsqlParserT_DEFINER, HplsqlParserT_DEFINITION, HplsqlParserT_DELETE, HplsqlParserT_DELIMITED, HplsqlParserT_DELIMITER, HplsqlParserT_DESC, HplsqlParserT_DESCRIBE, HplsqlParserT_DIAGNOSTICS, HplsqlParserT_DIR, HplsqlParserT_DIRECTORY, HplsqlParserT_DISTINCT, HplsqlParserT_DISTRIBUTE, HplsqlParserT_DO, HplsqlParserT_DOUBLE, HplsqlParserT_DROP, HplsqlParserT_DYNAMIC, HplsqlParserT_ENABLE, HplsqlParserT_ENGINE, HplsqlParserT_ESCAPED, HplsqlParserT_EXCEPT, HplsqlParserT_EXEC, HplsqlParserT_EXECUTE, HplsqlParserT_EXCEPTION, HplsqlParserT_EXCLUSIVE, HplsqlParserT_EXISTS, HplsqlParserT_EXIT, HplsqlParserT_FALLBACK, HplsqlParserT_FALSE, HplsqlParserT_FETCH, HplsqlParserT_FIELDS, HplsqlParserT_FILE, HplsqlParserT_FILES, HplsqlParserT_FLOAT, HplsqlParserT_FOR, HplsqlParserT_FOREIGN, HplsqlParserT_FORMAT, HplsqlParserT_FOUND, HplsqlParserT_FROM, HplsqlParserT_FULL, HplsqlParserT_FUNCTION, HplsqlParserT_GET, HplsqlParserT_GLOBAL, HplsqlParserT_GO, HplsqlParserT_GRANT, HplsqlParserT_GROUP, HplsqlParserT_HANDLER, HplsqlParserT_HASH, HplsqlParserT_HAVING, HplsqlParserT_HDFS, HplsqlParserT_HIVE, HplsqlParserT_HOST, HplsqlParserT_IDENTITY, HplsqlParserT_IF, HplsqlParserT_IGNORE, HplsqlParserT_IMMEDIATE, HplsqlParserT_IN, HplsqlParserT_INCLUDE, HplsqlParserT_INDEX, HplsqlParserT_INITRANS, HplsqlParserT_INNER, HplsqlParserT_INOUT, HplsqlParserT_INSERT, HplsqlParserT_INT, HplsqlParserT_INT2, HplsqlParserT_INT4, HplsqlParserT_INT8, HplsqlParserT_INTEGER, HplsqlParserT_INTERSECT, HplsqlParserT_INTERVAL, HplsqlParserT_INTO, HplsqlParserT_INVOKER, HplsqlParserT_IS, HplsqlParserT_ISOPEN, HplsqlParserT_ITEMS, HplsqlParserT_JOIN, HplsqlParserT_KEEP, HplsqlParserT_KEY, HplsqlParserT_KEYS, HplsqlParserT_LANGUAGE, HplsqlParserT_LEAVE, HplsqlParserT_LEFT, HplsqlParserT_LIKE, HplsqlParserT_LIMIT, HplsqlParserT_LINES, HplsqlParserT_LOCAL, HplsqlParserT_LOCATION, HplsqlParserT_LOCATOR, HplsqlParserT_LOCATORS, HplsqlParserT_LOCKS, HplsqlParserT_LOG, HplsqlParserT_LOGGED, HplsqlParserT_LOGGING, HplsqlParserT_LOOP, HplsqlParserT_MAP, HplsqlParserT_MATCHED, HplsqlParserT_MAX, HplsqlParserT_MAXTRANS, HplsqlParserT_MERGE, HplsqlParserT_MESSAGE_TEXT, HplsqlParserT_MICROSECOND, HplsqlParserT_MICROSECONDS, HplsqlParserT_MIN, HplsqlParserT_MULTISET, HplsqlParserT_NCHAR, HplsqlParserT_NEW, HplsqlParserT_NVARCHAR, HplsqlParserT_NO, HplsqlParserT_NOCOUNT, HplsqlParserT_NOCOMPRESS, HplsqlParserT_NOLOGGING, HplsqlParserT_NONE, HplsqlParserT_NOT, HplsqlParserT_NOTFOUND, HplsqlParserT_NUMERIC, HplsqlParserT_NUMBER, HplsqlParserT_OBJECT, HplsqlParserT_OFF, HplsqlParserT_ON, HplsqlParserT_ONLY, HplsqlParserT_OPEN, HplsqlParserT_OR, HplsqlParserT_ORDER, HplsqlParserT_OUT, HplsqlParserT_OUTER, HplsqlParserT_OVER, HplsqlParserT_OVERWRITE, HplsqlParserT_OWNER, HplsqlParserT_PACKAGE, HplsqlParserT_PARTITION, HplsqlParserT_PCTFREE, HplsqlParserT_PCTUSED, HplsqlParserT_PRECISION, HplsqlParserT_PRESERVE, HplsqlParserT_PRIMARY, HplsqlParserT_PRINT, HplsqlParserT_PROC, HplsqlParserT_PROCEDURE, HplsqlParserT_QUALIFY, HplsqlParserT_QUERY_BAND, HplsqlParserT_QUIT, HplsqlParserT_QUOTED_IDENTIFIER, HplsqlParserT_RAISE, HplsqlParserT_REAL, HplsqlParserT_REFERENCES, HplsqlParserT_REGEXP, HplsqlParserT_REPLACE, HplsqlParserT_RESIGNAL, HplsqlParserT_RESTRICT, HplsqlParserT_RESULT, HplsqlParserT_RESULT_SET_LOCATOR, HplsqlParserT_RETURN, HplsqlParserT_RETURNS, HplsqlParserT_REVERSE, HplsqlParserT_RIGHT, HplsqlParserT_RLIKE, HplsqlParserT_ROLE, HplsqlParserT_ROLLBACK, HplsqlParserT_ROW, HplsqlParserT_ROWS, HplsqlParserT_ROW_COUNT, HplsqlParserT_RR, HplsqlParserT_RS, HplsqlParserT_PWD, HplsqlParserT_TRIM, HplsqlParserT_SCHEMA, HplsqlParserT_SECOND, HplsqlParserT_SECONDS, HplsqlParserT_SECURITY, HplsqlParserT_SEGMENT, HplsqlParserT_SEL, HplsqlParserT_SELECT, HplsqlParserT_SET, HplsqlParserT_SESSION, HplsqlParserT_SESSIONS, HplsqlParserT_SETS, HplsqlParserT_SHARE, HplsqlParserT_SIGNAL, HplsqlParserT_SIMPLE_DOUBLE, HplsqlParserT_SIMPLE_FLOAT, HplsqlParserT_SMALLDATETIME, HplsqlParserT_SMALLINT, HplsqlParserT_SQL, HplsqlParserT_SQLEXCEPTION, HplsqlParserT_SQLINSERT, HplsqlParserT_SQLSTATE, HplsqlParserT_SQLWARNING, HplsqlParserT_STATS, HplsqlParserT_STATISTICS, HplsqlParserT_STEP, HplsqlParserT_STORAGE, HplsqlParserT_STORED, HplsqlParserT_STRING, HplsqlParserT_SUBDIR, HplsqlParserT_SUBSTRING, HplsqlParserT_SUM, HplsqlParserT_SUMMARY, HplsqlParserT_SYS_REFCURSOR, HplsqlParserT_TABLE, HplsqlParserT_TABLESPACE, HplsqlParserT_TEMPORARY, HplsqlParserT_TERMINATED, HplsqlParserT_TEXTIMAGE_ON, HplsqlParserT_THEN, HplsqlParserT_TIMESTAMP, HplsqlParserT_TITLE, HplsqlParserT_TO, HplsqlParserT_TOP, HplsqlParserT_TRANSACTION, HplsqlParserT_TRUE, HplsqlParserT_TRUNCATE, HplsqlParserT_UNIQUE, HplsqlParserT_UPDATE, HplsqlParserT_UR, HplsqlParserT_USE, HplsqlParserT_USING, HplsqlParserT_VALUE, HplsqlParserT_VALUES, HplsqlParserT_VAR, HplsqlParserT_VARCHAR, HplsqlParserT_VARCHAR2, HplsqlParserT_VARYING, HplsqlParserT_VOLATILE, HplsqlParserT_WHILE, HplsqlParserT_WITH, HplsqlParserT_WITHOUT, HplsqlParserT_WORK, HplsqlParserT_XACT_ABORT, HplsqlParserT_XML, HplsqlParserT_YES, HplsqlParserT_ACTIVITY_COUNT, HplsqlParserT_CUME_DIST, HplsqlParserT_CURRENT_DATE, HplsqlParserT_CURRENT_TIME_MILLIS, HplsqlParserT_CURRENT_TIMESTAMP, HplsqlParserT_CURRENT_USER, HplsqlParserT_DENSE_RANK, HplsqlParserT_FIRST_VALUE, HplsqlParserT_LAG, HplsqlParserT_LAST_VALUE, HplsqlParserT_LEAD, HplsqlParserT_PART_COUNT, HplsqlParserT_PART_LOC, HplsqlParserT_RANK, HplsqlParserT_ROW_NUMBER, HplsqlParserT_STDEV, HplsqlParserT_SYSDATE, HplsqlParserT_VARIANCE, HplsqlParserT_USER:
		{
			p.SetState(3429)
			p.Non_reserved_words()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQidentContext is an interface to support dynamic dispatch.
type IQidentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdent() []IIdentContext
	Ident(i int) IIdentContext
	AllT_DOT() []antlr.TerminalNode
	T_DOT(i int) antlr.TerminalNode

	// IsQidentContext differentiates from other interfaces.
	IsQidentContext()
}

type QidentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQidentContext() *QidentContext {
	var p = new(QidentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_qident
	return p
}

func InitEmptyQidentContext(p *QidentContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_qident
}

func (*QidentContext) IsQidentContext() {}

func NewQidentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QidentContext {
	var p = new(QidentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_qident

	return p
}

func (s *QidentContext) GetParser() antlr.Parser { return s.parser }

func (s *QidentContext) AllIdent() []IIdentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentContext); ok {
			len++
		}
	}

	tst := make([]IIdentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentContext); ok {
			tst[i] = t.(IIdentContext)
			i++
		}
	}

	return tst
}

func (s *QidentContext) Ident(i int) IIdentContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentContext)
}

func (s *QidentContext) AllT_DOT() []antlr.TerminalNode {
	return s.GetTokens(HplsqlParserT_DOT)
}

func (s *QidentContext) T_DOT(i int) antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DOT, i)
}

func (s *QidentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QidentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *QidentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterQident(s)
	}
}

func (s *QidentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitQident(s)
	}
}




func (p *HplsqlParser) Qident() (localctx IQidentContext) {
	localctx = NewQidentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, HplsqlParserRULE_qident)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3432)
		p.Ident()
	}
	p.SetState(3437)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 432, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3433)
				p.Match(HplsqlParserT_DOT)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(3434)
				p.Ident()
			}


		}
		p.SetState(3439)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 432, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IStringContext is an interface to support dynamic dispatch.
type IStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStringContext differentiates from other interfaces.
	IsStringContext()
}

type StringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringContext() *StringContext {
	var p = new(StringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_string
	return p
}

func InitEmptyStringContext(p *StringContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_string
}

func (*StringContext) IsStringContext() {}

func NewStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringContext {
	var p = new(StringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_string

	return p
}

func (s *StringContext) GetParser() antlr.Parser { return s.parser }

func (s *StringContext) CopyAll(ctx *StringContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type Double_quotedStringContext struct {
	StringContext
}

func NewDouble_quotedStringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Double_quotedStringContext {
	var p = new(Double_quotedStringContext)

	InitEmptyStringContext(&p.StringContext)
	p.parser = parser
	p.CopyAll(ctx.(*StringContext))

	return p
}

func (s *Double_quotedStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Double_quotedStringContext) L_D_STRING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_D_STRING, 0)
}


func (s *Double_quotedStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDouble_quotedString(s)
	}
}

func (s *Double_quotedStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDouble_quotedString(s)
	}
}


type Single_quotedStringContext struct {
	StringContext
}

func NewSingle_quotedStringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Single_quotedStringContext {
	var p = new(Single_quotedStringContext)

	InitEmptyStringContext(&p.StringContext)
	p.parser = parser
	p.CopyAll(ctx.(*StringContext))

	return p
}

func (s *Single_quotedStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Single_quotedStringContext) L_S_STRING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_S_STRING, 0)
}


func (s *Single_quotedStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterSingle_quotedString(s)
	}
}

func (s *Single_quotedStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitSingle_quotedString(s)
	}
}



func (p *HplsqlParser) String_() (localctx IStringContext) {
	localctx = NewStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, HplsqlParserRULE_string)
	p.SetState(3442)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case HplsqlParserL_S_STRING:
		localctx = NewSingle_quotedStringContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3440)
			p.Match(HplsqlParserL_S_STRING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case HplsqlParserL_D_STRING:
		localctx = NewDouble_quotedStringContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3441)
			p.Match(HplsqlParserL_D_STRING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInt_numberContext is an interface to support dynamic dispatch.
type IInt_numberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_INT() antlr.TerminalNode
	T_SUB() antlr.TerminalNode
	T_ADD() antlr.TerminalNode

	// IsInt_numberContext differentiates from other interfaces.
	IsInt_numberContext()
}

type Int_numberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInt_numberContext() *Int_numberContext {
	var p = new(Int_numberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_int_number
	return p
}

func InitEmptyInt_numberContext(p *Int_numberContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_int_number
}

func (*Int_numberContext) IsInt_numberContext() {}

func NewInt_numberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Int_numberContext {
	var p = new(Int_numberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_int_number

	return p
}

func (s *Int_numberContext) GetParser() antlr.Parser { return s.parser }

func (s *Int_numberContext) L_INT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_INT, 0)
}

func (s *Int_numberContext) T_SUB() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUB, 0)
}

func (s *Int_numberContext) T_ADD() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ADD, 0)
}

func (s *Int_numberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Int_numberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Int_numberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterInt_number(s)
	}
}

func (s *Int_numberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitInt_number(s)
	}
}




func (p *HplsqlParser) Int_number() (localctx IInt_numberContext) {
	localctx = NewInt_numberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, HplsqlParserRULE_int_number)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3445)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_ADD || _la == HplsqlParserT_SUB {
		{
			p.SetState(3444)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_ADD || _la == HplsqlParserT_SUB) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(3447)
		p.Match(HplsqlParserL_INT)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDec_numberContext is an interface to support dynamic dispatch.
type IDec_numberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	L_DEC() antlr.TerminalNode
	T_SUB() antlr.TerminalNode
	T_ADD() antlr.TerminalNode

	// IsDec_numberContext differentiates from other interfaces.
	IsDec_numberContext()
}

type Dec_numberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDec_numberContext() *Dec_numberContext {
	var p = new(Dec_numberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_dec_number
	return p
}

func InitEmptyDec_numberContext(p *Dec_numberContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_dec_number
}

func (*Dec_numberContext) IsDec_numberContext() {}

func NewDec_numberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dec_numberContext {
	var p = new(Dec_numberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_dec_number

	return p
}

func (s *Dec_numberContext) GetParser() antlr.Parser { return s.parser }

func (s *Dec_numberContext) L_DEC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserL_DEC, 0)
}

func (s *Dec_numberContext) T_SUB() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUB, 0)
}

func (s *Dec_numberContext) T_ADD() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ADD, 0)
}

func (s *Dec_numberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dec_numberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Dec_numberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterDec_number(s)
	}
}

func (s *Dec_numberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitDec_number(s)
	}
}




func (p *HplsqlParser) Dec_number() (localctx IDec_numberContext) {
	localctx = NewDec_numberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, HplsqlParserRULE_dec_number)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3450)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == HplsqlParserT_ADD || _la == HplsqlParserT_SUB {
		{
			p.SetState(3449)
			_la = p.GetTokenStream().LA(1)

			if !(_la == HplsqlParserT_ADD || _la == HplsqlParserT_SUB) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(3452)
		p.Match(HplsqlParserL_DEC)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IBool_literalContext is an interface to support dynamic dispatch.
type IBool_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_TRUE() antlr.TerminalNode
	T_FALSE() antlr.TerminalNode

	// IsBool_literalContext differentiates from other interfaces.
	IsBool_literalContext()
}

type Bool_literalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBool_literalContext() *Bool_literalContext {
	var p = new(Bool_literalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_literal
	return p
}

func InitEmptyBool_literalContext(p *Bool_literalContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_bool_literal
}

func (*Bool_literalContext) IsBool_literalContext() {}

func NewBool_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bool_literalContext {
	var p = new(Bool_literalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_bool_literal

	return p
}

func (s *Bool_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Bool_literalContext) T_TRUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TRUE, 0)
}

func (s *Bool_literalContext) T_FALSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FALSE, 0)
}

func (s *Bool_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bool_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Bool_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterBool_literal(s)
	}
}

func (s *Bool_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitBool_literal(s)
	}
}




func (p *HplsqlParser) Bool_literal() (localctx IBool_literalContext) {
	localctx = NewBool_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, HplsqlParserRULE_bool_literal)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3454)
		_la = p.GetTokenStream().LA(1)

		if !(_la == HplsqlParserT_FALSE || _la == HplsqlParserT_TRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INull_constContext is an interface to support dynamic dispatch.
type INull_constContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_NULL() antlr.TerminalNode

	// IsNull_constContext differentiates from other interfaces.
	IsNull_constContext()
}

type Null_constContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNull_constContext() *Null_constContext {
	var p = new(Null_constContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_null_const
	return p
}

func InitEmptyNull_constContext(p *Null_constContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_null_const
}

func (*Null_constContext) IsNull_constContext() {}

func NewNull_constContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Null_constContext {
	var p = new(Null_constContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_null_const

	return p
}

func (s *Null_constContext) GetParser() antlr.Parser { return s.parser }

func (s *Null_constContext) T_NULL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NULL, 0)
}

func (s *Null_constContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Null_constContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Null_constContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterNull_const(s)
	}
}

func (s *Null_constContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitNull_const(s)
	}
}




func (p *HplsqlParser) Null_const() (localctx INull_constContext) {
	localctx = NewNull_constContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, HplsqlParserRULE_null_const)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3456)
		p.Match(HplsqlParserT_NULL)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INon_reserved_wordsContext is an interface to support dynamic dispatch.
type INon_reserved_wordsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	T_ACTION() antlr.TerminalNode
	T_ACTIVITY_COUNT() antlr.TerminalNode
	T_ADD2() antlr.TerminalNode
	T_ALL() antlr.TerminalNode
	T_ALLOCATE() antlr.TerminalNode
	T_ALTER() antlr.TerminalNode
	T_AND() antlr.TerminalNode
	T_ANSI_NULLS() antlr.TerminalNode
	T_ANSI_PADDING() antlr.TerminalNode
	T_AS() antlr.TerminalNode
	T_ASC() antlr.TerminalNode
	T_ASSOCIATE() antlr.TerminalNode
	T_AT() antlr.TerminalNode
	T_AUTO_INCREMENT() antlr.TerminalNode
	T_AVG() antlr.TerminalNode
	T_BATCHSIZE() antlr.TerminalNode
	T_BEGIN() antlr.TerminalNode
	T_BETWEEN() antlr.TerminalNode
	T_BIGINT() antlr.TerminalNode
	T_BINARY_DOUBLE() antlr.TerminalNode
	T_BINARY_FLOAT() antlr.TerminalNode
	T_BIT() antlr.TerminalNode
	T_BODY() antlr.TerminalNode
	T_BREAK() antlr.TerminalNode
	T_BULK() antlr.TerminalNode
	T_BY() antlr.TerminalNode
	T_BYTE() antlr.TerminalNode
	T_CALL() antlr.TerminalNode
	T_CALLER() antlr.TerminalNode
	T_CASCADE() antlr.TerminalNode
	T_CASE() antlr.TerminalNode
	T_CASESPECIFIC() antlr.TerminalNode
	T_CAST() antlr.TerminalNode
	T_CHAR() antlr.TerminalNode
	T_CHARACTER() antlr.TerminalNode
	T_CHARSET() antlr.TerminalNode
	T_CLIENT() antlr.TerminalNode
	T_CLOSE() antlr.TerminalNode
	T_CLUSTERED() antlr.TerminalNode
	T_CMP() antlr.TerminalNode
	T_COLLECT() antlr.TerminalNode
	T_COLLECTION() antlr.TerminalNode
	T_COLUMN() antlr.TerminalNode
	T_COMMENT() antlr.TerminalNode
	T_COMPRESS() antlr.TerminalNode
	T_CONSTANT() antlr.TerminalNode
	T_COPY() antlr.TerminalNode
	T_COMMIT() antlr.TerminalNode
	T_CONCAT() antlr.TerminalNode
	T_CONDITION() antlr.TerminalNode
	T_CONSTRAINT() antlr.TerminalNode
	T_CONTINUE() antlr.TerminalNode
	T_COUNT() antlr.TerminalNode
	T_COUNT_BIG() antlr.TerminalNode
	T_CREATE() antlr.TerminalNode
	T_CREATION() antlr.TerminalNode
	T_CREATOR() antlr.TerminalNode
	T_CS() antlr.TerminalNode
	T_CUME_DIST() antlr.TerminalNode
	T_CURRENT() antlr.TerminalNode
	T_CURRENT_DATE() antlr.TerminalNode
	T_CURRENT_SCHEMA() antlr.TerminalNode
	T_CURRENT_TIME_MILLIS() antlr.TerminalNode
	T_CURRENT_TIMESTAMP() antlr.TerminalNode
	T_CURRENT_USER() antlr.TerminalNode
	T_CURSOR() antlr.TerminalNode
	T_DATA() antlr.TerminalNode
	T_DATABASE() antlr.TerminalNode
	T_DATE() antlr.TerminalNode
	T_DATETIME() antlr.TerminalNode
	T_DAY() antlr.TerminalNode
	T_DAYS() antlr.TerminalNode
	T_DEC() antlr.TerminalNode
	T_DECIMAL() antlr.TerminalNode
	T_DECLARE() antlr.TerminalNode
	T_DEFAULT() antlr.TerminalNode
	T_DEFERRED() antlr.TerminalNode
	T_DEFINED() antlr.TerminalNode
	T_DEFINER() antlr.TerminalNode
	T_DEFINITION() antlr.TerminalNode
	T_DELETE() antlr.TerminalNode
	T_DELIMITED() antlr.TerminalNode
	T_DELIMITER() antlr.TerminalNode
	T_DENSE_RANK() antlr.TerminalNode
	T_DESC() antlr.TerminalNode
	T_DESCRIBE() antlr.TerminalNode
	T_DIAGNOSTICS() antlr.TerminalNode
	T_DIR() antlr.TerminalNode
	T_DIRECTORY() antlr.TerminalNode
	T_DISTINCT() antlr.TerminalNode
	T_DISTRIBUTE() antlr.TerminalNode
	T_DO() antlr.TerminalNode
	T_DOUBLE() antlr.TerminalNode
	T_DROP() antlr.TerminalNode
	T_DYNAMIC() antlr.TerminalNode
	T_ENABLE() antlr.TerminalNode
	T_ENGINE() antlr.TerminalNode
	T_ESCAPED() antlr.TerminalNode
	T_EXCEPT() antlr.TerminalNode
	T_EXEC() antlr.TerminalNode
	T_EXECUTE() antlr.TerminalNode
	T_EXCEPTION() antlr.TerminalNode
	T_EXCLUSIVE() antlr.TerminalNode
	T_EXISTS() antlr.TerminalNode
	T_EXIT() antlr.TerminalNode
	T_FALLBACK() antlr.TerminalNode
	T_FALSE() antlr.TerminalNode
	T_FETCH() antlr.TerminalNode
	T_FIELDS() antlr.TerminalNode
	T_FILE() antlr.TerminalNode
	T_FILES() antlr.TerminalNode
	T_FIRST_VALUE() antlr.TerminalNode
	T_FLOAT() antlr.TerminalNode
	T_FOR() antlr.TerminalNode
	T_FOREIGN() antlr.TerminalNode
	T_FORMAT() antlr.TerminalNode
	T_FOUND() antlr.TerminalNode
	T_FROM() antlr.TerminalNode
	T_FULL() antlr.TerminalNode
	T_FUNCTION() antlr.TerminalNode
	T_GET() antlr.TerminalNode
	T_GLOBAL() antlr.TerminalNode
	T_GO() antlr.TerminalNode
	T_GRANT() antlr.TerminalNode
	T_GROUP() antlr.TerminalNode
	T_HANDLER() antlr.TerminalNode
	T_HASH() antlr.TerminalNode
	T_HAVING() antlr.TerminalNode
	T_HDFS() antlr.TerminalNode
	T_HIVE() antlr.TerminalNode
	T_HOST() antlr.TerminalNode
	T_IDENTITY() antlr.TerminalNode
	T_IF() antlr.TerminalNode
	T_IGNORE() antlr.TerminalNode
	T_IMMEDIATE() antlr.TerminalNode
	T_IN() antlr.TerminalNode
	T_INCLUDE() antlr.TerminalNode
	T_INDEX() antlr.TerminalNode
	T_INITRANS() antlr.TerminalNode
	T_INNER() antlr.TerminalNode
	T_INOUT() antlr.TerminalNode
	T_INSERT() antlr.TerminalNode
	T_INT() antlr.TerminalNode
	T_INT2() antlr.TerminalNode
	T_INT4() antlr.TerminalNode
	T_INT8() antlr.TerminalNode
	T_INTEGER() antlr.TerminalNode
	T_INTERSECT() antlr.TerminalNode
	T_INTERVAL() antlr.TerminalNode
	T_INTO() antlr.TerminalNode
	T_INVOKER() antlr.TerminalNode
	T_ITEMS() antlr.TerminalNode
	T_IS() antlr.TerminalNode
	T_ISOPEN() antlr.TerminalNode
	T_JOIN() antlr.TerminalNode
	T_KEEP() antlr.TerminalNode
	T_KEY() antlr.TerminalNode
	T_KEYS() antlr.TerminalNode
	T_LAG() antlr.TerminalNode
	T_LANGUAGE() antlr.TerminalNode
	T_LAST_VALUE() antlr.TerminalNode
	T_LEAD() antlr.TerminalNode
	T_LEAVE() antlr.TerminalNode
	T_LEFT() antlr.TerminalNode
	T_LIKE() antlr.TerminalNode
	T_LIMIT() antlr.TerminalNode
	T_LINES() antlr.TerminalNode
	T_LOCAL() antlr.TerminalNode
	T_LOCATION() antlr.TerminalNode
	T_LOCATOR() antlr.TerminalNode
	T_LOCATORS() antlr.TerminalNode
	T_LOCKS() antlr.TerminalNode
	T_LOG() antlr.TerminalNode
	T_LOGGED() antlr.TerminalNode
	T_LOGGING() antlr.TerminalNode
	T_LOOP() antlr.TerminalNode
	T_MAP() antlr.TerminalNode
	T_MATCHED() antlr.TerminalNode
	T_MAX() antlr.TerminalNode
	T_MAXTRANS() antlr.TerminalNode
	T_MERGE() antlr.TerminalNode
	T_MESSAGE_TEXT() antlr.TerminalNode
	T_MICROSECOND() antlr.TerminalNode
	T_MICROSECONDS() antlr.TerminalNode
	T_MIN() antlr.TerminalNode
	T_MULTISET() antlr.TerminalNode
	T_NCHAR() antlr.TerminalNode
	T_NEW() antlr.TerminalNode
	T_NVARCHAR() antlr.TerminalNode
	T_NO() antlr.TerminalNode
	T_NOCOMPRESS() antlr.TerminalNode
	T_NOCOUNT() antlr.TerminalNode
	T_NOLOGGING() antlr.TerminalNode
	T_NONE() antlr.TerminalNode
	T_NOT() antlr.TerminalNode
	T_NOTFOUND() antlr.TerminalNode
	T_NUMERIC() antlr.TerminalNode
	T_NUMBER() antlr.TerminalNode
	T_OBJECT() antlr.TerminalNode
	T_OFF() antlr.TerminalNode
	T_ON() antlr.TerminalNode
	T_ONLY() antlr.TerminalNode
	T_OPEN() antlr.TerminalNode
	T_OR() antlr.TerminalNode
	T_ORDER() antlr.TerminalNode
	T_OUT() antlr.TerminalNode
	T_OUTER() antlr.TerminalNode
	T_OVER() antlr.TerminalNode
	T_OVERWRITE() antlr.TerminalNode
	T_OWNER() antlr.TerminalNode
	T_PACKAGE() antlr.TerminalNode
	T_PART_COUNT() antlr.TerminalNode
	T_PART_LOC() antlr.TerminalNode
	T_PARTITION() antlr.TerminalNode
	T_PCTFREE() antlr.TerminalNode
	T_PCTUSED() antlr.TerminalNode
	T_PRECISION() antlr.TerminalNode
	T_PRESERVE() antlr.TerminalNode
	T_PRIMARY() antlr.TerminalNode
	T_PRINT() antlr.TerminalNode
	T_PROC() antlr.TerminalNode
	T_PROCEDURE() antlr.TerminalNode
	T_PWD() antlr.TerminalNode
	T_QUALIFY() antlr.TerminalNode
	T_QUERY_BAND() antlr.TerminalNode
	T_QUIT() antlr.TerminalNode
	T_QUOTED_IDENTIFIER() antlr.TerminalNode
	T_RAISE() antlr.TerminalNode
	T_RANK() antlr.TerminalNode
	T_REAL() antlr.TerminalNode
	T_REFERENCES() antlr.TerminalNode
	T_REGEXP() antlr.TerminalNode
	T_RR() antlr.TerminalNode
	T_REPLACE() antlr.TerminalNode
	T_RESIGNAL() antlr.TerminalNode
	T_RESTRICT() antlr.TerminalNode
	T_RESULT() antlr.TerminalNode
	T_RESULT_SET_LOCATOR() antlr.TerminalNode
	T_RETURN() antlr.TerminalNode
	T_RETURNS() antlr.TerminalNode
	T_REVERSE() antlr.TerminalNode
	T_RIGHT() antlr.TerminalNode
	T_RLIKE() antlr.TerminalNode
	T_RS() antlr.TerminalNode
	T_ROLE() antlr.TerminalNode
	T_ROLLBACK() antlr.TerminalNode
	T_ROW() antlr.TerminalNode
	T_ROWS() antlr.TerminalNode
	T_ROW_COUNT() antlr.TerminalNode
	T_ROW_NUMBER() antlr.TerminalNode
	T_SCHEMA() antlr.TerminalNode
	T_SECOND() antlr.TerminalNode
	T_SECONDS() antlr.TerminalNode
	T_SECURITY() antlr.TerminalNode
	T_SEGMENT() antlr.TerminalNode
	T_SEL() antlr.TerminalNode
	T_SELECT() antlr.TerminalNode
	T_SESSION() antlr.TerminalNode
	T_SESSIONS() antlr.TerminalNode
	T_SET() antlr.TerminalNode
	T_SETS() antlr.TerminalNode
	T_SHARE() antlr.TerminalNode
	T_SIGNAL() antlr.TerminalNode
	T_SIMPLE_DOUBLE() antlr.TerminalNode
	T_SIMPLE_FLOAT() antlr.TerminalNode
	T_SMALLDATETIME() antlr.TerminalNode
	T_SMALLINT() antlr.TerminalNode
	T_SQL() antlr.TerminalNode
	T_SQLEXCEPTION() antlr.TerminalNode
	T_SQLINSERT() antlr.TerminalNode
	T_SQLSTATE() antlr.TerminalNode
	T_SQLWARNING() antlr.TerminalNode
	T_STATS() antlr.TerminalNode
	T_STATISTICS() antlr.TerminalNode
	T_STEP() antlr.TerminalNode
	T_STDEV() antlr.TerminalNode
	T_STORAGE() antlr.TerminalNode
	T_STORED() antlr.TerminalNode
	T_STRING() antlr.TerminalNode
	T_SUBDIR() antlr.TerminalNode
	T_SUBSTRING() antlr.TerminalNode
	T_SUM() antlr.TerminalNode
	T_SUMMARY() antlr.TerminalNode
	T_SYSDATE() antlr.TerminalNode
	T_SYS_REFCURSOR() antlr.TerminalNode
	T_TABLE() antlr.TerminalNode
	T_TABLESPACE() antlr.TerminalNode
	T_TEMPORARY() antlr.TerminalNode
	T_TERMINATED() antlr.TerminalNode
	T_TEXTIMAGE_ON() antlr.TerminalNode
	T_THEN() antlr.TerminalNode
	T_TIMESTAMP() antlr.TerminalNode
	T_TITLE() antlr.TerminalNode
	T_TO() antlr.TerminalNode
	T_TOP() antlr.TerminalNode
	T_TRANSACTION() antlr.TerminalNode
	T_TRIM() antlr.TerminalNode
	T_TRUE() antlr.TerminalNode
	T_TRUNCATE() antlr.TerminalNode
	T_UNIQUE() antlr.TerminalNode
	T_UPDATE() antlr.TerminalNode
	T_UR() antlr.TerminalNode
	T_USE() antlr.TerminalNode
	T_USER() antlr.TerminalNode
	T_USING() antlr.TerminalNode
	T_VALUE() antlr.TerminalNode
	T_VALUES() antlr.TerminalNode
	T_VAR() antlr.TerminalNode
	T_VARCHAR() antlr.TerminalNode
	T_VARCHAR2() antlr.TerminalNode
	T_VARYING() antlr.TerminalNode
	T_VARIANCE() antlr.TerminalNode
	T_VOLATILE() antlr.TerminalNode
	T_WHILE() antlr.TerminalNode
	T_WITH() antlr.TerminalNode
	T_WITHOUT() antlr.TerminalNode
	T_WORK() antlr.TerminalNode
	T_XACT_ABORT() antlr.TerminalNode
	T_XML() antlr.TerminalNode
	T_YES() antlr.TerminalNode

	// IsNon_reserved_wordsContext differentiates from other interfaces.
	IsNon_reserved_wordsContext()
}

type Non_reserved_wordsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNon_reserved_wordsContext() *Non_reserved_wordsContext {
	var p = new(Non_reserved_wordsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_non_reserved_words
	return p
}

func InitEmptyNon_reserved_wordsContext(p *Non_reserved_wordsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = HplsqlParserRULE_non_reserved_words
}

func (*Non_reserved_wordsContext) IsNon_reserved_wordsContext() {}

func NewNon_reserved_wordsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Non_reserved_wordsContext {
	var p = new(Non_reserved_wordsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = HplsqlParserRULE_non_reserved_words

	return p
}

func (s *Non_reserved_wordsContext) GetParser() antlr.Parser { return s.parser }

func (s *Non_reserved_wordsContext) T_ACTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ACTION, 0)
}

func (s *Non_reserved_wordsContext) T_ACTIVITY_COUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ACTIVITY_COUNT, 0)
}

func (s *Non_reserved_wordsContext) T_ADD2() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ADD2, 0)
}

func (s *Non_reserved_wordsContext) T_ALL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALL, 0)
}

func (s *Non_reserved_wordsContext) T_ALLOCATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALLOCATE, 0)
}

func (s *Non_reserved_wordsContext) T_ALTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ALTER, 0)
}

func (s *Non_reserved_wordsContext) T_AND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AND, 0)
}

func (s *Non_reserved_wordsContext) T_ANSI_NULLS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ANSI_NULLS, 0)
}

func (s *Non_reserved_wordsContext) T_ANSI_PADDING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ANSI_PADDING, 0)
}

func (s *Non_reserved_wordsContext) T_AS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AS, 0)
}

func (s *Non_reserved_wordsContext) T_ASC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ASC, 0)
}

func (s *Non_reserved_wordsContext) T_ASSOCIATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ASSOCIATE, 0)
}

func (s *Non_reserved_wordsContext) T_AT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AT, 0)
}

func (s *Non_reserved_wordsContext) T_AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AUTO_INCREMENT, 0)
}

func (s *Non_reserved_wordsContext) T_AVG() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_AVG, 0)
}

func (s *Non_reserved_wordsContext) T_BATCHSIZE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BATCHSIZE, 0)
}

func (s *Non_reserved_wordsContext) T_BEGIN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BEGIN, 0)
}

func (s *Non_reserved_wordsContext) T_BETWEEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BETWEEN, 0)
}

func (s *Non_reserved_wordsContext) T_BIGINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BIGINT, 0)
}

func (s *Non_reserved_wordsContext) T_BINARY_DOUBLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BINARY_DOUBLE, 0)
}

func (s *Non_reserved_wordsContext) T_BINARY_FLOAT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BINARY_FLOAT, 0)
}

func (s *Non_reserved_wordsContext) T_BIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BIT, 0)
}

func (s *Non_reserved_wordsContext) T_BODY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BODY, 0)
}

func (s *Non_reserved_wordsContext) T_BREAK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BREAK, 0)
}

func (s *Non_reserved_wordsContext) T_BULK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BULK, 0)
}

func (s *Non_reserved_wordsContext) T_BY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BY, 0)
}

func (s *Non_reserved_wordsContext) T_BYTE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_BYTE, 0)
}

func (s *Non_reserved_wordsContext) T_CALL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CALL, 0)
}

func (s *Non_reserved_wordsContext) T_CALLER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CALLER, 0)
}

func (s *Non_reserved_wordsContext) T_CASCADE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CASCADE, 0)
}

func (s *Non_reserved_wordsContext) T_CASE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CASE, 0)
}

func (s *Non_reserved_wordsContext) T_CASESPECIFIC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CASESPECIFIC, 0)
}

func (s *Non_reserved_wordsContext) T_CAST() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CAST, 0)
}

func (s *Non_reserved_wordsContext) T_CHAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CHAR, 0)
}

func (s *Non_reserved_wordsContext) T_CHARACTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CHARACTER, 0)
}

func (s *Non_reserved_wordsContext) T_CHARSET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CHARSET, 0)
}

func (s *Non_reserved_wordsContext) T_CLIENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLIENT, 0)
}

func (s *Non_reserved_wordsContext) T_CLOSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLOSE, 0)
}

func (s *Non_reserved_wordsContext) T_CLUSTERED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CLUSTERED, 0)
}

func (s *Non_reserved_wordsContext) T_CMP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CMP, 0)
}

func (s *Non_reserved_wordsContext) T_COLLECT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLLECT, 0)
}

func (s *Non_reserved_wordsContext) T_COLLECTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLLECTION, 0)
}

func (s *Non_reserved_wordsContext) T_COLUMN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COLUMN, 0)
}

func (s *Non_reserved_wordsContext) T_COMMENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMENT, 0)
}

func (s *Non_reserved_wordsContext) T_COMPRESS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMPRESS, 0)
}

func (s *Non_reserved_wordsContext) T_CONSTANT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONSTANT, 0)
}

func (s *Non_reserved_wordsContext) T_COPY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COPY, 0)
}

func (s *Non_reserved_wordsContext) T_COMMIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COMMIT, 0)
}

func (s *Non_reserved_wordsContext) T_CONCAT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONCAT, 0)
}

func (s *Non_reserved_wordsContext) T_CONDITION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONDITION, 0)
}

func (s *Non_reserved_wordsContext) T_CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONSTRAINT, 0)
}

func (s *Non_reserved_wordsContext) T_CONTINUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CONTINUE, 0)
}

func (s *Non_reserved_wordsContext) T_COUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COUNT, 0)
}

func (s *Non_reserved_wordsContext) T_COUNT_BIG() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_COUNT_BIG, 0)
}

func (s *Non_reserved_wordsContext) T_CREATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATE, 0)
}

func (s *Non_reserved_wordsContext) T_CREATION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATION, 0)
}

func (s *Non_reserved_wordsContext) T_CREATOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CREATOR, 0)
}

func (s *Non_reserved_wordsContext) T_CS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CS, 0)
}

func (s *Non_reserved_wordsContext) T_CUME_DIST() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CUME_DIST, 0)
}

func (s *Non_reserved_wordsContext) T_CURRENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT, 0)
}

func (s *Non_reserved_wordsContext) T_CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT_DATE, 0)
}

func (s *Non_reserved_wordsContext) T_CURRENT_SCHEMA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT_SCHEMA, 0)
}

func (s *Non_reserved_wordsContext) T_CURRENT_TIME_MILLIS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT_TIME_MILLIS, 0)
}

func (s *Non_reserved_wordsContext) T_CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT_TIMESTAMP, 0)
}

func (s *Non_reserved_wordsContext) T_CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURRENT_USER, 0)
}

func (s *Non_reserved_wordsContext) T_CURSOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_CURSOR, 0)
}

func (s *Non_reserved_wordsContext) T_DATA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATA, 0)
}

func (s *Non_reserved_wordsContext) T_DATABASE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATABASE, 0)
}

func (s *Non_reserved_wordsContext) T_DATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATE, 0)
}

func (s *Non_reserved_wordsContext) T_DATETIME() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DATETIME, 0)
}

func (s *Non_reserved_wordsContext) T_DAY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DAY, 0)
}

func (s *Non_reserved_wordsContext) T_DAYS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DAYS, 0)
}

func (s *Non_reserved_wordsContext) T_DEC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEC, 0)
}

func (s *Non_reserved_wordsContext) T_DECIMAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DECIMAL, 0)
}

func (s *Non_reserved_wordsContext) T_DECLARE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DECLARE, 0)
}

func (s *Non_reserved_wordsContext) T_DEFAULT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFAULT, 0)
}

func (s *Non_reserved_wordsContext) T_DEFERRED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFERRED, 0)
}

func (s *Non_reserved_wordsContext) T_DEFINED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFINED, 0)
}

func (s *Non_reserved_wordsContext) T_DEFINER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFINER, 0)
}

func (s *Non_reserved_wordsContext) T_DEFINITION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DEFINITION, 0)
}

func (s *Non_reserved_wordsContext) T_DELETE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DELETE, 0)
}

func (s *Non_reserved_wordsContext) T_DELIMITED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DELIMITED, 0)
}

func (s *Non_reserved_wordsContext) T_DELIMITER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DELIMITER, 0)
}

func (s *Non_reserved_wordsContext) T_DENSE_RANK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DENSE_RANK, 0)
}

func (s *Non_reserved_wordsContext) T_DESC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DESC, 0)
}

func (s *Non_reserved_wordsContext) T_DESCRIBE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DESCRIBE, 0)
}

func (s *Non_reserved_wordsContext) T_DIAGNOSTICS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DIAGNOSTICS, 0)
}

func (s *Non_reserved_wordsContext) T_DIR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DIR, 0)
}

func (s *Non_reserved_wordsContext) T_DIRECTORY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DIRECTORY, 0)
}

func (s *Non_reserved_wordsContext) T_DISTINCT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DISTINCT, 0)
}

func (s *Non_reserved_wordsContext) T_DISTRIBUTE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DISTRIBUTE, 0)
}

func (s *Non_reserved_wordsContext) T_DO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DO, 0)
}

func (s *Non_reserved_wordsContext) T_DOUBLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DOUBLE, 0)
}

func (s *Non_reserved_wordsContext) T_DROP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DROP, 0)
}

func (s *Non_reserved_wordsContext) T_DYNAMIC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_DYNAMIC, 0)
}

func (s *Non_reserved_wordsContext) T_ENABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ENABLE, 0)
}

func (s *Non_reserved_wordsContext) T_ENGINE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ENGINE, 0)
}

func (s *Non_reserved_wordsContext) T_ESCAPED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ESCAPED, 0)
}

func (s *Non_reserved_wordsContext) T_EXCEPT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXCEPT, 0)
}

func (s *Non_reserved_wordsContext) T_EXEC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXEC, 0)
}

func (s *Non_reserved_wordsContext) T_EXECUTE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXECUTE, 0)
}

func (s *Non_reserved_wordsContext) T_EXCEPTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXCEPTION, 0)
}

func (s *Non_reserved_wordsContext) T_EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXCLUSIVE, 0)
}

func (s *Non_reserved_wordsContext) T_EXISTS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXISTS, 0)
}

func (s *Non_reserved_wordsContext) T_EXIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_EXIT, 0)
}

func (s *Non_reserved_wordsContext) T_FALLBACK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FALLBACK, 0)
}

func (s *Non_reserved_wordsContext) T_FALSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FALSE, 0)
}

func (s *Non_reserved_wordsContext) T_FETCH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FETCH, 0)
}

func (s *Non_reserved_wordsContext) T_FIELDS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FIELDS, 0)
}

func (s *Non_reserved_wordsContext) T_FILE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FILE, 0)
}

func (s *Non_reserved_wordsContext) T_FILES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FILES, 0)
}

func (s *Non_reserved_wordsContext) T_FIRST_VALUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FIRST_VALUE, 0)
}

func (s *Non_reserved_wordsContext) T_FLOAT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FLOAT, 0)
}

func (s *Non_reserved_wordsContext) T_FOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOR, 0)
}

func (s *Non_reserved_wordsContext) T_FOREIGN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOREIGN, 0)
}

func (s *Non_reserved_wordsContext) T_FORMAT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FORMAT, 0)
}

func (s *Non_reserved_wordsContext) T_FOUND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FOUND, 0)
}

func (s *Non_reserved_wordsContext) T_FROM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FROM, 0)
}

func (s *Non_reserved_wordsContext) T_FULL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FULL, 0)
}

func (s *Non_reserved_wordsContext) T_FUNCTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_FUNCTION, 0)
}

func (s *Non_reserved_wordsContext) T_GET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GET, 0)
}

func (s *Non_reserved_wordsContext) T_GLOBAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GLOBAL, 0)
}

func (s *Non_reserved_wordsContext) T_GO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GO, 0)
}

func (s *Non_reserved_wordsContext) T_GRANT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GRANT, 0)
}

func (s *Non_reserved_wordsContext) T_GROUP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_GROUP, 0)
}

func (s *Non_reserved_wordsContext) T_HANDLER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HANDLER, 0)
}

func (s *Non_reserved_wordsContext) T_HASH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HASH, 0)
}

func (s *Non_reserved_wordsContext) T_HAVING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HAVING, 0)
}

func (s *Non_reserved_wordsContext) T_HDFS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HDFS, 0)
}

func (s *Non_reserved_wordsContext) T_HIVE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HIVE, 0)
}

func (s *Non_reserved_wordsContext) T_HOST() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_HOST, 0)
}

func (s *Non_reserved_wordsContext) T_IDENTITY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IDENTITY, 0)
}

func (s *Non_reserved_wordsContext) T_IF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IF, 0)
}

func (s *Non_reserved_wordsContext) T_IGNORE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IGNORE, 0)
}

func (s *Non_reserved_wordsContext) T_IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IMMEDIATE, 0)
}

func (s *Non_reserved_wordsContext) T_IN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IN, 0)
}

func (s *Non_reserved_wordsContext) T_INCLUDE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INCLUDE, 0)
}

func (s *Non_reserved_wordsContext) T_INDEX() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INDEX, 0)
}

func (s *Non_reserved_wordsContext) T_INITRANS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INITRANS, 0)
}

func (s *Non_reserved_wordsContext) T_INNER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INNER, 0)
}

func (s *Non_reserved_wordsContext) T_INOUT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INOUT, 0)
}

func (s *Non_reserved_wordsContext) T_INSERT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INSERT, 0)
}

func (s *Non_reserved_wordsContext) T_INT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INT, 0)
}

func (s *Non_reserved_wordsContext) T_INT2() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INT2, 0)
}

func (s *Non_reserved_wordsContext) T_INT4() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INT4, 0)
}

func (s *Non_reserved_wordsContext) T_INT8() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INT8, 0)
}

func (s *Non_reserved_wordsContext) T_INTEGER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTEGER, 0)
}

func (s *Non_reserved_wordsContext) T_INTERSECT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTERSECT, 0)
}

func (s *Non_reserved_wordsContext) T_INTERVAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTERVAL, 0)
}

func (s *Non_reserved_wordsContext) T_INTO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INTO, 0)
}

func (s *Non_reserved_wordsContext) T_INVOKER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_INVOKER, 0)
}

func (s *Non_reserved_wordsContext) T_ITEMS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ITEMS, 0)
}

func (s *Non_reserved_wordsContext) T_IS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_IS, 0)
}

func (s *Non_reserved_wordsContext) T_ISOPEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ISOPEN, 0)
}

func (s *Non_reserved_wordsContext) T_JOIN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_JOIN, 0)
}

func (s *Non_reserved_wordsContext) T_KEEP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_KEEP, 0)
}

func (s *Non_reserved_wordsContext) T_KEY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_KEY, 0)
}

func (s *Non_reserved_wordsContext) T_KEYS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_KEYS, 0)
}

func (s *Non_reserved_wordsContext) T_LAG() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LAG, 0)
}

func (s *Non_reserved_wordsContext) T_LANGUAGE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LANGUAGE, 0)
}

func (s *Non_reserved_wordsContext) T_LAST_VALUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LAST_VALUE, 0)
}

func (s *Non_reserved_wordsContext) T_LEAD() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LEAD, 0)
}

func (s *Non_reserved_wordsContext) T_LEAVE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LEAVE, 0)
}

func (s *Non_reserved_wordsContext) T_LEFT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LEFT, 0)
}

func (s *Non_reserved_wordsContext) T_LIKE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LIKE, 0)
}

func (s *Non_reserved_wordsContext) T_LIMIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LIMIT, 0)
}

func (s *Non_reserved_wordsContext) T_LINES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LINES, 0)
}

func (s *Non_reserved_wordsContext) T_LOCAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCAL, 0)
}

func (s *Non_reserved_wordsContext) T_LOCATION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCATION, 0)
}

func (s *Non_reserved_wordsContext) T_LOCATOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCATOR, 0)
}

func (s *Non_reserved_wordsContext) T_LOCATORS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCATORS, 0)
}

func (s *Non_reserved_wordsContext) T_LOCKS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOCKS, 0)
}

func (s *Non_reserved_wordsContext) T_LOG() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOG, 0)
}

func (s *Non_reserved_wordsContext) T_LOGGED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOGGED, 0)
}

func (s *Non_reserved_wordsContext) T_LOGGING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOGGING, 0)
}

func (s *Non_reserved_wordsContext) T_LOOP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_LOOP, 0)
}

func (s *Non_reserved_wordsContext) T_MAP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAP, 0)
}

func (s *Non_reserved_wordsContext) T_MATCHED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MATCHED, 0)
}

func (s *Non_reserved_wordsContext) T_MAX() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAX, 0)
}

func (s *Non_reserved_wordsContext) T_MAXTRANS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MAXTRANS, 0)
}

func (s *Non_reserved_wordsContext) T_MERGE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MERGE, 0)
}

func (s *Non_reserved_wordsContext) T_MESSAGE_TEXT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MESSAGE_TEXT, 0)
}

func (s *Non_reserved_wordsContext) T_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MICROSECOND, 0)
}

func (s *Non_reserved_wordsContext) T_MICROSECONDS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MICROSECONDS, 0)
}

func (s *Non_reserved_wordsContext) T_MIN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MIN, 0)
}

func (s *Non_reserved_wordsContext) T_MULTISET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_MULTISET, 0)
}

func (s *Non_reserved_wordsContext) T_NCHAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NCHAR, 0)
}

func (s *Non_reserved_wordsContext) T_NEW() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NEW, 0)
}

func (s *Non_reserved_wordsContext) T_NVARCHAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NVARCHAR, 0)
}

func (s *Non_reserved_wordsContext) T_NO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NO, 0)
}

func (s *Non_reserved_wordsContext) T_NOCOMPRESS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOCOMPRESS, 0)
}

func (s *Non_reserved_wordsContext) T_NOCOUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOCOUNT, 0)
}

func (s *Non_reserved_wordsContext) T_NOLOGGING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOLOGGING, 0)
}

func (s *Non_reserved_wordsContext) T_NONE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NONE, 0)
}

func (s *Non_reserved_wordsContext) T_NOT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOT, 0)
}

func (s *Non_reserved_wordsContext) T_NOTFOUND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NOTFOUND, 0)
}

func (s *Non_reserved_wordsContext) T_NUMERIC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NUMERIC, 0)
}

func (s *Non_reserved_wordsContext) T_NUMBER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_NUMBER, 0)
}

func (s *Non_reserved_wordsContext) T_OBJECT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OBJECT, 0)
}

func (s *Non_reserved_wordsContext) T_OFF() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OFF, 0)
}

func (s *Non_reserved_wordsContext) T_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ON, 0)
}

func (s *Non_reserved_wordsContext) T_ONLY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ONLY, 0)
}

func (s *Non_reserved_wordsContext) T_OPEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OPEN, 0)
}

func (s *Non_reserved_wordsContext) T_OR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OR, 0)
}

func (s *Non_reserved_wordsContext) T_ORDER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ORDER, 0)
}

func (s *Non_reserved_wordsContext) T_OUT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OUT, 0)
}

func (s *Non_reserved_wordsContext) T_OUTER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OUTER, 0)
}

func (s *Non_reserved_wordsContext) T_OVER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OVER, 0)
}

func (s *Non_reserved_wordsContext) T_OVERWRITE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OVERWRITE, 0)
}

func (s *Non_reserved_wordsContext) T_OWNER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_OWNER, 0)
}

func (s *Non_reserved_wordsContext) T_PACKAGE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PACKAGE, 0)
}

func (s *Non_reserved_wordsContext) T_PART_COUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PART_COUNT, 0)
}

func (s *Non_reserved_wordsContext) T_PART_LOC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PART_LOC, 0)
}

func (s *Non_reserved_wordsContext) T_PARTITION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PARTITION, 0)
}

func (s *Non_reserved_wordsContext) T_PCTFREE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PCTFREE, 0)
}

func (s *Non_reserved_wordsContext) T_PCTUSED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PCTUSED, 0)
}

func (s *Non_reserved_wordsContext) T_PRECISION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRECISION, 0)
}

func (s *Non_reserved_wordsContext) T_PRESERVE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRESERVE, 0)
}

func (s *Non_reserved_wordsContext) T_PRIMARY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRIMARY, 0)
}

func (s *Non_reserved_wordsContext) T_PRINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PRINT, 0)
}

func (s *Non_reserved_wordsContext) T_PROC() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PROC, 0)
}

func (s *Non_reserved_wordsContext) T_PROCEDURE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PROCEDURE, 0)
}

func (s *Non_reserved_wordsContext) T_PWD() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_PWD, 0)
}

func (s *Non_reserved_wordsContext) T_QUALIFY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_QUALIFY, 0)
}

func (s *Non_reserved_wordsContext) T_QUERY_BAND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_QUERY_BAND, 0)
}

func (s *Non_reserved_wordsContext) T_QUIT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_QUIT, 0)
}

func (s *Non_reserved_wordsContext) T_QUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_QUOTED_IDENTIFIER, 0)
}

func (s *Non_reserved_wordsContext) T_RAISE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RAISE, 0)
}

func (s *Non_reserved_wordsContext) T_RANK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RANK, 0)
}

func (s *Non_reserved_wordsContext) T_REAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REAL, 0)
}

func (s *Non_reserved_wordsContext) T_REFERENCES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REFERENCES, 0)
}

func (s *Non_reserved_wordsContext) T_REGEXP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REGEXP, 0)
}

func (s *Non_reserved_wordsContext) T_RR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RR, 0)
}

func (s *Non_reserved_wordsContext) T_REPLACE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REPLACE, 0)
}

func (s *Non_reserved_wordsContext) T_RESIGNAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESIGNAL, 0)
}

func (s *Non_reserved_wordsContext) T_RESTRICT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESTRICT, 0)
}

func (s *Non_reserved_wordsContext) T_RESULT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESULT, 0)
}

func (s *Non_reserved_wordsContext) T_RESULT_SET_LOCATOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RESULT_SET_LOCATOR, 0)
}

func (s *Non_reserved_wordsContext) T_RETURN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RETURN, 0)
}

func (s *Non_reserved_wordsContext) T_RETURNS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RETURNS, 0)
}

func (s *Non_reserved_wordsContext) T_REVERSE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_REVERSE, 0)
}

func (s *Non_reserved_wordsContext) T_RIGHT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RIGHT, 0)
}

func (s *Non_reserved_wordsContext) T_RLIKE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RLIKE, 0)
}

func (s *Non_reserved_wordsContext) T_RS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_RS, 0)
}

func (s *Non_reserved_wordsContext) T_ROLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROLE, 0)
}

func (s *Non_reserved_wordsContext) T_ROLLBACK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROLLBACK, 0)
}

func (s *Non_reserved_wordsContext) T_ROW() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROW, 0)
}

func (s *Non_reserved_wordsContext) T_ROWS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROWS, 0)
}

func (s *Non_reserved_wordsContext) T_ROW_COUNT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROW_COUNT, 0)
}

func (s *Non_reserved_wordsContext) T_ROW_NUMBER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_ROW_NUMBER, 0)
}

func (s *Non_reserved_wordsContext) T_SCHEMA() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SCHEMA, 0)
}

func (s *Non_reserved_wordsContext) T_SECOND() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SECOND, 0)
}

func (s *Non_reserved_wordsContext) T_SECONDS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SECONDS, 0)
}

func (s *Non_reserved_wordsContext) T_SECURITY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SECURITY, 0)
}

func (s *Non_reserved_wordsContext) T_SEGMENT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEGMENT, 0)
}

func (s *Non_reserved_wordsContext) T_SEL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SEL, 0)
}

func (s *Non_reserved_wordsContext) T_SELECT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SELECT, 0)
}

func (s *Non_reserved_wordsContext) T_SESSION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SESSION, 0)
}

func (s *Non_reserved_wordsContext) T_SESSIONS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SESSIONS, 0)
}

func (s *Non_reserved_wordsContext) T_SET() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SET, 0)
}

func (s *Non_reserved_wordsContext) T_SETS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SETS, 0)
}

func (s *Non_reserved_wordsContext) T_SHARE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SHARE, 0)
}

func (s *Non_reserved_wordsContext) T_SIGNAL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SIGNAL, 0)
}

func (s *Non_reserved_wordsContext) T_SIMPLE_DOUBLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SIMPLE_DOUBLE, 0)
}

func (s *Non_reserved_wordsContext) T_SIMPLE_FLOAT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SIMPLE_FLOAT, 0)
}

func (s *Non_reserved_wordsContext) T_SMALLDATETIME() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SMALLDATETIME, 0)
}

func (s *Non_reserved_wordsContext) T_SMALLINT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SMALLINT, 0)
}

func (s *Non_reserved_wordsContext) T_SQL() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SQL, 0)
}

func (s *Non_reserved_wordsContext) T_SQLEXCEPTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SQLEXCEPTION, 0)
}

func (s *Non_reserved_wordsContext) T_SQLINSERT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SQLINSERT, 0)
}

func (s *Non_reserved_wordsContext) T_SQLSTATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SQLSTATE, 0)
}

func (s *Non_reserved_wordsContext) T_SQLWARNING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SQLWARNING, 0)
}

func (s *Non_reserved_wordsContext) T_STATS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STATS, 0)
}

func (s *Non_reserved_wordsContext) T_STATISTICS() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STATISTICS, 0)
}

func (s *Non_reserved_wordsContext) T_STEP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STEP, 0)
}

func (s *Non_reserved_wordsContext) T_STDEV() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STDEV, 0)
}

func (s *Non_reserved_wordsContext) T_STORAGE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STORAGE, 0)
}

func (s *Non_reserved_wordsContext) T_STORED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STORED, 0)
}

func (s *Non_reserved_wordsContext) T_STRING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_STRING, 0)
}

func (s *Non_reserved_wordsContext) T_SUBDIR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUBDIR, 0)
}

func (s *Non_reserved_wordsContext) T_SUBSTRING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUBSTRING, 0)
}

func (s *Non_reserved_wordsContext) T_SUM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUM, 0)
}

func (s *Non_reserved_wordsContext) T_SUMMARY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SUMMARY, 0)
}

func (s *Non_reserved_wordsContext) T_SYSDATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SYSDATE, 0)
}

func (s *Non_reserved_wordsContext) T_SYS_REFCURSOR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_SYS_REFCURSOR, 0)
}

func (s *Non_reserved_wordsContext) T_TABLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLE, 0)
}

func (s *Non_reserved_wordsContext) T_TABLESPACE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TABLESPACE, 0)
}

func (s *Non_reserved_wordsContext) T_TEMPORARY() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TEMPORARY, 0)
}

func (s *Non_reserved_wordsContext) T_TERMINATED() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TERMINATED, 0)
}

func (s *Non_reserved_wordsContext) T_TEXTIMAGE_ON() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TEXTIMAGE_ON, 0)
}

func (s *Non_reserved_wordsContext) T_THEN() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_THEN, 0)
}

func (s *Non_reserved_wordsContext) T_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TIMESTAMP, 0)
}

func (s *Non_reserved_wordsContext) T_TITLE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TITLE, 0)
}

func (s *Non_reserved_wordsContext) T_TO() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TO, 0)
}

func (s *Non_reserved_wordsContext) T_TOP() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TOP, 0)
}

func (s *Non_reserved_wordsContext) T_TRANSACTION() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TRANSACTION, 0)
}

func (s *Non_reserved_wordsContext) T_TRIM() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TRIM, 0)
}

func (s *Non_reserved_wordsContext) T_TRUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TRUE, 0)
}

func (s *Non_reserved_wordsContext) T_TRUNCATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_TRUNCATE, 0)
}

func (s *Non_reserved_wordsContext) T_UNIQUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UNIQUE, 0)
}

func (s *Non_reserved_wordsContext) T_UPDATE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UPDATE, 0)
}

func (s *Non_reserved_wordsContext) T_UR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_UR, 0)
}

func (s *Non_reserved_wordsContext) T_USE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_USE, 0)
}

func (s *Non_reserved_wordsContext) T_USER() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_USER, 0)
}

func (s *Non_reserved_wordsContext) T_USING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_USING, 0)
}

func (s *Non_reserved_wordsContext) T_VALUE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VALUE, 0)
}

func (s *Non_reserved_wordsContext) T_VALUES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VALUES, 0)
}

func (s *Non_reserved_wordsContext) T_VAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VAR, 0)
}

func (s *Non_reserved_wordsContext) T_VARCHAR() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VARCHAR, 0)
}

func (s *Non_reserved_wordsContext) T_VARCHAR2() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VARCHAR2, 0)
}

func (s *Non_reserved_wordsContext) T_VARYING() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VARYING, 0)
}

func (s *Non_reserved_wordsContext) T_VARIANCE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VARIANCE, 0)
}

func (s *Non_reserved_wordsContext) T_VOLATILE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_VOLATILE, 0)
}

func (s *Non_reserved_wordsContext) T_WHILE() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WHILE, 0)
}

func (s *Non_reserved_wordsContext) T_WITH() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITH, 0)
}

func (s *Non_reserved_wordsContext) T_WITHOUT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WITHOUT, 0)
}

func (s *Non_reserved_wordsContext) T_WORK() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_WORK, 0)
}

func (s *Non_reserved_wordsContext) T_XACT_ABORT() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_XACT_ABORT, 0)
}

func (s *Non_reserved_wordsContext) T_XML() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_XML, 0)
}

func (s *Non_reserved_wordsContext) T_YES() antlr.TerminalNode {
	return s.GetToken(HplsqlParserT_YES, 0)
}

func (s *Non_reserved_wordsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Non_reserved_wordsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *Non_reserved_wordsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.EnterNon_reserved_words(s)
	}
}

func (s *Non_reserved_wordsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(HplsqlListener); ok {
		listenerT.ExitNon_reserved_words(s)
	}
}




func (p *HplsqlParser) Non_reserved_words() (localctx INon_reserved_wordsContext) {
	localctx = NewNon_reserved_wordsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, HplsqlParserRULE_non_reserved_words)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3458)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -33554464) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -24696061953) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & -36028797018963969) != 0) || ((int64((_la - 192)) & ^0x3f) == 0 && ((int64(1) << (_la - 192)) & -9007199271518737) != 0) || ((int64((_la - 256)) & ^0x3f) == 0 && ((int64(1) << (_la - 256)) & -864744076811961345) != 0) || ((int64((_la - 320)) & ^0x3f) == 0 && ((int64(1) << (_la - 320)) & 267403263) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


func (p *HplsqlParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 4:
			var t *Block_endContext = nil
			if localctx != nil { t = localctx.(*Block_endContext) }
			return p.Block_end_Sempred(t, predIndex)

	case 11:
			var t *Expr_stmtContext = nil
			if localctx != nil { t = localctx.(*Expr_stmtContext) }
			return p.Expr_stmt_Sempred(t, predIndex)

	case 79:
			var t *Create_routine_paramsContext = nil
			if localctx != nil { t = localctx.(*Create_routine_paramsContext) }
			return p.Create_routine_params_Sempred(t, predIndex)

	case 159:
			var t *Select_list_aliasContext = nil
			if localctx != nil { t = localctx.(*Select_list_aliasContext) }
			return p.Select_list_alias_Sempred(t, predIndex)

	case 172:
			var t *From_alias_clauseContext = nil
			if localctx != nil { t = localctx.(*From_alias_clauseContext) }
			return p.From_alias_clause_Sempred(t, predIndex)

	case 190:
			var t *Delete_aliasContext = nil
			if localctx != nil { t = localctx.(*Delete_aliasContext) }
			return p.Delete_alias_Sempred(t, predIndex)

	case 192:
			var t *Bool_exprContext = nil
			if localctx != nil { t = localctx.(*Bool_exprContext) }
			return p.Bool_expr_Sempred(t, predIndex)

	case 200:
			var t *ExprContext = nil
			if localctx != nil { t = localctx.(*ExprContext) }
			return p.Expr_Sempred(t, predIndex)

	case 220:
			var t *Func_paramContext = nil
			if localctx != nil { t = localctx.(*Func_paramContext) }
			return p.Func_param_Sempred(t, predIndex)


	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *HplsqlParser) Block_end_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
			return !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "TRANSACTION")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *HplsqlParser) Expr_stmt_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
			return !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "GO")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *HplsqlParser) Create_routine_params_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
			return !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "IS") &&
	        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "AS") &&
	        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "DYNAMIC") && strings.EqualFold(p.GetTokenStream().LT(2).GetText(), "RESULT")
	        

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *HplsqlParser) Select_list_alias_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
			return !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "INTO") && !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "FROM")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *HplsqlParser) From_alias_clause_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 4:
			return !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "EXEC") &&
	        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "EXECUTE") && 
	        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "INNER") &&
	        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "LEFT") &&
	        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "GROUP") &&
	        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "ORDER") &&
	        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "LIMIT") &&
	        !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "WITH")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *HplsqlParser) Delete_alias_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
			return !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "ALL")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *HplsqlParser) Bool_expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 6:
			return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *HplsqlParser) Expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
			return p.Precpred(p.GetParserRuleContext(), 13)

	case 8:
			return p.Precpred(p.GetParserRuleContext(), 12)

	case 9:
			return p.Precpred(p.GetParserRuleContext(), 14)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *HplsqlParser) Func_param_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 10:
			return !strings.EqualFold(p.GetTokenStream().LT(1).GetText(), "INTO")

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

